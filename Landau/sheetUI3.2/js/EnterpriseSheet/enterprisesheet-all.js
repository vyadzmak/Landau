/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) CubeDrive Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
if(!Ext.isIE){
	/*		 
	 * EXT 4.2.1 or EXT 4.2.2 can not set isIE rightly in IE11 and edge, we need check again
	 */
	var userAgent = navigator.userAgent;
				
	if(/(Edge\/)|(MSIE)/gi.test(userAgent) || /(Trident\/)/gi.test(navigator.appVersion)) {
		Ext.isIE = true;
		Ext.isChrome = false;
		Ext.isSafari = false;
		Ext.isWebKit = false;
		Ext.isGecko = false;
		Ext.isOpera = false;
	}
}

Ext.override(Ext.menu.Menu, {
    onMouseLeave: function(e) {
	    var me = this;
	
	    var visibleSubmenu = false;
	    me.items.each(function(item) { 
	        if(item.menu && item.menu.isVisible()) { 
	            visibleSubmenu = true;
	        }
	    })
	    if(visibleSubmenu) {
	        return;
	    }
	
	    me.deactivateActiveItem();
	
	    if (me.disabled) {
	        return;
	    }
	
	    me.fireEvent('mouseleave', me, e);
    }
});


/**
 * Base class from Ext.ux.TabReorderer.
 */
Ext.define('Ext.ux.BoxReorderer', {
    mixins: {
        observable: 'Ext.util.Observable'
    },

    /**
     * @cfg {String} itemSelector
     * A {@link Ext.DomQuery DomQuery} selector which identifies the encapsulating elements of child
     * Components which participate in reordering.
     */
    itemSelector: '.x-box-item',

    /**
     * @cfg {Mixed} animate
     * If truthy, child reordering is animated so that moved boxes slide smoothly into position.
     * If this option is numeric, it is used as the animation duration in milliseconds.
     */
    animate: 100,

    constructor: function() {
        
        this.mixins.observable.constructor.apply(this, arguments);
    },

    init: function(container) {
        var me = this;
 
        me.container = container;
 
        // Set our animatePolicy to animate the start position (ie x for HBox, y for VBox)
        me.animatePolicy = {};
        me.animatePolicy[container.getLayout().names.x] = true;
        
        

        // Initialize the DD on first layout, when the innerCt has been created.
        me.container.on({
            scope: me,
            boxready: me.afterFirstLayout,
            beforedestroy: me.onContainerDestroy
        });
    },

    /**
     * @private Clear up on Container destroy
     */
    onContainerDestroy: function() {
        var dd = this.dd;
        if (dd) {
            dd.unreg();
            this.dd = null;
        }
    },

    afterFirstLayout: function() {
        var me = this,
            layout = me.container.getLayout(),
            names = layout.names,
            dd;
            
        // Create a DD instance. Poke the handlers in.
        // TODO: Ext5's DD classes should apply config to themselves.
        // TODO: Ext5's DD classes should not use init internally because it collides with use as a plugin
        // TODO: Ext5's DD classes should be Observable.
        // TODO: When all the above are trus, this plugin should extend the DD class.
        dd = me.dd = Ext.create('Ext.dd.DD', layout.innerCt, me.container.id + '-reorderer');
        Ext.apply(dd, {
            animate: me.animate,
            reorderer: me,
            container: me.container,
            getDragCmp: this.getDragCmp,
            clickValidator: Ext.Function.createInterceptor(dd.clickValidator, me.clickValidator, me, false),
            onMouseDown: me.onMouseDown,
            startDrag: me.startDrag,
            onDrag: me.onDrag,
            endDrag: me.endDrag,
            getNewIndex: me.getNewIndex,
            doSwap: me.doSwap,
            findReorderable: me.findReorderable
        });

        // Decide which dimension we are measuring, and which measurement metric defines
        // the *start* of the box depending upon orientation.
        dd.dim = names.width;
        dd.startAttr = names.beforeX;
        dd.endAttr = names.afterX;
    },

    getDragCmp: function(e) {
        return this.container.getChildByElement(e.getTarget(this.itemSelector, 10));
    },

    // check if the clicked component is reorderable
    clickValidator: function(e) {
        var cmp = this.getDragCmp(e);

        // If cmp is null, this expression MUST be coerced to boolean so that createInterceptor is able to test it against false
        return !!(cmp && cmp.reorderable !== false);
    },

    onMouseDown: function(e) {
        var me = this,
            container = me.container,
            containerBox,
            cmpEl,
            cmpBox;

        // Ascertain which child Component is being mousedowned
        me.dragCmp = me.getDragCmp(e);
        if (me.dragCmp) {
            cmpEl = me.dragCmp.getEl();
            me.startIndex = me.curIndex = container.items.indexOf(me.dragCmp);

            // Start position of dragged Component
            cmpBox = cmpEl.getBox();

            // Last tracked start position
            me.lastPos = cmpBox[this.startAttr];

            // Calculate constraints depending upon orientation
            // Calculate offset from mouse to dragEl position
            containerBox = container.el.getBox();
            if (me.dim === 'width') {
                me.minX = containerBox.left;
                me.maxX = containerBox.right - cmpBox.width;
                me.minY = me.maxY = cmpBox.top;
                me.deltaX = e.getX() - cmpBox.left;
            } else {
                me.minY = containerBox.top;
                me.maxY = containerBox.bottom - cmpBox.height;
                me.minX = me.maxX = cmpBox.left;
                me.deltaY = e.getY() - cmpBox.top;
            }
            me.constrainY = me.constrainX = true;
        }
    },

    startDrag: function() {
        var me = this,
            dragCmp = me.dragCmp;
            
        if (dragCmp) {
            // For the entire duration of dragging the *Element*, defeat any positioning and animation of the dragged *Component*
            dragCmp.setPosition = Ext.emptyFn;
            dragCmp.animate = false;

            // Animate the BoxLayout just for the duration of the drag operation.
            if (me.animate) {
                me.container.getLayout().animatePolicy = me.reorderer.animatePolicy;
            }
            // We drag the Component element
            me.dragElId = dragCmp.getEl().id;
            me.reorderer.fireEvent('StartDrag', me, me.container, dragCmp, me.curIndex);
            // Suspend events, and set the disabled flag so that the mousedown and mouseup events
            // that are going to take place do not cause any other UI interaction.
            dragCmp.suspendEvents();
            dragCmp.disabled = true;
            dragCmp.el.setStyle('zIndex', 100);
        } else {
            me.dragElId = null;
        }
    },

    /**
     * @private
     * Find next or previous reorderable component index.
     * @param {Number} newIndex The initial drop index.
     * @return {Number} The index of the reorderable component.
     */
    findReorderable: function(newIndex) {
        var me = this,
            items = me.container.items,
            newItem;

        if (items.getAt(newIndex).reorderable === false) {
            newItem = items.getAt(newIndex);
            if (newIndex > me.startIndex) {
                 while(newItem && newItem.reorderable === false) {
                    newIndex++;
                    newItem = items.getAt(newIndex);
                }
            } else {
                while(newItem && newItem.reorderable === false) {
                    newIndex--;
                    newItem = items.getAt(newIndex);
                }
            }
        }

        newIndex = Math.min(Math.max(newIndex, 0), items.getCount() - 1);

        if (items.getAt(newIndex).reorderable === false) {
            return -1;
        }
        return newIndex;
    },

    /**
     * @private
     * Swap 2 components.
     * @param {Number} newIndex The initial drop index.
     */
    doSwap: function(newIndex) {
        var me = this,
            items = me.container.items,
            container = me.container,
            wasRoot = me.container._isLayoutRoot,
            orig, dest, tmpIndex, temp;

        newIndex = me.findReorderable(newIndex);

        if (newIndex === -1) {
            return;
        }

        me.reorderer.fireEvent('ChangeIndex', me, container, me.dragCmp, me.startIndex, newIndex);
        orig = items.getAt(me.curIndex);
        dest = items.getAt(newIndex);
        items.remove(orig);
        tmpIndex = Math.min(Math.max(newIndex, 0), items.getCount() - 1);
        items.insert(tmpIndex, orig);
        items.remove(dest);
        items.insert(me.curIndex, dest);

        // Make the Box Container the topmost layout participant during the layout.
        container._isLayoutRoot = true;
        container.updateLayout();
        container._isLayoutRoot = wasRoot;
        me.curIndex = newIndex;
    },

    onDrag: function(e) {
        var me = this,
            newIndex;

        newIndex = me.getNewIndex(e.getPoint());
        if ((newIndex !== undefined)) {
            me.reorderer.fireEvent('Drag', me, me.container, me.dragCmp, me.startIndex, me.curIndex);
            me.doSwap(newIndex);
        }

    },

    endDrag: function(e) {
        if (e) {
            e.stopEvent();
        }
        var me = this,
            layout = me.container.getLayout(),
            temp;

        if (me.dragCmp) {
            delete me.dragElId;

            // Reinstate the Component's positioning method after mouseup, and allow the layout system to animate it.
            delete me.dragCmp.setPosition;
            me.dragCmp.animate = true;
            
            // Ensure the lastBox is correct for the animation system to restore to when it creates the "from" animation frame
            me.dragCmp.lastBox[layout.names.x] = me.dragCmp.getPosition(true)[layout.names.widthIndex];

            // Make the Box Container the topmost layout participant during the layout.
            me.container._isLayoutRoot = true;
            me.container.updateLayout();
            me.container._isLayoutRoot = undefined;
            
            // Attempt to hook into the afteranimate event of the drag Component to call the cleanup
            temp = Ext.fx.Manager.getFxQueue(me.dragCmp.el.id)[0];
            if (temp) {
                temp.on({
                    afteranimate: me.reorderer.afterBoxReflow,
                    scope: me
                });
            } 
            // If not animated, clean up after the mouseup has happened so that we don't click the thing being dragged
            else {
                Ext.Function.defer(me.reorderer.afterBoxReflow, 1, me);
            }

            if (me.animate) {
                delete layout.animatePolicy;
            }
            me.reorderer.fireEvent('drop', me, me.container, me.dragCmp, me.startIndex, me.curIndex);
        }
    },

    /**
     * @private
     * Called after the boxes have been reflowed after the drop.
     * Re-enabled the dragged Component.
     */
    afterBoxReflow: function() {
        var me = this;
        me.dragCmp.el.setStyle('zIndex', '');
        me.dragCmp.disabled = false;
        me.dragCmp.resumeEvents();
    },

    /**
     * @private
     * Calculate drop index based upon the dragEl's position.
     */
    getNewIndex: function(pointerPos) {
        var me = this,
            dragEl = me.getDragEl(),
            dragBox = Ext.fly(dragEl).getBox(),
            targetEl,
            targetBox,
            targetMidpoint,
            i = 0,
            it = me.container.items.items,
            ln = it.length,
            lastPos = me.lastPos;

        me.lastPos = dragBox[me.startAttr];

        for (; i < ln; i++) {
            targetEl = it[i].getEl();

            // Only look for a drop point if this found item is an item according to our selector
            if (targetEl.is(me.reorderer.itemSelector)) {
                targetBox = targetEl.getBox();
                targetMidpoint = targetBox[me.startAttr] + (targetBox[me.dim] >> 1);
                if (i < me.curIndex) {
                    if ((dragBox[me.startAttr] < lastPos) && (dragBox[me.startAttr] < (targetMidpoint - 5))) {
                        return i;
                    }
                } else if (i > me.curIndex) {
                    if ((dragBox[me.startAttr] > lastPos) && (dragBox[me.endAttr] > (targetMidpoint + 5))) {
                        return i;
                    }
                }
            }
        }
    }
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.lang.Language', {
	content: {
		'absolute_coord' : 'Absolute coordinate',
		'above_average' : 'Above average',
		'absolute': 'Absolute',
		'aboutSheet': 'About EnterpriseSheet',
		'accounting' : 'Accounting',
		'action_broken_merged' : 'This action is aborted, because it will cause some merged cell broken.',
		'add_group': 'Add group',
		'add_variable': 'Add variable',	
		'add_variable_for': 'Add variable for : ',
		'add_new_dateset': 'Add new dataset',   
        'add': 'Add',
        'add_number_icon': 'Add number icon to the title',
        'add_date_icon': 'Add date icon to the title',
        'add_phone_icon': 'Add phone icon to the title', 
        'add_url_icon': 'Add url icon to the title', 
        'add_email_icon': 'Add email icon to the title', 
        'add_checkbox_icon': 'Add checkbox icon to the title', 
        'add_radio_icon': 'Add radio icon to the title', 
        'add_attach_icon': 'Add attachment icon to the title', 
        'add_currency_icon': 'Add currency icon to the title', 
        'add_perent_icon': 'Add percent icon to the title', 
        'add_text_icon':  'Add text icon to the title', 
        'add_drop_icon': 'Add dropdown icon to the title',
		'after': 'After',
		'all' : 'All',
		'allow_invalid' : 'Allow invalid data, but show hint',
		'all_changes_are_saved': 'Change saved',
		'align_justify' : 'Align justify',
		'align' : 'Align',
		'align_left' : 'Align left',		
		'align_center' : 'Align center',		
		'align_right' : 'Align right',		
		'align_top' : 'Align top',		
		'align_middle' : 'Align middle',		
		'align_bottom' : 'Align bottom',
		'apply_style_brush' : 'Apply style brush',
		'apply' : 'Apply',
		'area' : 'Area',
		'at' : 'at',
		'autofill_down' : 'Autofill down',		
		'autofill_up' : 'Autofill up',		
		'autofill_left' : 'Autofill left',		
		'autofill_right' : 'Autofill right',
		'average' : 'Average',
		'auto_adjust_row_height' : 'Auto adjust row height',
		'auto_adjust_column_width' : 'Auto adjust column width',
		'autofill' : 'Autofill',
		'authorSharing': 'Author, Sharing',
		
		'bad' : 'Bad',
		'bad_good_ok' : 'Bad, good and OK',
		'backward' : 'Backward',
		'between' : 'Between',
		'before': 'Before',
		'begin_at' : 'Begin at',
		'background_color': 'Background color',
		'back' : 'Back',
		'below_average' : 'Below average',
		'below_average' : 'Below average value',
		'bottom_side_cell_move_top' : 'Bottom side cells move top',
		'blue_theme' : 'Blue theme',
		'blank' : 'Blank',
		'bar' : 'Bar',
		'boolstyle' : 'Bool condition',
		'bold': 'Bold',
		'bold_tip': '<b>Bold (CTRL+B)</b><br/>Make your text bold.',
		'bottom10' : 'Bottom 10',
		'bottom_10_value' : 'Bottom 10',		
		'bottom_10%' : 'Bottom 10%',
		'bottom': 'Bottom',
		'bold_border_bottom' : 'Bold border bottom',	
		'border_color' : 'Border color',
		'border_all' : 'Border all',		
		'border_top' : 'Border top',		
		'border_right' : 'Border right',		
		'border_bottom' : 'Border bottom',		
		'border_left' : 'Border left',		
		'border_outside' : 'Border outside',		
		'border_inside' : 'Border inside',		
		'border_none' : 'Border none',
		'bold_border_outside' : 'Bold border outside',
		'border_top_bottom' : 'Border top and bottom',	
		'border_top_bottom_bold' : 'Border top and bold border bottom',
		'border_style' : 'Border style',
		'border' : 'Border',
        'brush' : 'Brush',
        'broken_merge_cell_hint': 'This action will break the merged cell, please cancel the related merge cell first.',
		
		'calculate' : 'Calculate',
		'calculate_highlight_cell' : 'Top/Bottom rules',
		'cancel_split' : 'Cancel split',
		'cancel_hide_row' : 'Cancel hide row',		
		'cancel_hide_column' : 'Cancel hide column',
		'can_not_change_part_merged_cell': 'Can not only change some part of a merged cell',
		'case_sensitive' : 'Case sensitive',
		'cannot_operate_merged_cell': 'Can not process this action on merged cell',		
		'cannot_operate_table_tpl': 'Can not process this action on table template',
		'cannot_set_table_tpl_for_single_cell': 'Can not apply table template for a single cell, please select a range.',
		'change_group' : 'Change group',
		'cancel_group': 'Cancel group',
		'cannot_calculate_value': 'Can not calculate the value of formula "{0}", please check the calling parameters.',
		'cannot_set_tpl_for_selection' : 'Can not set template for selection, there is already a template in the selection.',		
		'cannot_delete_normal_tpl_cell' : 'Can not delete normal cells and template cells at the same time',		
		'cannot_insert_break_tpl_cell' : 'Can not insert at the selection, it will break the table template region',
		'category' : 'Category',
		'can_not_create_filter' : 'Can not create filter for selection',		
		'can_not_sort_range' : 'Can not sort a single cell or the whole sheet',	
		'can_not_sort_merged_or_table_tpl' : 'Can not sort range which contains merged cell(s) or table template',
		'cancel' : 'Cancel',
		'cancel_merge_cell' : 'Cancel merged cell',
		'cancel_freeze' : 'Cancel freeze',
		'cancel_filtering' : 'Cancel filtering',
		'clear_filter' : 'Clear filter',
		'copy_without_style' : 'Copy without style',
		'create_filter_for' : 'Create filter for',
		'clean' : 'Clean',		
		'clean_for' : 'Clean for',		
		'clean_content' : 'Clean content',		
		'clean_style' : 'Clean style',
		'clean_border' : 'Clean border',
		'count' : 'Count',
		'clipboard' : 'Clipboard',
		'check_cell' : 'Check cell',
		'cell' : 'Cell',
		'chart' : 'Chart',	
		'charts' : 'Charts',
		'comma' : 'Comma',	
		'currency' : 'Currency',
		'chart_type': 'Chart type',	
		'chart_setting': 'Chart Settings',
		'circle_refer': 'Circular reference',	
		'circle_refer_display': 'There is a reference circule in the formula',
		'change_file_title': 'Change file title',
		'change_tpl_summary': 'Change the summary',
		'check_all': 'Check all',
		'clean_all': 'Clean all',
		'copy_sheet_to' : 'Copy sheet to',
		'cell_range' : 'Cell range',
		'clearCheckboxRadio': 'Clear Checkbox/Radio',	
		'checkbox': 'Checkbox',
		'change_property_for' : 'Change property for',		
		'change_border_for' : 'Change border for',		
		'change_condition_for' : 'Change condition for',		
		'change_column_width_for' : 'Change column width for',		
		'change_row_height_for' : 'Change row height for',
		'clear_condition' : 'Clear condition',
		'clear_selecttion_condition' : 'Clear condition of selection',		
		'clear_sheet_condition' : 'Clear condition of sheet',
		'close': 'Close',
		'clear' : 'Clear',
		'clear_table_tpl' : 'Clear table template',
		'color': 'Color',
		'component' : 'Component',
		'confirm' : 'Confirm',
		'copy_cell' : 'Copy cell',
		'contain': 'Contain',
		'column_absolute': 'Column absolute',	
		'cell_styles' : 'Cell styles',
		'comma_format' : 'Comma format',
		'condition' : 'Condition',
		'condition_style_manager' : 'Conditional style manager',
		'custom_style' : 'Custom style',
		'condition_highlight_cell' : 'Highlight cells rules',
		'colorbar' : 'Data bars',	
		'color_scales' : 'Color scales',	
		'condition_management' : 'Condition management',	
		'collapse_column_group': 'Collapse column group',
		'collapse_row_group': 'Collapse row group',
		'criteria' : 'Criteria',
		'create' : 'Create',
		'create_chart': 'Create chart',
		'create_picture': 'Create picture',
		'create_sheet_from_tpl': 'Create new sheet from existing template',
		'custom_sort' : 'Custom sort',
		'cut' : 'Cut',		
		'cut_tip' : '<b>Cut (CTRL+X)</b><br/>Remove the selection and put it on the clipboard.',
		'copy' : 'Copy',
		'copy_tip' : '<b>Copy (CTRL+C)</b><br/>Put a copy of selection on the clipboard.',
		'comment' : 'Comment',		
		'column' : 'Column',
		'column_width' : 'Column width',
		'custom' : 'Number custom',
		'customFormat' : 'Add custom number format',
		'customEnter' : 'Enter number format (Ex: $#,##0.00;[Red]-$#,##0.00;[Red]0)',
		'currency' : 'Currency',
		'currencyCodeUse' : 'Use currency code instead of symbol',
		
		'data' : 'Data',
		'date' : 'Date',
		'date_ocurring_at' : 'A Date Occurring',
		'data_range_select': 'Select data range',
		'data_range_for_mini_chart': 'Data range for sparkline chart',
		'data_modal' : 'Data and Modal',
		'dataTypeConf': 'Data type configure',
		'dark_color' : 'Dark color',
		'decimalDecrease' : 'Decrease decimal',
		'decimalIncrease' : 'Increase decimal',
		'decimalPlaces' : 'Decimal places',
		'deep_dark_color' : 'Deep dark color',
		'delete' : 'Delete',
		'delete_cell' : 'Delete cell',		
		'delete_row' : 'Delete row',		
		'delete_column' : 'Delete column',		
		'delete_sheet' : 'Delete sheet',
		'delete_chart': 'Delete chart',
		'delete_chart': 'Delete chart',
		'decrease_font_size' : 'Decrease font size',
		'delete_comment': 'Delete comment',
		'delete_picture': 'Delete picture',
		'delete_row_in_tabletpl' : 'You can only remove the whole row(s) for current selection in the table template, do you want to do it?',	
		'delete_column_in_tabletpl' : 'You can only remove the whole column(s) for current selection in the table template, do you want to do it?',
		'direction' : 'Direction',
		'do_u_really_wanna_delete': 'Do you really want to delete',
		'define_reference': 'Define a reference',
		'define_variable_for_cell': 'Defined a variable for this cell : ',
		'delete_condition_style' : 'Delete condition style',
		'double_border_bottom' : 'Double border bottom',
		'dot_move_left' : 'Dot move left',		
		'dot_move_right' : 'Dot move right',
		'double_border_bottom_top_border' : 'Double border bottom and border top',
		'documentation': 'Documentation',
		'drag_select_reference': 'Drag to select a reference',
		'dropdownURL' : 'Dropdown URL',
		
		'enable_disable_edit': 'Enable/Disable edit the selection',
		'edit' : 'Edit',
		'enter2char' : 'Please enter at least 2 characters to process search',
		'equal' : 'Equal',
		'explain_text' : 'Explain text',
		'error': 'Error',
		'expand_whole_row' : 'Expand sort to whole row',
		'expand_column_group': 'Expand column group',		
		'expand_row_group': 'Expand row group',
		'exportExcel': 'Export as Microsoft Excel',
		
		'fail2add_dataset': 'Fail to add dataset',         
        'fail2delete_dataset': 'Fail to delete dataset',
		'find' : 'Find',
		'find_replace' : 'Find and replace',
		'find_all': 'Find all',
		'file' : 'File',
		'file_name' : 'File name',
		'first_row_as_label' : 'Row label',		
		'first_col_as_label' : 'Column label',
		'filter_condition': 'Filtering by condition',
		'filter_sort': 'Filter and sort',
		'fill_sequence' : 'Fill sequence',
		'filtering' : 'Filtering',
		'fill_without_style' : 'fill without style',
		'format' : 'Format',
		'font' : 'Font',
		'format_brush': 'Format brush',
		'font_family': 'Font family',		
		'font_size': 'Font size',
		'font_color' : 'Font color',
		'forward' : 'Forward',
		'formatCells': 'Format Cells',
		'filter' : 'Filter',
		'function' : 'Function',
		'functionList' : 'Function list',
		'fraction' : 'Fraction',
		'freeze' : 'Freeze',		
		'freeze_sheet' : 'Freeze sheet',
		'freeze_first_row' : 'Freeze the first row',	
		'freeze_first_col' : 'Freeze the first column',
		
		'gain_loss': 'Win/Loss',
		'green_fill_darkgreen_text' : 'Green fill with dark green text',
		'good' : 'Good',
		'go_to_link' : 'Go to link',
		'greater_than': 'Greater than',		
		'greater_equal': 'Greater than or equal to',
		'greater_or_equal' : 'Greater or equal',
		'gray_theme' : 'Gray theme',
		'gray_text' : 'Gray text',

		'help' : 'Help',
		'hint' : 'Hint',
		'hide_column' : 'Hide column',
		'hint_text' : 'Hint text',
		'hide_cancel_hide' : 'Hide and cancel hide',	
		'hide_row' : 'Hide row',	
		'hide' : 'Hide',
		'hide_grid_line': 'Hide grid line',
		'hyperlink' : 'Hyperlink',	
		
		'ignore_blank' : 'Ignore blank',
		'image' : 'Image',
		'image_type_not' : 'Please select an image file to import',
		'image_not_available': 'The image is not available',
		'import' : 'Import',
		'importFile' : 'Import Excel file',
		'ImportDesc' : 'Choose a CSV or XLSX type file to import.',
		'ImportTakeAwhile' : 'It may take a few minutes to upload your file.',
        'insert_copy_overlap': 'Can not insert copied range when there is overlapped.',	
        'invalid_cell_content': 'Invalid cell content',
        'insert_copied': 'Insert copied',	
		'insert_copied_option': 'Insert copied option',
		'insert_column_at' : 'Insert column at',		
		'insert_cell_at' : 'Insert cell at',
		'insert_row_in_tabletpl' : 'You can only insert the whole row(s) for current selection in the table template, do you want to do it?',	
		'insert_column_in_tabletpl' : 'You can only insert the whole column(s) for current selection in the table template, do you want to do it?',
		'insert_function': 'Insert function',	
		'insert_sequence_no': 'Insert sequence No.',
		'insert_drop_list': 'Dropdown list',
        'input_drop_list': 'Input drop list',
        'input_variable_name': 'Variable name (only allow to contain letters, numbers . (dot) and _)',
		'input_reference_name': 'Input reference name',
		'input_file_name': 'Input file name',
		'input2search': 'Input to search',
		'input_sheet_name' : 'Input sheet name',
		'intelnet_error': 'Internal error, please try again.',
		'invalid_refer': 'Invalid reference',	
		'invalid_refer_display': 'Refer to a range does not exist, please check the spell of "{0}"',
		'index_out_range': 'Index out of range',		
		'index_out_param_range': 'The index is out of range in formula "{0}", please click <a href="{1}">here</a> to check more details.',
        'inc_indent' : 'Increase indent',
		'insert_whole_row' : 'Insert whole row',	
		'insert_whole_column' : 'Insert whole column',
		'insert_comment' : 'Insert comment',
		'insert_option' : 'Insert option',
		'insert_picture_by_url' : 'Insert picture by URL',
		'invalid_url' : 'Not a valid URL',
		'italic' : 'Italic',
		'italic_tip' : '<b>Italic (CTRL+I)</b><br/>Italicize your text.',
		'increase_font_size' : 'Increase font size',
		'insert_hyperlink': 'Insert hyperlink',
		'inspector' : 'Inspector',
		'input' : 'Input',
		'item' : 'Item',
		'insert_row_at' : 'Insert row at',
		'insert' : 'Insert',
		'insert_cell' : 'Insert cell',		
		'insert_row' : 'Insert row',		
		'insert_column' : 'Insert column',		
		'insert_sheet' : 'Insert sheet',
		'include' : 'Include',
		'inifnate_loop' : 'Infinite loop',
		'is_valid_date': 'Is valid date',
        'is_valid_email': 'Is valid email',	
		'is_valid_url': 'Is valid URL',
		'item_hint': 'Input like: apple, orange, banana. Separate items by ","',
		'item_list': 'Item list',	
		
		'keyboard_shortcuts': 'Keyboard shortcuts (CTRL+/)', 
		'keyboard_shortcuts_desc': '<Table WIDTH="100%"><tr><th COLSPAN="4" align="left">Text formatting</th></tr>' +
		                                 '<tr><td>Ctrl+B</td><td>Bold</td> <td>Ctrl+Shift+L</td><td>Align left</td></tr>' +
		                                 '<tr><td>Ctrl+U</td><td>Underline</td> <td>Ctrl+Shift+E</td><td>Align center</td></tr>' +
		                                 '<tr><td>Ctrl+I</td><td>Italic</td> <td>Ctrl+Shift+R</td><td>Align right</td></tr>' +
			                       '</Table>' +
			                       '<br/><Table WIDTH="100%"><tr><th COLSPAN="4" align="left">Actions</th></tr>' +		                                 
		                                 '<tr><td>Ctrl+O</td><td>Open file</td> <td>Ctrl+K</td> <td>Insert link</td> </tr>' +
		                                 '<tr><td>Ctrl+Z</td><td>Undo</td> <td>Ctrl+Y</td> <td>Redo</td></tr>' +
		                                 '<tr><td>Ctrl+X</td><td>Cut</td> <td>Ctrl+C</td><td>Copy</td></tr>' +
		                                 '<tr><td>Ctrl+V</td><td>Paste</td> <td>Ctrl+ALT+M</td><td>Insert/Edit Comment</td></tr>' +
			                             '<tr><td>Ctrl+F</td><td>Find and replace</td> <td></td><td></td></tr>' + 
			                        '</Table>',
		
		'label_setting' : 'Label settings',
		'last_week' : 'Last week',
		'last_month' : 'Last month',
		'layout' : 'Layout',
		'line_style' : 'Line style',
		'less_than': 'Less than',	
		'less_equal': 'Less than or equal to',
		'less_or_equal' : 'Less or equal',
		'list_number' : 'List number',		
		'list_dot' : 'List dot',		
		'line_space' : 'Line space',
		'line' : 'Line',
		'left': 'Left',
		'legend_position': 'Legend position',
		'less_than' : 'Less than',
		'light_color' : 'Light color',
		'link_cell' : 'Link cell',
		'link' : 'Link',
		'loading' : 'Loading',
		'login': 'Login',		
		'logout': 'Logout',
		'locale': 'Locale',
		'locale_chinese': 'Chinese (PRC)',
		'locale_english_us': 'English (United States)',
		'lang_en': 'English (英语)',
		'lang_zh': 'Chinese (中文)',
		'language' : 'Language (语言)',

		'mark_range' : 'Define named range',
		'max' : 'Max',	
		'min' : 'Min',
		'mini_charts' : 'Sparkline charts',
		'merge_cell' : 'Merge cells',		
		'merge_cell_in_column' : 'Merge cell in column',	
		'merge_cell_in_row' : 'Merge cell in row',
		'move_current_cell_right' : 'Move current cells right',	
		'move_current_cell_bottom' : 'Move current cells bottom',
		'money_format' : 'Money format',
		'money' : 'Money',
		'money_denmark_krone' : 'Denmark Krone',
		'money_china_rmb' : 'China RMB',
		'money_us_dollar' : 'United States Dollar',
		'money_korean_won' : 'Korean Won',
		'money_russian_rouble': 'Russian Ruble',
		'money_indian_rupee' : 'Indian Rupee',
		'money_european_euro' : 'Euro Member Countries',
		'money_japanese_yen': 'Japan Yen',
		'money_brazil_real' : 'Brazil Real',
		'money_english_pound' : 'United Kingdom Pound',
		'money_canada_dollar': 'Canadian Dollar',
		'money_australian_dollar' : 'Australian Dollar',
		'money_southAf_rand' : 'South African Rand',
		'money_indonsia_rupiah' : 'Indonesian Rupiah',
		'money_israel_shekel' : 'Israeli Shekel',
		'money_turky_lira' : 'Turkey Lira',
		'money_swit_franc' : 'Switzerland Franc',
		'money_sigapore' : 'Singapore Dollar',
		'money_argentina_peso' : 'Argentinan Peso',
		'money_chile_peso' : 'Chile Peso',
		'money_columbia_peso' : 'Colombian Peso',
		'money_taiwan_yen' : 'Taiwan New Dollar',
		'money_sweden' : 'Sweden Krona',
		'money_norway' : 'Norway Krone',
		'money_newzealand' : 'New Zealand Dollar',
		'money_malaysia' : 'Malaysian Ringgit',
		'money_hongkong' : 'Hong Kong Dollar',
		'money_saudi' : 'Saudi Arabia Riyal',
		'money_poland' : 'Poland Zloty',
		'money_mexico' : 'Mexico Peso',
		'money_iceland' : 'Iceland Krona',
		'money_bolivia' : 'Bolivian Boliviano',
		'money_bulgaria' : 'Bulgarian Lev',
		'money_egypt' : 'Egypt Pound',
		'money_lithuania' : 'Lithuanian Litas',
		'money_viet' : 'Viet Nam Dong',
		'money_ukraine' : 'Ukraine Hryvnia',
		'money_iran' : 'Iran Rial',
		'money_hungary' : 'Hungary Forint',
		'money_cuba' : 'Cuban Peso',
		'money_pakistan' : 'Pakistan Rupee',
		'money_romania' : 'Romanian New Leu',
		'money_jamaica' : 'Jamaican Dollar',
		'money_kazakhstan' : 'Kazakhstan Tenge',
		'money_lebanon' : 'Lebanon Pound',
		'money_thailand' : 'Thailand Baht',
		'money_afghan' : 'Afghanistan Afghani',
		'money_nigeria' : 'Nigeria Naira',
		'money_zimbabwe' : 'Zimbabwe Dollar',
		'money_albania' : 'Albania Lek',
		'money_czech' : 'Czech Republic Koruna',
		'more_functions' : 'More functions',
		'more': 'More',
		
		'nagativeNo' : 'Negative numbers',
		'name_repeated_with_calculate': 'This name is already taken by calculate',
		'negative' : 'Negative',
		'new_reference': 'Create a new reference',
		'new_validation': 'New validation',
		'new' : 'New',
		'new_customer_tpl' : 'New customer template',
		'new_cell_tpl' : 'New cell template',
		'new_dataset_name': 'New dataset name',         
        'new_dataset_hint': 'New dataset items, input like: apple, cat, bread. Separate items by comma (,)',
		'next': 'Next',
		'next_week' : 'Next week',
		'next_month' : 'Next month',
		'note' : 'Note',
		'none' : 'None',		
		'no_formula' : 'No formula',
		'no_fill_color' : 'No fill color',
		'number' : 'Number',
		'number_format' : 'Number format',
		'number_special' : 'Number Special',
		'number_filters' : 'Number filters',
		'number_not_right': 'The value of number is not right.',
		'no_selection_replace': 'Please select a target cell to replace',
		'not_valid_url': 'Not a valid URL',	
		'no_reference_name': 'No references to display',
		'not_contain': 'Not contain',
		'not_between' : 'Not between',
		'not_equal': 'Not equal',
		'no_related_calcualte': 'No related calculate available',
		'no_match_item': 'No match item found',
        'no_dataset_available': 'No dataset available',
		
		'ok' : 'OK',
		'on_before': 'On or before',
		'on_after': 'On or after',
		'only_current_range': 'Only sort current range',
		'options' : 'Options',	
		'open' : 'Open',	
		'open_sheet' : 'Open an existing sheet file',
		'output' : 'Output',
		'organize' : 'Organize',	
		'other_chart' : 'Other charts',
		'overline' : 'Overline',
		'other_borders' : 'Other borders',
		'only_fill_style' : 'Only fill style',
		'only_fill_content' : 'Only fill content',
		'only_allow_data_in_droplist': 'Only allow input data included in the drop list for the cell',
		'other_condition' : 'Other condition',
		'other_options' : 'Other options',
		'others' : 'Others',
		'other_accounting_format' : 'Other accounting format',
			
		'paste_at' : 'Paste at',
		'paste_number' : 'Paste number',
		'param_not_match': 'The length of parameter not the same',	
		'param_should_be_same': 'The length of all parameters need be the same in formula "{0}".',		
		'param_type_wrong': 'Parameter type error',		
		'param_need_be_num': 'The parameter of formula "{0}" need be a number',
		'param_miss': 'Parameter number is wrong',	
		'param_number_wrong': 'The calling parameter number for formula "{0}" is not right, please click <a href="{1}">here</a> to check more details.',
		'paste_copy_not_same_shape': 'The paste range should be the same shape as the copy range',
		'paste_number' : 'Paste number',		
		'paste_calculate' : 'Paste only with data or calculate',	
		'paste_calculate_format' : 'Paste with calculate and format',		
		'paste_style' : 'Only paste style',	
		'paste_reverse' : 'Reverse paste',		
		'paste_value' : 'Only paste value',	
		'paste_value_format' : 'Paste value with format',
		'paste_value_style' : 'Paste value with style',	
		'paste' : 'Paste',
		'paste_tip' : '<b>Paste (CTRL+V)</b><br/>Add content on the clipboard into the sheet.',	
		'paint_border' : 'Paint border',
		'pie' : 'Pie',
		'percentage' : 'Percentage',
		'percent' : 'Percent',
		'permissionDeny' : 'Permission Deny',
		'picture_link': 'Picture link',
		'picture_url' : 'Picture URL',
		'picture' : 'Picture',
		'phoneNumber': 'Phone number',
		'placeInDoc': 'Place in this document',
		'positive' : 'Positive',
		'preview' : 'Preview',		
		'preview_img_below': 'Click "Preview" to see the picture below after you enter the picture link.',
		'preview_widget_below': 'Click "Preview" to see the widget below after you enter the widget link.',
		'percent_set_as' : '%, set as',
		'percent_format' : 'Percent format',
		'positive_number' : 'Should be a positive number or 0',
		'pink_fill' : 'Red fill',
		'pure_color_fill' : 'Pure color fill',			
		'preference' : 'Preference',
		'prev': 'Prev',
		
		'radar': 'Radar',
		'range' : 'Range',
		'radio': 'Radio',
		'redo': 'Redo',
		'remove_filter': 'Remove filter',
		'remove' : 'Remove',
		'remove_indent' : 'Remove indent',
		'relative_coord' : 'Relative coordinate',
		'regular' : 'Regular',
		'rename' : 'Rename',
		'refresh': 'Refresh',
		'right': 'Right',
		'really_replace_all': 'Do you really want to replace all found cells?',
		'reference_name_invalid': 'This reference name is invalid, no blank is allowed or something like a cell/row/column reference range, <br/>such as "A1, B100". It should start with a letter or an underscore.',
		'reference_range': 'Reference range',
		'remove_validation' : 'Remove validation',
		'relative' : 'Relative',
		'replace_find' : 'Replace/Find',		
		'replace' : 'Replace',		
		'replace_all' : 'Replace all',		
		'replace_with' : 'Replace with',
		'remove_whole_row' : 'Remove whole row',	
		'remove_whole_column' : 'Remove whole column',	
		'remove_option' : 'Remove option',		
		'red_fill_darkred_text' : 'Red fill with dark red text',
		'red_text' : 'Red text',
		'repeat_value' : 'Repeat value',
		'right_side_cell_move_left' : 'Right side cells move left',
		'result_infinity': 'The calculated result is infinity',
		'row_absolute': 'Row absolute',
		'row' : 'Row',
		'ready' : 'Ready',
		'row_height' : 'Row height',
		'remote_select' : 'Custom dropdown list',
		'remote_select_type_hint': 'Please enter URL for access dropdown list. Return data from URL should be in json format with id and value. Such as:',
		
		'saving': 'Saving',
		'saving_beforeload': 'Saving before load',
		'save_change_before_reload' : 'Do you really want to reload the page before all your changes are saved.',
		'save' : 'Save',	
		'save_as' : 'Save as',
		'save_sheet_as': 'Save this sheet as',
		'saveBeforeExport' : 'Please save file first before processing export',
		'scatter' : 'Scatter',
		'science' : 'Science',
		'search': 'Search',
		'series_at_row': 'Series at row',		
		'series_at_col': 'Series at column',	
		'set_style_for_less' : 'Set style for cells less than below value',		
		'set_style_for_greater' : 'Set style for cells greater than below value',		
		'set_style_for_equal' : 'Set style for cells equal below value',		
		'set_style_for_include' : 'Set style for cells include below value',		
		'set_style_for_between' : 'Set style for cells between below values',		
		'set_style_begin_at' : 'Set style for cells begin at',	
		'set_style_date_ocurring_at' : 'Set style for cells date occurring',
		'set_style_max_value' : 'Set style for cells with top value',		
		'set_style_top_value' : 'Set style for cells with top percent',		
		'set_style_min_value' : 'Set style for cells with bottom value',		
		'set_style_bottom_value' : 'Set style for cells with bottom percent',		
		'set_style_above_average' : 'Set style for cells above average value',		
		'set_style_below_average' : 'Set style for cells below average value',		
		'set_style_for_cell' : 'Set Style for cells with below condition',
		'select_file2process' : 'Select a file and click Open button to process',
		'select_tpl2process' : 'Select a template sheet and click Copy button to process',
		'select_filter_condition': 'Select a filtering condition',
		'select_range_for_mini_chart': 'Select a range for sparkline chart',
		'select_all' : 'Select all',
		'select_image': 'Select an image to insert',
		'set_table_tpl' : 'Set table template for',
		'shape' : 'Shape',
		'sheet_name_invalid' : 'Sheet name is invalid, there is no char of "\'\"\+\-\*\/!" allowed.',	
		'sheet' : 'Sheet',
		'sheetTpl': 'Template Sheet',
		'sheetFromTpl': 'Sheet from Template',
		'sheetNewTpl': 'Untitled sheet template',
		'sheetTplUpdateTip': 'You are updating template sheet',
		'sheetPublicTip': 'This file have a public view link',
		'sort_option' : 'Sort option',
		'sort_asc' : 'Sort ascending',	
		'sort_desc' : 'Sort descending',
		'split' : 'Split',
		'strike': 'Strike',
		'share' : 'Share',
		'style' : 'Style',
		'steps' : 'step(s)',
		'set_as' : 'Set as',
		'show' : 'Show',
        'selection_range' : 'Selection range',
		'standard_colors' : 'Standard colors',
		'setting' : 'Settings',
		'select_from_left_list': 'Select a dataset from the left list',
		'setup_droplist': 'Setup drop list',
        'select_data_source': 'Select data set',
		'should_be_one_of': 'One of',
		'show_grid_line': 'Show grid line',
		'show_condition_style_of' : 'Show condition style of',
		'sole_value' : 'Sole value',
		'split_sheet' : 'Split sheet',
		'start' : 'Start',
		'series_position': 'Series position',
		'series' : 'Series',
		'selection_move2' : 'Move selection range to',
		'strong' : 'Strong',
		'swift_sheet' : 'EnterpriseSheet',		
		'swift_page' : 'Sheet Page',
		'symbol' : 'Symbol',
		'sort_filter' : 'Sort and filter at',
		'summary' : 'Summary',
		'subject_text' : 'Subject text',
		'supportImportFormat' : 'Support file format: CSV and XLSX',
		'support': 'Support',
		'sort' : 'Sort',
		'symbol' : 'Symbol',
		'sum' : 'Sum',
		'ssn' : 'Social Security Number',
		
		'tabColor': 'Tab color',
		'target_range_shouldbe_same_size': 'The target range should be the same size',
		'table' : 'Table',
		'table_styles' : 'Table style',
		'text_filters' : 'Text filters',
		'text' : 'Text',
		'text_long': 'Long text',
		'template' : 'Template',
		'theme_colors' : 'Theme colors',
		'time' : 'Time',
		'title' : 'Title',
		'today' : 'Today',
		'tomorrow' : 'Tomorrow',
		'this_week' : 'This week',
		'this_month' : 'This month',
		'title_x_axis': 'Title on X axis',	
		'title_y_axis': 'Title on Y axis',
		'total_sheet_number': 'Total sheet number',
		'top_10_value' : 'Top 10',		
		'top_10%' : 'Top 10%',
		'top10' : 'Top 10',
		'top': 'Top',
		'tool' : 'Tool',
		'to' : 'to',
		'type' : 'Type',
		
		'undo': 'Undo',
		'underline' : 'Underline',
		'underline_tip' : '<b>Underline (CTRL+U)</b><br/>Underline your text.',
		'uncheck_all': 'Uncheck all',
		'untitle_spreadsheet' : 'Untitled spreadsheet',
		'update_date': 'Update Date',
		'uploadHint' : '<font color="blue">Please be aware, due to technical limitations, there may be some improper formatting after importing the file.</font>',

		'var_already_defined': 'This variable is already defined, please change to another name.',
		'validation' : 'Validation',
		'value' : 'Value',	
		'value_invalid': 'Value is invalid',
		'value_of_calculate_invalid': 'The value of this calculate is not a number or a text.',
		'value_not_available': 'The value is not available to a function or formula.',
		'view' : 'View',
		
		'waiting': 'In process, please wait ...',
		'warning_text' : 'Warning text',
		'want2delete_dataset': 'Do you really want to delete this dataset?',
		'word_wrap' : 'Word wrap',
		'whoisediting': 'Click to see who is editing now',
		'listofediting': 'List of editing user(s)',
		
		'yesterday' : 'Yesterday',
		'yellow_fill_darkyellow_text' : 'Yellow fill with dark yellow text',
		'yellow_text' : 'Yellow text',
		
		'zero' : 'Zero',

		'7day' : 'In the last 7 days',
		
		'lookup':'Lookup',
	    'statistical':'Statistical',
	    'engineering':'Engineering',
	    'enterpriseSheet':'EnterpriseSheet',
	    'string':'Text',
	    'logic':'Logical',
	    'numeric':'Mathematical',
	    'finicial':'Financial',
		'info':'Information',
		'compatibility':'Compatibility',
        'processing': 'Processing',
        'action_on_read_only': 'Can not apply this action because this sheet is read only',
        'tab_name_existed': 'Can not add this new tab because this sheet name is already existed',
        'cannot_rename_existed_tabname': 'Can not rename this tab to an existed name',
        'wedgit': 'Widget',
        'wedgit_url': 'The url of widget',
        'create_wedgit': 'Create widget',
        'delete_wedgit': 'Delete widget',
        'icon_set': 'Icon sets',
        'public': 'Public',
        'enterEmailForNotif': 'Enter email below and click "Send" button to give notification',
        'privateView': 'This file is not public yet, click "Make Public" button to public it and generate a link',
        'privateKeep': 'Make Private',
        'publicFile': 'Make Public',
        'publicView': 'Allow anyone with the link to view (no sign-in required)',
        'publicFileEditable': 'Allow anyone with the link to edit (no sign-in required)',
        'publicViewFile': 'This file have a public link which allow anyone to view',
        'other_rule': 'Other rule',
        'iconset_rule': 'Icon set rule',
        'reverse_icon_set': 'Reverse Icon set',
        'show_icon_only': 'Show icon only',
        'customize': 'Customize',
        'when_value_is': 'When value is',
        'formula': 'Formula',
        'and': 'and',
        'backend_error_occur': 'Oops, there is a backend error, these changes are not updated. Please click "Report" to report this error to us, we will fix it ASAP.',
        'disconnect_with_server': 'Server connect error',
        'reconnect_in': 'reconnect in',
        'seconds': 'Seconds',
        'second': 'Second',
        'reconnect': 'Reconnect',
        'connectiong_sever': 'Connecting server',
        'report': 'Report',
        'submit': 'Submit',
        'delete_repeat_item': 'Delete repeat items',
        'found_repeat_value': 'Found {0} repeat value<br>{1} values will be reserved.',
        'can_not_only_change_part_of_array_formula': 'You changes are not made, because it can not only change part cells of the array formula',
        'hide_title_region': 'Hide title region',
        'show_title_region': 'Show title region',
        'image_in_cell': 'Image in cell',       
        'scope': 'Scope',
        'current_document': 'Current document',
        'invalid_name': 'Invalid name',
        'invalid_name_in_cal': 'There is invalid name in this formula',
        'calculating': 'Calculating',
        'input_array_formula': 'Input array formula',
        'first_row_as_label': 'First row as label',
        'first_col_as_label': 'First column as label',
        'not_rectangle_range': 'Can not process this action, because the chart related range is not a rectangle',
        'pivot_table': 'Pivot table',
        'set_header_title': 'Set as header title',
        'insert_date_picker': 'Insert date picker',
        'any_integer': 'Any integer',
        'any_number': 'Any number',
        'integer_only': 'Integer only',
        'col_icon': 'Column icon',
        'column_title': 'Column title',
        'input_column_title': 'Input column title',
        'column_data_type_config': 'Column data type configuration',
        'pick_data_type': 'Pick a column data type',
        'text':'Text',
        'number': 'Number',
        'date': 'Date',
        'single_select': 'Single select',
        'multi_options': 'Multiple options',        
        'phone': 'Phone',
        'email': 'Email',
        'url': 'URL',
        'currency': 'Currency',
        'attachment': 'Attachment',
        'text_type_hint': 'A piece of text, preset a default value for empty cells if needed',
        'text_type_hint2': 'A piece of long text',
        'phone_type_hint': 'A phone number, which is composed of 3 numbers or more',
        'url_type_hint': 'A URL, like: http://www.enterprisesheet.com',
        'email_type_hint': 'An email address, like: info@abc.com',
        'number_type_hint': 'A number, preset a default value for empty cells if needed',
        'date_type_hint': 'A date, check below if you want to add time field',
        'input_default_value': 'Input default value here',
        'add_time_field': 'Add time field',
        'checkbox_type_hint': 'A checkbox, you can only check or uncheck it',
        'radio_type_hint': 'A radio box',
        'default_value': 'Default value',
        'check_uncheck_only': 'You can only check or uncheck it',
        'hide_title': 'Hide column title',
        'show_title': 'Show column title',
        'min_value': 'Minimum value',
        'max_value': 'Maximum value',
        'is_date': 'need be a valid date',
        'clean_data_type': 'Clean data type',
        'single_select_type_hint': 'Single select list, you can select one of these options',
        'multi_options_type_hint': 'Multiple options, you can select more than one of these options',
        'should_be_part_of': 'Should be part of',
        'attach_type_hint': 'Attachment, you can attach file or image in the cell',
        'no_attach_yet': 'No attachment yet, click above button to add',
        'attachment': 'Attachment',
        'upload_file': 'Upload file',
        'link_file': 'Link file',
        'upload_linke_attachment': 'Upload or link more attachment',
        'enter_password': 'Enter password',
        'previous': 'Previous',
        'download': 'Download',
        'show_new_tab': 'Show in new tab',
        'on_current_page': 'On current page',
        'display': 'Display',
        'uploading': 'Uploading',
        'downloading': 'Downloading',
        'loading_calculating': 'Loading related cells and calculating',
        'prev_page': 'Last page',
        'next_page': 'Next page',
        'rendering': 'Rendering',
        'can_not_process_action_on_disabled_cell': 'Can not process this action on disabled cell',
        'skip_process_action_on_disabled_cell': 'Skip to perform this action on some related disabled cells',
        'confirm_process_action_on_disabled_cell': 'Can not process this action on disabled cell, click "Yes" to cancel the process, or click "No" to continue but skip the disabled cell',
        'change_checked': 'Change checked',
        'print_setting': 'Print setting',
        'page': 'Page',
        'header': 'Header',
        'footer': 'Footer',
        'margins': 'Margins',
        'orientation': 'Orientation',
        'portrait': 'Portrait',
        'landscape': 'Landscape',
        'scaling': 'Scaling',
        'adjust_to': 'Adjust to',
        'normal_size': 'Normal size',
        'paper_size': 'Paper size',
        'black_and_white': 'Black&White',
        'top_margin': 'Top margin',
        'bottom_margin': 'Bottom margin',
        'left_margin': 'Left margin',
        'right_margin': 'Right margin',
        'header_margin': 'Header margin',
        'footer_margin': 'Footer margin',
        'define_header': 'Define header',
        'define_footer': 'Define footer',
        'different_on_odd_even_page': 'Different on odd and even page',
        'different_on_first_page': 'Different on the first page',
        'page_1': 'Page &[Page No]',
        'page_&': 'Page &P',
        'page_1_total_page': 'Page &[Page No], total page &[Total page]',
        'page_&_total_page': 'Page &P, total page &N',
        'first_page_header': 'Header of the first page',
        'odd_page_header': 'Header of the odd page',
        'even_page_header': 'Header of the even page',
        'first_page_footer': 'Footer of the first page',
        'odd_page_footer': 'Footer of the odd page',
        'even_page_footer': 'Footer of the even page',
        'center': 'Center',
        'insert_page_no': 'Insert page No',
        'insert_total_page': 'Insert total page',
        'insert_date': 'Insert date',
        'page_no': 'Page No',
        'total_page': 'Total page',
        'change_saved': 'The change is saved successfully',
        'fail2save': 'Fail to save the change',
        'first_page': 'First page',
        'odd_page': 'Odd page',
        'even_page': 'Even page',
        'other_page': 'Other page',
        'print_hint': 'Due to some technique reason, you can not print this document directly, please export this file as a xlsx file, and then print in MS Excel.',
        'cut_move_selection': 'Cut and move selection',
        'change_cells': 'Change cells',
        'changed_by_other_user': 'Changed by other user',
        'remove_defined_func': 'Remove defined functions',
        'update_defined_func': 'Update defined functions',
        'create_defined_func': 'Create defined functions',
        'locating_mouseup_render': 'Locating...(release mouse to render)',
        'broken_tpl_cell_hint': 'This action will break the table template cell, please remove the related table template cells first.',
        'conflict_check': 'Checking to avoid any conflict with the editing from other user',
        'other_do_conflict_action': 'is making action which could cause conflict, please wait a moment',
        'your_action_conflicted': 'Your action is cancelled because confliction',
        'lock_edit_for_all': 'Lock editing of selection for all',
        'lock_edit_for_other': 'Lock editing of selection for others',
        'set_lock_edit': 'Lock editing of selection',
        'check_user_can_edit_selection': 'Check user who you allow to edit the selection',
        'can_edit_selection': 'can edit the selection',
        'hide_row_name': 'Hide row name',
        'show_row_name': 'Show row name',
        'hide_col_name': 'Hide column name',
        'show_col_name': 'Show column name',
        'name': 'Name',
        'permission': 'Permission',
        'read_only': 'Read only',
        'can_edit': 'Can edit',
        'can_share': 'Can share',
        'can_edit_not_del': 'Can edit but not delete',
        'can_edit_not_export': 'Can edit but not export',
        'allow': 'Allow',
        'no_one_allow_edit_selection': 'No one is allowed to edit the selection',
        'edit_selection': 'to edit the selection'
	}	
}, function(){
    if(!window['SLANG']){
        SLANG = (Ext.create('EnterpriseSheet.lang.Language')).content;
    }
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.common.CONST', {
	
	singleton : true,
	
	requires: [	   	   
	    'EnterpriseSheet.lang.Language'	   	   
	],
	
	constructor : function(){		
		if(!Ext.isIE){
			/*
			 * EXT 4.2.1 can not set isIE rightly in IE11, we need check again
			 */
			if(navigator.userAgent.indexOf('MSIE') !== -1 || navigator.appVersion.indexOf('Trident/') > 0) {
				Ext.isIE = true;
			}
		}
		
        var ml = (Ext.isChrome || Ext.isSafari) ? 17895697 : (Ext.isGecko ? 8000000 : 10000000);
        ml = 4094267;
        
		this.callParent(arguments);
		
		Ext.apply(this, {
			
			version: '3.2.1.20160420',  
			limitType: '3.0.5.20150201', 
            RECONNECT_SERVER_INTERVAL: 30000,
			FORMAT_DATE: 'date',	    
		    FORMAT_TIME: 'time',		    
		    FORMAT_DATE_TIME: 'datetime',		
			DEFAULT_DATE_FORMAT : 'Y-m-d', // Default should be yyyy-mm-dd match MS Excel default format
		    DEFAULT_TIME_FORMAT : 'H:i:s',
		    DEFAULT_DATE_TIME_FORMAT : 'Y-m-d H:i',
		    HIA_TIME_FORMAT : 'h:i A',
		    
		    // WE SAVE some repeat value in the cache
		    // this cache will be clean when cell is edit.
		    // See CellEditor.js -- startEdit method
		    GOLBAL_CACHE_LIST_10 : [],
		    GOLBAL_CACHE_KEY_10 : [],
		    
		    FORMAT_PERCENT: 'percent',	    
		    DEFAULT_PERCENT_FORMAT : '0.00%',
		    NO_DECIMAL_PERCENT_FORMAT : '0%',
    
		    FORMAT_COMMA: 'comma',	    
		    DEFAULT_COMMA_FORMAT : '#,000.00',
		    
		    FORMAT_SCIENCE: 'science',
		    DEFAULT_SCIENCE_FORMAT : '0.00E+00', 
		    
		    FORMAT_NUMBER: 'number',	    
		    DEFAULT_NUMBER_FORMAT : '0.00', 
		    
		    FORMAT_SPECIAL: 'special',	    
		    
		    FORMAT_CURRENCY: 'currency',
		    DEFAULT_CURRENCY_FORMAT: '#,##0.00', // will add money symbol in work level ...
		    
		    FORMAT_FRACTION: 'fraction',
		    DEFAULT_FRACTION_FORMAT : '# ?/?', 
			
		    MARKER_SHAPES: ['circle', 'cross', 'diamond', 'plus',  'triangle', 'line', 'arrow', 'square'],
			
			SSID: 'ENTERPRISESHEET$r3BwrrtnWdRxfvfMUZKBtp8Z5nnRxfDvs2GhdZ96GgFKw8BBRkPfL4H4UCt45CQH$LIBOYANG',
			
			/*
			 * url reg
			 */
			urlReg: /((((^https?)|(^ftp)|(^mailto)):\/\/)?([\-\w]+\.)+\w{2,3}(\/[%\-\w]+(\.\w{2,})?)*(([\w\-\.\?\\\/+@&#;`~=%!]*)(\.\w{2,})?)*\/?)/i,
			
			strictUrlReg: /((([A-Za-z]{3,9}:(?:\/\/)?)(?:[\-;:&=\+\$,\w]+@)?[A-Za-z0-9\.\-]+|(?:www\.|[\-;:&=\+\$,\w]+@)[A-Za-z0-9\.\-]+)((?:\/[\+~%\/\.\w\-_]*)?\??(?:[\-\+=&;%@\.\w_]*)#?(?:[\.\!\/\\\w]*))?)/,
						
			//urlProReg: /((http|ftp|https|mailto):\/\/)(([a-zA-Z0-9\._-]+\.[a-zA-Z]{2,6})|([0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}))(:[0-9]{1,4})*(\/[a-zA-Z0-9\&%_\.\/-~-]*)?/i,
			urlProReg: /^(http|ftp|https|mailto):/i,
			
			jsDateFm: ['Y-m-d', 'd-m-Y', 'F d, Y', 'M d, Y', 'm/d/Y', 'y-m-d', 'd-m-y', 'd-M-y', 'l, M d, Y'],   
            javaDateFm: ['yyyy-MM-dd', 'dd-MM-yyyy', 'MMMM dd, yyyy', 'MMM dd, yyyy', 'MM/dd/yyyy', 'yy-MM-dd', 'dd-MM-yy', 'dd-MMM-yy', 'EEEE, MMMM dd, yyyy'],
			
            jsTimeFm: ['H:i:s', 'H:i', 'g:i:s A', 'g:i A', 'G:i:s A'],   
            javaTimeFm: ['HH:mm:ss', 'HH:mm', 'hh:mm:ss AM/PM', 'hh:mm AM/PM', 'HH:mm:ss AM/PM'],	
            
            jsDateTimeFm: ['Y-m-d H:i:s', 'Y-m-d H:i', 'Y-m-d g:i:s A', 'Y-m-d g:i A', 'Y-m-d G:i:s A'],  
            javaDateTimeFm: ['yyyy-MM-dd HH:mm:ss', 'yyyy-MM-dd HH:mm', 'yyyy-MM-dd hh:mm:ss AM/PM', 'yyyy-MM-dd hh:mm AM/PM', 'yyyy-MM-dd HH:mm:ss AM/PM'],	
            
            // this is const to check whether it includes those special formuls
            // if yes, replace {} -> []
            specialFormuals : ["=sum", "=sumproduct", "=sumx2py2", "=sumx2my2", "=sumxmy2", "=small", "=rows",
                               "=index", "=large", "=lookup", "=type", "=match", "=networkdays", "=slope", "=workday",
                               "=steyx", "=avedev", "=devsq", "=rsq"],
            
			/*
			 * 4 different type of reference
			 */
			ABSOLUTE_COORD : 1,
			
			RELATIVE_COORD : 2,
			
			ABSOLUTE_ROW_COORD : 3,
			
			ABSOLUTE_COL_COORD : 4,
			
			REPEAT_VALUE : 0,
			
			SOLE_VALUE : 1,
			
			YESTERDAY : 0,
			
			TODAY : 1,
			
			TOMORROW : 2,
			
			SEVEN_DAY : 3,
			
			LAST_WEEK : 4,
			
			THIS_WEEK : 5,
			
			NEXT_WEEK : 6,
			
			LAST_MONTH : 7,
			
			THIS_MONTH : 8,
			
			NEXT_MONTH : 9,
			
			OTHER_OPTION : 10,
			
			ABOVE_AVERAGE : 0,
			
			BELOW_AVERAGE : 1,
			
			//MAX_ROW_NUMBER: 1048567,
			
			//MAX_COLUMN_NUMBER: 16384,
			
			/*
			 * request time out
			 */
			PULLING_TIMEOUT: 300000,
			
			MAX_ROW_NUMBER: 1048576,
			
			MAX_COLUMN_NUMBER: 1024,
			
			azChars : ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
			           'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'],
			           
			char2Num : {
                'A':0,
                'B':1,
                'C':2,
                'D':3,
                'E':4,
                'F':5,
                'G':6,
                'H':7,
                'I':8,
                'J':9,
                'K':10,
                'L':11,
                'M':12,
                'N':13,
                'O':14,
                'P':15,
                'Q':16,
                'R':17,
                'S':18,
                'T':19,
                'U':20,
                'V':21,
                'W':22,
                'X':23,
                'Y':24,
                'Z':25
			},
			
			letters : {
				'0':'A',
				'1':'B',
				'2':'C',
				'3':'D',
				'4':'E',
				'5':'F',
				'6':'G',
				'7':'H',
				'8':'I',
				'9':'J',
				'a':'K',
				'b':'L',
				'c':'M',
				'd':'N',
				'e':'O',
				'f':'P',
				'g':'Q',
				'h':'R',
				'i':'S',
				'j':'T',
				'k':'U',
				'l':'V',
				'm':'W',
				'n':'X',
				'o':'Y',
				'p':'Z',
                  
                '10':'K',
                '11':'L',
                '12':'M',
                '13':'N',
                '14':'O',
                '15':'P',
                '16':'Q',
                '17':'R',
                '18':'S',
                '19':'T',
                '20':'U',
                '21':'V',
                '22':'W',
                '23':'X',
                '24':'Y',
                '25':'Z'
			},
			
			
			// for more: http://www.xe.com/symbols.php
			money_code : {
				'usd': '$',
				'rmb': String.fromCharCode(165),				
				'eur': String.fromCharCode(8364),
				'all': 'Lek',
				'afn': String.fromCharCode(1547), 
				'ars': '$',
				'aud': 'A$',
				'bob': '$b',
				'brl': 'R$', // Brazil
				'bgn': String.fromCharCode(1083) + String.fromCharCode(1074),
				'cad': 'C$',
				'clp' : '$',
				'cop' : '$',
				'cup' : String.fromCharCode(8369),
				'czk' : String.fromCharCode(75) + String.fromCharCode(269),
				'dkk' : 'Kr',
				'egp' : String.fromCharCode(163),
				'hkd' : '$',
				'huf' : 'Ft',
				'isk' : 'Kr',
				'irr' : String.fromCharCode(65020),
				'inr': String.fromCharCode(8377),
				'idr' : 'Rp',
				'ils' : String.fromCharCode(8362),
				'jmd' : 'J$',
				'jpy' : String.fromCharCode(165),
				'kzt' : String.fromCharCode(1083)+String.fromCharCode(1074),
				'ltl': 'Lt',
				'won' : String.fromCharCode(8361),
				'lbp' : String.fromCharCode(163),
				'myr' : 'RM',
				'mxn' : '$',
				'ngn' : String.fromCharCode(8358),
				'nzd' : '$',
				'nok' : 'Kr',
				'pkr' : String.fromCharCode(8360),
				'pln' : 'z'+String.fromCharCode(322),
				'ron' : 'lei',
		        'rub': '&#x20bd;',
		        'sar': String.fromCharCode(65020),
		        'sgd' : '$',
				'zar' : 'R',
				'sek' : 'Kr',
				'chf' : 'CHF',
				'thb' : String.fromCharCode(3647), 
				'twd' : 'NT$',	
				'try' : String.fromCharCode(8356),
				'uah' : String.fromCharCode(8372),
				'gbp' : String.fromCharCode(8356),
				'vnd' : String.fromCharCode(8363),
				'zwd' : 'Z$'
			},
			
			money_list : [
			     {abbr: "usd", name: SLANG['money_us_dollar']},
	             {abbr: "rmb", name: SLANG['money_china_rmb']},
	             {abbr: "eur", name: SLANG['money_european_euro']},
	             {abbr: "all", name: SLANG['money_albania']},
	             {abbr: "afn", name: SLANG['money_afghan']},
	             {abbr: "ars", name: SLANG['money_argentina_peso']},
	             {abbr: "aud", name: SLANG['money_australian_dollar']},
	             {abbr: "bob", name: SLANG['money_bolivia']},
	             {abbr: "brl", name: SLANG['money_brazil_real']},
	             {abbr: "bgn", name: SLANG['money_bulgaria']},
	             {abbr: "cad", name: SLANG['money_canada_dollar']},
	             {abbr: "clp", name: SLANG['money_chile_peso']},
	             {abbr: "cop", name: SLANG['money_columbia_peso']},
	             {abbr: "cup", name: SLANG['money_cuba']},
	             {abbr: "czk", name: SLANG['money_czech']},
	             {abbr: "dkk", name: SLANG['money_denmark_krone']},
	             {abbr: "egp", name: SLANG['money_egypt']},
	             {abbr: "hkd", name: SLANG['money_hongkong']},	
	             {abbr: "huf", name: SLANG['money_hungary']},	
	             {abbr: "isk", name: SLANG['money_iceland']},
	             {abbr: "irr", name: SLANG['money_iran']},
	             {abbr: "inr", name: SLANG['money_indian_rupee']},
	             {abbr: "idr", name: SLANG['money_indonsia_rupiah']},
	             {abbr: "ils", name: SLANG['money_israel_shekel']},
	             {abbr: "jmd", name: SLANG['money_jamaica']},
	             {abbr: "jpy", name: SLANG['money_japanese_yen']},
	             {abbr: "kzt", name: SLANG['money_kazakhstan']},
	             {abbr: "won", name: SLANG['money_korean_won']}, 
	             {abbr: "lbp", name: SLANG['money_lebanon']},
	             {abbr: "ltl", name: SLANG['money_lithuania']},	             
	             {abbr: "myr", name: SLANG['money_malaysia']}, 
	             {abbr: "mxn", name: SLANG['money_mexico']},
	             {abbr: "nzd", name: SLANG['money_newzealand']}, 
	             {abbr: "ngn", name: SLANG['money_nigeria']}, 
	             {abbr: "nok", name: SLANG['money_norway']}, 
	             {abbr: "pkr", name: SLANG['money_pakistan']}, 
	             {abbr: "pln", name: SLANG['money_poland']}, 	
	             {abbr: "ron", name: SLANG['money_romania']},
	             {abbr: "rub", name: SLANG['money_russian_rouble']},
	             {abbr: "sar", name: SLANG['money_saudi']},
	             {abbr: "sgd", name: SLANG['money_sigapore']},
	             {abbr: "zar", name: SLANG['money_southAf_rand']},
	             {abbr: "sek", name: SLANG['money_sweden']},
	             {abbr: "chf", name: SLANG['money_swit_franc']},
	             {abbr: "twd", name: SLANG['money_taiwan_yen']},
	             {abbr: "thb", name: SLANG['money_thailand']},
	             {abbr: "try", name: SLANG['money_turky_lira']},	
	             {abbr: "uah", name: SLANG['money_ukraine']},
	             {abbr: "gbp", name: SLANG['money_english_pound']},
	             {abbr: "vnd", name: SLANG['money_viet']},
	             {abbr: "zwd", name: SLANG['money_zimbabwe']}
	        ],
	        
	        NUMBER_CUSTOM_FORMAT : {
				'num1': '0',
				'num2': '0.00',
				'num3': '#,##0',
				'num4': '#,##0.00',
				'num5': '# ?/?',
				'num6': '0.0e+00',
				'num7': '#,##0.00;[Red]-#,##0.00',
				'num8': '$#,##0.00;[Red]-$#,##0.00;[Red]ZERO'
	        },
			NUMBER_CUSTOM_COLOR : ['red', 'white', 'blue', 'magenta', 'yellow', 'black', 'cyan', 'green'],
			
			percent_list : [
				{name: '0%'},
				{name: '0.0%'},
				{name: '0.00%'},
				{name: '0.000%'},
				{name: '0.0000%'},
				{name: '0.00000%'}
			],
			
			EXCEL_DB_NUM : ['dbnum1', 'dbnum2', 'dbnum3'],
			CHINESE_NUM_1_16UNI : ['\u96f6', '\u4e00', '\u4e8c', '\u4e09', '\u56db', '\u4e94', '\u516d', '\u4e03', '\u516b', '\u4e5d'],
			CHINESE_NUM_2_16UNI : ['\u96f6', '\u58f9', '\u8d30', '\u4e09', '\u56db', '\u4e94', '\u516d', '\u4e03', '\u516b', '\u4e5d'],
			
			locale_list : [
			     {id: 'english_us', name: SLANG['locale_english_us']},
			     {id: 'chinese', name: SLANG['locale_chinese']} 
			],
			
			// 人民?大写转化 
			chinese_number_special : [
			     {id: 'rmb1', name: '\u4eba\u6c11\u5e01\u5927\u5199\u8f6c\u5316'}, 
			     {id: 'rmb2', name: '\u4eba\u6c11\u5e01\u5c0f\u5199\u8f6c\u5316'}
		    ],
			english_us_number_special : [{id: 'phoneus', name: SLANG['phoneNumber']}, {id: 'ssn', name: SLANG['ssn']}],
			
			fullWeekNames: [
			    'Monday',
			    'Tuesday',
			    'Wednesday',
			    'Thursday',
			    'Friday',
			    'Saturday',
			    'Sunday'
			],
			
			shortWeekNames: [
			    'Mon',
			    'Tue',
			    'Wed',
			    'Thu',
			    'Fri',
			    'Sat',
			    'Sun'
			],
			
			fullMonthNames: [
			    'January',
			    'February',
			    'March',
			    'April',
			    'May',
			    'June',
			    'July',
			    'August',
			    'September',
			    'October',
			    'November',
			    'December'
			],
			
			fullMonthNames_low: [
			    'january',
			    'february',
			    'march',
			    'april',
			    'may',
			    'june',
			    'july',
			    'august',
			    'september',
			    'october',
			    'november',
			    'december'
			],
			
			shortMonthNames : [
			    'Jan',
			    'Feb',
			    'Mar',
			    'Apr',
			    'May',
			    'Jun',
			    'Jul',
			    'Aug',
			    'Sep',
			    'Oct',
			    'Nov',
			    'Dec'
			],
			
			shortMonthNames_low: [
			    'jan',
			    'feb',
			    'mar',
			    'apr',
			    'may',
			    'jun',
			    'jul',
			    'aug',
			    'sep',
			    'oct',
			    'nov',
			    'dec'
			],
			
			dir : {
				'xy':'overflow:auto;',
				'x':'overflow-x:auto;',
				'y':'overflow-y:auto;',
				'none':'overflow:hidden;'
			},
			
			MAX_LENGTH : ml,
			
			dirbody : {
				/*
				 * 17895697 is the maximun height or width we can set for a div in ff3
				 */
				'xy':'width:110%;height:110%;',
				'x':'width:110%;height:100%;',
				'y':'width:100%;height:110%;',
				'none':'width:'+ml+'px;height:'+ml+'px;'
			},
			
			jsSSDateFormat : {
				'm' : 'm',
				'mm' : 'm',
				'mmm' : 'M',
				'mmmm' : 'F',
				'd' : 'j',
				'dd' : 'd',
				'ddd' : 'D',
				'dddd' : 'l',
				'yy': 'y',
				'yyyy': 'Y'
			},
			
			/*
			 * define the exceptions
			 */
			exceptions : {
				CAL_INFINATE_LOOP : {
					
				}
			},
			
			/*
			 * validation data type
			 */
			validateDataType : {
				'number': 0,
				'text': 1,
				'date': 2,
				'list': 3,
				'multi_options': 4,
				'checkbox': 5,
				'radio': 6,
				'attachment': 7,
				'phone': 8,
				'email': 9,
				'url': 10,
				'currency': 11,
				'percent': 12,
				'single_select': 13,
				'long_text': 14,
				'remote_select': 15
			},
			
			weekend_types : [
			      [],
			      [6, 0],
			      [0, 1],
			      [1, 2],
			      [2, 3],
			      [3, 4],
			      [4, 5],
			      [5, 6],
			      [],
			      [],
			      [],
			      [0],
			      [1],
			      [2],
			      [3],
			      [4],
			      [5],
			      [6]
		    ],
			
			/*
			 * validation option
			 */
			validateOption : {
				'between' : 0,
				'not_between' : 1,
				'less': 2,
				'less_equal': 3,
				'greater': 4,
				'greater_equal': 5,
				'equal': 6,
				'not_equal': 7,
				'contain': 8,
				'not_contain': 9,
				'is_email': 10,
				'is_url': 11,
				'is_date': 12,
				'date_before': 13,
				'date_on_before': 14,
				'date_after': 15,
				'date_on_after': 16,
                'any_number': 17,
                'is_phone': 18
			}
		});
		
		Ext.apply(this, {
			'MAX_COL_Z_INDEX': this['MAX_COLUMN_NUMBER']+1,
			
			//'IF_Z_INDEX': this['MAX_COLUMN_NUMBER']+1,
			
			'SM_Z_INDEX': this['MAX_COLUMN_NUMBER']+2,
			
			'RM_Z_INDEX' : this['MAX_COLUMN_NUMBER']+3,
			
            'INCELL_ITEM_Z_INDEX' : this['MAX_COLUMN_NUMBER']+4,
                  
			'FLOAT_Z_INDEX' : this['MAX_COLUMN_NUMBER']+14,
			
			'ACTIVE_FLOAT_Z_INDEX' : this['MAX_COLUMN_NUMBER']+15,
			
			'TOP_Z_INDEX' : this['MAX_COLUMN_NUMBER']+10000,
			
			'CORNER_Z_INDEX' : this['MAX_COLUMN_NUMBER']+10001
		});
	}
}, function(){
	SCONST = EnterpriseSheet.common.CONST;
	
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.common.Common', {
	
	requires: [
	    'EnterpriseSheet.common.CONST',
	    'EnterpriseSheet.lang.Language',
	    'Ext.data.proxy.Memory',
	    'Ext.data.ArrayStore',
        'Ext.tip.QuickTip'
	],
	
	singleton : true,
	
	constructor : function(){
		/*
		 * some colors
		 */
		/*
		var colors = [
		    'rgb(14,76,194)', 
		    'rgb(112,163,94)', 
		    'rgb(236,175,86)', 
		    'rgb(200,67,66)', 
		    'rgb(130,84,139)', 
		    'rgb(143,146,145)'
		];*/
		var colors = [
		    'rgb(148,174,10)', 
		    'rgb(17,95,166)', 
		    'rgb(166,17,32)', 
		    'rgb(255,136,9)', 
		    'rgb(255,209,62)', 
		    'rgb(166,17,135)',
		    'rgb(36,173,154)',
		    'rgb(124,116,116)',
		    'rgb(166,97,17)'
		];
		/*
		 * check whether the char is an ansII char or not
		 */
		var isNonAnsIIChar = function(charCode){
			return 127 < charCode;
		};
		
		var findNoAnsIIChar = function(str){
			for(var i = 0, len = str.length; i < len; i++){
				var charCode = str.charCodeAt(i);
				if(isNonAnsIIChar(charCode)){
					return i;
				}
			}
			return -1;
		}
		
		var nullOrUndefined = function(v){
			return undefined === v || null === v;
		}
		
		var isEmptyValue = function(v){
			return undefined === v || null === v || '' === v;
		}
		/*
		 * check an object is an empty one or not
		 */
		var isEmptyObj = function(o){		
			for(var p in o){
				if (o.hasOwnProperty(p)) {
					return false;
	            }			
			}
			return true;
		}
		
		/*
		 * delete members in an object
		 */
		var deleteMembers = function(o, members){
			for(var i = 0, len = members.length; i < len; i++){
				delete(o[members[i]]);
			}
			return o;
		}
		/*
		 * return true if v can transfer to a number
		 */
		var canbeNumber = function(v){
			return null !== v && '' !== v && isFinite(Number(v));
		};
		
		/*
		 * Factorize a num
		 */
		var factorizeNum = function(num){
			num = Math.abs(num);
			var factors = {};			
			for(var i = 2; i <= num;){				
				if(0 == num%i){
					factors[i] = factors[i] || 0;
					factors[i]++;
					num = num/i;					
				}else{
					i++;
				}
			}
			if(1 != num){
				factors[num] = factors[num] || 0;
				factors[num]++;
			}
			return factors;
		};
		
		/*
		 * get the member number of the object
		 */
		var countObjMember = function(o){
			if(o){
				var count = 0;
				for(var p in o){
					if (o.hasOwnProperty(p)) {
						count++;
					}
				}
				return count;
			}
		}; 
		
		var isEmptyStr = function(inStr){
			var blankRE=/^[\s]+$/;
	        if(inStr === "" || blankRE.test(inStr)) return true;
	        return false;
		};
		
		/*
		 * remove HTML tag in a string
		 */
		var removeHTMLTag = function(str){ 
			if('string' == SCOM.typeOf(str)){
				/*
				 * clear tag
				 */
				str = str.replace(/<\/?.+?>/g,"");
				/*
				 * clear transfer char, such as \n 
				 */
				str = str.replace(/\\?/g, "");
				/*
				 * trim the str
				 */
				str = Ext.String.trim(str);
			}
			return str;
		};
		
		/*
		 * transfer decimal to ABC, need to be from: A-Z, AA, AB, ...BA, BB, ...
		 */
		var number2Letter = function(num){
            num--;
            var arr = [];
            var first = true;
            while(true){
                var s, r, c = 27;
                if(first){
                    first = false;
                    c = 26;
                }
                s = Math.floor(num/c);
                r = num%c;
                arr.unshift(r);
                num = s;
                if(0 === s){
                    break;
                }
            }
            var len = arr.length
            if(1 < len){
                arr[0]--;
            }
            for(var i = 0; i < len; i++){
                arr[i] = SCONST.letters[arr[i]];
            }
            return arr.join('');
		};

		
		/*
		 * transfer ABC to decimal AA -> 26
		 */
		var letter2Number = function(str){
			str = str.toUpperCase();		
			var result = 0;
			
			var len = str.length, base = 1, first = true;
			for(var i = len-1; 0 <= i; i--) {
				var temp = SCONST.char2Num[str.charAt(i)];
                if(0 === i){
                    temp++;
                }
				result = result + temp*base;
                var c = 27;
                if(first){
                    first = false;
                    c = 26;
                }
                base *= c;
			}
            return 1 < len ? result+1 : result;
		};
           
		/*
		 * private
		 * get string from lang
		 */
		var getStr = function(str, defaultStr){
			var text;
			if(SLANG){
				text = SLANG[str];
			}
			if(!text){
				text = defaultStr || str;
			}
			return text;
		};
		
		var textFormatStore = new Ext.data.ArrayStore({
			fields:['id', 'text', 'preview'],
	        data:[
	        	['regular', getStr('regular'), ''],
	        	['number', getStr('number'), ''],
	        	['comma', getStr('comma'), ''],
	        	['money', getStr('money'), ''],
	        	//['accounting', getStr('accounting'), ''],
	        	['date', getStr('date'), ''],
	        	['time', getStr('time'), ''],
	        	['percent', getStr('percentage'), ''],
	        	['fraction', getStr('fraction'), ''],
	        	['science', getStr('science'), ''],
	        	['text', getStr('text'), '']
	        ]
		});		
		
		var fontFamilyStore = SCONFIG.fontFamilyStore_en;
		if (SCONFIG.default_locale == "chinese") {
			fontFamilyStore = SCONFIG.fontFamilyStore_cn;
		}
				
		var fontSizeStore = new Ext.data.ArrayStore({
			fields:['id', 'text'],
	        data:[
	        	['6', '6pt'],
	            ['7', '7pt'],
	            ['8', '8pt'],
	            ['9', '9pt'],
	            ['10', '10pt'],
	            ['11', '11pt'],
	            ['12', '12pt'],
	            ['14', '14pt'],
	            ['16', '16pt'],
	            ['18', '18pt'],
	            ['20', '20pt'],
	            ['22', '22pt'],
	            ['24', '24pt'],
	            ['26', '26pt'],
	            ['28', '28pt'],
	            ['36', '36pt'],
	            ['48', '48pt'],
	            ['72', '72pt']
	        ]
		});	
		
		/*
		 * the style for condition bool
		 */
		var boolStyleStore = new Ext.data.ArrayStore({
			fields:['id', 'text', 'style'],
			data:[
			    [1, getStr('red_fill_darkred_text'), {'cbgc':'rgb(248,105,107)', 'ccolor':'rgb(150,0,0)'}],
			    [2, getStr('yellow_fill_darkyellow_text'), {'cbgc':'rgb(255,235,132)', 'ccolor':'rgb(150,150,0)'}],
			    [3, getStr('green_fill_darkgreen_text'), {'cbgc':'rgb(90,190,123)', 'ccolor':'rgb(0,100,50)'}],
			    [4, getStr('pink_fill'), {'cbgc':'rgb(248,105,107)'}],
			    [5, getStr('red_text'), {'ccolor':'red'}],
			    [6, getStr('yellow_text'), {'ccolor':'rgb(255,255,0)'}],
			    [7, getStr('gray_text'), {'ccolor':'rgb(216,216,216)'}]
			    //[6, getStr('custom_style')+'...']
			]
		});
		
		/*
		 * store for repeat type in the condition
		 */
		var repeatStore = new Ext.data.ArrayStore({
			fields:[{name : 'id', type : 'int'}, 'text'],
			data:[
			    [SCONST.REPEAT_VALUE, getStr('repeat_value')],
			    [SCONST.SOLE_VALUE, getStr('sole_value')]
			]
		});
		
		var paperSizeStore = new Ext.data.ArrayStore({
			fields:[{name : 'id', type : 'int'}, 'text'],
			data:[
			    [8, 'A3 29.7cm*42cm'],
			    [9, 'A4 21cm*29.7cm'],
			    [10, 'A5 14.8cm*21cm'],
			    [11, 'A6 10.5cm*14.8cm']
			]
		});
		
		/*
		 * store for date option in the condition
		 */
		var dateOptionStore = new Ext.data.ArrayStore({
			fields:[{name : 'id', type : 'int'}, 'text'],
			data:[
			    [SCONST.YESTERDAY, getStr('yesterday')],
			    [SCONST.TODAY, getStr('today')],
			    [SCONST.TOMORROW, getStr('tomorrow')],
			    [SCONST.SEVEN_DAY, getStr('7day')],
			    [SCONST.LAST_WEEK, getStr('last_week')],
			    [SCONST.THIS_WEEK, getStr('this_week')],
			    [SCONST.NEXT_WEEK, getStr('next_week')],
			    [SCONST.LAST_MONTH, getStr('last_month')],
			    [SCONST.THIS_MONTH, getStr('this_month')],
			    [SCONST.NEXT_MONTH, getStr('next_month')]//,
			   // [SCONST.OTHER_OPTION, getStr('other_options')+'...']
			]
		});		
		
		/*
		 * filter condition type store
		 */
		var filterConditionStore = new Ext.data.ArrayStore({
			fields:['ctype', 'display'],
			data:[
			    ['eq', getStr('equal')],
			    ['neq', getStr('not_equal')],
			    ['gt', getStr('greater_than')],
			    ['ge', getStr('greater_or_equal')],
			    ['lt', getStr('less_than')],
			    ['le', getStr('less_or_equal')],
			    ['bw', getStr('between')],
			    ['t10', getStr('top10')],
			    ['b10', getStr('bottom10')],
			    ['av', getStr('above_average')],
			    ['bv', getStr('below_average')]
			]
		});
			
        var iconSetTpl = new Ext.XTemplate([
            '<tpl for="."><div class="ss-condition-iconset x-boundlist-item">',
                '<tpl for="icons">',
                    '<div class="ss-condition-icon" style="background-image:url(', SCONFIG.CONDITION_ICONS_PATH, '/{parent.set}/{.}.png);"></div>',
                '</tpl>',
            '</div></tpl>'
        ].join(''));
         
        var iconSetData = [{
            set: 0,
            level: 3,
            icons: [0, 1, 2]
        }, {
            set: 1,
            level: 3,
            icons: [0, 1, 2]
        }, {
            set: 2,
            level: 3,
            icons: [0, 1, 2]
        }, {
            set: 5,
            level: 3,
            icons: [0, 1, 2]
        }, {
            set: 6,
            level: 3,
            icons: [0, 1, 2]
        }, {
            set: 7,
            level: 3,
            icons: [0, 1, 2]
        }, {
            set: 8,
            level: 3,
            icons: [0, 1, 2]
        }, {
            set: 9,
            level: 3,
            icons: [0, 1, 2]
        }, {
            set: 3,
            level: 4,
            icons: [0, 1, 2, 3]
        }, {
            set: 4,
            level: 4,
            icons: [0, 1, 2, 3]
        }];
           
        var iconSetStore = new Ext.data.Store({
            fields: ['set', 'level', 'icons'],
            data: iconSetData
        });
        var iconData = [];
        for(var i = 0, len = iconSetData.length; i < len; i++){
            var it = iconSetData[i], setIndex = it['set'], icons = it['icons'];
            for(var j = 0, count = icons.length; j < count; j++){
                iconData.push({
                    'set': setIndex,
                    'idx': icons[j]
                });
            }
        }
        var iconTpl = new Ext.XTemplate([
            '<tpl for=".">',
                '<div class="ss-condition-iconset x-boundlist-item ss-condition-icon" style="background-image:url(', SCONFIG.CONDITION_ICONS_PATH, '/{set}/{idx}.png);"></div>',
            '</tpl>'
        ].join(''));
           
        var iconStore = new Ext.data.Store({
            fields: ['set', 'idx'],
            data: iconData
        });
           
        var titleIconTpl = new Ext.XTemplate([
            '<tpl for=".">',
                '<div class="x-boundlist-item ss-title-icon" style="background-image:url(', SCONFIG.TITLE_ICONS_PATH, '/{idx}.png);"></div>',
            '</tpl>'
        ].join(''));
        
        var titleIconData = [           
            {'idx':'add'},
            {'idx':'address'},
            {'idx':'attach'},
            {'idx':'bug'},
            {'idx':'calendar'},
            {'idx':'calculator'},
            {'idx':'cancel'},
            {'idx':'checkbox'},
            {'idx':'cog'},
            {'idx':'contact'},
            {'idx':'date'},
            {'idx':'disk'},
            {'idx':'dropdown'},
            {'idx':'email'},
            {'idx':'folder'},
            {'idx':'group'},
            {'idx':'image'},
            {'idx':'information'},
            {'idx':'key'},
            {'idx':'link'},
            {'idx':'map'},
            {'idx':'money'},
            {'idx':'money_dollar'},
            {'idx':'money_yen'},
            {'idx':'number'},
            {'idx':'page'},
            {'idx':'percent'},
            {'idx':'profile'},
            {'idx':'phone'},
            {'idx':'printer'},
            {'idx':'radio'},
            {'idx':'remoteList'},
            {'idx':'star'},
            {'idx':'sum'},
            {'idx':'table'},
            {'idx':'text'},
            {'idx':'textLong'},
            {'idx':'thumb_down'},
            {'idx':'thumb_up'},
            {'idx':'tick'},
            {'idx':'time'},
            {'idx':'user'},
            {'idx':'wrench'},
            {'idx':'zoom'},
            {'idx':'warning'},
            {'idx':'tag_blue'},
            {'idx':'tag_green'},
            {'idx':'tag_orange'},
            {'idx':'tag_purple'},
            {'idx':'tag_red'}
        ];
        var titleIconStore = new Ext.data.Store({
        	fields: ['idx'],
        	data: titleIconData
        });
			
		var themeColors = [
			'FFFFFF', '000000', 'EEECE1', '1F497D', '4F81BD', 'C0504D', '9BBB59', '8064A2', '4BACC6', 'F79646',
			'F2F2F2', '7F7F7F', 'DDD9C3', 'C6D9F0', 'DBE5F1', 'F2DCDB', 'EBF1DD', 'E5E0EC', 'DBEEF3', 'FDEADA',
			'D8D8D8', '595959', 'C4BD97', '8DB3E2', 'B8CCE4', 'E5B9B7', 'D7E3BC', 'CCC1D9', 'B7DDE8', 'FBD5B5',
			'BFBFBF', '3F3F3F', '938953', '548DD4', '95B3D7', 'D99694', 'C3D69B', 'B2A2C7', '92CDDC', 'FAC08F',
			'A5A5A5', '262626', '494429', '17365D', '366092', '953734', '76923C', '5F497A', '31849B', 'E36C09',
			'7F7F7F', '0C0C0C', '1D1B10', '0F243E', '244061', '632423', '4F6128', '3F3151', '205867', '984806'
		];		
			
		/*
		 * copy an object or array
		 */
		var copy = function(o){
			if(Ext.clone){
				/*
				 * use Ext lib clone if could
				 */
				return Ext.clone(o);
			}
			var type = SCOM.typeOf(o);
			if('array' == type){
				var c = [];
				for(var i = 0, len = o.length; i < len; i++){
					c.push(copy(o[i]));
				}
				return c;
			}else if('object' == type){
				var c = {};
				for(var p in o){
					if(o.hasOwnProperty(p)){
						c[p] = copy(o[p]);
					}					
				}
				return c;
			}else{
				return o;
			}				
		};
		
		var typeOf = function(o){		
			var type = Ext.typeOf(o);
			/*
			 * extjs 4 change the SCOM.typeOf function, we need wrap it
			 */
			if('null' == type || 'undefined' == type){
				return false;
			}
			return type;
		}
		
		var genTimeStamp = function(){
			return Ext.Date.format(new Date(), 'YmdHisu');
		}
		
		var getInnerText = function(el){		
			if(el.innerText){
				return el.innerText;
			}else if(el.textContent){
				return el.textContent;
			}else{
				var anyString = "";
		        var childS = el.childNodes;
		        for(var i = 0; i < childS.length; i++){
		            if(childS[i].nodeType == 1)
		                anyString += childS[i].tagName=="BR" ? '' : childS[i].innerText;
		            else if(childS[i].nodeType == 3)
		                anyString += childS[i].nodeValue;
		        }
		        return anyString;
			}        
	    }
		
		var getPureText = function(html){
			var el = Ext.get('ss-puretext-tool');
			if(!el){
				el = Ext.DomHelper.append(Ext.getBody(), '<div id="ss-puretext-tool" style="position:absolute;top:-1000px;left:-1000px;">'+html+'</div>', true);
			}else{
				el.update(html);
			}
			var text = getInnerText(el.dom);			
			
			return text;
		};
		
		/*
		 * create reg based on str 
		 */
		var genRegExp = function(exp, matchCase){
			exp = exp.toString();
			var attributes = matchCase ? 'g' : 'gi';
			exp = exp.replace(/\*/gi, '[.]*');
			exp = exp.replace(/\?/gi, '.');
			var first = exp.charAt(0);
			var last = exp.charAt(exp.length-1);
			if('[' != first){
				exp = '^'+exp;
			}			
			if('*' != last){
				exp += '$';
			}								
			
			var reg = new RegExp(exp, attributes);
			return reg;
		};		
		
		/*
		 * get the index of an element in the array
		 */
		var indexOfArray = function(arr, it, caseSensitive){
			var isStr = Ext.isString(it);
			if(caseSensitive || !isStr){
				return Ext.Array.indexOf(arr, it);
			}else{
				it = it.toLowerCase();
				for(var i = 0, len = arr.length; i < len; i++){
					var o = arr[i];
					if(Ext.isString(o)){
						var low = o.toLowerCase();
						if(low === it){
							return i;
						}
					}else if(o === it){
						return i;
					}
				}
				return -1;
			}
		};           
		
        var mergeSpan = function(target, origin){
            var oRowStart = origin[0], oRowEnd = origin[2], oColStart = origin[1], oColEnd = origin[3];
            var tRowStart = target[0], tRowEnd = target[2], tColStart = target[1], tColEnd = target[3];
            var minRow, maxRow, minCol, maxCol;
            if(oRowStart < tRowStart){
                minRow = oRowStart;
            }else{
                minRow = tRowStart;
            }
            if(oColStart < tColStart){
                minCol = oColStart;
            }else{
                minCol = tColStart;
            }
            if(oRowEnd > tRowEnd){
                maxRow = oRowEnd;
            }else{
                maxRow = tRowEnd;
            }
            if(oColEnd > tColEnd){
                maxCol = oColEnd;
            }else{
                maxCol = tColEnd;
            }
            return [minRow, minCol, maxRow, maxCol];
        }
        
        /*
         * find the first parent node for the both passed element
         */
        var findParentNodeForBoth = function(a, b){
            if(a.contains(b)){
                return a;
            }
            if(b.contains(a)){
                return b;
            }
            var body = Ext.getBody();
            var p = a.parent();
            while(p !== body){
                if(p.contains(b)){
                    return p;
                }
                p = p.parent();
            }
            return body;
        }
		
		var config = {	
			colors : colors,
			
			themeColors : themeColors,
			
			fontFamilyStore : fontFamilyStore,
			
			fontSizeStore : fontSizeStore,
			
			textFormatStore	: textFormatStore,
			
			boolStyleStore : boolStyleStore,
			
			repeatStore : repeatStore,
			
			paperSizeStore : paperSizeStore,
			
			dateOptionStore : dateOptionStore,
			
            iconTpl: iconTpl,
           
            titleIconTpl: titleIconTpl,
           
            iconSetTpl: iconSetTpl,
           
            iconStore: iconStore,
           
            titleIconStore: titleIconStore,
           
            iconSetStore: iconSetStore,
			
			filterConditionStore : filterConditionStore,
			
			nullOrUndefined : nullOrUndefined,
			
			isNonAnsIIChar : isNonAnsIIChar,
			
			findNoAnsIIChar : findNoAnsIIChar,
			
			isEmptyObj : isEmptyObj,
			
			isEmptyValue : isEmptyValue,
			
			deleteMembers : deleteMembers,
			
			canbeNumber : canbeNumber,
			
			isEmptyStr : isEmptyStr,
			
			factorizeNum : factorizeNum,
			
			countObjMember : countObjMember,
			
			number2Letter : number2Letter,
			
			letter2Number : letter2Number,
					
			copy : copy,
			
			typeOf : typeOf,
			
			genTimeStamp : genTimeStamp,
			
			getInnerText : getInnerText,
			
			getPureText : getPureText,
			
			genRegExp : genRegExp,
			
			indexOfArray : indexOfArray,
			
            mergeSpan: mergeSpan,
           
            findParentNodeForBoth: findParentNodeForBoth,
           
            transferArr2Pairs : function(arr){
            	arr.sort(function(a, b){
            		return a-b;
            	});
                var obj = [], start = false, end;
                for(var i = 0, len = arr.length; i < len; i++){
                    var v = Number(arr[i]);
                    if(false === start){
                        start = v;
                        end = start;
                    }else{
                        if(end+1 === v){
                            end = v;
                        }else{
                            obj.push([start, end]);
                            start = v;
                            end = start;
                        }
                    }
                }
                if(false !== start){
                    obj.push([start, end]);
                }
                return obj;
            },
           
            /**
             * a loop function which will visit every element in items, and it will defer a interval every limit MS
             */
            eachLimitDefer : function(items, fn, fnScope, callback, cbScope, limitMS, interval){
                var me = SCOM || window;
                me._eldClock = new Date();
                var index = 0, len = items.length;
                var loop = function(){
                    var count = 0, flag = false;
                    while(index < len){
                        fn.call(fnScope, items[index]);
                        index++;
                        var elapsed = Ext.Date.getElapsed(me._eldClock);
                        if(limitMS <= elapsed){
                            me._eldClock = new Date();
                            flag = true;
                            break;
                        }
                    }
                    if(flag){
                        Ext.Function.defer(loop, interval);
                    }else{
                        if(callback){
                            callback.call(cbScope);
                        }
                    }
                }
                loop();
            },
			
			/*
			 * KMP compare
			 */
			kmpCompare : function(str, exp, matchCase){
				var reg = genRegExp(exp, matchCase);
				reg.lastIndex = 0;
				var result = reg.test(str);				
				return result;				
			},
			/*
			 * remove all html tags in string
			 */
			removeHTMLTag : removeHTMLTag,
			
            getAMPM : function(){
                var am = Ext.Date.format(Ext.Date.parse('01:01', 'H:i'), 'A');
                var pm = Ext.Date.format(Ext.Date.parse('21:01', 'H:i'), 'A');

                return {
                    am: am,
                    pm: pm
                }
            },
			
			/*
			 * get this function from the internet
			 */
			getSelectedText : function() { 
			    if(window.getSelection){ 
			        // This technique is the most likely to be standardized. 
			        // getSelection() returns a Selection object, which we do not document. 
			        return window.getSelection().toString(); 
			    }else if(document.getSelection){ 
			        // This is an older, simpler technique that returns a string 
			        return document.getSelection(); 
			    }else if(document.selection){ 
			        // This is the IE-specific technique. 
			        // We do not document the IE selection property or TextRange objects. 
			        return document.selection.createRange().text; 
			    } 
			},
				
			/*
			 * this function is from internet with some modification
			 * get the startpos and endpos
			 */
			getSelectedTextPos : function(){
				if(document.selection){				
			        var r = document.selection.createRange();
			        var container = r.parentElement();
			        var d = r.duplicate();
		       		d.moveToElementText(container);
		       		d.setEndPoint('EndToEnd', r);        		
		       		var startOffset = d.text.length-r.text.length;
		       		var endOffset = d.text.length;        		
			        return {
			        	container:container,
			        	startOffset:startOffset,    
			        	endOffset:endOffset    	
			        };
			    }else if(window.getSelection){ 				
					var s = window.getSelection();	
					if(0 < s.rangeCount){					
						var r = s.getRangeAt(0);
						return {
							startContainer:r.startContainer,
							endContainer:r.endContainer,
							startOffset:r.startOffset,
							endOffset:r.endOffset
						};
					}								
				}
			},
			
			/*
			 * get this function from internet
			 */
			getCursorPosition: function(t){ 
				if (document.selection) { 
					t.focus(); 
					var ds = document.selection; 
					var range = ds.createRange(); 
					var stored_range = range.duplicate(); 
					stored_range.moveToElementText(t); 
					stored_range.setEndPoint("EndToEnd", range); 
					t.selectionStart = stored_range.text.length - range.text.length; 
					t.selectionEnd = t.selectionStart + range.text.length; 
					return t.selectionStart; 
				} else return t.selectionStart 
			},
			
			/*
			 * select all text in the element
			 */
			selectAll : function(elem){
				try{
			    	var el = elem;	    	
			    	var str = el.innerHTML;
			    	if(str && 0 < str.length){
				    	var container = el, startContainer = endContainer = el.firstChild, endOffset = startOffset = str.length;
				    	
				    	if(document.selection){			   			
				   			/*
				   			 * for IE
				   			 */
				   			var range = document.selection.createRange();
				            document.selection.empty();
				            range.moveToElementText(container);			            
							range.select();
				   		}else if(window.getSelection){				    	
				    		/*
				    		 * for webkit and ff
				    		 */
				    		var s = window.getSelection();
							if(0 < s.rangeCount){
								s.removeAllRanges();
							}
							var range = document.createRange();			
							/*
							 * create a range select the el
							 */
							range.selectNodeContents(el);		
							/*
							 * add to selection
							 */
							s.addRange(range);
							
				   		}
			    	}
		    	}catch(e){
		    		
		    	}
			},
			
			/*
			 * set the cursor to the assigned position
			 */
			setCursorPosition : function(elem, pos){
				try{
			    	var el = elem;	    	
			    	var str = el.innerHTML;
			    	var strLen = str.length;
			    	if(str && 0 < strLen){			    				    	
				    	var container = el, startContainer = endContainer = el.firstChild, endOffset = startOffset = strLen;
				    	
				    	if(document.selection){			   			
				   			/*
				   			 * for IE
				   			 */
				   			var range = document.selection.createRange();
				            document.selection.empty();
				            range.moveToElementText(container);				            
				            range.moveStart('character', pos);
				            range.moveEnd('character', pos);
				            range.collapse(true);
							range.select();
				   		}else if(window.getSelection){				    	
				    		/*
				    		 * for webkit and ff
				    		 */
				    		var s = window.getSelection();
							if(0 < s.rangeCount){
								s.removeAllRanges();
							}
							var range = document.createRange();			
							/*
							 * create a range select the el
							 */							
							range.setStart(startContainer, pos);
							range.setEnd(startContainer, pos);							
							/*
							 * add to selection
							 */
							s.addRange(range);							
				   		}
			    	}
		    	}catch(e){
		    		console.log(e);
		    	}
			},
			
			/*
			 * set the caret to the end of the string
			 */
			moveCursor2End: function(elem){
				try{
			    	var el = elem;	    	
			    	var str = el.innerHTML;
			    	if(str && 0 < str.length){
				    	var container = el, startContainer = endContainer = el.firstChild, endOffset = startOffset = str.length;
				    	
				    	if(document.selection){			   			
				   			/*
				   			 * for IE
				   			 */
				   			var range = document.selection.createRange();
				            document.selection.empty();
				            range.moveToElementText(container);			            
				            range.collapse(false);
							range.select();
				   		}else if(window.getSelection){				    	
				    		/*
				    		 * for webkit and ff
				    		 */
				    		var s = window.getSelection();
							if(0 < s.rangeCount){
								s.removeAllRanges();
							}
							var range = document.createRange();			
							/*
							 * create a range select the el
							 */
							range.selectNode(el);			
							/*
							 * add to selection
							 */
							s.addRange(range);
							/*
							 * collapse the selection to end
							 */
							s.collapse(el, 1);
				   		}
			    	}
		    	}catch(e){
		    		
		    	}
		    },
		    
		    skipBlankForCommaOrPercent : function(data){
		    	if(Ext.isString(data)){
		    		var reg = /^[0-9,.%\s]+$/gi;
		    		if(reg.test(data)){
		    			data = data.replace(/([\s]+%)|(%[\s]+)|([\s]+,)|(,[\s]+)|([\s]+.)|(.[\s]+)/gi, function(w){
		    				return w.trim();
		    			});
		    			return data;
		    		}
		    	}
		    	return data;
		    },
			
			/*
			 * return true if the key is [LEFT, RIGHT, TOP, DOWN, ENTER, TAB]
			 */
			isSpecialKey : function(key){
				var keyObj = Ext.EventObject ? Ext.EventObject : Ext.event.Event;
				return key == keyObj.LEFT || key == keyObj.RIGHT
					|| key == keyObj.UP || key == keyObj.DOWN
					|| key == keyObj.ENTER || key == keyObj.TAB;
			},
			
			/*
			 * swtich the theme
			 */
			setActiveStyleSheet: function(title) {
			    var i,
			        a,
			        links = document.getElementsByTagName("link"),
			        len = links.length;
			    for (i = 0; i < len; i++) {
			        a = links[i];
			        if (a.getAttribute("rel").indexOf("style") != -1 && a.getAttribute("title")) {
			            a.disabled = true;
			            if (a.getAttribute("title") == title) a.disabled = false;
			        }
			    }
			},
           
            /**
             * return true if need show enterprise sheet logo
             */
            needShowLogo : function(){
                return '3.0.5.20150201' !== SCONST.limitType;
            },
           
            /**
             * show enterprisesheet logo
             */
            showPoweredByLogo : function(el){
            	
            	// calculate the expired date ...
            	
            	
                var logoEl = Ext.DomHelper.append(el, ['<div style="',
                    'position:absolute;right:20px;bottom:20px;padding: 10px 16px;',
                    'background:rgb(60,60,60);color:white;cursor:pointer;font-size:12px;',
                    '-webkit-border-radius: 3px;',
                    '-moz-border-radius: 3px;',
                    'border-radius: 3px;',
                    'opacity:.9;',
                    '-moz-box-shadow:2px 2px 6px #BBB;',
                    '-webkit-box-shadow:2px 2px 6px #BBB;',
                    'box-shadow:2px 2px 6px #BBB;',
                    'z-index:', SCONST['CORNER_Z_INDEX'],
                    ';">Powered by EnterpriseSheet</div>'].join(''), true);
           
                var tip = Ext.create('Ext.tip.ToolTip', {
                    target: logoEl.id,
                    anchor: 'left',
                    //anchorOffset: 10,
                    width: 370,
                    dismissDelay: 10000,
                    renderTo: Ext.getBody(),
                    html: 'This FREE one month trial of spreadsheet is powered by EnterpriseSheet. You need buy commercial license before the expired date and remove this logo. Click here to see more detail information.'
                });
         
                logoEl.on('click', function(){
                     window.open('http://www.enterprisesheet.com');
                }, this);
            }
		};
		
		this.callParent(arguments);
		
		Ext.apply(this, config);
	}
}, function(){
	SCOM = EnterpriseSheet.common.Common;
           
    Ext.apply(Ext.form.field.VTypes, {
        varname:  function(v) {
            return /^(([a-z_]+[a-z_0-9]*)|([a-z_]+[a-z_0-9.]*[a-z_]+))$/.test(v);
        },
        varnameText: 'Must be composed by letter, number, _ or .'
    });
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.common.Helper', {

    singleton: true,
    
    /*
     * get number format based on digital len
     */
    getNumFormat : function(digital){
        var numFormat = '0,0';
        if(digital && Ext.isNumber(digital)){
                numFormat += '.';
                for(var i = 0; i < digital; i++){
                        numFormat += '0';
                }
        }
        return numFormat;
    },
    
    /**
     * return 00 length for: 0.00E+00
     */
    getExpFractionDigits : function(format) {
    	var format = format.toUpperCase().split('E+')[0];
    	var commaSep = format.split('.');
    	var result = 0; 
    	if (commaSep.length > 1) result = commaSep[1].length;
    	return result;
    },
    
    /**
     * money|rmb|2|none
     * And return result ...
     */
    formatMoneyWithPrecise : function(format, num) {
    	var result = num, color = null;
    	try {
	    	var moneyCombineFormat = format.split("|");
			var symbol = moneyCombineFormat[1];
			var formatReg = '#,##0', decimals = moneyCombineFormat[2], negativeNo = moneyCombineFormat[3];
			
			if (decimals > 0) {
				formatReg = '#,##0.';
				for (var i=0; i<decimals; i++) formatReg += '0';
			}
			
			result = symbol + Ext.util.Format.number(num, formatReg); 
			if (num < 0) {	    			    					
				if (negativeNo == "negative2" || negativeNo == "negative3") color = 'red'; 
				if (negativeNo == "negative2") result = symbol + Ext.util.Format.number(-num, formatReg);
				else result = '-' +  symbol + Ext.util.Format.number(-num, formatReg);
			}
    	} catch (e) {
    		// not need process anything ...
    	}
		
		return {data: result, color: color};
    },
    
    /**
     * this will format number as custom format: such as:
     *       $#,##0.00;[Red]-$#,##0.00;0;@  -- It will be separated by ; format: pos;neg;0;not_number
     *       0.00E+00
     *       # ?/? | # ?/16
     *       [DBNum1][$-411]#,##0 -- this is for chinese ...
     *       [DBNum2][$-411]#,##0
     * 
     */
    formatNumberWithCustom : function(format, num) {
    	var commaIndex = format.split(';'), result = num, formatPart1 = null;
    	var positiveFm = commaIndex[0], negativeFm = null, zeroFm = null, textFm = null;
    	if (commaIndex.length > 1) negativeFm = commaIndex[1];
    	if (commaIndex.length > 2) zeroFm = commaIndex[2];
    	if (commaIndex.length > 3) textFm = commaIndex[3];
    	
    	// check num now ..
    	var myFm = positiveFm;
    	if (num < 0) { 
    		if (negativeFm) {
    			myFm = negativeFm;
    			num = 0-num;
    		}
    	} else if  (num == 0) { 
    		if (zeroFm) myFm = zeroFm;
    	} 
    	
    	// now I need check whether format include formatPart1 such as: [Red]
    	if (myFm.charAt(0) == '[') {
    		var nextSepPos = 0, formatPart1 = '';
    	    for (var i=1; i<myFm.length; i++) {
				var chartAtI = myFm.charAt(i);
				
				if (chartAtI == "]") {
				    nextSepPos = i;
				    break;
				}	
				formatPart1 = formatPart1.concat(chartAtI);
			}	    
    	    if (nextSepPos > 0) myFm = myFm.substring(nextSepPos+1, myFm.length); 
    	    
    	    // check whether this is color first ...
    	    if (formatPart1 && HELPER.isArrayContain(SCONST.NUMBER_CUSTOM_COLOR, formatPart1.toLowerCase())) 
    	    	formatPart1 = formatPart1.toLowerCase();
    	    else {
    	    	if (formatPart1) { // check whether it is: DBNum1, DBNum2
    	    		if (HELPER.isArrayContain(SCONST.EXCEL_DB_NUM, formatPart1.toLowerCase())) {
    	    			// this is special case for handle Japanese
    	    			var result = HELPER.convertToJapaneseDBNum(formatPart1, myFm, num);
    	    			return {result: result, color: null};
    	    		}
    	    	} else 
    	    		formatPart1 = null;
    	    }
    	}
    	
    	// check whether this is for science format ... 0.000E+00
    	var result = num;
    	if (myFm.indexOf('e+0')>-1 || myFm.indexOf('E+0')>-1) {
    		var fractionSize = HELPER.getExpFractionDigits(format);
		    result = num.toExponential(fractionSize);
		    
    	} else if (myFm.indexOf('# ?') > -1 && myFm.indexOf('?/') > -1) { // this is for the format # ?/? | # ?/16
    		var digitals = myFm.split('/')[1];
    		if(Ext.isNumber(Number(digitals))) result = HELPER.getFractionWithFixedDenom(num, digitals);
    		else result = HELPER.getFraction(num, digitals.length);
    		
    	} else
    		result = Ext.util.Format.number(num, myFm);
    	
    	return {result: result, color: formatPart1};
    },
    
    /**
     * this function will convert number in fraction ... such:
     *  0.5 -> 1/2
     */
    getFraction : function(num, digitals) {
    	var min = 2, max = Math.pow(10, digitals) - 1;
    	if (max < 2) max = 2;
    	
    	var intVal = 0, upVal = 0, downVal = 0, decimalsVal = 0;
    	if (num > 0) {
            decimalsVal = num - Math.ceil(num) + 1.0;
            if (decimalsVal == 1.0) {
                decimalsVal = 0;
                intVal = num;
            } else
                intVal = Math.ceil(num) - 1.0;
        } else if (num < 0) {
            intVal = Math.ceil(num);
            decimalsVal = Math.ceil(num) - num;
        }
    	
    	// faultVal = 0.0005 
    	var faultVal = 0.0005;
    	if (digitals > 1) faultVal = 0.0001;
    	if (digitals > 2) faultVal = 0.00001;

    	var getResult = false, lastTriedValue = 0;
    	for (var n = min; n <= max; n++) {
            var valueIntegerTemp = Math.round(n * decimalsVal);
            var guessVal = valueIntegerTemp / n;
            var deviation = Math.abs(guessVal - decimalsVal);
            if (getResult ? deviation < Math.abs(lastguessVal - decimalsVal) : true){
                getResult = true;
                lastguessVal = guessVal;
                upVal = valueIntegerTemp;
                downVal = n;
                if (deviation < faultVal) break;
            }
    	}
    	
    	var result = num;
    	if (upVal == 0) result = intVal;
    	else if (intVal == 0) {
    		if (num < 0) result = '- ' + upVal + "/" + downVal;
    		else  result = upVal + "/" + downVal;
    	} else result = intVal + " " + upVal + "/" + downVal;
    	
    	return result;
    },
    
    convert2DollarFraction : function(num, digitals) { 
    	var numStr = num.toString();
    	var numArr = numStr.split('.');
    	if (numArr.length == 1) return num;
    	
    	var part1 = numArr[0], part2 = digitals*("0." + numArr[1]);
    	var digLen = digitals.toString().length;
    	var result = parseInt(part1) + part2/Math.pow(10, digLen);
    	return result;
    },
    
    convert2DollarInt : function(num, digitals) { 
    	var numStr = num.toString();
    	var numArr = numStr.split('.');
    	if (numArr.length == 1) return num;
    	
    	var digLen = digitals.toString().length;
    	var part1 = numArr[0], part2 = Math.pow(10, digLen)*("0." + numArr[1]); 	
    	var result = parseInt(part1) + part2/digitals;
    	return result;
    },
    
    /**
     * This will check Japanese number format ...
     */
    convertToJapaneseDBNum : function(dbNum, remindFormat, num) {
    	var fm = remindFormat, result = num;
    	if (this.startWith(remindFormat, '[$-411]')) {
    		fm = remindFormat.substring(7, fm.length);
    		result = Ext.util.Format.number(num, fm);
    		var convertResult = '';
            for (var i=0; i<result.length; i++) {
				var chartAtI = result.charAt(i);
				if (Ext.isNumber(Number(chartAtI))) chartAtI = SCONST.CHINESE_NUM_1_16UNI[chartAtI];
				convertResult = convertResult.concat(chartAtI);
            }
            result = convertResult;
    	} else 
    	    result = Ext.util.Format.number(num, fm);
    	
    	return result;
    },
    
    ///////////////////////////////////////////////////////////////////
    applySpecialFormat : function(num, format) {
    	if (format == 'rmb1') return this.applyRMBBigConvert(num);
    	else if (format == 'rmb2') return this.applyRMBBigConvert(num, 'small');
    	else if (format == 'phoneus') return this.applyPhoneUSConvert(num);
    	else if (format == 'ssn') return this.applySSNConvert(num);
    	
    	return format;
    },
    
    applyPhoneUSConvert : function(num) {
    	var parts = num.toString().split(".");
    	var integer = parts[0];  	
    	return integer.replace(/(\d+)(\d\d\d)(\d\d\d\d)/, '($1) $2-$3');
    },
    
    applySSNConvert : function(num) {
    	var parts = num.toString().split(".");
    	var integer = parts[0];  	
    	if (integer.length < 9) {
    		for (var i=integer.length; i<9; i++)  integer = "0".concat(integer);
    	}
    	return integer.replace(/(\d+)(\d\d)(\d\d\d\d)/, '$1-$2-$3');	
    },
    
    /**
     * applyRMBBigConvert is from
     * 
     * https://code.google.com/archive/p/my-framework/
     * 
     * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 * 
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 * 
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
     */
    applyRMBBigConvert : function(num, type) {
    	var MAXIMUM_NUMBER = 99999999999.99; 
    	var CN_ZERO = "\u96f6", CN_ONE = "\u58f9", CN_TWO = "\u8d30", CN_THREE = "\u53c1", CN_FOUR = "\u8086", CN_FIVE = "\u4f0d", CN_SIX = "\u9646", CN_SEVEN = "\u67d2", CN_EIGHT = "\u634c", CN_NINE = "\u7396", CN_TEN = "\u62fe", CN_HUNDRED = "\u4f70", CN_THOUSAND = "\u4edf", CN_TEN_THOUSAND = "\u4e07", CN_HUNDRED_MILLION = "\u4ebf", CN_SYMBOL = "\u4eba\u6c11\u5e01", CN_DOLLAR = "\u5706", CN_TEN_CENT = "\u89d2", CN_CENT = "\u5206", CN_INTEGER = "\u6574";
    	if (type && type == 'small') {
    	    CN_ZERO = "\u96f6", CN_ONE = "\u4e00", CN_TWO = "\u4e8c", CN_THREE = "\u4e09", CN_FOUR = "\u56db", CN_FIVE = "\u4e94", CN_SIX = "\u516d", CN_SEVEN = "\u4e03", CN_EIGHT = "\u516b", CN_NINE = "\u4e5d", CN_TEN = "\u5341", CN_HUNDRED = "\u767e", CN_THOUSAND = "\u5343", CN_TEN_THOUSAND = "\u4e07", CN_HUNDRED_MILLION = "\u4ebf", CN_SYMBOL = "\u4eba\u6c11\u5e01", CN_DOLLAR = "\u5143", CN_TEN_CENT = "\u89d2", CN_CENT = "\u5206", CN_INTEGER = "\u6574";    		
    	}
    	var integral, decimal, outputCharacters, parts, digits, radices, bigRadices, decimals, zeroCount, i, p, d, quotient, modulus; 
    
    	if (num > MAXIMUM_NUMBER) return num;
    	
    	parts = num.toString().split(".");
		if (parts.length > 1) { 
	        integral = parts[0]; 
	        decimal = parts[1]; 
	        // Cut down redundant decimal digits that are after the second. 
	        decimal = decimal.substr(0, 2); 
	    } else { 
	        integral = parts[0]; 
	        decimal = ""; 
	    } 
		
		digits = new Array(CN_ZERO, CN_ONE, CN_TWO, CN_THREE, CN_FOUR, CN_FIVE, CN_SIX, CN_SEVEN, CN_EIGHT, CN_NINE); 
	    radices = new Array("", CN_TEN, CN_HUNDRED, CN_THOUSAND); 
	    bigRadices = new Array("", CN_TEN_THOUSAND, CN_HUNDRED_MILLION); 
	    decimals = new Array(CN_TEN_CENT, CN_CENT); 
	    
	    outputCharacters = ""; 
	    // Process integral part if it is larger than 0: 
	    if (Number(integral) > 0) { 
	        zeroCount = 0; 
	        for (i = 0; i < integral.length; i++) { 
	            p = integral.length - i - 1; 
	            d = integral.substr(i, 1); 
	            quotient = p / 4; 
	            modulus = p % 4; 
	            if (d == "0")  zeroCount++; 
	            else { 
	                if (zeroCount > 0) outputCharacters += digits[0]; 
	                zeroCount = 0; 
	                outputCharacters += digits[Number(d)] + radices[modulus]; 
	            } 
	            if (modulus == 0 && zeroCount < 4) { 
	                outputCharacters += bigRadices[quotient]; 
	                zeroCount = 0; 
	            } 
	        } 
	        outputCharacters += CN_DOLLAR; 
	    } 
	    
	    // Process decimal part if there is: 
	    if (decimal != "") { 
	        for (i = 0; i < decimal.length; i++) { 
	            d = decimal.substr(i, 1); 
	            if (d != "0") outputCharacters += digits[Number(d)] + decimals[i]; 
	        } 
	    } 
	    
	    if (outputCharacters == "") outputCharacters = CN_ZERO + CN_DOLLAR; 
	    if (decimal == "") outputCharacters += CN_INTEGER; 
	    // outputCharacters = CN_SYMBOL + outputCharacters; 
	    return outputCharacters; 
    },
    
    ///////////////////////////////////////////////////////////////////
    
    /**
     * this will get fraction result such as for # ?/16
     */
    getFractionWithFixedDenom : function(num, fixedDenom) {
    	var intVal = 0, decimalsVal = 0;
    	if (num > 0) {
            decimalsVal = num - Math.ceil(num) + 1.0;
            if (decimalsVal == 1.0) {
                decimalsVal = 0;
                intVal = num;
            } else
                intVal = Math.ceil(num) - 1.0;
        } else if (num < 0) {
            intVal = Math.ceil(num);
            decimalsVal = Math.ceil(num) - num;
        }
    	
    	var nomVal = 0, preVal = 0, posDecimalVal = Math.abs(decimalsVal);
    	for (var n = 1; n <= fixedDenom; n++) {
            var currentVal = n / fixedDenom;
            if (currentVal > posDecimalVal) {
            	if ((currentVal-posDecimalVal)>(posDecimalVal-preVal)) nomVal = n-1;
            	else nomVal = n;
            	break;
            }
            preVal = currentVal;
    	}
    	
    	var result = num;
    	if (nomVal == 0 || decimalsVal == 0) result = intVal;
    	else if (intVal == 0) {
    		if (num < 0) {
    			if (nomVal == fixedDenom) result = -1;
    			else result = '- ' + nomVal + "/" + fixedDenom;
    		} else  {
    			if (nomVal == fixedDenom) result = 1;
    			else result = nomVal + "/" + fixedDenom;
    		}
    	} else {
    		if (nomVal == fixedDenom) {
    			if (num < 0) result = intVal - 1;
    			else result = intVal + 1;
    		} else result = intVal + " " + nomVal + "/" + fixedDenom;
    	}
    	
    	return result;
    },
    
    /**
     * parse the number format and return something
     */
    parseNumberFm : function(fm) {
    	var color = null;
    	if (fm.charAt(0) == '[') {
    		var nextSepPos = 0, color = '';
    	    for (var i=1; i<fm.length; i++) {
				var chartAtI = fm.charAt(i);
				
				if (chartAtI == "]") {
				    nextSepPos = i;
				    break;
				}	
				color = color.concat(chartAtI);
			}	    
    	    if (nextSepPos > 0) fm = fm.substring(nextSepPos+1, fm.length);  	    
    	    if (HELPER.isArrayContain(SCONST.NUMBER_CUSTOM_COLOR, color.toLowerCase())) color = color.toLowerCase();
    	    else color = null;
    	}
    	
    	if (color) fm = "<font color=" + color + ">" + fm + "</font>";
    	return fm;
    },
    
    /**
     * check whether it is integer or float
     */
    isInt : function(n) {
    	return typeof n === 'number' && n % 1 == 0;
    },
   
    /**
     * check to see it is money format
     */
    isMoneyFormat : function(format) {
    	var result = false;
    	if ('money' == format || 
				'dollar' == format || 
				'rmb' == format || 
				'pound' == format || 
				'euro' == format ||
				'japanese' == format ||
				'spanish' == format
			) {
    		result = true;
    	}
    	return result;
    },
    
    /*
     * return with money format - need based on different format
     */
    getMoneyFormat : function(data, format){
    	var numFormat = '0,000.00';
    	var moneySymbol = '$'; // default
    	if (format == 'rmb') moneySymbol = String.fromCharCode(165);
    	if (format == 'pound') moneySymbol = String.fromCharCode(8356);
    	if (format == 'euro') moneySymbol = String.fromCharCode(8364);
    	if (format == 'japanese') moneySymbol = String.fromCharCode(165);
    	
    	var result = moneySymbol + '  ' + Ext.util.Format.number(data, numFormat);
        return result;
    },
    
    /**
     * this function will return the value from money result
     * For example:
     *      $3,000 -> 3000
     */
    getValueFromMoneyData : function(data) {
    	data = Ext.String.trim(data.toString());
    	var moneyFormats = ["$", String.fromCharCode(165), String.fromCharCode(8356), String.fromCharCode(8364)];
    	
    	for (var i=0; i<moneyFormats.length; i++) {
    		var temp = moneyFormats[i];
    		data = data.replace(temp, "");
    	}
    	data = data.replace(/,/gi, "");
    	return data;
    },
    
    /**
     * this is help function to update money symbol press
     */
    updateToolbarMoneyPress : function(fm, menu) {
    	
    	var dollarItem = 0,
    	    rmbItem = 1,
    	    euroItem = 2,
    	    poundItem = 3,
    	    jpItem = 4,
    	    spanishItem = 5,
    	    noneItem = 6;
    	
    	// get last one - none ...
    	var moneyClearItem = menu.items.get(noneItem);
    	moneyClearItem.setDisabled(false);
    	    
    	if('dollar' == fm || 'money' == fm){       	
        	var item = menu.items.get(dollarItem);
        	item.setChecked(true, true);
        } else if('rmb' == fm){
        	var item = menu.items.get(rmbItem);
        	item.setChecked(true, true);
        } else if('euro' == fm){
        	var item = menu.items.get(euroItem);
        	item.setChecked(true, true);
        } else if('pound' == fm){
        	var item = menu.items.get(poundItem);
        	item.setChecked(true, true);
        } else if('japanese' == fm){
        	var item = menu.items.get(jpItem);
        	item.setChecked(true, true);
        } else if('spanish' == fm){       	
        	var item = menu.items.get(spanishItem);
        	item.setChecked(true, true);
        } else {
        	menu.items.each(function(it){
        		if(it.checked){
        			it.setChecked(false, true);
        		}
        	});

        	moneyClearItem.setDisabled(true);
        }    	
    },

    /**
     * get digital part length
     */
    getDigitalLen : function(num){
            var str = num.toString();
            var parts = str.split('.');
            if(str.indexOf('e')==-1 && 2 == parts.length){
                    return parts[1].length;
            }
            return 0;
    },

    /**
     * @Public
     * Check str include single quote - ignore from FBox[
     * @param {string} - the string to be checked.
     */
    fmFormatWithQuote : function(inStr) {
        var formatOk = true;

        // first case, check whether start / end with '
        if (this.startEndWith(inStr, "'")) return false;

        var arrItems = this.getArrFromMathOper(inStr, "all");
        for (var j=0; j<arrItems.length; j++) {
            if (this.startEndWith(arrItems[j], "'")) return false;
        }

        return formatOk;
    },
    
    /**
     * parse the date and time if inStr include something like :
     */
    parseDateTime : function(inStr) {
    	if (inStr) {   	
	    	var inStr = inStr.trim();
	    	var meetColon = false;
	    	var separatePos = 0;
	    	for (var i=inStr.length; i>0; i--) {
	    		var chartAtI = inStr.charAt(i);
	    		if (chartAtI == ':') meetColon = true;
	    		if (meetColon && chartAtI == ' ') {
	    			separatePos = i;
	    			break;
	    		}
	    	}
	    	
	    	var date = inStr, time = null;
	    	if (separatePos > 0) {
	    	    date = inStr.substring(0, separatePos);
	    	    time = inStr.substring(separatePos+1, inStr.length);
	    	}
	    	
	    	return {date: date, time:time};
    	} else 
    		return null;
    },
    
    // this will parse: 'Y年m月d日', 'y年m月d日', 'M d, Y, H:i:s', 'M d, Y, H:i', 'M d, Y, g:i:s A'
    parseDateTimeFM : function(inStr) {
    	var inStr = inStr.trim();
    	var meetColon = false;
    	var separatePos = 0;
    	for (var i=inStr.length; i>0; i--) {
    		var chartAtI = inStr.charAt(i);
    		if (chartAtI == ':') meetColon = true;
    		if (meetColon && chartAtI == ' ') {
    			separatePos = i;
    			break;
    		}
    	}
    	
    	var dateFm = inStr, timeFm = null;
    	if (separatePos > 0) {
    	    dateFm = inStr.substring(0, separatePos);
    	    timeFm = inStr.substring(separatePos+1, inStr.length);
    	}
    	
    	return {dateFm: dateFm, timeFm: timeFm};
    },

    /**
     * @Public
     * this will parse string and get the array ...
     * separate by + / - / * / / and check each part start with quote or not
     * @param {string} - the string to be checked.
     * @param {string} - all or plus
     */
    getArrFromMathOper : function(inStr, separator) {
        var arrItems = [];
        var tempStr = "";
        for (var i=0; i<inStr.length; i++) {
            var chartAtI = inStr.charAt(i);
            if (separator == "plus") {
                if (chartAtI == "+") {
                    arrItems.push(tempStr);
                    tempStr = "";
                } else
                    tempStr = tempStr.concat(chartAtI);
            } else {
                if (chartAtI == "+" || chartAtI == "-" || chartAtI == "*" || chartAtI == "/") {
                    arrItems.push(tempStr);
                    tempStr = "";
                } else
                    tempStr = tempStr.concat(chartAtI);
            }
        }
        if (tempStr.length > 0) arrItems.push(tempStr);

        return arrItems;
    },

    /**
     * @public
     * This method will look input the string.
     * And return first part of item before + - * /
     * For example:
     *       =(a+b)-c+2
     * result: {firstItem:"(a+b)", operator: "-", remindItem: "c+2"}
     * Need ignore the following case - if math operator inside it:
     *     ()
     *     ""
     *     []
     *     {}
     * @params {String} - the string to be checked
     **/
    separatedByMathOperObj : function(inStr) {
        inStr = this.strTrim(inStr);
        
        // a list of separate item ...
        var firstItem = "";
        var operator = null;
        var remindItem = null;

        // check cases: " double quote, { bracket, ( parentheses, [
        var meetDoubleQuote = false;
        var countParenthese = 0;
        var ignoreCount = 0;
        // start parse it by character
        for (var i=0; i<inStr.length; i++) {
            // read each character ...
            var chartAtI = inStr.charAt(i);
            if (chartAtI == "\"") {
                meetDoubleQuote = !meetDoubleQuote;
            } else if (chartAtI == "[" || chartAtI == "{") {
                ignoreCount = ignoreCount + 1;
            }
            else if (chartAtI == "]" || chartAtI == "}") {
                ignoreCount = ignoreCount - 1;
            } else if (chartAtI == "(") {
                countParenthese = countParenthese + 1;
            } else if (chartAtI == ")") {
                countParenthese = countParenthese - 1;
            }

            if (!meetDoubleQuote && ignoreCount == 0 && countParenthese == 0) { // meet double quote
                // now need check to see whether it is
                if (chartAtI == "+" || chartAtI == "-" || chartAtI == "*" || chartAtI == "/") {
                    operator = chartAtI;
                    remindItem = inStr.substring(i+1);
                    break;
                }
            }
            firstItem = firstItem.concat(chartAtI);
        }

        return {
            firstItem:firstItem,
            operator: operator,
            remindItem: remindItem
        };
    },

    /**
     * @public
     * Check to see whether this string start/end with ...
     * @param {string} - the string to be start / end
     **/
    startEndWith : function(inStr, startEndStr) {
        var result = false;
        inStr = this.strTrim(inStr);
        if (this.startWith(inStr, startEndStr) && this.endWith(inStr, startEndStr))  result = true;
        return result;
    },

    /**
     * @public
     * Check to see whether this string start with ...
     * @param {string} - the string to be start
     **/
    startWith : function(inStr, startStr) {
        return inStr.substring(0, startStr.length) === startStr;
    },

    /**
     * @public
     * Check to see whether this string end with ...
     * @param {string} - the string to be end
     **/
    endWith : function(inStr, endStr) {
        return inStr.substring(inStr.length-endStr.length, inStr.length) === endStr;
    },

    /**
     * @public
     * Trim the input string
     * @param {string} - the string to be trim
     **/
    strTrim : function(inStr) {
        var result = inStr;
        if (inStr != null) {
            result = inStr.replace(/^\s+|\s+$/g, ""); // trim first ....
        }
        return result;
    },

    /**
     * @public
     * Check whether it is number
     * @param {string} - the string to be checked
     **/
    isNumber : function(inStr) {
    	
    	if (inStr == null || inStr == undefined) return false;
    	if (typeof inStr == 'string') { 
    		if (inStr.trim().length == 0) return false;
    	}
    	
        var numPart1 = Number(inStr);
        if (Ext.isNumber(numPart1)) return true;
        else return false;
    },
	
	/**
     * @public
     * Check whether it is boolean
     * @param {string|object} - the string to be checked
     **/
    isBoolean : function(inStr) {
	    //if (inStr instanceof Boolean) return true;
	    if (typeof inStr == 'boolean') return true;
		if (typeof inStr == 'string') {
            if (inStr.toLowerCase() == "true" || inStr.toLowerCase() == "false") return true;
		}
        
		return false;
    },
    
    /**
     * this method will return boolean value
     */
    getBoolean : function(inStr) {
    	if (HELPER.isBoolean(inStr)) {
    		if (typeof inStr == 'boolean') return inStr;
			if (typeof inStr == 'string') { 
	            if (inStr.toLowerCase() == "true") return true;
	            else if (inStr.toLowerCase() == "false") return false;
	            else throw 'SS_ERROR_VALUE';
			}
    	} else {
    	    throw 'SS_ERROR_VALUE';
    	}
    },
    
    /**
     * this function will check whether array contains the inString ...
     */
    isArrayContain : function(inArray, inString) {
    	for (var i=0; i<inArray.length; i++) {
    		if (inArray[i] == inString) return true; 
    	}
    	return false;
    },
    
    // check to see whether array includes this object already
    isArrayIncludeDateObj : function(vendors, obj) {
    	var found = false;
		for(var i = 0; i < vendors.length; i++) {			
		    if ( HELPER.convertDateToNum(vendors[i]) === HELPER.convertDateToNum(obj) ) {
		        found = true;
		        break;
		    }
		}	
		return found;
    },
    
    /**
     * this function convert boolean value to int
     */
    convertBoolean2Int : function(inStr) {
        if (HELPER.isBoolean(inStr)) {
    		if (typeof inStr == 'boolean') {
    			if (inStr) return 1;
    			else return 0;
    		}
    		
			if (typeof inStr == 'string') { 
	            if (inStr.toLowerCase() == "true") return 1;
	            else if (inStr.toLowerCase() == "false") return 0;
	            else throw 'SS_ERROR_VALUE';
			}
    	} else {
    	    throw 'SS_ERROR_VALUE';
    	}
    },
    
    /**
     * @public
     * this will convert date to days - min 1900 - as google spreadsheet did
     * @param {Date} - the date to be converted
     **/
    convertDateToNum : function(inDate) {
        var one_day = 1000*60*60*24;
        var oneNine00 = new Date(1900, 0, 0);
        // need use ceil - floor will be problem @ March 11,12 2012
        // TRY to see whether it crash browser ...
        var escpaeDays = Math.ceil((Ext.Date.clearTime(inDate).getTime()-Ext.Date.clearTime(oneNine00).getTime())/(one_day)) + 1;
        return escpaeDays;
    },
    
    /**
     * convert data to time
     */
    convertDateToTimeVal : function(inDate) {
    	var totalSeconds = ((inDate.getHours() * 60) + inDate.getMinutes()) * 60 + inDate.getSeconds();
        var secondsADay = 24 * 3600;
        return totalSeconds / secondsADay;
    },

    /**
     * @public
     * this will see whether this str is date format MM/dd/yy format ...
     * @param {String} - the string to be checked
     **/
    isMdyDate : function(inStr) {
        if (inStr == null || inStr == "NaN" || inStr.length < 9) return false;
        var j = new RegExp("^[0-1][0-9]/[0-9]{2}/[0-9]{4}$");
        if(j.test(inStr)) return true;
        else return false;
    },
    
    /**
     * this will check whether it is our spreadsheet default format date
     * Please check with for format: 
     *       SCONST.DEFAULT_DATE_FORMAT - 2013-09-10
     */
    isSSDefaultDate : function(inStr) {
    	if (inStr == null || inStr == "NaN" || inStr.length < 9) return false;
    	var j = new RegExp("^[0-9]{4}-[0-1][0-9]-[0-9]{2}$");
        if(j.test(inStr)) return true;
        else return false;
    },

    /**
     * @public
     * This will calculate the date now
     * @param {String} - a data string
     * @param {number} - to add or reduce
     * @param {string} - + | -
     */
    calculateDate : function(inStr, num, oper) {
        var inDate = this.parseDefaultDate(inStr);
        if (oper == "+") {
            inDate = this.addDate(inDate, num);
        } else if (oper == "-") {
            inDate = this.addDate(inDate, 0-num);
        } else if (oper == "*") {
        	var temp = HELPER.convertDateToNum(inDate);
            inDate = this.addDate(inDate, temp*(num-1));
        } else
            throw {code: 'calculate date operator error'};

        // format this out as default date format ...
        // TODO
        // This will be changed in the future ...
        return Ext.Date.format(inDate, SCONST.DEFAULT_DATE_FORMAT);
    },
    
    calculateNetworkDays : function(startDate, endDate, holidays) {   	
    	return HELPER.calculateNetworkDaysIntl(startDate, endDate, 1, holidays) 
    },
    
    calculateNetworkDaysIntl : function(startDate, endDate, weekType, holidays) {   	
    	var startInt = HELPER.convertDateToNum(startDate);
    	var endInt = HELPER.convertDateToNum(endDate);
    	
		var isNeg = false;
		if (endInt < startInt) {
			isNeg = true;
			var temp = startInt;
			startInt = endInt;
			endInt = temp;
			var tempDate = startDate;
			startDate = endDate;
			endDate = tempDate;
		}

		var days = endInt - startInt + 1;	
		var weeks = Math.floor(days / 7), reminder = days % 7;
		var reduceTime = (weekType > 10) ? 1 : 2;
	    var days = days - (weeks * reduceTime);
	    
	    var weekends = SCONST.weekend_types[weekType];
	    var startDay = startDate.getDay(), endDay = endDate.getDay();
	    if (reminder > 0) {
		    if (( endDay >= startDay &&  endDay>=weekends[0] && weekends[0]>=startDay ) ||
		    	( endDay < startDay &&  (endDay >= weekends[0] || weekends[0] >= startDay )) )  {
		    	days = days - 1;
		    }	    
		    if (weekends.length == 2) {
		    	if ( ( endDay >= startDay &&  endDay>=weekends[1] && weekends[1]>=startDay ) ||
		    	( endDay < startDay &&  (endDay >= weekends[1] || weekends[1] >= startDay )) ) {
		    	    days = days - 1;
		        }
		    }
	    }
	    
	    if (holidays && holidays.length > 0) {
	    	for (var i=0; i<holidays.length; i++) {
	    		var tempDate = holidays[i];
	    		var workday = tempDate.getDay();
	    		if (HELPER._compare2Date(tempDate, startDate) >= 0 && HELPER._compare2Date(endDate, tempDate) >= 0 ) {
	    			if (weekends.length == 1 && weekends[0] != workday) days = days - 1;
	    			if (weekends.length == 2 && weekends[0] != workday && weekends[1] != workday ) days = days - 1;
	    		}
	    	}
	    	
	    	if (days < 0) days = 0;
	    }
	        
	    return isNeg ? 0-days : days;
    },
    
    /**
     * return the workday ...
     */
    calculateWorkDay : function(startDate, days, holidays) {   	
    	return HELPER.calculateWorkDayIntl(startDate, days, 1, holidays);
    },
    
    calculateWorkDayIntl : function(startDate, days, weekend_type, holidays) {   	
    	var nextDate = startDate;

    	if (days > 0) {
    		nextDate = HELPER.addDate(startDate, 1);
    		if (HELPER.isHolidayOrWeekend(nextDate, holidays, weekend_type) == false) days = days - 1;
    		nextDate = this.calculateWorkDayIntl(nextDate, days, weekend_type, holidays);    		
    	}
    	
	    // negative 
    	if (days < 0) {
    		nextDate = HELPER.addDate(startDate, -1);
    		if (HELPER.isHolidayOrWeekend(nextDate, holidays, weekend_type) == false)  days = days + 1;
    		nextDate = this.calculateWorkDayIntl(nextDate, days, weekend_type, holidays);
    	}
    	
    	return nextDate;
    },
    
    /**
     * Check to see whether it is holiday or weekend
     */
    isHolidayOrWeekend : function(inDate, holidays, weekend) {
    	var workday = inDate.getDay();
    	
    	var weekends = SCONST.weekend_types[weekend];
    	if (weekends.length == 2 && (workday == weekends[0] || workday == weekends[1]) )  return true; 
    	if (weekends.length == 1 && workday == weekends[0] )  return true; 
    	
    	if (holidays && holidays.length > 0) {
    		for (var i=0; i<holidays.length; i++) {
	    		var tempDate = holidays[i];
	    		if (HELPER._compare2Date(tempDate, inDate) == 0) return true;
    		}
    	}  	
    	return false;
    },

    /**
     * @public
     * This will calculate the date now
     * @param {String} - a data string
     * @param {number} - to add or reduce
     * @param {string} - * | /
     */
    calculateDateByNum : function(inStr, num, oper) {
        var inDate = this.parseDefaultDate(inStr);
        if (oper == "*") {
            return this.convertDateToNum(inDate) * num;
        } else if (oper == "/") {
            return this.convertDateToNum(inDate) / num;
        } else
            throw {code: 'calculate date operator error'};
    },

    /**
     * @public
     * This will calculate the date now
     * @param {number} - to add or reduce
     * @param {String} - a data string
     * @param {string} - * | /
     */
    calculateDateByNum2 : function(num, inStr, oper) {
        var inDate = this.parseDefaultDate(inStr);

        if (oper == "*") {
            return this.convertDateToNum(inDate) * num;
        } else if (oper == "/") {
            return num / this.convertDateToNum(inDate);
        } else if (oper == "-") {
            return num - this.convertDateToNum(inDate);
        } else
            throw {code: 'calculate date operator error'};
    },

    /**
     * @public
     * This will calculate 2 date now
     * @param {String} - a data string
     * @param {String} - a data string
     * @param {string} - + - * /
     */
    calculate2Date : function(inStr1, inStr2, oper) {
        var result = null;
        var inDate1 = this.parseDefaultDate(inStr1);
        var inDate2 = this.parseDefaultDate(inStr2);
        if (oper == "+")  {
            result = this.convertDateToNum(inDate2) + this.convertDateToNum(inDate1); 
        } else if (oper == "-")  {
            result = this.convertDateToNum(inDate1) - this.convertDateToNum(inDate2); 
        } else if (oper == "*") {
            result = this.convertDateToNum(inDate2) * this.convertDateToNum(inDate1);
        } else if (oper == "/") {
            result = this.convertDateToNum(inDate1) / this.convertDateToNum(inDate2);
        }

        return result;
    },

    /**
     * @public
     * This will add the date now 
     */
    addDate : function(inDate, num) {
        inDate.setDate(inDate.getDate() + num); 
        return inDate;
    },
    
    _compare2Date : function(date1, date2) {
    	return date1 - date2;
    },
    
    /**
     * this method will calculate diff date
     * method - true -> europe
     *          false -> U.S. (NASD)
     */
    calDifferentDateByMethod : function(enddate, startdate, method) { 	
    	var yearDiffDays = 0, monthDiffDays = 0, dayDiffDays = 0, startday = 0, endday = 0;
		yearDiffDays = (enddate.getYear() - startdate.getYear()) * 360;
		monthDiffDays = (enddate.getMonth() - startdate.getMonth()) * 30;
		
		if (method) { // this is Europe method. 31 -> 30 of the same month
			if (startdate.getDate() == 31) startday = 30;
			else startday = startdate.getDate();

			if (enddate.getDate() == 31)  endday = 30;
			else endday = enddate.getDate();
			dayDiffDays = endday - startday;
		} else { // this is US method
			if (startdate.getDate() == 31) startday = 30;
			else startday = startdate.getDate();

			if (enddate.getDate() == 31 && startday < 30) {
				monthDiffDays = monthDiffDays + 30;
				endday = 1;
			} else if (enddate.getDate() == 31 && startday >= 30) {
				endday = 30;
			} else {
				endday = enddate.getDate();
			}

			dayDiffDays = endday - startday;
		}

		return yearDiffDays + monthDiffDays + dayDiffDays;  	
    },
    
    /**
     * this method will calculate diff date
     * method - 0 - US (NASD) 30/360
     *          1 - Actual/actual
     *          2 - Actual/360
     *          3 - Actual/365
     *          4 - European 30/360
     */
    calDiffDateByMethod : function(enddate, startdate, method, frequency) { 	
    	var yearDiffDays = 0, monthDiffDays = 0, dayDiffDays = 0, startday = 0, endday = 0;
		yearDiffDays = (enddate.getYear() - startdate.getYear()) * 360;
		monthDiffDays = (enddate.getMonth() - startdate.getMonth()) * 30;
		
		var result = 0;		
		if (method == 4) { // this is Europe method. 31 -> 30 of the same month
			if (startdate.getDate() == 31) startday = 30;
			else startday = startdate.getDate();

			if (enddate.getDate() == 31)  endday = 30;
			else endday = enddate.getDate();
			dayDiffDays = endday - startday;
			result = yearDiffDays + monthDiffDays + dayDiffDays; 
		} else if (method == 0 || method == 2) { // this is US method
			if (startdate.getDate() == 31) startday = 30;
			else startday = startdate.getDate();

			if (enddate.getDate() == 31 && startday < 30) {
				monthDiffDays = monthDiffDays + 30;
				endday = 1;
			} else if (enddate.getDate() == 31 && startday >= 30) {
				endday = 30;
			} else {
				endday = enddate.getDate();
			}

			dayDiffDays = endday - startday;
			result = yearDiffDays + monthDiffDays + dayDiffDays; 
		} else if (method == 1) { // Actual/actual
			result = this.convertDateToNum(enddate) - this.convertDateToNum(startdate); 
		} else if (method == 3) { // Actual/365
			return 365.0 / frequency;
		}

		return result;  	
    },
    
    _isLeapYear : function(year) {
    	var result = (year % 400 === 0 || (year % 4 === 0 && year % 100 !== 0)) || year === 1900;
    	return result;
    },
    
    /**
     * this will return actual days in year from to ...
     */
    _actualDaysPerYear : function (from, to) {
    	var y1 = from.getFullYear();
        var y2 = to.getFullYear();
        var d1, d2;
        var feb29s, years;
        d1 = from;
        d1.setFullYear(d1.getFullYear() + 1);
        if (HELPER._compare2Date(to, d1) > 0) {
            years = y2 + 1 - y1;
            d1 = new Date(y1, 0, 1);
            d2 = new Date(y2 + 1, 0, 1);
            var diffDate = HELPER.convertDateToNum(d2) - HELPER.convertDateToNum(d1);
            feb29s = diffDate - 365 * (y2 + 1 - y1);
        } else {
            years = 1;
            if ((HELPER._isLeapYear(y1) && from.getMonth() < 3) || (HELPER._isLeapYear(y2) && (to.getMonth() * 0x100 + to.getDate() >= 2 * 0x100 + 29)))
                feb29s = 1;
            else
                feb29s = 0;
        }
        var d = feb29s / years;
        return 365 + d;
    },

    /**
     * @public
     * Whether it includes the basic math oper
     * @param {string} - the string to be checked
     **/
    includeBasicMathOper : function(inStr) {
        var result = false;
        var j = new RegExp();
        j.compile("\\+|-|\\*|\\/");
        if (j.test(inStr)) {
            result = true;
        }
        return result;
    },

    /**
     * @public
     * Whether it includes the basic math oper
     * @param {string} - the string to be checked
     **/
    removeParentheses : function(inStr) {
        var result = this.strTrim(inStr);
        if (this.startWith(result, "(") && this.endWith(result, ")")) {
        	// this is the only ( and ) then do it. Otherwise, do not do it ...
        	var temp = result.substring(1, result.length-1);
        	var leftPar = temp.indexOf('('), rightPar = temp.indexOf(')');
        	if (leftPar == -1 || rightPar == -1) result = temp;
        }
        return result;
    },

    /*
     * @public
     * Check to see whether string includes quote or not ...
     * @params {String} - string to be checked
     **/
    trimAndIncludeQuote : function(inStr) {
        var result = false;
        if (Ext.isString(inStr)) {
            inStr = inStr.replace(/^\s+|\s+$/g, "");
            if ((inStr.charAt(inStr.length-1) == '"' && inStr.charAt(0) == '"') || (inStr.charAt(inStr.length-1) == "'" && inStr.charAt(0) == "'"))  result = true;
        }
        return result;
    },

    /*
     * @public
     * This method is used to trim and remove " and "
     * @params {String} - string to be checked
     **/
    trimAndRemoveQuote : function(inStr) {
        var result;
        if (Ext.isString(inStr)) {
            result = inStr.replace(/^\s+|\s+$/g, "");
            result = result.replace(/^"|"$/g, "");
            result = result.replace(/^'|'$/g, "");
        }
        return result;
    },

    /**
     * fixed a bug related to 1693
     * @public
     * check whether the charAt(index) of str is in quote
     * @param {String} - a string to be checked
     * @param {number} - start from
     **/
    whetherInQuote : function(str, index){
        var sqNum = 0, dqNum = 0;
        for(var i = 0; i <= index; i++){
            var chr = str.charCodeAt(i);
            
            if(34 === chr){
                dqNum++;
            }
            if(39 === chr){
                sqNum++;
            }
        }
        
        return (1 == sqNum%2) || (1 == dqNum%2);
    },

    /**
     * @public
     * check whether the charAt(index) of str is in a function or not
     * @param {String} - a string to be checked
     * @param {number} - start from
     **/
    whetherInFun : function(str, index){
        var inFunFlg = false, emb = 0;
        for(var i = index-1; 0 <= i; i--){
            var chr = str.charAt(i);
            if('(' == chr){
                emb++;
            }else if(')' == chr){
                emb--;
            }
            if(0 < emb && ']' == str.charAt(i-1)){
                var fname = '';
                for(var j = i-3; j >= 0; j--){
                    var ch = str.charAt(j);
                    if('"' == ch){
                        break;
                    }
                    fname = ch+fname;
                }
                if('condition' === fname){
                    inFunFlg = false;
                }else{
                    inFunFlg = true;
                }
                break;
            }
        }
        return inFunFlg;
    },

    /**
     *  @public
     *  this will validate url is right or not
     *  If it is not work, return false.
     *  @param {string} - the url need to be validated.
     */
    validateURL:function(url){
        if(url){
            url = url.toString();
            var myURL = url.trim();
            if(myURL.length != 0){
                var j = new RegExp();
                j.compile(/^[a-z]+:\/\/[a-z0-9-]+\.[a-z0-9]+/gi);
                if(j.test(myURL)){
                    return true;
                }
            }
        }
        return false;
    },

    /**
     *  @public
     *  this will validate url is right or not
     *  If it is not work, return error msg
     *  @param {string} - the url need to be validated.
     */
    validateURLWithErrorMsg : function(url){
        if (url) {
            var myURL = url.toString().trim();
            if(myURL.length > 0 && /\S+\.\S+$/i.test(myURL)){
                // this is a kind of too complex ... 
                // I am afraid this will cost too much - think performance ....
                var j = new RegExp("^(((ht|f)tp(s?))\://)?(www.|[a-zA-Z0-9\-\.\@]+)(com|edu|gov|mil|net|org|biz|info|name|museum|asia|[a-zA-Z]{2})(\:[0-9]+)*(/($|[a-zA-Z0-9\.\,\;\?\'\\\+&amp;%\$#\=~_\-]+))*$");
                if(j.test(myURL)) return true;
            }
        }

        return 'URL should be in format: "http://www.google.com"';
    },

    /**
     *  @public
     *  this will validate html is url.
     *  If it is url ,obj  increases hyperlink and css object .
     *  @param {string} - the html need to be validated.
     */
    generateHyperlink:function(html,obj){
        if(Ext.ss.common.Helper.validateURLWithErrorMsg( html) == true){
            var css = obj['css']||'';
            obj['hyperlink'] = html;
            if((css&&css.indexOf(SCONST.cssHash[4])==-1)||!css){
                css += " "+SCONST.cssHash[4];
                obj['css'] = css;
            }
        }
    },
	
	/**
     * @ public
     * This is the method to get last day
     * @param {String} - input date
     */
	getlastday:function(date){
	    var tmpdate = new Date(date.getYear(),date.getMonth()+1,1);
		var tmpdate = new Date(tmpdate - 86400000);
		return tmpdate.getDate();
	},
	
	/**
     * @ public
     * This is the method to convert percent into number: 8% --> 0.08
     * @param {String} - percent number 
     */
	convertPercent2num : function(inStr) {
	    // check whether it include percent %
		var modeFlag = false;
		inStr = inStr.replace(/[0-9]+(\.)?[0-9]*%/g, function(w){
			 var matchPos = arguments[arguments.length-2];
			 /*
			  * if the 5% included in "" or '' then not transfer to number
			  */
			 if(Ext.ss.common.Helper.whetherInQuote(inStr, matchPos+w.length-1)){
					return w;
			 }
			 var next = inStr.charAt(matchPos+w.length);
			 if(next && /[0-9]/gi.test(next)){
				 modeFlag = true;
				 return w;
			 }
			 var r = w.replace("%","");
			 return (Number(r)/100);
		});
		if (modeFlag){
			inStr += ';throw "SS_ERROR_VALUE";';
		}
		return inStr;
	},
	
	// check to see wheether it is end with %, if yes - return number
	convertPercent2num2 : function(inStr) {
		if(typeof inStr === 'string' && inStr.substr(-1) === "%" ) {
			var result = parseFloat(inStr) / 100.0;
			return result;
		} else 
			return inStr;
	},
	
    /**
     * @ public
     * This is the method to unwrap link
     * @param {String} - input url string to be checked
     */
    unwrapLink : function(url) {
        var flag = false;
        if (url) {
            var myURL = url.toString().trim();
            if (Ext.ss.common.Mask.isLink(myURL)) {
                flag = true;
                var parts = myURL.split('>', 1);
                url = parts[0].slice(9, -1);
            }
        }
        return {
            url : url,
            flag : flag
        };
    },
    
    wrapLink : function(url) {
		return '<a href="' + url + '">' + url + '</a>';
	},
    
    /*
     * return true if the passed value is null or undefined or empty string
     */
    isEmptyValue : function(val){
    	if(val == null || false == Ext.typeOf(val)){
    		return true;
    	}
    	var s = val.toString().trim();
    	if('' === s){
    		return true;
    	}
    	
    	return false;
    },
    
    /**
     * This function is used to update compare condition - add "=" if only have single =
     * In general, case: >=, <=, !=, <>, and =. If it is only =, make it double ...
     * JS: == means equal, in human single = means equal.
     * 
     * This condition assume always start from > < = 
     * 
     * =1 => ==1
     * >1 => >1
     * =apple => =="apple"  this is a special case, if it is not number, should add "",
     * 
     * TODO: another case
     * =5%  => ==0.05
     */
    updateCompareCondition : function (val) {
    	val = val.toString().trim();
    	var compareFlag = /^\s*[!<>=]/gi.test(val);    	
    	if (compareFlag) {
    		val = val.toString().trim();
    		
    		if (val.length > 1) {
	    		if (val.substring(0,1) == "=" && val.substring(1,2) != "=" ) {
	    			val = "=" + val;
	    		} 
	    		
	    		// first character is ! = < > sure
	    		var firstPart = val.substring(0,1);
	    		var secondPart = val.slice(1);
	    		var first2ndPart = secondPart.substring(0,1);
	    		
	    		if (first2ndPart == "=" || first2ndPart == ">" || first2ndPart == "<") {
	    			firstPart = val.substring(0,2);
	    			secondPart = val.slice(2);
	    			
	    			// <> is not work ... should be changed as !=
	    			if (firstPart == "<>") firstPart = "!=";
	    		}
	    		secondPart = HELPER.convertPercent2num2(secondPart.trim()); // check special case ...if it is %
	    		
	    		// check whether it is number ?
	    		if (Ext.isNumber(Number(secondPart))) {
	    			return firstPart.concat(secondPart);
	    		} else 
	    			return firstPart.concat('"').concat(secondPart).concat('"');
    		}
    	}
    	
    	return val;
    },
    
    /**
     * This function will chop extra zero function, in some case we have this kind of problem ...
     * Such as: =POWER(1.1,5) -- 1.6105100000000000001 - first we need round it and then 
     * Chop the extra zero if it is there ... this is a bug in javascript ...
     */
    roundUpNonZero : function(val) {
    	// just take guess and round to 12 number ...
    	var numFormat = '0.00000000000'; 
    	var result = Ext.util.Format.number(val, numFormat);
    	var str = result.toString();
        // check whether it is zero
        for (var i=str.length; i>0; i--) {
        	var tempChar = str.charAt(i-1);        	
        	if (tempChar != '0') {
        		if (tempChar == '.') return str.substr(0, i-1);
        		else return str.substr(0, i);
        	}
        }
        
        return val;
    },
    
    /**
     * this is the function to round not zero
     * Such as: =POWER(1.1,5) -- 1.6105100000000000001 - first we need round it and then 
     * Chop the extra zero if it is there ... this is a bug in javascript ...
     */
    valRoundUpNonZero : function (val) {
    	// check whether it is number, if not, return it
    	var val = Number(val);
    	if (Ext.isNumber(val)) {
	    	var digitalLen = Ext.ss.common.Helper.getDigitalLen(val);
			if (digitalLen > 14) { // now I know this is a special case and we need deal with - round to something chop it ... 
				val = Ext.ss.common.Helper.roundUpNonZero(val);
			}
    	}
		
		return val;
    },
    
    getPercentNumPart : function(str){
    	if(str){
    		str = str.toString();
    		var last = str.charAt(str.length-1);
    		if('%' == last){
    			str = str.slice(0, str.length-1);
    			str = str.replace(/,/g, '');
    			var num = Number(str);
    			
    			if(Ext.isNumber(num)){
    				
    				var parts = str.split('.'), d = 0;
    				if(2 == parts.length){
    					d = parts[1].length;    					
    				}
    				d += 2;
    				num = num/100;
    				str = num.toString();
    				parts = str.split('.');
    				var dot;
    				if(2 == parts.length){
    					dot = parts[1];
    					var m = Number(dot.slice(d, d+1));
    					
    					dot = dot.slice(0, d);
    					if(5 <= m){
    						m = Number(dot.charAt(dot.length-1))+1;    						
    						dot = dot.slice(0, d-1)+m;    						
    					}
    				}
    				if(dot){
    					num = parts[0]+'.'+dot;
    				}    				    			
    				return Number(num);
    			}
    		}
    	}
    },
    
    /**
     * this is the function to recheck data format 
     * 
     * For example, in the cell - it is percent format and now I enter text 
     * format should be removed ...
     * 
     * Id origFormat is null, then we can ignore this steps ... need double check ...
     * 
     */
    checkDataFormat : function (str, origFormat) {
    	
    },
    
    /**
     * parse date in default format - 
     * 
     * We should parse your string manually, 
     * and use the Date constructor with the year, month and day arguments to avoid ambiguity:
     */
    parseDefaultDate : function(input) {
	    var parts = input.split('-');
	    return new Date(parts[0], parts[1]-1, parts[2]); // months are 0-based
	},
	
	/**
	 * Check to see whether string end with 
	 */
	stringEndsWith : function(str, suffix) {
		
	},
	
	/**
     * Check to see whetehr this str is percent 
     */
    isPercent : function(str) {
    	var result = false;  
    	
    	if (str) {
    		str = str.toString();
    		var last = str.charAt(str.length-1);
    		if('%' != last) return false;
    		
    		str = str.slice(0, str.length-1);
    		str = str.replace(/,/g, '');
    		var num = Number(str);
    		
    		if(Ext.isNumber(num)) result = true;
    	}
    	
    	return result;
    },
	
	/**
	 * this is function to test whether it is science format
	 */
	isScienceFormat : function(inStr) {	
		
		inStr = inStr.toLowerCase();	
		var parts = inStr.split('e+');
		if (2 == parts.length) {
			var ePart1 = Ext.util.Format.trim(parts[0]);
			var ePart2 = Ext.util.Format.trim(parts[1]);
			
			if( /^[0-9.]+$/gi.test(ePart1) && /^[0-9]+$/gi.test(ePart2)) return true;
		}
		
		parts = inStr.split('e-');
		if (2 == parts.length) {
			var ePart1 = Ext.util.Format.trim(parts[0]);
			var ePart2 = Ext.util.Format.trim(parts[1]);
			
			if( /^[0-9.]+$/gi.test(ePart1) && /^[0-9]+$/gi.test(ePart2)) return true;
		}

		return false;
	},
	
	/**
	 * this is function to test whether it is comma format
	 */
	isCommaFormat : function(inStr) {					
		if (inStr.indexOf(",") !== -1) {
			inStr = inStr.replace(/,/g, '');
			var num = Number(inStr);
			if (Ext.isNumber(num)) return true;
		}
		
		return false;
	},
	
	/**
	 * this function is used to check num format ... default is number format - null 
	 */
	checkNumFormat : function(value) {
		
		if (value == null || value === undefined) return null;
		
    	var str = value.toString();
    	
    	// ok, we need check whether this is science 
    	// this should be before isNumber ...
    	if(Ext.ss.common.Helper.isScienceFormat(str)) return SCONST.FORMAT_SCIENCE;
    	
    	var num = Number(str);
    	if(Ext.isNumber(num))  return null;
    	
    	// ok, need check whther it is percent ...
    	if(Ext.ss.common.Helper.isPercent(str))  return SCONST.FORMAT_PERCENT;
    	
    	// this is used to check whether it is comma included ...
    	if(Ext.ss.common.Helper.isCommaFormat(str)){
    		str = str.replace(/,/g, '');
    		return  SCONST.FORMAT_COMMA;
    	}
    	
    	return null;		
	},
	
	/**
	 * this function will be used to check whether it is math function 
	 * Check to see whether string include + - / * ^
	 */
	includeMathOperator : function(inStr) {
		if (inStr.indexOf("+") !== -1 || inStr.indexOf("*") !== -1
				|| inStr.indexOf("-") !== -1 || inStr.indexOf("/") !== -1) {
			return true;
		}
		return false;
	},
	
	/**
	 * if cond is: =A* then it should be change as: A*
	 *             =*A => *A
	 */
	changeCondSpecialCase : function(inStr) {
		var str = inStr.toString().trim();
		if (str != null && str.length > 2) {		
			if (str.substring(0,2) === '=*' || 
					(str.charAt(0) === '=' && str.slice(str.length-1) === '*')) {
				str = str.slice(1);
			}			
		}
		
		return str;
	},
	
	/**
	 * this is repeat text with times ...
	 */
	repeat : function(txt, times) {
		times = Number(times);
		if (Ext.isNumber(times)) {
			if (0 > times)
				throw { code: 'CAL_NO_VALUE', cal: 'repeat' };
			else if (0 == times)
				return "";
		} else
			throw { code: 'CAL_NO_VALUE', cal: 'repeat' };

		if (Ext.isNumber(txt) || Ext.isString(txt)) {
			txt = txt.toString();
			var arr = [];
			for ( var i = 0; i < times; i++) {
				arr.push(txt);
			}
			return arr.join('');
		} else
			throw { code: 'CAL_NO_VALUE', cal: 'repeat' };
	},
	
	/**
	 * this function will set the bottom bar status in Saving process
	 * Also we need disable some button (like SAVE, NEW, OPEN etc) in the tool bar ...
	 */
	setBottombarStatusInSaving : function(ss) {
		ss.setStatus({
			text : feyaSoft.ss.lang['saveChanges'],
			iconCls : 'x-status-busy'
		});
		
		// ok set file status --- 
		ss.file.inSaving = true;
		
		// disable menu
		if (ss.toolbar.get(0)) ss.toolbar.get(0).setDisabled(true);
		if (ss.toolbar.get(1)) ss.toolbar.get(1).setDisabled(true);
		if (ss.toolbar.get(2)) ss.toolbar.get(2).setDisabled(true);
	},
	
	// if it is temporary, do not show SAVED information ...
	setBottombarStatusInDone : function(ss, isTemporary) {
		if (isTemporary == null || isTemporary == false)
	        ss.setStatus({
				text : feyaSoft.lang.common['saved']+' '+feyaSoft.lang.common['at']+' '+(new Date().format('H:i:s d/m Y')),
				iconCls : 'x-status-valid'
			});
		else 
			ss.setStatus({
				text : feyaSoft.ss.lang['newSpreadsheet'],
				iconCls : 'x-status-valid'
			});
		
        delete(ss.file.inSaving);
        
        if (ss.toolbar.get(0)) ss.toolbar.get(0).setDisabled(false);
		if (ss.toolbar.get(1)) ss.toolbar.get(1).setDisabled(false);
		if (ss.toolbar.get(2)) ss.toolbar.get(2).setDisabled(false);
	},
	
	setBottombarStatusInFailed : function(ss) {
		ss.setStatus({
              text : feyaSoft.ss.lang['fail2Save'],
              iconCls : 'x-status-error'
		});
		
		delete(ss.file.inSaving);
		
		if (ss.toolbar.get(0)) ss.toolbar.get(0).setDisabled(false);
		if (ss.toolbar.get(1)) ss.toolbar.get(1).setDisabled(false);
		if (ss.toolbar.get(2)) ss.toolbar.get(2).setDisabled(false);
	},
	
	/**
	 * this function is used for ISIF, start to set status that
	 * ISIF call is in process
	 */
	setBottombarStatusInProcessISIF : function(ss) {
		ss.setStatus({
			text : "Updating ISIF, please wait ...",
			iconCls : 'x-status-busy'
		});
		
		// ok set file status --- 
		ss.file.inSaving = true;
		
		// disable menu
		if (ss.toolbar.get(0)) ss.toolbar.get(0).setDisabled(true);
		if (ss.toolbar.get(1)) ss.toolbar.get(1).setDisabled(true);
		if (ss.toolbar.get(2)) ss.toolbar.get(2).setDisabled(true);
	},
	
	setBottombarStatusEndISIF : function(ss) {
		ss.setStatus({
			text : "ISIF Changed",
			iconCls : 'x-status-valid'
		});
		
		// ok set file status --- 
		delete(ss.file.inSaving);
		
		// disable menu
		if (ss.toolbar.get(0)) ss.toolbar.get(0).setDisabled(false);
		if (ss.toolbar.get(1)) ss.toolbar.get(1).setDisabled(false);
		if (ss.toolbar.get(2)) ss.toolbar.get(2).setDisabled(false);
	},
	
	/////////////////////////////////////////////////////////////////////////////////
	// those method is from DateSourceHelper from old version 
	////////////////////////////////////////////////////////////////////////////////
	/**
     * @public
     * recheck double quote case = "123" + 123
     * replace anything with "123"  =>  123
     * 
     * And "=1/0" => Infinity
     * 
     * @param {string} - the string to be start / end
     **/
    reCheckDoubleQuote : function(inStr) {
    	// check condition ... =+ => =
    	if (this.startWith(inStr, "=+")) inStr = "=" + inStr.substring(2);
    	
        var needReCal = false;
        var arrItems = HELPER.getArrFromMathOper(inStr, "plus");
        for (var j=0; j<arrItems.length; j++) {
            var temp = HELPER.strTrim(arrItems[j]);
            if (HELPER.startEndWith(temp, "\"")) {
                var tempNumStr = temp.substring(1, temp.length-1);
                var tempNum = Number(tempNumStr);
                if (Ext.isNumber(tempNum)) {
                    arrItems[j] = tempNum;
                    needReCal = true;
                }
            }
        }
        // ok, need recaluclate ...
        if (needReCal) inStr = arrItems.join("+");

        // another case - replace all "=1/0" as Infinity
        // TODO be careful ...
        // inStr = inStr.replace(/"=1\/0"/g, "Infinity");
        
        return inStr;
    },
    
    /**
     * convert special formula name now ..
     * =STDEV.S(A2:A11) -> =STDEV_S(A2:A11)
     */
    convertSpecialFormulaName : function(inStr) {
    	var lowCalStr = inStr.toLowerCase();
    	if (lowCalStr.indexOf("stdev.s(") != -1)  inStr = inStr.replace(/stdev.s\(/ig, "stdev_s(");
    	if (lowCalStr.indexOf("stdev.p(") != -1)  inStr = inStr.replace(/stdev.p\(/ig, "stdev_p(");
    	if (lowCalStr.indexOf("var.p(") != -1)  inStr = inStr.replace(/var.p\(/ig, "var_p(");
    	if (lowCalStr.indexOf("=var(") != -1) { // for special case ...
    		inStr = inStr.replace(/=var\(/ig, "=var_orig(");
    	}
    	if (lowCalStr.indexOf("var.s(") != -1)  inStr = inStr.replace(/var.s\(/ig, "var_s(");
    	if (lowCalStr.indexOf("percentile.inc(") != -1)  inStr = inStr.replace(/percentile.inc\(/ig, "percentile_inc(");
    	if (lowCalStr.indexOf("percentile.exc(") != -1)  inStr = inStr.replace(/percentile.exc\(/ig, "percentile_exc(");
    	if (lowCalStr.indexOf("quartile.inc(") != -1)  inStr = inStr.replace(/quartile.inc\(/ig, "quartile_inc(");
    	if (lowCalStr.indexOf("quartile.exc(") != -1)  inStr = inStr.replace(/quartile.exc\(/ig, "quartile_exc(");
    	if (lowCalStr.indexOf("mode.sngl(") != -1)  inStr = inStr.replace(/mode.sngl\(/ig, "mode(");
    	if (lowCalStr.indexOf("expon.dist(") != -1)  inStr = inStr.replace(/expon.dist\(/ig, "expon_dist(");
    	if (lowCalStr.indexOf("rank.avg(") != -1)  inStr = inStr.replace(/rank.avg\(/ig, "rank_avg(");
    	if (lowCalStr.indexOf("rank.eq(") != -1)  inStr = inStr.replace(/rank.eq\(/ig, "rank_eq(");
    	if (lowCalStr.indexOf("binom.dist(") != -1)  inStr = inStr.replace(/binom.dist\(/ig, "binomdist(");
    	if (lowCalStr.indexOf("networkdays.intl(") != -1)  inStr = inStr.replace(/networkdays.intl\(/ig, "networkdays_intl(");
    	if (lowCalStr.indexOf("workday.intl(") != -1)  inStr = inStr.replace(/workday.intl\(/ig, "workday_intl(");
    	
    	return inStr;
    },
    
    // check whether this is special formula ...
    isIncludeSpecialFormulas : function(lowStr) {
    	var listSpecialFormulas = SCONST.specialFormuals;
    	for (var i=0; i<listSpecialFormulas.length; i++) {
    		if (lowStr.indexOf(listSpecialFormulas[i]) != -1) return true;
    	}
    	return false;
    },
    
    replaceBraces : function(str){
        var newStr;
        while(true){
            newStr = str.replace(/("[^\"]*")|('[^\']*')|({[^{}]+})/gi, function(w){
                if(arguments[3]){
                    var match = arguments[3];
                    match = match.slice(1, -1);
                    var parts = match.split(';'), len = parts.length;
                    if(1 < len){
                        for(var i = 0; i < len; i++){
                            parts[i] = '(['+parts[i]+'])';
                        }
                        match = parts.join(',');
                    }
                    return '(['+match+'])';
                }else{
                    return w;
                }
            });
            if(newStr === str){
                break;
            }
            str = newStr;
        }
        return newStr;
    },
                                                                             
    /**
     * @public
     * Extra "{}" replace "[]".
     * case =sum({1,2,3,4,5},6,7,8) replace  =sum([1,2,3,4,5],6,7,8)
     * 
     * more case, like small, large 
     * 
     **/
    reCheckBracesAndExtraComma : function(str) {
    	
    	// to lowcase now ...
    	var lowStr = str.toLowerCase();    	
    	if(HELPER.isIncludeSpecialFormulas(lowStr)) {	
    		// this replace the special case ...
    		str = str.replace(/\'([^ \']+)\'|\"([^ \"]+)\"|(\{)|(\})/g,function(v,m){
    		 	var start=arguments[5];
    		 	if(v=="{") {
    		 	   var itm=str.substring(start+1,start+20);
    		       itm=itm.trim();
    		 	   if((itm.indexOf("{")==0)||(itm.indexOf("{")!=-1)||itm.indexOf('sheetIndex:')==-1) v="[";
    		 	} else if(v=="}") {
    		 	   var itm=str.substring(start-20,start);
    		 	   if(itm.indexOf('ab:') == -1 || ( itm.indexOf('}')!=-1 && itm.indexOf('ab:')!=-1 ) )  v="]";
    		 	}
    		 	return v;
			});
			
			// special case for rows - =rows({1,2;3,4}) - ; need to be changed as },{
    		// index is also -- INDEX({1,-2;3,4},0,2)
    		// =LOOKUP("C", {"a","b","c","d";1,2,3,4}) -> =LOOKUP("C", ["a","b","c","d"], [1,2,3,4])
    		if ( lowStr.indexOf("=type") != -1 || lowStr.indexOf("=rows") != -1 || lowStr.indexOf("=index") != -1 || lowStr.indexOf("=lookup") != -1) {
    			str = str.replace(/\'([^ \']+)\'|\"([^ \"]+)\"|(\;)/g, function(v,m) {		 	
	    		 	if(v==";") v='],[';
	    		 	return v;
				});
    		} else { // sumxmy2 - =SUMXMY2({1,2;3,4}, {5,6;7,8})  ; need to be converted as =SUMXMY2([1,2,3,4], [5,6,7,8]) 
				str = str.replace(/\'([^ \']+)\'|\"([^ \"]+)\"|(\;)/g, function(v,m) { 		 	
	    		 	if(v==";") v=',';
	    		 	return v;
				});
    		}
    	}
    	
    	// this is for another case: =AREAS((A1:C3,B4:B5)) -> =AREAS(A1:C3,B4:B5)
		if(lowStr.indexOf("=areas") != -1) {
			str = str.replace("((", "(").replace("))", ")");
		}
		
		// check rate special case - =RATE(2*12, -250, 5000, , 1)                             
		// recehck whether this is special comma
		// sum(,3) => sum(3)
		// sum(2, ) => sum(2)
        // case  =sum(2,,,,,3) replace  =sum(2,0,0,0,0,3)
        // case =SUM(,,2,,SUM(,33,,,SUM(,,,2,2,,,sum(2,),),,,),,,,) replace   =SUM(0,0,2,0,SUM(0,33,0,0,SUM(0,0,0,2,2,0,0,sum(2,0),0),0,0,0),0,0,0,0)
        // case =sum(2,) replace   sum(2,0) 
		if (lowStr.indexOf("=rate") != -1 || lowStr.indexOf("=sum") != -1 || lowStr.indexOf("=pv") != -1){
            str = str.replace(/,\s*,/g, ',0,');
        }
		str = str.replace(/\(\s*,/g,'(').replace(/,\s*\)/g,')');
		
    	return str;
    },
    
    // check whethwer all str is empty or not ...
    isEmptyStr : function(inStr) {
        var blankRE=/^[\s]+$/;
        if(inStr === "" || blankRE.test(inStr)) return true;
        return false;
    },
    
    /**
     * this is function is used to format the number. There are lots of cases in here
     * 
     * And extjs does not provided enough cover - so we need handle some special cases ...
     * 
     * for example: ####.#, 000.0, #.0#, ???.???. 
     *              #,### #, 0,0,,
     *              0.00%
     *              $0,000.00
     * 
     * @param number 
     * @param format
     */
    formatNumber : function(num, fm) {  
    	// check fm ...
    	if (typeof fm != "string") throw { code: 'CAL_PARAM_MISS', cal: 'formatNumber' };
    	if (fm === "%") return "%";
    	
    	var finalFm = fm;
    	
	    // check to see whether it is percent ...
	    var formatType = "decimal";
	    if (fm.substr(-1) === "%") {
	    	formatType = "percent";
	    	finalFm = finalFm.slice(0, finalFm.length-1);
	    	num = parseFloat(num) * 100;
	    }
	    
	    // ok handle format with # and ?, at this moment, just quick replace this with 0
	    // TODO
	    finalFm = finalFm.replace(/#/g,"0").replace(/\?/g,"0");
	    
	    // this is for handle science format ...
	    if (HELPER.isScienceFormat(finalFm)) {
	    	// TODO -- and need set this value as scient format ....
	    	var value = Number(num).toExponential(2); 
	    	return value;
	    }
	    		
	    var result = Ext.util.Format.number(num, finalFm); 	    
	    if (formatType === "percent") result = result + "%";
	    
	    return result;  
    },
    
    replaceDateFm : function(fm) {
    	// replace yyyy - Y, mm - m and dd - d
		if (fm && Ext.isString(fm) && fm.length > 1) {
			// special case: hh:mm - not replace mm
			fm = fm.replace(/yyyy/gi, "Y").replace(/yy/gi, "y")
			       .replace(/mmmm/gi, "F").replace(/mmm/gi, "M").replace(/mm/g, "m")
			       .replace(/dddd/gi, "l").replace(/ddd/g, "D").replace(/dd/gi, "d").replace(/D/gi, "d")
			       .replace(/hh/g, "h");
			if (fm.indexOf(":m") != -1) { // h:i - hour and minutes
				fm = fm.replace(/:m/i, ":i");
			}
			
			// for the case am/pm OR AM/PM
			fm = fm.replace(/am\/pm/i, "A");				
			
			// for weekday ...
			fm = fm.replace(/aaaaa/i, "l").replace(/aaaa/i, "l").replace(/aaa/i, "D");	
		}
		
		return fm;
    },
    
    calculateErf : function(value) {
		// constants
	    var a1 =  0.254829592;
	    var a2 = -0.284496736;
	    var a3 =  1.421413741;
	    var a4 = -1.453152027;
	    var a5 =  1.061405429;
	    var p  =  0.3275911;
	
	    // Save the sign of x
	    var sign = 1;
	    if (value < 0)  sign = -1;
	    var x = Math.abs(value);
	
	    // A&S formula 7.1.26
	    var t = 1.0/(1.0 + p*x);
	    var y = 1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*Math.exp(-x*x);
	
	    return sign*y;
	},
	
	// this function will sort inArr with required order
	sortNumberArray : function(inArr, order) {
		if (order == "asc") return inArr.sort(function(a,b){return a - b});
		else return inArr.sort(function(a,b){return b-a});
	},
	
	/**
     * @public
     * This is the method recursive call the operation to add item
     * For example:
     *     =today()+1+b1+c1
     * We need loop each part and recursive call them one by one
     *
     * @param {string} - input string
     * @param {arry} - array obj. It will be a list of {firstItem:firstItem, operator: operator, remindItem: remindItem}
     **/
    recursiveMathOpers : function(str, arrObj) {
        // first check whether str inlcude single quote ... like: ='123' etc
        // var checkQuoteFormat = Ext.ss.common.Helper.fmFormatWithQuote(str);
        // if (checkQuoteFormat == false) throw 'SS_ERROR_REF'; 
        var separatedObj = HELPER.seperatedByMathOper(str);    
        if (separatedObj) {
            arrObj.push(separatedObj);
            if (separatedObj.remindItem) this.recursiveMathOpers(separatedObj.remindItem, arrObj);
        }
    },
    
    /**
     * @public
     * ok, this is the method to check cases:
     *  CASE: =123 + "test"
     *     = 12 - "test"   that is: + - * /
     *     = '123'
     *     = 'a1' + 'test'
     *     =today()+2
     *     =1+today()
     * if this math operator does not valid - need return
     * NULL means this math ok, ERROR means wrong
     * TODO:
     * on case miss:  =TRIM(MID(A1, 1, 3))+123 - this is a hard one - ignore this temporary
     * @param {string} - the input string which will be checked
     * @param {object} - eval object
     */
    seperatedByMathOper : function(str) {
        // trim and remove parentheses if any ...
        str = HELPER.removeParentheses(str); // trim first ....

        // now we start parse the string and get the result based on + - * /
        // also need take care of () and FBox. FBox[
        var separatedObj = HELPER.separatedByMathOperObj(str);

        // check first operator is existing or not - if not, return null
        if (separatedObj.firstItem == null) return null;

        return separatedObj;
    },

    /*
     * @public
     * calculate 2 part based on part1, part2 and operator
     * @param {String} - part1
     * @param {String} - part2
     * @param {string} - operator
     **/
    calculateByOper : function(part1, part2, oper) {
        // check error conditions ...
        if (part1 == "#REF!" || part1 == "#REF!") throw 'SS_ERROR_REF';

        // 2 special case
        if (part1 == null) return part2;
        if (oper == null) return part1;

        // now we need check the different case in here ...
        // part1, part2 can
        //  @string @date @number ....
        var numPart1 = Number(part1);
        var numPart2 = Number(part2);

        //console.log("part1 = " + part1);
        //console.log("part2 = " + part2);

        // pre-define result ...
        var result = null;

        // We will come to case by case in here, first start with DATE...
        // Check date format now ...
        if (Ext.ss.common.Helper.isSSDefaultDate(part1)) {
        	
            if (Ext.isNumber(numPart2)) {
                if (oper == "-" || oper == "+")  result = Ext.ss.common.Helper.calculateDate(part1, numPart2, oper);
                else result = Ext.ss.common.Helper.calculateDateByNum(part1, numPart2, oper);
            } else if (Ext.ss.common.Helper.isSSDefaultDate(part2)) {
                result = Ext.ss.common.Helper.calculate2Date(part1, part2, oper);
            } else {
                throw 'SS_ERROR_VALUE';
            }
            return result;
        }
        if (Ext.ss.common.Helper.isSSDefaultDate(part2)) {
            if (Ext.isNumber(numPart1)) {
                if (oper == "+")  result = Ext.ss.common.Helper.calculateDate(part2, numPart1, oper);
                else result = Ext.ss.common.Helper.calculateDateByNum2(numPart1, part2, oper);
            } else {
                throw 'SS_ERROR_VALUE';
            }
            return result;
        }

        // both are number - that is easy part
        if(Ext.isNumber(numPart1) && Ext.isNumber(numPart2)){
            return eval(part1+oper+part2);
        }

        throw 'SS_ERROR_VALUE';
    },
    
    // ==========================================================================================================
    
    /**
     * this function will convert the following example:
     * =today()+2
     * =day(today()-2)
     * =array1*array2
     * AS
     * =overwritePlus(today(),2);
     * ok, recreate this as new string with formula - special formula: overwritePlus and overwriteMinus
     * 
     * =text(today()+6, "mmmm d")
     * AS:   =text(overwritePlus(today(),6), "mmmm d")
     * 
     * CASE one more: =sum(12, -5) should be ignore ...
     *                =day(2014-10-10, 2014-10-05)
     *                =B5+1 -- this need convert
     *                
     * Update @ 2015 03 07 -- case 3.0e+10 OR 3.0E+5 need ignore too.
     * Update @ 2015 03 07 -- case meet < > = stop too
     * Update @ 2015 03 08 -- one more case need ignore
     *     =1000*-1
     * 
     * SOLUTION:
     *     Separated by + or -
     *     For part1, work from right to left and see whether it meet (, if yes stop and get part 1
     *     For part2, work from left to right and see whether it meet ), if yes stop and get part 1
     *     If +, = ...  overwrite(part1, part2)  ....
     *     
     */
    convertPlusMinus : function(inStr, checkParenthese) {   	
    	var result = inStr;  // if anything wrong, just return original inStr
    	
    	// check whether it start with =
		if (this.startWith(inStr, "="))  inStr = inStr.substring(1, inStr.length);	
		// I do not know whether we need this ... ??? seems we do not need
        if (checkParenthese) inStr = HELPER.removeParentheses(inStr); // trim and remove parentheses if any ...
        
        var firstItem = "";
        var operator = null;
        var remindItem = null;
        var operatorPart1 = "";
        var operatorPart2 = "";
        
        // add one more condition - before +/- character
        // var beforeIsChar = true;
    	
        // check cases: " double quote, { bracket, ( parentheses, [
        var meetDoubleQuote = false;
        var meetSingleQuote = false;
		var ignoreCount = 0, preChar = null;
		for (var i=0; i<inStr.length; i++) {

            // read each character ...
            var chartAtI = inStr.charAt(i);
            if (chartAtI == "\"") {
                meetDoubleQuote = !meetDoubleQuote;
            } if (chartAtI == "'") {
                meetSingleQuote = !meetSingleQuote;
            }  else if (chartAtI == "[" || chartAtI == "{") {
                ignoreCount = ignoreCount + 1;
            } else if (chartAtI == "]" || chartAtI == "}") {
                ignoreCount = ignoreCount - 1;
            } 
            
            if (!meetDoubleQuote && !meetSingleQuote && ignoreCount == 0  
            		&& (chartAtI == "+" || chartAtI == "-") 
            		&& "*" != preChar && "/" != preChar ) { 
        		operator = chartAtI;
                remindItem = inStr.substring(i+1);
                break;
            }
            firstItem = firstItem.concat(chartAtI);
            // check preChar ...
            preChar = chartAtI;
		}
		
		// add condition ...
		if (remindItem == null) return result;
		
		// check special case firstpart is null ... such as: -ok, -5
		if (firstItem == "" && operator == "-") firstItem = "0";
		
		// ok, we need check firstItem then ----------------------------- 
		var firstPartSepPos = 0;
		var countParenthese = 0;
		for (var i=firstItem.length; i>0; i--) {
			var chartAtI = firstItem.charAt(i-1);
			
			if (chartAtI == "(" && countParenthese == 0) {
			    firstPartSepPos = i;
			    break;
			}
			
			// check to see whether it meet , and > < = .... NEED do more test
			if ((chartAtI == "," || chartAtI == "=" || chartAtI == ">" || chartAtI == "<") && countParenthese == 0) {
			    firstPartSepPos = i;
			    break;
			}
			
			if (chartAtI == ")") countParenthese = countParenthese + 1;
			else if (chartAtI == "(") countParenthese = countParenthese - 1;		
			operatorPart1 = chartAtI + operatorPart1;
		}
		
		if (firstPartSepPos == 0) firstItem = "";
		else {
			firstItem = firstItem.substring(0, firstPartSepPos);
		}
		
		// do a check first - need think about -val
		operatorPart1 = this.strTrim(operatorPart1);
		if (operatorPart1.length == 0) operatorPart1 = "0";
		
		// ok, we need check remindItem then ----------------------------- 
		countParenthese = 0;
		var secondPartSepPos = 0;
		for (var i=0; i<remindItem.length; i++) {
			var chartAtI = remindItem.charAt(i);
			
			if (chartAtI == ")" && countParenthese == 0) {
			    secondPartSepPos = i;
			    break;
			}
			
			// check to see whether it meet , 
			if ((chartAtI == "," || chartAtI == "=" || chartAtI == ">" || chartAtI == "<") && countParenthese == 0) {
			    secondPartSepPos = i;
			    break;
			}
			
			// check to see whether it meet , 
			if ((chartAtI == "+" || chartAtI == "-" ) && countParenthese == 0) {
			    secondPartSepPos = i;
			    break;
			}
			
			if (chartAtI == "(") countParenthese = countParenthese + 1;
			else if (chartAtI == ")") countParenthese = countParenthese - 1;		
			operatorPart2 = operatorPart2.concat(chartAtI);
		}
		
		if (secondPartSepPos == 0) remindItem = "";
		else {
			remindItem = remindItem.substring(secondPartSepPos);
		}
    	
		// trim first ...
		operatorPart2 = this.strTrim(operatorPart2);
		if (operatorPart2.length > 0) {
			if (Ext.isNumber(Number(operatorPart1)) && Ext.isNumber(Number(operatorPart2))) return result;
			if (/[0-9.]+e$/i.test(operatorPart1) && Ext.isNumber(Number(operatorPart2))) return result;	
			
			if (operator == "+") result = "=" + firstItem + "overwriteplus(" + operatorPart1 + "," + operatorPart2+")"+remindItem;
			else if (operator == "-") result = "=" + firstItem + "overwriteminus(" + operatorPart1 + "," + operatorPart2+")"+remindItem;

			// recursive call remindItem ....
			return this.convertPlusMinus(result, false);
		} 
		
		return result;
    },
    
    /**
     * this is for handle * and /
     */
    convertMulDiv : function(inStr) {   	
    	var result = inStr;  // if anything wrong, just return original inStr
    	
    	// check whether it start with =
		if (this.startWith(inStr, "="))  inStr = inStr.substring(1, inStr.length);	

        var firstItem = "";
        var operator = null;
        var remindItem = null;
        var operatorPart1 = "";
        var operatorPart2 = "";
        
        // check cases: " double quote, { bracket, ( parentheses, [
        var meetDoubleQuote = false;
        var meetSingleQuote = false;
		var ignoreCount = 0;
		for (var i=0; i<inStr.length; i++) {

            // read each character ...
            var chartAtI = inStr.charAt(i);
            if (chartAtI == "\"") {
                meetDoubleQuote = !meetDoubleQuote;
            } if (chartAtI == "'") {
                meetSingleQuote = !meetSingleQuote;
            }  else if (chartAtI == "[" || chartAtI == "{") {
                ignoreCount = ignoreCount + 1;
            } else if (chartAtI == "]" || chartAtI == "}") {
                ignoreCount = ignoreCount - 1;
            } 
            
            if (!meetDoubleQuote && !meetSingleQuote && ignoreCount == 0  
            		&& (chartAtI == "*" || chartAtI == "/") ) { 
        		operator = chartAtI;
                remindItem = inStr.substring(i+1);
                break;
            }
            firstItem = firstItem.concat(chartAtI);
		}
		
		// add condition ...
		if (remindItem == null) return result;
		
		// ok, we need check firstItem then ----------------------------- 
		var firstPartSepPos = 0;
		var countParenthese = 0;
		for (var i=firstItem.length; i>0; i--) {
			var chartAtI = firstItem.charAt(i-1);
			
			if (chartAtI == "(" && countParenthese == 0) {
			    firstPartSepPos = i;
			    break;
			}
			
			// check to see whether it meet , and > < = .... NEED do more test
			if ((chartAtI == "," || chartAtI == "=" || chartAtI == ">" || chartAtI == "<" || chartAtI == "+" || chartAtI == "-") && countParenthese == 0) {
			    firstPartSepPos = i;
			    break;
			}
			
			if (chartAtI == ")") countParenthese = countParenthese + 1;
			else if (chartAtI == "(") countParenthese = countParenthese - 1;		
			operatorPart1 = chartAtI + operatorPart1;
		}
		
		if (firstPartSepPos == 0) firstItem = "";
		else {
			firstItem = firstItem.substring(0, firstPartSepPos);
		}
		
		// do a check first 
		operatorPart1 = this.strTrim(operatorPart1);
		if (operatorPart1.length == 0) return result;
		
		// ok, we need check remindItem then ----------------------------- 
		countParenthese = 0;
		var secondPartSepPos = 0;
		for (var i=0; i<remindItem.length; i++) {
			var chartAtI = remindItem.charAt(i);
			
			if (chartAtI == ")" && countParenthese == 0) {
			    secondPartSepPos = i;
			    break;
			}
			
			// check to see whether it meet , 
			if ((chartAtI == "," || chartAtI == "=" || chartAtI == ">" || chartAtI == "<" || chartAtI == "+" || chartAtI == "-") 
					&& countParenthese == 0) {
			    // need handle special case =a1*-1 
				if (i == 0 && (chartAtI == "-" || chartAtI == "+")) {
					operatorPart2 = operatorPart2.concat(chartAtI);
					continue;
				} else {
					secondPartSepPos = i;
				    break;
				}
			}
			
			// check to see whether it meet , 
			if ((chartAtI == "*" || chartAtI == "/" ) && countParenthese == 0) {
			    secondPartSepPos = i;
			    break;
			}
			
			if (chartAtI == "(") countParenthese = countParenthese + 1;
			else if (chartAtI == ")") countParenthese = countParenthese - 1;		
			operatorPart2 = operatorPart2.concat(chartAtI);
		}
		
		if (secondPartSepPos == 0) remindItem = "";
		else {
			remindItem = remindItem.substring(secondPartSepPos);
		}
    	
		// trim first ...
		operatorPart2 = this.strTrim(operatorPart2);
		if (operatorPart2.length > 0) {
			// if operatorPart1 and operatorPart2 both are number - ignore it ...
			if (Ext.isNumber(Number(operatorPart1)) && Ext.isNumber(Number(operatorPart2))) return result;
			if (operator == "*") result = "=" + firstItem + "overwritemultiple(" + operatorPart1 + "," + operatorPart2+")"+remindItem;
			else if (operator == "/") result = "=" + firstItem + "overwritedivide(" + operatorPart1 + "," + operatorPart2+")"+remindItem;

			// recursive call remindItem ....
			return this.convertMulDiv(result);
		} 
		
		return result;
    },
    
    /**
     * @ public
     * This is the method to convert power to function
     *   case 1: =1.1^5
     *   case 2: =(1+3%)^5
     *   case 3: =(1+3%)^(1+2)
     *   case 4: =2*3^2+1
     *   case 5: =2^2^3
     *   case 6: =2+(1+A1)^(b1+3)*2+2
     *   case 7: =2+(2^2)-5
     *   caee 8: =2+2+2^3
     *   
     * @param {String} - power number
     */
	convertPower : function(inStr) {	
		var result = inStr;  // if anything wrong, just return original inStr
    	
    	// check whether it start with =
		if (this.startWith(inStr, "="))  inStr = inStr.substring(1, inStr.length);	

        var firstItem = "";
        var operator = null;
        var remindItem = null;
        var operatorPart1 = "";
        var operatorPart2 = "";
        
        // check cases: " double quote, { bracket, ( parentheses, [
        var meetDoubleQuote = false;
        var meetSingleQuote = false;
		var ignoreCount = 0;
		for (var i=0; i<inStr.length; i++) {

            // read each character ...
            var chartAtI = inStr.charAt(i);
            if (chartAtI == "\"") {
                meetDoubleQuote = !meetDoubleQuote;
            } if (chartAtI == "'") {
                meetSingleQuote = !meetSingleQuote;
            }  else if (chartAtI == "[" || chartAtI == "{") {
                ignoreCount = ignoreCount + 1;
            } else if (chartAtI == "]" || chartAtI == "}") {
                ignoreCount = ignoreCount - 1;
            } 
            
            if (!meetDoubleQuote && !meetSingleQuote && ignoreCount == 0  
            		&& chartAtI == "^"  ) { 
        		operator = chartAtI;
                remindItem = inStr.substring(i+1);
                break;
            }
            firstItem = firstItem.concat(chartAtI);
		}
		
		// add condition ...
		if (remindItem == null) return result;
		
		// ok, we need check firstItem then ----------------------------- 
		var firstPartSepPos = 0;
		var countParenthese = 0;
		for (var i=firstItem.length; i>0; i--) {
			var chartAtI = firstItem.charAt(i-1);
			
			if (chartAtI == "(" && countParenthese == 0) {
			    firstPartSepPos = i;
			    break;
			}
			
			// check to see whether it meet , and > < = .... NEED do more test
			if ((chartAtI == "," || chartAtI == "=" || chartAtI == ">" || chartAtI == "<" 
				|| chartAtI == "+" || chartAtI == "-" || chartAtI == "*" || chartAtI == "/" ) && countParenthese == 0) {
			    firstPartSepPos = i;
			    break;
			}
			
			if (chartAtI == ")") countParenthese = countParenthese + 1;
			else if (chartAtI == "(") countParenthese = countParenthese - 1;		
			operatorPart1 = chartAtI + operatorPart1;
		}
		
		if (firstPartSepPos == 0) firstItem = "";
		else {
			firstItem = firstItem.substring(0, firstPartSepPos);
		}
		
		// do a check first 
		operatorPart1 = this.strTrim(operatorPart1);
		if (operatorPart1.length == 0) return result;
		
		// ok, we need check remindItem then ----------------------------- 
		countParenthese = 0;
		var secondPartSepPos = 0;
		for (var i=0; i<remindItem.length; i++) {
			var chartAtI = remindItem.charAt(i);
			
			if (chartAtI == ")" && countParenthese == 0) {
			    secondPartSepPos = i;
			    break;
			}
			
			// check to see whether it meet , 
			if ((chartAtI == "," || chartAtI == "=" || chartAtI == ">" || chartAtI == "<"
				|| chartAtI == "+" || chartAtI == "-" || chartAtI == "*" || chartAtI == "/") && countParenthese == 0) {
			    secondPartSepPos = i;
			    break;
			}
			
			// check to see whether it meet , 
			if ( chartAtI == "^" && countParenthese == 0) {
			    secondPartSepPos = i;
			    break;
			}
			
			if (chartAtI == "(") countParenthese = countParenthese + 1;
			else if (chartAtI == ")") countParenthese = countParenthese - 1;		
			operatorPart2 = operatorPart2.concat(chartAtI);
		}
		
		if (secondPartSepPos == 0) remindItem = "";
		else {
			remindItem = remindItem.substring(secondPartSepPos);
		}
    	
		// trim first ...
		operatorPart2 = this.strTrim(operatorPart2);
		if (operatorPart2.length > 0) {
			if (operator == "^") result = "=" + firstItem + "power(" + operatorPart1 + "," + operatorPart2+")"+remindItem;

			// recursive call remindItem ....
			return this.convertPower(result);
		} 
		
		return result;
	},
	
	/**
	 * this is private function -- TODO the above 3 method are same logic. 
	 * Get common part and put in here ....
	 */
	__checkFirstPart : function() {
		
	},
	
	__checkSecondPart : function() {
		
	},
    
    // ===============================================================================================================
    
    /**
     * this function will convert the following example:
     *     A1:D5>=2 => overwritecondition(A1:D5, ">=", 2);
     *  @ {inStr} - in string
     *  @ {overwriteFnName} - 
     *  @ {needRemoveParenthese} - true or empty ...
     */
    convertCondition : function(inStr, overwriteFnName, needRemoveParenthese) {   	
    	var result = inStr;  // if anything wrong, just return original inStr
    	
    	// check whether it start with =
    	var firstChar = "";
		if (this.startWith(inStr, "=")) {
			inStr = inStr.substring(1, inStr.length);	
			firstChar = "=";
		}
        
        var firstItem = "";
        var operator = null;
        var remindItem = null;
        var operatorPart1 = "";
        var operatorPart2 = "";
        
        // check cases: " double quote, { bracket, ( parentheses, [
        var meetDoubleQuote = false;
        var meetSingleQuote = false;
		var ignoreCount = 0, strLen = inStr.length;
		for (var i=0; i<strLen; i++) {

            // read each character ...
            var chartAtI = inStr.charAt(i);
            if (chartAtI == "\"") {
                meetDoubleQuote = !meetDoubleQuote;
            } if (chartAtI == "'") {
                meetSingleQuote = !meetSingleQuote;
            }  else if (chartAtI == "[" || chartAtI == "{") {
                ignoreCount = ignoreCount + 1;
            } else if (chartAtI == "]" || chartAtI == "}") {
                ignoreCount = ignoreCount - 1;
            } 
            
            if (!meetDoubleQuote && !meetSingleQuote && ignoreCount == 0 && 
            		(chartAtI == ">" || chartAtI == "<" || chartAtI == "=") ) { // meet double quote
        		operator = chartAtI;
        		// check next item whether it is still > < =
        		if (strLen > i) {
        		    var nextChart = inStr.charAt(i+1);
        		    if (nextChart == ">" || nextChart == "<" || nextChart == "=") {
        		    	operator += nextChart;
        		    	i += 1;
        		    }
        		}
        		
                remindItem = inStr.substring(i+1);
                break;
            }
            firstItem = firstItem.concat(chartAtI);
		}
		
		// add condition ...
		if (remindItem == null) return result;
		
		// ok, we need check firstItem then ----------------------------- 
		var firstPartSepPos = 0;
		var countParenthese = 0;
		for (var i=firstItem.length; i>0; i--) {
			var chartAtI = firstItem.charAt(i-1);
			
			if (chartAtI == "(" && countParenthese == 0) {
			    firstPartSepPos = i;
			    break;
			}
			
			// check to see whether it meet , 
			if (chartAtI == "," && countParenthese == 0) {
			    firstPartSepPos = i;
			    break;
			}
			
			if (chartAtI == ")") countParenthese = countParenthese + 1;
			else if (chartAtI == "(") countParenthese = countParenthese - 1;		
			operatorPart1 = chartAtI + operatorPart1;
		}
		
		if (firstPartSepPos == 0) firstItem = "";
		else {
			firstItem = firstItem.substring(0, firstPartSepPos);
			//firstItem = firstItem.replace("(", "[");
		}
		
		// do a check first 
		operatorPart1 = this.strTrim(operatorPart1);
		if (operatorPart1.length == 0) return result;
		
		// ok, we need check remindItem then ----------------------------- 
		countParenthese = 0;
		var secondPartSepPos = 0;
		for (var i=0; i<remindItem.length; i++) {
			var chartAtI = remindItem.charAt(i);
			
			if (chartAtI == ")" && countParenthese == 0) {
			    secondPartSepPos = i;
			    break;
			}
			
			// check to see whether it meet , 
			if (chartAtI == "," && countParenthese == 0) {
			    secondPartSepPos = i;
			    break;
			}
			
			// check to see whether it meet , 
			if ((chartAtI == ">" || chartAtI == "<" || chartAtI == "=" ) && countParenthese == 0) {
			    secondPartSepPos = i;
			    break;
			}
			
			if (chartAtI == "(") countParenthese = countParenthese + 1;
			else if (chartAtI == ")") countParenthese = countParenthese - 1;		
			operatorPart2 = operatorPart2.concat(chartAtI);
		}
		
		if (secondPartSepPos == 0) remindItem = "";
		else {
			remindItem = remindItem.substring(secondPartSepPos);
			//remindItem = remindItem.replace(")", "]");
		}
    	
		// trim first ...
		operatorPart2 = this.strTrim(operatorPart2);
		if (operatorPart2.length > 0) {
			if (operator) {
				// ok we need do extra step for case ... remvoe () and replace * with ,
				// *(a1:a2>6) -> ,overwritecondition(a1:a2, ">", 6)
				// this is special case ....
				if (needRemoveParenthese && remindItem.charAt(0) == ")" && firstItem.slice(-1) == "(") {
					remindItem = remindItem.substr(1);
					firstItem = firstItem.slice(0, -1);
					if (firstItem.slice(-1) == "*") firstItem = firstItem.slice(0, -1) + ",";
				}
				
				result = firstChar + firstItem + overwriteFnName + "(" + operatorPart1 + ",'" + operator + "'," + operatorPart2+")"+remindItem;
			}
			else return inStr;
	
			// recursive call remindItem ....
			return this.convertCondition(result, overwriteFnName, needRemoveParenthese);
		} 
		
		return result;
    },
    
    // such as: =text("date", fm) & " per hour"
    // not this: SUMIF(G299:G304, ">" & H299)
    convertAndSymbol : function(inStr, checkParenthese) {   	
    	var result = inStr;  // if anything wrong, just return original inStr
    	
    	// check whether it start with =
		if (this.startWith(inStr, "="))  inStr = inStr.substring(1, inStr.length);	
        if (checkParenthese) inStr = HELPER.removeParentheses(inStr); // trim and remove parentheses if any ...
        
        var firstItem = "";
        var remindItem = null;
        var operatorPart1 = "";
        var operatorPart2 = "";
        
        // check cases: " double quote, { bracket, ( parentheses, [
        var meetDoubleQuote = false;
        var meetSingleQuote = false;
		var ignoreCount = 0;
		for (var i=0; i<inStr.length; i++) {
            var chartAtI = inStr.charAt(i);
            if (chartAtI == "\"") {
                meetDoubleQuote = !meetDoubleQuote;
            } else if ( !meetDoubleQuote && (chartAtI == "[" || chartAtI == "{")) {
                ignoreCount = ignoreCount + 1;
            } else if ( !meetDoubleQuote && (chartAtI == "]" || chartAtI == "}")) {
                ignoreCount = ignoreCount - 1;
            } 
            
            if (!meetDoubleQuote && ignoreCount == 0 && chartAtI == "&" ) { // meet &
                remindItem = inStr.substring(i+1);
                break;
            }
            firstItem = firstItem.concat(chartAtI);
		}
		
		// add condition ...
		if (remindItem == null) return result;
		
		// ok, we need check firstItem then ----------------------------- 
		var firstPartSepPos = 0, countParenthese = 0;
		meetDoubleQuote = false;
		
		for (var i=firstItem.length; i>0; i--) {
			var chartAtI = firstItem.charAt(i-1);
			
			if (chartAtI == "\"")  meetDoubleQuote = !meetDoubleQuote;	
			else if (!meetDoubleQuote && chartAtI == "(" && countParenthese == 0) {
			    firstPartSepPos = i;
			    break;
			}
			
			// check to see whether it meet , 
			if (!meetDoubleQuote && chartAtI == "," && countParenthese == 0) {
			    firstPartSepPos = i;
			    break;
			}
			
			if (!meetDoubleQuote && chartAtI == ")") countParenthese = countParenthese + 1;
			else if (!meetDoubleQuote && chartAtI == "(") countParenthese = countParenthese - 1;		
			operatorPart1 = chartAtI + operatorPart1;
		}
		
		if (firstPartSepPos == 0) firstItem = "";
		else  firstItem = firstItem.substring(0, firstPartSepPos);
		
		// do a check first 
		operatorPart1 = this.strTrim(operatorPart1);
		if (operatorPart1.length == 0) return result;
		
		// ok, we need check remindItem then ----------------------------- 
		countParenthese = 0;
		var secondPartSepPos = 0;
		for (var i=0; i<remindItem.length; i++) {
			var chartAtI = remindItem.charAt(i);
			
			if (chartAtI == "\"")  meetDoubleQuote = !meetDoubleQuote;
			else if (!meetDoubleQuote && chartAtI == ")" && countParenthese == 0) {
			    secondPartSepPos = i;
			    break;
			}
			
			// check to see whether it meet , 
			if (!meetDoubleQuote && chartAtI == "," && countParenthese == 0) {
			    secondPartSepPos = i;
			    break;
			}
			
			// check to see whether it meet , 
			if (!meetDoubleQuote && chartAtI == "&"  && countParenthese == 0) {
			    secondPartSepPos = i;
			    break;
			}
			
			if (!meetDoubleQuote && chartAtI == "(") countParenthese = countParenthese + 1;
			else if (!meetDoubleQuote && chartAtI == ")") countParenthese = countParenthese - 1;		
			operatorPart2 = operatorPart2.concat(chartAtI);
		}
		
		if (secondPartSepPos == 0) remindItem = "";
		else {
			remindItem = remindItem.substring(secondPartSepPos);
		}
    	
		// trim first ...
		operatorPart2 = this.strTrim(operatorPart2);
		if (operatorPart2.length > 0) {
			result = "=" + firstItem + "overwriteAnd(" + operatorPart1 + "," + operatorPart2+")"+remindItem;		
			// recursive call remindItem ....
			if (remindItem && remindItem.indexOf("&") != -1) return this.convertAndSymbol(result, false);
		} 
		
		return result;     
    },
    
    fromToUnitData : [
	   // WEIGHT AND MASS               
	   ['g', 'weightAndMass', 1],
	   ['sg', 'weightAndMass', 14593.90294],
	   ['lbm', 'weightAndMass', 453.59237],
	   ['u', 'weightAndMass', 1.66053E-24],
	   ['ozm', 'weightAndMass', 28.349523125],
	   // DISTANCE
	   ['m', 'distance', 1],
	   ['mi', 'distance', 1609.344],
	   ['Nmi', 'distance', 1852],
	   ['in', 'distance', 0.0254],
	   ['ft', 'distance', 0.3048],
	   ['yd', 'distance', 0.9144],
	   ['ang', 'distance', 1E-10],
	   ['Pica', 'distance', 0.000352778],
	   // Time
	   ['yr', 'time', 31557600],
	   ['day', 'time', 86400],
	   ['hr', 'time', 3600],
	   ['mn', 'time', 60],
	   ['sec', 'time', 1],
	   // PRESSURE
	   ['Pa', 'pressure', 1],
	   ['p', 'pressure', 1],
	   ['at', 'pressure', 101325],
	   ['atm', 'pressure', 101325],
	   ['mmHg', 'pressure', 133.3223684],
	   // FORCE
	   ['N', 'force', 1],
	   ['dyn', 'force', 0.00001],
	   ['dy', 'force', 0.00001],
	   ['lbf', 'force', 4.448221615],
	   // ENERGY
	   ['J', 'energy', 1],
	   ['e', 'energy', 0.0000001],
	   ['c', 'energy', 4.184],
	   ['cal', 'energy', 4.1868],
	   ['ev', 'energy', 1.60219e-19],
	   ['eV', 'energy', 1.60219e-19],
	   ['HPh', 'energy', 2684519.5368856],
	   ['hh', 'energy', 2684519.538],
	   ['Wh', 'energy', 3600],
	   ['wh', 'energy', 3600],
	   ['flb', 'energy', 1.355817948],
	   ['btu', 'energy', 1055.055853],
	   ['BTU', 'energy', 1055.055853],
	   // POWER
	   ['HP', 'power', 745.6998716],
	   ['h', 'power', 745.6998716],
	   ['W', 'power', 1],
	   ['w', 'power', 1],
	   // MAGNETISM
	   ['T', 'magnetism', 10000],
	   ['ga', 'magnetism', 1],
	   // TEMPERATURE - ok, this is not right ...some format here ... ???
	   ['C', 'temperature', 1],
	   ['cel', 'temperature', 1],
	   ['F', 'temperature', 33.8],
	   ['fah', 'temperature', 33.8],
	   ['K', 'temperature', 274.15],
	   ['kel', 'temperature', 274.15],
	   // LIQUID MEASURE
	   ['tsp', 'liquidMeasure', 1],
	   ['tbs', 'liquidMeasure', 3],
	   ['oz', 'liquidMeasure', 6],
	   ['cup', 'liquidMeasure', 48],
	   ['pt', 'liquidMeasure', 96],
	   ['us_pt', 'liquidMeasure', 96],
	   ['uk_pt', 'liquidMeasure', 96],
	   ['qt', 'liquidMeasure', 192],
	   ['gal', 'liquidMeasure', 768],
	   ['l', 'liquidMeasure', 202.8841362],
	   ['lt', 'liquidMeasure', 202.8841362]	   
	],
	
	getGDA : function(cost, remindVal, endVal, period, factor) {
        var result, costVal, startVal, tempVal = factor / endVal;
        if (tempVal >= 1) {
            tempVal = 1;
            if (period === 1) costVal = cost;
            else  costVal = 0;
        } else  
        	costVal = cost * Math.pow(1 - tempVal, period - 1);

        startVal = cost * Math.pow(1 - tempVal, period);
        if (startVal < remindVal)  result = costVal - remindVal;
        else result = costVal - startVal;
        if (result < 0)  result = 0;
        return result;
    },
	
	getVDB : function(cost, salvage, life, life1, period, factor) {
		var result = 0, endPeriod = Math.ceil(period);
        var termVal, tempVal = 0, iCost = cost - salvage, judge = false, gdaVal = 0;
        for (var i = 1; i <= endPeriod; i++) {
            if (!judge) {
                gdaVal = HELPER.getGDA(cost, salvage, life, i, factor);
                tempVal = iCost / (life1 - (i - 1));
                if (tempVal > gdaVal) {
                    termVal = tempVal;
                    judge = true;
                } else {
                    termVal = gdaVal;
                    iCost -= gdaVal;
                }
            } else termVal = tempVal;
            
            if (i === endPeriod) termVal *= (period + 1 - endPeriod);
            result += termVal;
        }        
        return result;
	},
	
	// Copyright (c) 2012 Sutoiku, Inc.
    // Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
    // The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	IMREAL : function(inumber) {
	  // Return 0 if inumber is equal to 0
	  if (inumber === 0 || inumber === '0') return 0;
	 
	  // Handle special cases
	  if (['i', '+i', '1i', '+1i', '-i', '-1i', 'j', '+j', '1j', '+1j', '-j', '-1j'].indexOf(inumber) >= 0) return 0;
	 
	  // Lookup sign
	  var plus = inumber.indexOf('+');
	  var minus = inumber.indexOf('-');
	  if (plus === 0) plus = inumber.indexOf('+', 1);
	  if (minus === 0) minus = inumber.indexOf('-', 1);
	  
	  // Lookup imaginary unit
	  var last = inumber.substring(inumber.length - 1, inumber.length);
	  var unit = (last === 'i' || last === 'j');
	  
	  if (plus >= 0 || minus >= 0) {
	    // Return error if imaginary unit is neither i nor j
	    if (!unit) '#NUM!';
	 
	    // Return real coefficient of complex number
	    if (plus >= 0) {
	      return (isNaN(inumber.substring(0, plus)) || isNaN(inumber.substring(plus + 1, inumber.length - 1))) ?
	        '#NUM!' :
	        Number(inumber.substring(0, plus));
	    } else {
	      return (isNaN(inumber.substring(0, minus)) || isNaN(inumber.substring(minus + 1, inumber.length - 1))) ?
	        '#NUM!' :
	        Number(inumber.substring(0, minus));
	    }
	  } else {
	    if (unit) {
	      return (isNaN(inumber.substring(0, inumber.length - 1))) ? '#NUM!' : 0;
	    } else {
	      return (isNaN(inumber)) ? '#NUM!' : Number(inumber);
	    }
	  }
	},
	
	// Copyright (c) 2012 Sutoiku, Inc.
    // Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
    // The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	IMAGINARY : function(inumber) {
		  // Return 0 if inumber is equal to 0
		  if (inumber === 0 || inumber === '0') return 0;
		 
		  // Handle special cases
		  if (['i', 'j'].indexOf(inumber) >= 0) return 1;
		  
		  // Normalize imaginary coefficient
		  inumber = inumber.replace('+i', '+1i').replace('-i', '-1i').replace('+j', '+1j').replace('-j', '-1j');
		  
		  // Lookup sign
		  var plus = inumber.indexOf('+');
		  var minus = inumber.indexOf('-');
		  if (plus === 0) plus = inumber.indexOf('+', 1);
		  if (minus === 0) minus = inumber.indexOf('-', 1);
		  
		  // Lookup imaginary unit
		  var last = inumber.substring(inumber.length - 1, inumber.length);
		  var unit = (last === 'i' || last === 'j');
		  
		  if (plus >= 0 || minus >= 0) {
		    // Return error if imaginary unit is neither i nor j
		    if (!unit) throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'IMAGINARY' };
		 
		    // Return imaginary coefficient of complex number
		    if (plus >= 0) {
		      return (isNaN(inumber.substring(0, plus)) || isNaN(inumber.substring(plus + 1, inumber.length - 1))) ?
		        '#NUM!' :
		        Number(inumber.substring(plus + 1, inumber.length - 1));
		    } else {
		      return (isNaN(inumber.substring(0, minus)) || isNaN(inumber.substring(minus + 1, inumber.length - 1))) ?
		        '#NUM!' :
		        -Number(inumber.substring(minus + 1, inumber.length - 1));
		    }
		  } else {
		    if (unit) {
		      return (isNaN(inumber.substring(0, inumber.length - 1))) ? '#NUM!' : inumber.substring(0, inumber.length - 1);
		    } else {
		      return (isNaN(inumber)) ? '#NUM!' : 0;
		    }
		  }
	},
	
	// Copyright (c) 2012 Sutoiku, Inc.
    // Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
    // The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    // Some algorithms have been ported from Apache OpenOffice:
	IMARGUMENT : function(inumber) {
		var x = HELPER.IMREAL(inumber);
		var y = HELPER.IMAGINARY(inumber);
		 
		// Return error if either coefficient is not a number
		if (x === '#NUM!' || y === '#NUM!') return '#NUM!';
		 
		// Return error if inumber is equal to zero
		if (x === 0 && y === 0) throw { code: 'SS_ERROR_INFINITY', cal: 'IMARGUMENT' };
		  
		// Return PI/2 if x is equal to zero and y is positive
		if (x === 0 && y > 0) return Math.PI / 2;
		 
		// Return -PI/2 if x is equal to zero and y is negative
		if (x === 0 && y < 0) return -Math.PI / 2;
		 
		// Return zero if x is negative and y is equal to zero
		if (y === 0 && x > 0) return 0;
		 
		// Return zero if x is negative and y is equal to zero
		if (y === 0 && x < 0) return -Math.PI;
		  
		// Return argument of complex number
		if (x > 0) {
		    return Math.atan(y / x);
		} else if (x < 0 && y >= 0) {
		    return Math.atan(y / x) + Math.PI;
		} else {
		    return Math.atan(y / x) - Math.PI;
		}
	},
	
	// Copyright (c) 2012 Sutoiku, Inc.
    // Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
    // The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    // Some algorithms have been ported from Apache OpenOffice:
	IMDIV : function(inumber1, inumber2) {
		  var a = HELPER.IMREAL(inumber1);
		  var b = HELPER.IMAGINARY(inumber1);
		  var c = HELPER.IMREAL(inumber2);
		  var d = HELPER.IMAGINARY(inumber2);
		  
		  // Lookup imaginary unit
		  var unit1 = inumber1.substring(inumber1.length - 1);
		  var unit2 = inumber1.substring(inumber1.length - 1);
		  var unit = 'i';
		  if (unit1 === 'j') {
		    unit = 'j';
		  } else if (unit2 === 'j') {
		    unit = 'j';
		  }
		 
		  // Return error if either coefficient is not a number
		  if (a === '#NUM!' || b === '#NUM!' || c === '#NUM!' || d === '#NUM!') return '#NUM!';
		 
		  // Return error if inumber2 is null
		  if (c === 0 && d === 0) return '#NUM!';
		 
		  // Return exponential of complex number
		  var den = c * c + d * d;
		  return HELPER.COMPLEX((a * c + b * d) / den, (b * c - a * d) / den, unit);
	},
	
    COMPLEX : function(real, imaginary, suffix) {
		  // Return error if either number is a non-numeric value
		  if (isNaN(real) || isNaN(imaginary)) throw { code: 'VALUE_NOT_AVAILABLE', cal: 'COMPLEX' };
		 
		  // Set suffix
		  var suffix = (typeof suffix === 'undefined') ? 'i' : suffix;
		 
		  // Return error if suffix is neither "i" nor "j"
		  if (suffix !== 'i' && suffix !== 'j') throw { code: 'VALUE_NOT_AVAILABLE', cal: 'COMPLEX' };
		 
		  // Return complex number
		  if (real === 0 && imaginary === 0) {
		      return 0;
		  } else if (real === 0) {
			  var digitalLen = HELPER.getDigitalLen(imaginary);
		      if (digitalLen > 13) imaginary = HELPER.roundUpNonZero(imaginary);
		      return (imaginary === 1) ? suffix : imaginary.toString() + suffix;
		  } else if (imaginary === 0) {			  
			  var digitalLen = HELPER.getDigitalLen(real);
		      if (digitalLen > 13) real = HELPER.roundUpNonZero(real);
			  
		      return real.toString();
		  } else {		  
			  var digitalLen = HELPER.getDigitalLen(real);
		      if (digitalLen > 13) real = HELPER.roundUpNonZero(real);	      
		      digitalLen = HELPER.getDigitalLen(imaginary);
		      if (digitalLen > 13) imaginary = HELPER.roundUpNonZero(imaginary);
			  
		      var sign = (imaginary > 0) ? '+' : '';
		      return real.toString() + sign + ((imaginary === 1) ? suffix : imaginary.toString() + suffix);
		  }
	},
	
	// =========================================================================================================
	/**
	 * this is used to convert if condition. = if(fn, result1, result2)
     * result1 and result2 can be error result with exception, we need handle it special ...
     * -> =if(fn, function(){return (result1)}, function(){return (result2)})
     */
	convertIftruefalseCdt : function(inputFormula) { // ignore if it is countif, averageif, sumif
		var paras = HELPER.getFormulaParas(inputFormula, "if");
		// parse the parameters and separate them by comma ,
		
		var itemPart1 = null, itemPart2 = null, itemPart3 = null, temp = "", totalComma = 0;
		var meetDoubleQuote = false, meetSingleQuote = false;
		var ignoreCount = 0, strLen = paras.length;
		for (var i=0; i<strLen; i++) {
			var chartAtI = paras.charAt(i);
            if (chartAtI == "\"") meetDoubleQuote = !meetDoubleQuote;
            else if (chartAtI == "'")  meetSingleQuote = !meetSingleQuote;
            else if (chartAtI == "[" || chartAtI == "{" || chartAtI == "(") ignoreCount = ignoreCount + 1;
            else if (chartAtI == "]" || chartAtI == "}" || chartAtI == ")") ignoreCount = ignoreCount - 1;
            
            if (ignoreCount == 0 && !meetDoubleQuote && !meetSingleQuote && chartAtI == ",") {
            	if (itemPart1 == null) itemPart1 = temp;
            	else if (itemPart2 == null) itemPart2 = temp;
            	else if (itemPart3 == null) itemPart3 = temp;          	
            	temp = "";
            	totalComma++;
            } else         
                temp = temp.concat(chartAtI);
		}
		
		if (totalComma > 2) return inputFormula; // something wrong, just return original string ...
		
		if (itemPart2 == null) itemPart2 = temp;
		else if (itemPart3 == null) itemPart3 = temp;
		
		if (itemPart2 != null && !Ext.isNumber(itemPart2))  itemPart2 = "function() {return (" + itemPart2 + ")}";
		if (itemPart3 != null && !Ext.isNumber(itemPart3))  itemPart3 = "function() {return (" + itemPart3 + ")}";
		
		// we need do more for condition part ...itemPart1
		//if (HELPER.isExpressFn(itemPart1)) {
		//	itemPart1 = HELPER.convertCondition(itemPart1, "overwriteCompareCond");
		//}
		
		var replacedParas = itemPart1 + "," + itemPart2 + "," + itemPart3;
		return inputFormula.replace(paras, replacedParas);
	},
	
	// =========================================================================================================
	
	/**
	 * this is the process to convert condition ... for example:
	 *    =SUMPRODUCT((B2:B11*C2:C11)*(D2:D11>3)) 
     * Condition need to be changed to: 
     *    D2:D11>3 -> overwritecondition(D2:D11, ">", 3);
	 */
	convertFormulaCondition : function(inStr, formulaname) {		
		// first get sumproduct ... and related parameters ...
		var paras = HELPER.getFormulaParas(inStr, formulaname);		
		var newParas = HELPER.convertCondition(paras, "overwriteArrCompareCond", true);
		return inStr.replace(paras, newParas);
	},
	
	/**
	 * This is the method to get parameter from formula inside ...
	 */
	getFormulaParas : function(inStr, formulaName) {
		var result = "";
		var parts = inStr.toLowerCase().split(formulaName + '(');
		var len = parts[0].length + formulaName.length + 1;
		
		var countParenthese = 0; // check to see whether meet ")"
		for (var i=len; i<inStr.length; i++) {
			var chartAtI = inStr.charAt(i);		
			if (chartAtI == ")")  {
				if (countParenthese == 0) return result;
			    else countParenthese -= 1;
			} else if (chartAtI == "(")  countParenthese += 1;
			result = result + chartAtI;
		}
		
		return null;
	},
	 
	/**
	 * calculate condition for cell - and return array ...
	 */
	checkConditionForArr : function(conditionAllowedColumns, conditionArr, condition) {
		if (conditionAllowedColumns == null) conditionAllowedColumns = [];
		
		return conditionAllowedColumns;
	},
	
	/**
	 * this will pass a array of two dimension arry and return back sumproduct 
	 * 
	 * [ [[A1,A2,A3], [B1,B2,B3]], [[C1], [C2]], [[D1], [D2]] ]
	 */
	getSumProduct : function(list2DimArr, formulaName) {
		// calculate now ...
		var basicLen = list2DimArr[0].length, maxColumn = list2DimArr[0][0].length;
		var columnArrayLength = [maxColumn]; // this will save the max column size of each array ...
		for ( var m = 1; m < list2DimArr.length; m++) {
			if ((list2DimArr[m]).length != basicLen) {
				list2DimArr = [];
				throw {code: 'CAL_NO_VALUE', cal: formulaName };
			}
			var temp = list2DimArr[m][0].length;
			if (maxColumn < temp) maxColumn = temp;
			columnArrayLength.push(temp);
		}
		
		var total = 0;
		
		// LOOP column first ... 
		for (var k = 0; k<maxColumn; k++) {
			
			// loop each item ..
			for ( var i = 0; i < list2DimArr[0].length; i++ ) {
				var result = 1;
				for ( var j = 0; j < list2DimArr.length; j++ ) {
					// we need check to see whether this is > columnArrayLength
					var tempVal, maxItemLen = columnArrayLength[j];
					if (k < maxItemLen) tempVal = list2DimArr[j][i][k];
					else tempVal = list2DimArr[j][i][maxItemLen-1];
					
					// if it is boolean .... set as zero ...
					if (HELPER.isBoolean(tempVal)) tempVal = 0;
					// if it is empty ...
					var num = Number(tempVal);			
					if (tempVal === undefined) { // any item is undefined, forget this loop now
						result = 0;
						break;
					} else {
						if (!Ext.isNumber(num)) throw {code: 'CAL_NO_VALUE', cal: formulaName };
						result *= num;
					}
				}
				total += result;
			}			
		}
		
		return total;
	},
	
	/**
	 * This method is used to get the value from cache. It not existing, return null.
	 * Max is 10 items. 
	 * This cache is a list of key, value (array) item.
	 */
	getValueFromCache : function(key) {
		if(typeof SCONST.GOLBAL_CACHE_KEY_10 === 'undefined') return null;	
		
		for (var i=0; i<SCONST.GOLBAL_CACHE_KEY_10.length; i++) {
			if(key === SCONST.GOLBAL_CACHE_KEY_10[i]) {
				var temp = SCONST.GOLBAL_CACHE_LIST_10[i];
				return Ext.decode(temp);
			}
		}
		
		return null;
	},
	
	/**
	 * Currently we set this as 50 cache. Too small is not that useful ...
	 * I do not know whether we need clean it. 
	 * @TODO - need be careful due to performance issues.
	 */
	addValueToCache : function(key, items) {
		for (var i=0; i<SCONST.GOLBAL_CACHE_KEY_10.length; i++) {
			var temp = SCONST.GOLBAL_CACHE_KEY_10[i];
			if (temp == key) return;
		}
		
		if (items && Ext.isArray(items) && items.length > 20) {
			// delete first item ...
			if (SCONST.GOLBAL_CACHE_KEY_10.length > 30) {
				SCONST.GOLBAL_CACHE_KEY_10.splice(0, 1);
				SCONST.GOLBAL_CACHE_LIST_10.splice(0, 1);				
			}
			
			SCONST.GOLBAL_CACHE_KEY_10.push(key);	
			SCONST.GOLBAL_CACHE_LIST_10.push(Ext.encode(items));			
		}
	},
	
                                                                             
    singleArr2ToArr1 : function(arr2){
        var flag = true, arr1 = [];
        for(var i = 0, len = arr2.length; i < len; i++){
            var it = arr2[i];
            if(1 !== it.length || Ext.isArray(it[0])){
                flag = false;
                break;
            }else{
                arr1.push(it[0]);
            }
        }
        if(flag){
            return arr1;
        }else{
            return arr2;
        }
    },
                                                                             
	/**
	 * multiple/add/devide etc 2 array as one array ..
	 */
	cal2ArrsAs1Arr : function(arr1, arr2, calculateMethod) {
		if (arr1.length == 0 || arr2.length == 0 || arr1.length != arr2.length) 
			throw {code: 'CAL_NO_VALUE', cal: 'cal2ArrsAs1Arr'};
		
		var megArr = [];		
		for (var len = 0; len < arr1.length; len++) {
			var val1 = arr1[len], val2 = arr2[len];
			
			if (val1 === undefined || val2 === undefined) { // any item is undefined, forget this loop now
				megArr.push(undefined);
				continue;
			}
			
			// if it is boolean .... set as zero ...
			if (HELPER.isBoolean(val1)) val1 = 0;
			if (HELPER.isBoolean(val2)) val2 = 0;
			
			// if it is empty ...
			var num1 = Number(val1), num2 = Number(val2);			
			if (!Ext.isNumber(num1) || !Ext.isNumber(num2)) throw {code: 'CAL_NO_VALUE', cal:  'cal2ArrsAs1Arr'};
			
			var result = num1 + num2;
			if (calculateMethod == "multiple") result = num1 * num2;
			if (calculateMethod == "divide") result = num1 / num2;
			
			megArr.push(result);
		}
		
		// clean for cache ...
		arr1 = [], arr2 = [];
		
		return megArr;
	},
	
	/**
	 * multiple/add/devide etc two 2-dimension array as one 2-dimension array ..
	 */
	combine2ArrsAs1Arr : function(arr1, arr2, calculateMethod) {
		if (arr1.length == 0 || arr2.length == 0 || arr1.length != arr2.length) 
			throw {code: 'CAL_NO_VALUE', cal: 'combine2ArrsAs1Arr'};
		
		var meg2DimArr = [];
		
		var arr1SubLen = arr1[0].length, arr2SubLen = arr2[0].length;
        if(!Ext.isNumber(arr1SubLen) && !Ext.isNumber(arr2SubLen)){
            
        }
        
		var subArrLen = (arr1SubLen > arr2SubLen) ? arr1SubLen : arr2SubLen;
		
		for (var x = 0, arr1Len = arr1.length; x < arr1Len; x++) {
			var subArray = [];
			for (var y = 0; y < subArrLen; y++) {
				var val1, val2;
				if (arr1SubLen>y) val1 = arr1[x][y];
				else val1 = arr1[x][arr1SubLen-1]
				if (arr2SubLen>y) val2 = arr2[x][y];
				else val2 = arr2[x][arr2SubLen-1]
				
				if (val1 === undefined || val2 === undefined) { // any item is undefined, forget this loop now
					subArray.push(undefined);
					continue;
				}
				
				// if it is boolean .... set as zero ...
				if (HELPER.isBoolean(val1)) val1 = 0;
				if (HELPER.isBoolean(val2)) val2 = 0;
				
				// if it is empty ...
				var num1 = Number(val1), num2 = Number(val2);			
				if (!Ext.isNumber(num1) || !Ext.isNumber(num2)) throw {code: 'CAL_NO_VALUE', cal: 'combine2ArrsAs1Arr'};
				
				var result;
				if (calculateMethod == "multiple") result = num1 * num2;
				else if (calculateMethod == "divide") result = num1 / num2;
				else num1 + num2;
				
				subArray.push(result);
			}
			meg2DimArr.push(subArray);
		}
		
		// clean for cache ...
		arr1 = [], arr2 = [];
		
		return meg2DimArr;
	},
	
	// this is function to compare 2 string ...
	compare2String : function(str1, symbol, str2) {
		var result = str1.localeCompare(str2);
		if (result > 0 && (symbol == ">" || symbol == ">=" || symbol == "!=") ) return true;
		else if (result == 0 && (symbol == "=" || symbol == "==") ) return true;
		else if (result < 0 && (symbol == "<" || symbol == "<=" || symbol == "!=") ) return true;
		return false;
	},
	
	// calculate binom_dist
	calculateBinom : function(x, n, p) {
		var sum1 = 1, sum2 = 1;
		for ( var i = Math.floor(n); i > Math.floor(n) - Math.floor(x); i--)  sum1 = sum1 * i;
		for ( var i = 1; i <= Math.floor(x); i++)  sum2 = sum2 * i;
		var combin = Math.floor(sum1 / sum2);	
		return combin*Math.pow(p, x)*Math.pow((1-p), (n-x));
	},
	
	// add bracket to the science data 2.03e+01 -> (2.03e+01)
	addBracket2ScienceData : function(inStr) {
		var result = inStr.replace(/[0-9.]+e[\+\-][0-9]+/gi, function(w){
			return "(" + w + ")";
		});
		
		return result;
	},
	
	/*
	 * check the passed string is an express or not
	 */
	isExpress : function(str){
		return /^\s*[\!\<\>\=]/gi.test(str);
	},
	
	/*
	 * check the passed string is an express function or not
	 * For example: B2>5
	 */
	isExpressFn : function(str) {	
		return /[\<\>\=]/gi.test(str);
	},
	
	/**
	 * this will get median from array
	 */
	getMedianfromArr : function(arr) {
		var alen = arr.length;
		
		if(2 >= alen){
			var sum = 0;
			for(var i = 0; i < alen; i++){
				sum += arr[i];
			}
			return sum/alen;
		}else{
			arr.sort(function(a, b){
				return a-b;
			});
			if(0 != alen%2){ // this is odd
				var mid = Math.floor(alen/2);		
				return arr[mid];
			}else{
				var mid = Math.floor(alen/2);						
				var sum = (arr[mid]+arr[mid-1])/2;
				return sum;
			}					
		}
	}
	
    
}, function(){
    /*
     * define a global var
     */
    HELPER = EnterpriseSheet.common.Helper;
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.common.FormulaHelper', {

    singleton: true,

    BesselI0  : function(num) {
    	var result, val;
		var absNum = Math.abs(num);
		if (absNum < 3.75) {
			val = num/3.75;
			val == val*val;
			result = 1.0 + val*(3.5156229+val*(3.0899424 + val*(1.2067492+val*(0.2659732+val*(0.360768e-1+val*0.45813e-2)))));
		} else {
			val = 3.75/absNum;
			result = (Math.exp(absNum)/Math.sqrt(absNum))*(0.39894228+val*(0.1328592e-1+val*(0.225319e-2+val*(-0.157565e-2+val*(0.916281e-2+val*(-0.2057706e-1+val*(0.2635537e-1+val*(-0.1647633e-1+val*0.392377e-2))))))));
		}
		return result;
    },
    
    BesselI1 : function(num) {
		var result, val;
		var absNum = Math.abs(num);
		if (absNum < 3.75) {
			val = num/3.75;
			val == val*val;
			var temp = 0.5+val*(0.87890594+val*(0.51498869+val*(0.15084934+val*(0.2658733e-1+val*(0.301532e-2+val*0.32411e-3)))));
			result = absNum*temp;
		} else {
			val = 3.75/absNum;
			result = 0.2282967e-1+val*(-0.2895312e-1+val*(0.1787654e-1-val*0.420059e-2));
			result = 0.39894228+val*(-0.3988024e-1+val*(-0.362018e-2+val*(0.163801e-2+val*(-0.1031555e-1+val*result))));
			result *= (Math.exp(absNum)/Math.sqrt(absNum));
		}
		if (num < 0.0) result = 0 - result;
		return result;
	},
	
	BesselJ0 : function(num) {
		var remain, tempX, val,result,result1,result2;
		var absNum = Math.abs(num);
		if (absNum < 8.0) {
			val = num * num;
			result1 = 57568490574.0 + val * (-13362590354.0 + val * (651619640.7 + val * (-11214424.18 + val * (77392.33017 + val * (-184.9052456)))));
			result2 = 57568490411.0 + val * (1029532985.0 + val * (9494680.718 + val * (59272.64853 + val * (267.8532712 + val * 1.0))));
			result = result1 / result2;
		} else {
			remain = 8.0 / absNum;
			val = remain * remain;
			tempX = absNum - 0.785398164;
			result1 = 1.0 + val * (-0.1098628627e-2 + val * (0.2734510407e-4 + val * (-0.2073370639e-5 + val * 0.2093887211e-6)));
			result2 = -0.1562499995e-1 + val * (0.1430488765e-3 + val * (-0.6911147651e-5 + val * (0.7621095161e-6 - val * 0.934935152e-7)));
			result = Math.sqrt(0.636619772 / absNum) * (Math.cos(tempX) * result1 - remain * Math.sin(tempX) * result2);
		}
		return result;
    },
    
    BesselJ1 : function(num) {
		var absNum,remain,tempX,val,result,result1,result2;
		absNum = Math.abs(num);
		if (absNum < 8.0) {
			val = num*num;
			result1 = num*(72362614232.0+val*(-7895059235.0+val*(242396853.1+val*(-2972611.439+val*(15704.48260+val*(-30.16036606))))));
			result2 = 144725228442.0+val*(2300535178.0+val*(18583304.74+val*(99447.43394+val*(376.9991397+val*1.0))));
			result = result1/result2;
		} else {
			remain = 8.0/absNum;
			val = remain*remain;
			tempX = absNum-2.356194491;
			result1 = 1.0+val*(0.183105e-2+val*(-0.3516396496e-4+val*(0.2457520174e-5+val*(-0.240337019e-6))));
			result2 = 0.04687499995 + val*(-0.2002690873e-3+val*(0.8449199096e-5+val*(-0.88228987e-6+val*0.105787412e-6)));
			result = Math.sqrt(0.636619772/absNum)*(Math.cos(tempX)*result1-remain*Math.sin(tempX)*result2);
			if (num < 0.0) result = 0-result;
		}
		return result;
    },
    
    besseli : function(val, n) {
		var accurateNum = 20.0;	
		var BIGNO = 1.0e10;
		var BIGNI = 1.0e-10;
		var j,bi,bim,bip,tox,result;
		if (val == 0.0) return 0.0;
		else {
			tox=2.0/Math.abs(val);
			bip=result=0.0;
			bi=1.0;
	        for (j=2*(n+Math.floor(Math.sqrt(accurateNum*n)));j>0;j--) {
				bim=bip+j*tox*bi;
				bip=bi;
				bi=bim;
				if (Math.abs(bi) > BIGNO) {
					result *= BIGNI;
					bi *= BIGNI;
					bip *= BIGNI;
				}
				if (j == n) result=bip;
			}
			result *= FORMULA_HELPER.BesselI0(val) / bi;
			if (val < 0.0 && (n & 1)) result = 0 - result;
			return result;
		}
    },
    
    besselj : function(x, n) {
		
		var accurateNum = 20.0;		
		var BIGNO = 1.0e10;
		var BIGNI = 1.0e-10;
		var j,jsum,m,absNum,besselJ,besselJm,besselJp,sum,tox,result;
		absNum=Math.abs(x);
		if (absNum == 0.0) return 0.0;
		else if (absNum > n) {
			tox = 2.0/absNum;
			besselJm= FORMULA_HELPER.BesselJ0(absNum);
			besselJ= FORMULA_HELPER.BesselJ1(absNum);
			for (j=1;j<n;j++) {
				besselJp=j*tox*besselJ-besselJm;
				besselJm=besselJ;
				besselJ=besselJp;
			}
			result=besselJ;
		} else {
			tox=2.0/absNum;
			if (Math.sqrt(accurateNum*n) >= 0)
				m=2*((n + Math.floor(Math.sqrt(accurateNum*n))) / 2);
			else
				m=2*((n + Math.ceil(Math.sqrt(accurateNum*n))) / 2);
			jsum=0;
			besselJp=result=sum=0.0;
			besselJ=1.0;
			for (j=m;j>0;j--) {
				besselJm=j*tox*besselJ-besselJp;
				besselJp=besselJ;
				besselJ=besselJm;
				if (Math.abs(besselJ) > BIGNO) {
					besselJ *= BIGNI;
					besselJp *= BIGNI;
					result *= BIGNI;
					sum *= BIGNI;
				}
				if (jsum) sum += besselJ;
				jsum=!jsum;
				if (j == n) result=besselJp;
			}
			sum = 2.0*sum-besselJ;
			result /= sum;
		}
		
		if (x < 0.0 && (n & 1)) result = 0 - result;
		return result;
    },
    
    besselk : function(x, n) {	
		var j,besselK,remain,bkp,tox;
		tox = 2.0/x;
		remain= FORMULA_HELPER.BesselK0(x);
		besselK = FORMULA_HELPER.BesselK1(x);
		for (j=1;j<n;j++) {
			bkp = remain+j*tox*besselK;
			remain = besselK;
			besselK = bkp;
		}
		return besselK;
    },
    
    // common function ....
    BesselK0 : function(numVal) {
		var val, result;
		if (numVal <= 2.0) {
			val = numVal*numVal/4.0;
			result = (-Math.log(numVal/2.0)*this.BesselI0(numVal))-0.57721566+0.42278420*val+0.23069756*val*val+0.03488590*val*val*val+0.00262698*val*val*val*val+0.00010750*val*val*val*val*val+0.00000740*val*val*val*val*val*val;
		} else {
			val = 2.0/numVal;
			result = (Math.exp(-numVal)/Math.sqrt(numVal))*(1.25331414+val*(-0.7832358e-1+val*(0.2189568e-1+val*(-0.1062446e-1+val*(0.587872e-2+val*(-0.251540e-2+val*0.53208e-3))))));
		}
		return result;
    },
    
    BesselK1 : function(numVal) {
		var val, result;
		if (numVal <= 2.0) {
			val=numVal*numVal/4.0;
			result = (Math.log(numVal/2.0)*this.BesselI1(numVal))+(1.0/numVal)*(1.0+val*(0.15443144+val*(-0.67278579+val*(-0.18156897+val*(-0.1919402e-1+val*(-0.110404e-2+val*(-0.4686e-4)))))));
		} else {
			val=2.0/numVal;
			result = (Math.exp(-numVal)/Math.sqrt(numVal))*(1.25331414+val*(0.23498619+val*(-0.3655620e-1+val*(0.1504268e-1+val*(-0.780353e-2+val*(0.325614e-2+val*(-0.68245e-3)))))));
		}
		return result;
    },
    
    /**
     * BESSELY
     */
    bessely : function(numVal, n) {
		var j,by,bym,bessYp,tox;
		tox = 2.0/numVal;
		bessY = FORMULA_HELPER.BesselY1(numVal);
		bessYm = FORMULA_HELPER.BesselY0(numVal);
		for (j=1;j<n;j++) {
			bessYp = j*tox*bessY-bessYm;
			bessYm = bessY;
			bessY = bessYp;
		}
		return bessY;
    },
    
    'BesselY0' : function(numVal) {
		var remain, tempX, squareNum, result, result1, result2;
		if (numVal < 8.0)  {
			squareNum=numVal*numVal;
			result1 = -2957821389.0+squareNum*(7062834065.0+squareNum*(-512359803.6+squareNum*(10879881.29+squareNum*(-86327.92757+squareNum*228.4622733))));
			result2 = 40076544269.0+squareNum*(745249964.8+squareNum*(7189466.438+squareNum*(47447.26470+squareNum*(226.1030244+squareNum*1.0))));
			result = (result1/result2)+0.636619772*this.BesselJ0(numVal)*Math.log(numVal);
		} else {
			remain=8.0/numVal;
			squareNum = remain*remain;
			tempX = numVal-0.785398164;
			result1 = 1.0+squareNum*(-0.1098628627e-2+squareNum*(0.2734510407e-4+squareNum*(-0.2073370639e-5+squareNum*0.2093887211e-6)));
			result2 = -0.1562499995e-1+squareNum*(0.1430488765e-3+squareNum*(-0.6911147651e-5+squareNum*(0.7621095161e-6+squareNum*(-0.934945152e-7))));
			result = Math.sqrt(0.636619772/numVal)*(Math.sin(tempX)+result1+remain*Math.cos(tempX)*result2);
		}
		return result;
	},
	
	'BesselY1': function(numVal) {
		var remain, tempX, squareNum, result, result1, result2;
		if (numVal < 8.0) { 
			squareNum = numVal*numVal;
			result1 = numVal*(-0.4900604943e13+squareNum*(0.1275274390e13+squareNum*(-0.5153438139e11+squareNum*(0.7349264551e9+squareNum*(-0.4237922726e7+squareNum*0.8511937935e4)))));
			result2 = 0.2499580570e14+squareNum*(0.4244419664e12+squareNum*(0.3733650367e10+squareNum*(0.2245904002e8+squareNum*(0.1020426050e6+squareNum*(0.3549632885e3+squareNum)))));
			result = (result1/result2)+0.636619772*(this.BesselJ1(numVal)*Math.log(numVal)-1.0/numVal);
		} else {
			remain=8.0/numVal;
			squareNum = remain*remain;
			tempX = numVal-2.356194491;
			result1 = 1.0+squareNum*(0.183105e-2+squareNum*(-0.3516396496e-4+squareNum*(0.2457520174e-5+squareNum*(-0.240337019e-6))));
			result2 = 0.04687499995+squareNum*(-0.202690873e-3+squareNum*(0.8449199096e-5+squareNum*(-0.88228987e-6+squareNum*0.10578e-6)));
			result = Math.sqrt(0.636619772/numVal)*(Math.sin(tempX)*result1+remain*Math.cos(tempX)*result2);
		}
		return result;
	},
	
	/**
	 * The picomath library is in the public domain. Do whatever you want with it, no strings attached. Use at your own risk.
	 * http://picomath.org/
	 */
	'gamma': function(x) {
		var gamma = 0.577215664901532860606512090; // Euler's gamma constant
	    if (x < 0.001) return 1.0/(x*(1.0 + gamma*x));
	    
	    if (x < 12.0) {
	        var y = x, n = 0;
            var arg_was_less_than_one = (y < 1.0);

            if (arg_was_less_than_one)  y += 1.0;
            else {
	            n = Math.floor(y) - 1;  // will use n later
		        y -= n;
		    }
                
            var p = [
	            -1.71618513886549492533811E+0,
	             2.47656508055759199108314E+1,
	            -3.79804256470945635097577E+2,
	             6.29331155312818442661052E+2,
	             8.66966202790413211295064E+2,
	            -3.14512729688483675254357E+4,
	            -3.61444134186911729807069E+4,
	             6.64561438202405440627855E+4
	        ];
 
            var q = [
	            -3.08402300119738975254353E+1,
	             3.15350626979604161529144E+2,
	            -1.01515636749021914166146E+3,
	            -3.10777167157231109440444E+3,
	             2.25381184209801510330112E+4,
	             4.75584627752788110767815E+3,
	            -1.34659959864969306392456E+5,
	            -1.15132259675553483497211E+5
	        ];
		
	        var num = 0.0;
	        var den = 1.0;
	
	        var z = y - 1;
	        for (i = 0; i < 8; i++) {
	        	num = (num + p[i])*z;
                den = den*z + q[i];
	        }
	        var result = num/den + 1.0;
	        
            if (arg_was_less_than_one) result /= (y-1.0);
            else {
            	for (i = 0; i < n; i++)
                    result *= y++;
            }
            
            return result;
	    }
		    
        // between 12 - 171 ============================
	    var c =[
	         1.0/12.0,
	        -1.0/360.0,
	         1.0/1260.0,
	        -1.0/1680.0,
	         1.0/1188.0,
	        -691.0/360360.0,
	         1.0/156.0,
	        -3617.0/122400.0
	    ];
	    var z = 1.0/(x*x);
	    var sum = c[7];
	    for (var i=6; i >= 0; i--)
	    {
	        sum *= z;
	        sum += c[i];
	    }
	    var series = sum/x;
	    var halfLogTwoPi = 0.91893853320467274178032973640562;
        var logGamma = (x - 0.5)*Math.log(x) - x + halfLogTwoPi + series;  
	    
        return Math.exp(logGamma);
	}
    
}, function(){
    /*
     * define a global var
     */
    FORMULA_HELPER = EnterpriseSheet.common.FormulaHelper;
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.common.ColorMenu', {
	/* Begin Definitions */
	
	extend : 'Ext.menu.Menu',
	
	requires: [	    
	   	'EnterpriseSheet.common.Common',       
	   	'Ext.picker.Color'
	],
	
	/* End Definitions */
	
	themeColorStr : 'Theme Colors',
	
	standardColorStr : 'Standard Colors',
	
	plain:true,
	        
	initComponent : function(){
		this.cls = this.cls || '';
		this.cls = 'color-menu '+this.cls;
        
        this.themeColorPicker = Ext.create('Ext.picker.Color', {
            allowReselect:true,
            colors:SCOM['themeColors'],
            listeners:{
                'select':{
                    fn:this.onSelectColor,
                    scope:this
                }
            }
        });
           
        this.standardColorPicker = Ext.create('Ext.picker.Color', {
            allowReselect:true,
            listeners:{
                'select':{
                    fn:this.onSelectColor,
                    scope:this
                }
            }
        });
        var mitems = ['<span class="menu-title">'+this.themeColorStr+'</span>', this.themeColorPicker, '<span class="menu-title">'+this.standardColorStr+'</span>', this.standardColorPicker];
        if(this.items instanceof Array){
        	mitems = mitems.concat(this.items);
        }
        this.items = mitems;
            		
		this.callParent();
		
        this.on('afterrender', function(){
            var block = this.themeColorPicker.getEl().down('.x-color-picker-item');
            var w = block.getWidth()*10+10;
            this.themeColorPicker.setWidth(w);
            this.themeColorPicker.getEl().setStyle('height', 'auto');
            this.standardColorPicker.setWidth(w);
            this.standardColorPicker.getEl().setStyle('height', 'auto');            
        }, this);
	},
	
	
	onSelectColor : function(cp, color){
		color = '#'+color;
		this.hide();
		if(this.selectHandler){
			this.selectHandler.call(this.scope || this, cp, color);
		}		
	}
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.common.ColorButton', {
	/* Begin Definitions */
	
	extend : 'Ext.button.Split',	
	
	requires: [	    
	   	'EnterpriseSheet.common.Common',       
	   	'EnterpriseSheet.common.ColorMenu'
	],
	
	/* End Definitions */
	
	themeColorStr : 'Theme Colors',
	
	standardColorStr : 'Standard Colors',
	
	initialColor : 'black',
	
	//minWidth : 20,
	        
	initComponent : function(){
		this.cls = this.cls || '';
		this.cls = 'color-picker '+this.cls;		
        
        this.menu = new EnterpriseSheet.common.ColorMenu({
            items: Ext.isArray(this.menu) ? this.menu : [],
            selectHandler: this.onSelectColor,
            scope: this
        });
            		
		this.callParent();
		
		this.on({
			scope: this,
			'afterrender': this._afterRender
		});
	},
	
	_afterRender : function(){		
		
		var em = this.el.down('.x-btn-button');
		if(em){
			/*
			 * create color block element
			 */
			this.colorBlock = Ext.core.DomHelper.append(em.dom, '<a class="color-block"></a>', true);
					
			this.setColor(this.initialColor);
		}		
	},
	
	/*
	 * change the color of the block
	 */
	setColor : function(color){
		if(!this.colorBlock){
			return;
		}
		if(!color || 'transparent' == color){
			this.colorBlock.setStyle('background-color', '');
			this.colorBlock.setStyle('border', '1px solid');
		}else{			
			this.colorBlock.setStyle('background-color', color);
			this.colorBlock.setStyle('border', '1px solid '+color);
		}
	},
	
	onSelectColor : function(cp, color){
		this.setColor(color);
		if(this.selectHandler){
			this.selectHandler.call(this.scope || this, cp, color);
		}		
	}
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.common.SimpleButton', {
	/* Begin Definitions */
	
	extend : 'Ext.Component',		
	
	alias: 'widget.simplebtn',
	
	/* End Definitions */		
	
	/*
	 * define the max text length
	 */
	color: 'rgb(1,132,187)',
	//color: 'rgb(60,116,164)',
	
	maxTextLength: 15,
	
	renderTpl : '<span class="ss-simple-button-text">{text}</span><div class="ss-simple-button-sep"><div class="ss-simple-button-arrow"></div></div>',
	
	initRenderData: function() {
		
		var data = this.callParent(arguments);
		
		var text = this.text;
		if(text && text.length > this.maxTextLength){
			text = Ext.util.Format.ellipsis(text, this.maxTextLength);
			text = '<span data-qtip="'+this.text+'">'+text+'</span>';
		}
		data.text = text || '&nbsp;';
		return data;        
    },
	
	initComponent : function(){
		
		this.cls = this.cls || '';
		
		this.cls += ' ss-simple-button x-unselectable';		
		
		/*
		 * init the binded menu
		 */
		this.initMenu();
		 
		this.callParent(arguments);
        
        this.on('afterrender', this._afterRender, this);
        this.on('resize', function(){
        	var el = this.getEl();
        	var width = el.getWidth();
        	
    		el.setStyle('min-width', Math.ceil(width)+'px');
        }, this);
	},
	
	/*
	 * init menu
	 */
	initMenu : function(){
		if(this.menu){
			if(!(this.menu instanceof Ext.menu.Menu)){
				this.menu = new Ext.menu.Menu({
					items: this.menu
				});
			}
		}
	},
	
	/*
	 * afterRender
	 */
	_afterRender : function(){
		var el = this.getEl();	
		var paddingRight = el.getPadding('r') || '';
		/*
		 * add icon cls
		 */
		if(this.iconCls){			
			el.addCls(this.iconCls);
		}
		el.setStyle('outline-color', this.color);
		/*
		 * get sep and arrow element
		 */
		this.spanEl = el.down('.ss-simple-button-text');
		this.sepEl = el.down('.ss-simple-button-sep');
		this.arrowEl = el.down('.ss-simple-button-arrow');
				
		/*
		 * add pressed css
		 */		
		this.toggle(this.pressed, true);
		
		this.mon(el, {
			scope: this,
			'mousedown': function(){
                if(!this.disabled){
                    el.addCls('ss-simple-button-push');
                }
			}
		});
		Ext.getBody().on('mouseup', function(){
            var el = this.getEl();
            if(el && el.hasCls('ss-simple-button-push')){
                el.removeCls('ss-simple-button-push');
            }
        }, this);

		/*
		 * show arrow based on whether has menu
		 */
		if(this.menu && !this.hideArrow && !this.notSplited){
			el.setStyle('padding-right', (18+paddingRight)+'px');			
			this.sepEl.show();
		}else{
			// in IE8, need add this condition, otherwise, exception ...
			if (paddingRight != null && paddingRight != '') el.setStyle('padding-right', paddingRight+'px');			
			this.sepEl.hide();
		}
		
		/*
		 * for click listener
		 */
		this.mon(el, {
			scope: this,
			'click': function(e){
                if(this.disabled){
                    return;
                }
				var target = Ext.get(e.getTarget('.ss-simple-button-sep'));
				if(target == this.sepEl){
					this.showMenu();
				}else{
					if(this.handler){						
						this.handler.call(this.scope, this, e);
					}else if(this.notSplited){
						this.showMenu();
					}
					this.fireEvent('click', this, e);
				}				
			}
		})
	},
	
	showMenu : function(){
		var el = this.getEl();
		/*
		 * add a single listener for update css after menu hide
		 */
		this.menu.on('hide', function(){
			el.removeCls('ss-simple-button-push');
		}, this, {single: true});					
		el.addCls('ss-simple-button-push');
		/*
		 * add a ref to menu
		 */
		this.menu.bindBtn = this;
		/*
		 * show menu
		 */
		this.menu.showBy(el);
	},
	
	/*
	 * toggle the pressed
	 */
	toggle: function(pressed, suspendEvent){
		this.pressed = pressed;
		var el = this.getEl();
		if(this.pressed){
			el.addCls('ss-simple-button-pressed');
			el.setStyle('color', 'white');
			el.setStyle('background-color', this.color);
			this.arrowEl.setStyle('border-top-color', 'white');
			this.sepEl.setStyle('border-left-color', 'white');
		}else{
			el.removeCls('ss-simple-button-pressed');
			el.setStyle('color', this.color);
			el.setStyle('background-color', '');
			this.arrowEl.setStyle('border-top-color', this.color);
			this.sepEl.setStyle('border-left-color', this.color);
		}
		if(!suspendEvent){
			this.fireEvent('toggle', this, this.pressed);
		}
	},
	
	isPressed : function(){
		return this.pressed;
	},
	
	setText : function(text){
		if(text && text.length > this.maxTextLength){
			var fullText = text;
			text = Ext.util.Format.ellipsis(text, this.maxTextLength);
			text = '<span data-qtip="'+fullText+'">'+text+'</span>';
		}
		this.el.setStyle('min-width', '0px');
		this.spanEl.update(text);
		var w = Math.ceil(this.el.getWidth());
		this.el.setStyle('min-width', w+'px');
	},
	
	setIconCls : function(cls) {
        var me = this,
        el = me.el,
        oldCls = me.iconCls;
        
	    me.iconCls = cls;
	    if (el) {
	        // Remove the previous iconCls from the button
	        el.removeCls(oldCls);
	        el.addCls(cls || '');
	    }
	    return me;
	},
           
    setBtnColor : function(color){
        this.color = color;
        var el = this.getEl();
        el.setStyle('outline-color', this.color);
        this.toggle(this.pressed, true);
    }
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.common.Tip', {
	
	/* Begin Definitions */
	
	extend: 'Ext.tip.ToolTip',		
	
	/* End Definitions */
	
	showAtTarget:function(t, xy){
    	this.target = t;
        if(this.disabled || this.triggerElement == t){
        	return;
       	}
        if (t) {
        	this.triggerElement = t;
            this.clearTimer('hide');            
            this.targetXY = xy || t.getXY();
            this.show();
        }
	}
}, function(){
	SQTIP = function(){
		var tip;
		return {
			init : function(config){
				if(!tip){
					var o = Ext.apply({
						autoWidth:true,
						autoHeight:true,
						mouseOffset:[0, -40]
					}, config);
					o.autoHide = false;
					tip = new EnterpriseSheet.common.Tip(o);
				}
			},
			
			show : function(html, t, xy){
				if(tip){
					if(html){
						if(tip.body){
							/*
							 * make it auto-width
							 */
							var el = tip.getEl(), body = tip.body;
							el.setStyle('width', 'auto');
							body.setStyle('width', 'auto');							
				            body.update(html);
				            el.setStyle('height', 'auto');
				            body.setStyle('height', 'auto');
				        }else{
				            tip.html = html;
				        }
					}				
					tip.showAtTarget(t, xy);
				}
			},
			
			hide : function(){
				if(tip){
					tip.hide();
				}
			}
		}	
	}();
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.common.IconField', {
	/* Begin Definitions */
	
	extend : 'Ext.button.Button',
	
	requires: [	    
	   	'EnterpriseSheet.common.Common'
	],
	
	/* End Definitions */
	
	        
	initComponent : function(){
		this.cls = this.cls || '';
		this.cls = 'icon-field '+this.cls;
        
        this.myIconTpl = SCOM.iconTpl;
           
        this.iconStore = SCOM.iconStore;
           
        this.iconView = Ext.create('Ext.view.View', {
            store: this.iconStore,
            tpl: this.myIconTpl,
            width: 150,
            itemSelector: 'div.ss-condition-iconset',
            overItemCls: 'ss-iconset-over'
        });
           
        this.menu = {
            plain: true,
            items: [this.iconView]
        };
        var data = this.iconValue || this.iconStore.getAt(0).data;
           
        this.setIcon(SCONFIG.CONDITION_ICONS_PATH+'/'+data['set']+'/'+data['idx']+'.png');
        
        this.iconValue = data;
           
		this.callParent();
           
        this.iconView.on('itemclick', this.onIconClick, this);
	},
           
    /**
     * set the iconset for the selection
     */
    onIconClick : function(view, rec){
        var data = rec.data;
        var oldVal = this.iconValue;
        this.iconValue = data;
        this.setIcon(SCONFIG.CONDITION_ICONS_PATH+'/'+data['set']+'/'+data['idx']+'.png');
        
        this.menu.hide();
        this.fireEvent('valuechange', oldVal, data, this);
    },
           
    getIconValue : function(){
        return this.iconValue;
    },
           
    setValue : function(data, suspendEvent){
        var oldVal = this.iconValue;
        this.iconValue = data;
        this.setIcon(SCONFIG.CONDITION_ICONS_PATH+'/'+data['set']+'/'+data['idx']+'.png');
        
        if(!suspendEvent){
            this.fireEvent('valuechange', oldVal, data, this);
        }
    }
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.common.IconSetField', {
	/* Begin Definitions */
	
	extend : 'Ext.button.Button',
	
	requires: [	    
	   	'EnterpriseSheet.common.Common'
	],
	
	/* End Definitions */
	
	        
	initComponent : function(){
		this.cls = this.cls || '';
		this.cls = 'icon-field '+this.cls;
        
        this.iconSetTpl = SCOM.iconSetTpl;
           
        this.iconSetStore = SCOM.iconSetStore;
           
        this.iconSetView = Ext.create('Ext.view.View', {
            store: this.iconSetStore,
            tpl: this.iconSetTpl,
            itemSelector: 'div.ss-condition-iconset',
            overItemCls: 'ss-iconset-over'
        });
           
        this.menu = {
            plain: true,
            items: [this.iconSetView]
        };
        var data = this.value || this.iconSetStore.getAt(0).data;
        var html = this.iconSetTpl.apply([data]);
        
        this.iconValue = data;
        this.setText(html);
           
		this.callParent();
           
        this.iconSetView.on('itemclick', this.onIconSetClick, this);
	},
           
    /**
     * set the iconset for the selection
     */
    onIconSetClick : function(view, rec){
        var data = rec.data;
        var oldVal = this.iconValue;
        this.iconValue = data;
        var html = this.iconSetTpl.apply([data]);
        this.setText(html);
 
        this.menu.hide();
        this.fireEvent('valuechange', oldVal, data, this);
    },
           
    getIconValue : function(){
        return this.iconValue;
    },
           
    setValue : function(data, suspendEvent){
        var oldVal = this.iconValue;
        this.iconValue = data;
        if(!data){
           this.setText('<div>'+SLANG['customize']+'</div>');
        }else{
           var html = this.iconSetTpl.apply([data]);
           this.setText(html);
        }
        if(!suspendEvent){
           this.fireEvent('valuechange', oldVal, data, this);
        }
    }
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.common.LoadMask', {
	/* Begin Definitions */
	
	extend : 'Ext.LoadMask',

	
	/* End Definitions */
           
              
	initComponent : function(){
			
        this.cls = this.cls || '';
        
        this.cls = 'ss-loadmask '+this.cls;
           
		this.callParent(arguments);			
		
		this.on('afterrender', function(){
			Ext.DomHelper.append(this.msgEl.dom, ['<div class="mask-per" style="display:none;">',
			    '<div class="mask-perinner"></div>',
			'</div>'].join(''), true);
			this.perEl = this.msgEl.child('div.mask-per');
			this.perInnerEl = this.perEl.child('div.mask-perinner');
		}, this);
	},
           
    /**
     * update percent
     */
    updatePercent : function(percent){
        percent = Math.floor(percent * 100);
        if(99 < percent){
            percent = 99;
        }
        this.perInnerEl.setWidth(percent+'%');
        this.perEl.setStyle('display', '');
        this.msgTextEl.update(this.msg+' '+percent+'%');
    },
           
    hide : function(){
        delete(this._delayShowFlag);
        if (this.perEl) this.perEl.setStyle('display', 'none');
        this.callParent(arguments);
    },
           
    show : function(displayText, showDelayTime){
        displayText = displayText || this.msg;
        if(Ext.isNumber(showDelayTime)){
            this._delayShowFlag = true;
            Ext.Function.defer(function(){
                if(this._delayShowFlag){
                    EnterpriseSheet.common.LoadMask.superclass.show.apply(this);
                    this.msgTextEl.update(displayText);
                }
            }, showDelayTime, this);
        }else{
            this.callParent(arguments);
            this.msgTextEl.update(displayText);
        }
    },
    
    updateText : function(displayText){
    	this.msgTextEl.update(displayText);
    }
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.common.action.Action', {
	
	/* Begin Definitions */
	
	extend: 'Ext.Action',		
	
	/* End Definitions */
	
	/*
	 * overrdie addComponent
	 */
	addComponent : function(comp){
		this.callParent(arguments);		
		/*
		 * allow user to pass onceConfig for some special attributes,
		 * it will remove immediately, so you have to set up it to action before you generate a comp
		 */
		if(this.onceConfig){
			Ext.apply(comp, this.onceConfig);
			delete(this.onceConfig);
		}
	},
	
	/*
	 * modify the callEach function, only call the function for item if existed
	 */
	callEach : function(fnName, args){
        var cs = this.items;
        for(var i = 0, len = cs.length; i < len; i++){
        	if('function' == SCOM.typeOf(cs[i][fnName])){
        		cs[i][fnName].apply(cs[i], args);
        	}
        }
    },
    
	toggle : function(pressed, suspendEvent){
		this.initialConfig.pressed = pressed;
        this.callEach('toggle', [pressed, suspendEvent]);
	}
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.common.measure.CharMeasure', {
	
	/* Begin Definitions */	
	
	/* End Definitions */	
	
	constructor : function(){
		this.callParent(arguments);
		
		this.el = Ext.core.DomHelper.append(Ext.getBody(), '<div class="sc-char-measure"><span class="sp-span"></span></div>');
		this.span = this.el.firstChild;
	},
	
	/*
	 * get the tab width, the width of tab key
	 */
	getTabCharWidth : function(){
		if(SCOM.nullOrUndefined(this._tabWidth)){
			var el = Ext.core.DomHelper.append(Ext.getBody(), '<span style="padding-left:20px;font-size:14px;font-weight:normal;font-style:none;">&nbsp;</span>', true);
			this._tabWidth = el.getWidth();
			Ext.removeNode(el.dom);
		}		
		return this._tabWidth;
	},
	
	/*
	 * measure the passed html, return the width of every chars in that html 
	 */
	measure : function(html){
		this.span.innerHTML = html;
		var rects = this.span.getClientRects();
		var arr = [];
		for(var i = 0, len = rects.length; i < len; i++){
			var rect = rects[i];
			if(!SCOM.nullOrUndefined(rect.width)){
				arr.push(rect.width);
			}else{
				arr.push(rect.right-rect.left);
			}			
		}		
		this.span.innerHTML = '';
		return arr;
	}
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.common.measure.PixelMeasure', {
	
	/* Begin Definitions */	
	
	/* End Definitions */	
	
	constructor : function(){
		this.callParent(arguments);
		
		this.el = Ext.core.DomHelper.append(Ext.getBody(), '<div class="sc-px-measure"></div>', true);		
	},
	
	/*
	 * measure the passed html, return the width of every chars in that html 
	 */
	measure : function(width){
		this.el.setStyle('width', width);
		return this.el.getWidth();
	}
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.common.menu.ScaleItem', {
	
	/* Begin Definitions */
	
	extend: 'Ext.menu.Item',
	
	alias: 'widget.scaleitem', 
	
	/* End Definitions */
	
	/*
	 * the scale could be {small, medium, large}, the size is 16px, 24px and 32px
	 */
	scale : 'small',
		
	initComponent : function(){		
		this.cls = Ext.baseCSSPrefix+'scale-menu-item'+' '+Ext.baseCSSPrefix+this.scale+'-menu-item';
		
		this.callParent(arguments);	
	}
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.common.menu.ScaleMenu', {
	
	/* Begin Definitions */
	
	extend: 'Ext.menu.Menu',
		
	alias: 'widget.scalemenu',
	
	requires: ['EnterpriseSheet.common.menu.ScaleItem'],
	
	/* End Definitions */
	
	/*
	 * the scale could be {small, medium, large}, the size is 16px, 24px and 32px
	 */
	scale : 'small',
	
	initComponent : function(){
		this.bodyCls = Ext.baseCSSPrefix+'scale-menu-body'+' '+Ext.baseCSSPrefix+this.scale+'-menu-body';			
		
		this.callParent();		
	}
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.common.pop.PopWin', {
	
	/* Begin Definitions */
		
	extend : 'Ext.window.Window',
	
	/* End Definitions */
	
	bodyStyle : 'padding:10px;background-color:white;',
	
	resizable : false,			
    
    stateful: false,
    
    modal: true,
    
    shim : true,
    
    buttonAlign : "right",
    
    okText : 'OK',
	
	cancelText : 'Cancel',
    
    closable : true,
    
    closeAction : 'hide',
    
    /*
     * true to not reset the window when show
     */
    skipResetOnShow: false,
    
    updateConfig : Ext.emptyFn,
    
    initComponent : function(){
    	
    	this.prepareButton();
    	
    	this.callParent();    	
    	
    	this.on({
    		scope:this,
    		'show':function(){
    			if(!this.skipResetOnShow){
    				this.reset();
    			}
    			
    			this.getEl().setVisible(true);
    		}
    	});
        if('hide' === this.closeAction){
            this.on('hide', this.quit, this);
        }else{
            this.on('close', this.quit, this);
        }
    },
    
    /*
     * override ghost function, this function has bug in Extjs4.1RC
     */
    ghost: function(cls) {
    	/*
	     * for a bug in 4.1RC
	     */
	    if(!Ext.getVersion('core').isLessThan('4.0.9')){
	    	var me = this;
	    	me.ghostPanel = new Ext.panel.Panel({
	            renderTo: document.body,
	            floating: {
	                shadow: false
	            },
	            frame: (Ext.supports.CSS3BorderRadius && !me.isWindow) ? me.frame : false,
	            overlapHeader: me.overlapHeader,
	            headerPosition: me.headerPosition,
	            baseCls: me.baseCls,
	            cls: me.baseCls + '-ghost ' + (cls ||'')
	        });
	    }    	
    	return this.callParent(arguments);
    },
    
    getStr : function(str){
    	if(SLANG){
    		return SLANG[str] || str; 
    	}
    	return str;
    },
    
    /*
     * reset fields if has
     */
    reset : function(){
    	var fn = function(items){
    		items.each(function(it){
				if(it.items){
					fn(it.items);
				}else if('function' == SCOM.typeOf(it.reset)){
					it.reset();
				}
			});
    	}    	
    	if(this.items){
    		fn(this.items);
    	}    	
    },
    
    /*
     * check whether all fields are valid
     */
    isValid : function(){
    	var flag = true;
    	var fn = function(items){
    		items.each(function(it){
    			if(it.isVisible() && !it.disabled){
					if('function' == SCOM.typeOf(it.isValid)){
						var valid = it.isValid();
						if(flag){
							flag = valid;
						}
					}else if(it.items){
						fn(it.items);
					}
    			}
			});
    	} 
    	if(this.items){
    		fn(this.items);
    	}
    	return flag;
    },
    
    /*
	 * create the buttons, default to create OK and CANCEL buttons,   
	 * the subclass can overwrite it to create buttons as they want 	 
	 */
    prepareButton : function(){
    	this.buttons = [{
			text:this.okText,
			handler:this.onOK,
			scope:this
		}, {
			text:this.cancelText,
			handler:this.onCancel,
			scope:this
		}];
    },
    
    onOK : function(){
    	if(this.isValid()){
			var flag = true;
			if(this.applyCallback){
				var o = this.applyCallback;
				flag = o.fn.call(o.scope || this, this.prepareParam(), this);
			}
			if(false !== flag){
				this.hide();
			}
    	}
	},
	
	onCancel : function(){
		var flag = true;
		if(this.cancelCallback){
			var o = this.cancelCallback;
			flag = o.fn.call(o.scope || this, this.prepareParam(), this);
		}
		if(false !== flag){
			this.hide();
		}
	},
	
	/*
	 * when window close or hide, it will call quit
	 */
	quit : function(){
		if(this.closeCallback){
			var o = this.closeCallback;
			o.fn.call(o.scope, this);
		}
	},
	
    
    /*
     * this function will params for the callback function
     * the subclass can overwrite it to provide the params as they want 
     */
    prepareParam : Ext.emptyFn 
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.common.toolbar.BorderToolbar', {
	
	extend: 'Ext.toolbar.Toolbar',
	
	alias: 'widget.bordertoolbar',
	
	// private
    onBeforeAdd: function(component) {
    	/* skip add -toolbar
        if (component.is('field') || (component.is('button') && this.ui != 'footer')) {
            component.ui = component.ui + '-toolbar';
        }
		*/
        // Any separators needs to know if is vertical or not
        if (component instanceof Ext.toolbar.Separator) {
            component.setUI((this.vertical) ? 'vertical' : 'horizontal');
        }
        /*
         * call gradparent's method
         */
        Ext.toolbar.Toolbar.superclass.onBeforeAdd.apply(this, arguments);
        //this.callParent(arguments);
    }	
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.common.ribbon.ButtonGroup', {
	/* Begin Definitions */
	
	extend : 'Ext.container.ButtonGroup',	
	
	alias: 'widget.ribbonbuttongroup',
		
	
	/* End Definitions */
	
	//headerPosition : 'bottom',
	
	//preventHeader: true,
	
	layout : {
		type: 'table',
		tableAttrs: {
            style: {
                height: '100%'
            }
        }
	}
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.common.ribbon.Toolbar', {
	/* Begin Definitions */
	
	extend : 'Ext.toolbar.Toolbar',	
	
	alias: 'widget.ribbontoolbar',
		
	requires: ['EnterpriseSheet.common.ribbon.ButtonGroup'],
	
	/* End Definitions */
	
	/*
	 * set overflow to true
	 */
	enableOverflow : true,		
	
	style : 'border:none;',
	
	constructor : function(){
		
		if(!this.layout){
			this.layout = {
				type: 'hbox',
				align: 'stretch'
			};
		}
		
		this.callParent(arguments);
	}
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.common.ribbon.TabToolbar', {
	/* Begin Definitions */
	
	extend : 'Ext.panel.Panel',			
	
	alias: 'widget.ribbontabtoolbar',
	
	requires: [
	    'EnterpriseSheet.common.ribbon.Toolbar',
	    'Ext.layout.container.Card'
	],
	
	/* End Definitions */
	
	cls : 'rb-tabtoolbar',
	
	layout : {
		type: 'card',
		bindToOwnerCtComponent: false,
		bindToOwnerCtContainer: false,
		deferredRender: true
	},
	
	activeItem : 0,
	
	initComponent : function(){	
		var len = !this.items ? 0 : this.items.length;
		if(0 < len){						
			this.hbuttons = this.hbuttons || [];			
			var count = this.hbuttons.length;									
			var id = Ext.id();			
			for(var i = 0; i < len; i++){
				this.hbuttons.push({	
					minWidth: 55,
					text: this.items[i].title,
					closable: false,
					itemIndex: i,
					active: 0 === i,
					pressed: 0 === i,
					enableToggle: true,
					toggleGroup: id+'-tabs',
					handler: this.switchTab,
					scope: this
				});
			}
			this.tbar = new Ext.toolbar.Toolbar({				
				items : this.hbuttons
			});			
		}
		/*
		 * keep the items and avoid the normal render
		 */
		this._tmpItems = this.items;
		delete(this.items);
		
		this.callParent();		
		
		/*
		 * some resize issue, we have to add the items after the toolbar resized
		 */
		this.on('resize', function(p, width, height){
			if(this._tmpItems){
				if(this._tmpItems instanceof Ext.util.MixedCollection){
					for(var i = 0, len = this._tmpItems.getCount(); i < len; i++){
						var it = this._tmpItems.get(i);
						this.add(it);
					}
				}else if('array' == Ext.typeOf(this._tmpItems)){
					for(var i = 0, len = this._tmpItems.length; i < len; i++){
						var it = this._tmpItems[i];
						this.add(it);
					}
				}else{
					this.add(this._tmpItems);
				}				
				delete(this._tmpItems);
				
			}
		}, this, {single: true});
	},
	
	/*
	 * switch tab
	 */
	switchTab : function(btn){
		if(!btn.pressed){
			btn.toggle(true, true);
		}else{
			var itemIndex = btn.itemIndex;
			this.getLayout().setActiveItem(itemIndex);
		}
	}
});
/**
 * CubeDrive Private Cloud
 * Copyright (c) FeyaSoft Inc 2014. All right reserved.
 * http://www.cubedrive.com
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY
 * KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE
 * AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
Ext.define('EnterpriseSheet.common.PhotoViewer', {
	extend: 'Ext.util.Observable',		
	
	requires: ['EnterpriseSheet.lang.Language'],
	
	shieldLabel: 'Please enter password to view',
	
	showPhotos : function(photos, index){		
		this.photos = Ext.clone(photos);
		this.cursor = index;
		if(!this.el){
			var body = Ext.getBody();
			var w = body.getWidth()-300, h = body.getHeight()-20;
			
			this.el = body.mask();									
			this.el.addCls('photo-viewer');
						
			this.el.update([
			    '<div class="photo-viewer-frame"></div>',
			    '<table cellpadding="0" cellspacing="0" class="photo-viewer-inner"><tbody>',
			    	'<tr>',
				    	'<td class="photo-col" rowspan=2>',
				    		'<img style="max-width:', w, 'px;max-height:', h, 'px;" />',
				    	'</td>',
				    	'<td class="info-col">',
				    		'<div class="photo-name"></div>',
				    		'<div class="update-time"></div>',
				    		'<div class="file-type"></div>',
				    	'</td>',
			    	'</tr><tr>',
				    	'<td class="option-col">',
				    		'<div class="cursor-info">&nbsp;</div>',
				    		'<div class="photo-navi">', 
				    			'<div class="photo-prev enabled"><span name="prev" class="action">', SLANG['previous'], '</span></div>',
				    			'<div class="photo-next enabled"><span name="next" class="action">', SLANG['next'], '</span></div>',
				    		'</div>',
				    		'<div class="download enabled"><span name="download" class="action">', SLANG['download'], '</span></div>',
				    	'</td>',
			    	'</tr>',
			    '</tbody></table>'
			].join(''));	
			this.nameEl = this.el.down('.photo-name');
			this.updateTimeEl = this.el.down('.update-time');
			this.fileTypeEl = this.el.down('.file-type');
			this.photoEl = this.el.down('.photo-col');	
			this.optionEl = this.el.down('.option-col');
			this.cursorEl = this.el.down('.cursor-info');
			this.imgEl = this.photoEl.down('img');
			this.prevEl = this.el.down('.photo-prev');
			this.nextEl = this.el.down('.photo-next');
			this.downloadEl = this.el.down('.download');
            this.downloadTextEl = this.downloadEl.down('span');
			this.el.on('click', this.onViewerElClick, this);
		}
		
		this.el.show();
		var photo = this.photos[this.cursor];
		this.updatePhoto(photo);	
		this.updatePrevNext();
	},
	
	/**
	 * update photo
	 */
	updatePhoto : function(photo){
		this.imgEl.dom.src = SCONFIG['BLANK_PHOTO'];
		this.nameEl.update(photo.name);
		this.updateTimeEl.update(photo.updateDate);	
		    
		
		this.downloadEl.addCls('enabled');
		this.downloadEl.removeCls('disabled');
        if('img' === photo.type){
           this.imgEl.dom.src = photo.url;
           this.fileTypeEl.update(SLANG['image']);
        }else{
           this.imgEl.dom.src = SCONFIG['ATTACH_ICON32'];
           this.fileTypeEl.update(SLANG['file']);           
        }
        this.imgEl.attachUrl = photo.url;
	},		
	
	/**
	 * update the prev and next states
	 */
	updatePrevNext : function(){
		if(0 === this.cursor){
			this.prevEl.removeCls('enabled');
			this.prevEl.addCls('disabled');
		}else{
			this.prevEl.addCls('enabled');
			this.prevEl.removeCls('disabled');
		}
		if(this.photos.length-1 === this.cursor){
			this.nextEl.removeCls('enabled');
			this.nextEl.addCls('disabled');
		}else{
			this.nextEl.addCls('enabled');
			this.nextEl.removeCls('disabled');
		}
		this.cursorEl.update(SLANG['display']+' '+(this.cursor+1)+'/'+this.photos.length+' '+SLANG['on_current_page']);
	},
	
	/**
	 * when click on option ct
	 */
	onViewerElClick : function(e){
		var target = e.getTarget(), tgEl = Ext.get(target);
		if(tgEl.hasCls('action')){
			var name = target.getAttribute('name');
			var div = Ext.get(target).parent();			
			if(!div.hasCls('disabled')){
				if('download' == name){
                    if(!this.downloadState){
                        this.syncDownloadingState(true);
                        document.location = this.imgEl.attachUrl;
                    }
				}else if('prev' == name){
					this.prevPhoto();				
				}else if('next' == name){
					this.nextPhoto();				
				}
			}
		}else{
			if(target !== this.photoEl.dom && tgEl.up('.photo-col') !== this.photoEl){
				this.imgEl.dom.src = SCONFIG['BLANK_PHOTO'];
				this.el.hide();						
			}	
		}						
	},
	
	/**
	 * show prev photo
	 */
	prevPhoto : function(){
        this.syncDownloadingState(false);
		this.cursor--;
		this.updatePrevNext();
		var photo = this.photos[this.cursor];
		this.updatePhoto(photo);
	},
	
	/**
	 * show next photo
	 */
	nextPhoto : function(){
        this.syncDownloadingState(false);
		this.cursor++;
		this.updatePrevNext();
		var photo = this.photos[this.cursor];
		this.updatePhoto(photo);
	},
           
    syncDownloadingState : function(state){
        if(state){
            this.downloadState = true;
            this.downloadTextEl.update(SLANG['downloading']+'...');
            Ext.Function.defer(function(){
                delete(this.downloadState);
                this.downloadTextEl.update(SLANG['download']);
            }, 3000, this);
        }else{
            delete(this.downloadState);
            this.downloadTextEl.update(SLANG['download']);
        }
    },
	
	/**
	 * enter shield password
	 */
	onShieldFieldKeyDown : function(field, e){
		var key = e.getKey();
		if(13 === key){
			if(field.isValid()){
				var val = field.getValue();
				this.fireEvent('checkphotoshield', val, this.photos[this.cursor], this);
			}
		}
	}
}, function(){
	PHOTOVIEWER = Ext.create('EnterpriseSheet.common.PhotoViewer', {
		shieldLabel: SLANG['enter_password']
	});	
});
Ext.define('EnterpriseSheet.sheet.data.Format', {
	
	requires : [
        'EnterpriseSheet.common.Common',
        'EnterpriseSheet.common.Helper'
    ],
		
	singleton : true,
	
	constructor : function(){
		
		/* 
		 * the default date format
		 */
		var defaultDateFormat = SCONST.DEFAULT_DATE_FORMAT, // Default should be yyyy-mm-dd 
		    defaultTimeFormat = SCONST.DEFAULT_TIME_FORMAT;
		
		/*
		 * the formats will use to try to parse date
		 * @ Deprecated
		 */
		var dateCheckFormats = [
		    'Ymd', 'YmdHis', 
		    'Y-m-d', 'Y-m-d H:i:s', 'Y-m-d H:i',
		    'Y/m/d', 'Y/m/d H:i:s', 'Y/m/d H:i',
		    'm/d/Y', 'm/d/Y H:i:s', 'm/d/Y H:i',
		    'd-M-y', 'd-M-y H:i', 'd-M-y H:i:s',
		    'd-M-Y', 'd-M-Y H:i', 'd-M-Y H:i:s',
		    'd/M/y', 'd/M/y H:i', 'd/M/y H:i:s', 
		    'd/M/Y', 'd/M/Y H:i', 'd/M/Y H:i:s',
		    'M/d/Y', 'M/d/Y H:i:s', 'M/d/Y H:i',
		    'M d, Y', 'M d, Y H:i:s', 'M d, Y H:i',
		    
		    'Ymj', 'YmjHis', 
		    'Y-m-j', 'Y-m-j H:i:s', 'Y-m-j H:i',
		    'Y/m/j', 'Y/m/j H:i:s', 'Y/m/j H:i',
		    'm/j/Y', 'm/j/Y H:i:s', 'm/j/Y H:i',
		    'j-M-y', 'j-M-y H:i', 'j-M-y H:i:s',
		    'j-M-Y', 'j-M-Y H:i', 'j-M-Y H:i:s',
		    'j/M/y', 'j/M/y H:i', 'j/M/y H:i:s', 
		    'j/M/Y', 'j/M/Y H:i', 'j/M/Y H:i:s',
		    'M/j/Y', 'M/j/Y H:i:s', 'M/j/Y H:i',
		    'M j, Y', 'M j, Y H:i:s', 'M j, Y H:i',
		    
		    'Ynd', 'YndHis', 
		    'Y-n-d', 'Y-n-d H:i:s', 'Y-n-d H:i',
		    'Y/n/d', 'Y/n/d H:i:s', 'Y/n/d H:i',
		    'n/d/Y', 'n/d/Y H:i:s', 'n/d/Y H:i',
		    'd-n-y', 'd-n-y H:i', 'd-n-y H:i:s',
		    'd-n-Y', 'd-n-Y H:i', 'd-n-Y H:i:s',
		    'd/n/y', 'd/n/y H:i', 'd/n/y H:i:s', 
		    'd/n/Y', 'd/n/Y H:i', 'd/n/Y H:i:s',
		    'n/d/Y', 'n/d/Y H:i:s', 'n/d/Y H:i',
		    'n d, Y', 'n d, Y H:i:s', 'n d, Y H:i',
		    
		    'Ynj', 'YnjHis', 
		    'Y-n-j', 'Y-n-j H:i:s', 'Y-n-j H:i',
		    'Y/n/j', 'Y/n/j H:i:s', 'Y/n/j H:i',
		    'n/j/Y', 'n/j/Y H:i:s', 'n/j/Y H:i',
		    'j-n-y', 'j-n-y H:i', 'j-n-y H:i:s',
		    'j-n-Y', 'j-n-Y H:i', 'j-n-Y H:i:s',
		    'j/n/y', 'j/n/y H:i', 'j/n/y H:i:s', 
		    'j/n/Y', 'j/n/Y H:i', 'j/n/Y H:i:s',
		    'n/j/Y', 'n/j/Y H:i:s', 'n/j/Y H:i',
		    'n j, Y', 'n j, Y H:i:s', 'n j, Y H:i',
		    
		    'YFd', 'YFdHis', 
		    'Y-F-d', 'Y-F-d H:i:s', 'Y-F-d H:i',
		    'Y/F/d', 'Y/F/d H:i:s', 'Y/F/d H:i',
		    'F/d/Y', 'F/d/Y H:i:s', 'F/d/Y H:i',
		    'd-F-y', 'd-F-y H:i', 'd-F-y H:i:s',
		    'd-F-Y', 'd-F-Y H:i', 'd-F-Y H:i:s',
		    'd/F/y', 'd/F/y H:i', 'd/F/y H:i:s', 
		    'd/F/Y', 'd/F/Y H:i', 'd/F/Y H:i:s',
		    'F/d/Y', 'F/d/Y H:i:s', 'F/d/Y H:i',
		    'F d, Y', 'F d, Y H:i:s', 'F d, Y H:i'
		];
		
		var dateFormats = [		                   
		   'Y-m-d', 'y-m-d', 'Y-M-d', 'y-M-d', 'Y-n-d', 'y-n-d', 'Y-m-j', 'y-m-j', 'Y-M-j', 'y-M-j', 'Y-n-j', 'y-n-j', 'Y-F-d', 'y-F-d', 'Y-F-j', 'y-F-j',
		   'm-d-Y', 'm-d-y', 'M-d-Y', 'M-d-y', 'n-d-Y', 'n-d-y', 'm-j-Y', 'm-j-y', 'M-j-Y', 'M-j-y', 'n-j-Y', 'n-j-y', 'F-d-Y', 'F-d-y', 'F-j-Y', 'F-j-y',
		   'd-m-Y', 'd-m-y', 'd-M-Y', 'd-M-y', 'd-n-Y', 'd-n-y', 'j-m-Y', 'j-m-y', 'j-M-Y', 'j-M-y', 'j-n-Y', 'j-n-y', 'd-F-Y', 'd-F-y', 'j-F-Y', 'j-F-y',

	       'Y/m/d', 'y/m/d', 'Y/M/d', 'y/M/d', 'Y/n/d', 'y/n/d', 'Y/m/j', 'y/m/j', 'Y/M/j', 'y/M/j', 'Y/n/j', 'y/n/j', 'Y/F/d', 'y/F/d', 'Y/F/j', 'y/F/j',               
	       'm/d/Y', 'm/d/y', 'M/d/Y', 'M/d/y', 'n/d/Y', 'n/d/y', 'm/j/Y', 'm/j/y', 'M/j/Y', 'M/j/y', 'n/j/Y', 'n/j/y', 'F/d/Y', 'F/d/y', 'F/j/Y', 'F/j/y',
	       'd/m/Y', 'd/m/y', 'd/M/Y', 'd/M/y', 'd/n/Y', 'd/n/y', 'j/m/Y', 'j/m/y', 'j/M/Y', 'j/M/y', 'j/n/Y', 'j/n/y', 'd/F/Y', 'd/F/y', 'j/F/Y', 'j/F/y',
		       
	       
	       'Y.m.d', 'y.m.d', 'Y.M.d', 'y.M.d', 'Y.n.d', 'y.n.d', 'Y.m.j', 'y.m.j', 'Y.M.j', 'y.M.j', 'Y.n.j', 'y.n.j', 'Y.F.d', 'y.F.d', 'Y.F.j', 'y.F.j',           
	       'm.d.Y', 'm.d.y', 'M.d.Y', 'M.d.y', 'n.d.Y', 'n.d.y', 'm.j.Y', 'm.j.y', 'M.j.Y', 'M.j.y', 'n.j.Y', 'n.j.y', 'F.d.Y', 'F.d.y', 'F.j.Y', 'F.j.y',
	       'd.m.Y', 'd.m.y', 'd.M.Y', 'd.M.y', 'd.n.Y', 'd.n.y', 'j.m.Y', 'j.m.y', 'j.M.Y', 'j.M.y', 'j.n.Y', 'j.n.y', 'd.F.Y', 'd.F.y', 'j.F.Y', 'j.F.y',
	       
	       'Y,m,d', 'y,m,d', 'Y,M,d', 'y,M,d', 'Y,n,d', 'y,n,d', 'Y,m,j', 'y,m,j', 'Y,M,j', 'y,M,j', 'Y,n,j', 'y,n,j', 'Y,F,d', 'y,F,d', 'Y,F,j', 'y,F,j',           
	       'm,d,Y', 'm,d,y', 'M,d,Y', 'M,d,y', 'n,d,Y', 'n,d,y', 'm,j,Y', 'm,j,y', 'M,j,Y', 'M,j,y', 'n,j,Y', 'n,j,y', 'F,d,Y', 'F,d,y', 'F,j,Y', 'F,j,y',
	       'd,m,Y', 'd,m,y', 'd,M,Y', 'd,M,y', 'd,n,Y', 'd,n,y', 'j,m,Y', 'j,m,y', 'j,M,Y', 'j,M,y', 'j,n,Y', 'j,n,y', 'd,F,Y', 'd,F,y', 'j,F,Y', 'j,F,y',
	       'm,d Y', 'm,d y', 'M,d Y', 'M,d y', 'n,d Y', 'n,d y', 'm,j Y', 'm,j y', 'M,j Y', 'M,j y', 'n,j Y', 'n,j y', 'd,F Y', 'd,F y', 'j,F Y', 'j,F y',
	       'd,m Y', 'd,m y', 'd,M Y', 'd,M y', 'd,n Y', 'd,n y', 'j,m Y', 'j,m y', 'j,M Y', 'j,M y', 'j,n Y', 'j,n y', 'd,F Y', 'd,F y', 'j,F Y', 'j,F y',
	       'M d, Y', 'm d, Y', 'F d, Y',
	       'm/d Y', 'm/d y', 'M/d Y', 'M/d y', 'n/d Y', 'n/d y', 'm/j Y', 'm/j y', 'M/j Y', 'M/j y', 'n/j Y', 'n/j y', 'd/F Y', 'd/F y', 'j/F Y', 'j/F y',
	       'd/m Y', 'd/m y', 'd/M Y', 'd/M y', 'd/n Y', 'd/n y', 'j/m Y', 'j/m y', 'j/M Y', 'j/M y', 'j/n Y', 'j/n y', 'F/d Y', 'F/d y', 'F/j Y', 'F/j y',
	                      
	       'Y m d', 'y m d', 'Y M d', 'y M d', 'Y n d', 'y n d', 'Y m j', 'y m j', 'Y M j', 'y M j', 'Y n j', 'y n j', 'Y F d', 'y F d', 'Y F j', 'y F j',            
	       'm d Y', 'm d y', 'M d Y', 'M d y', 'n d Y', 'n d y', 'm j Y', 'm j y', 'M j Y', 'M j y', 'n j Y', 'n j y', 'F d Y', 'F d y', 'F j Y', 'F j y',  
	       'd m Y', 'd m y', 'd M Y', 'd M y', 'd n Y', 'd n y', 'j m Y', 'j m y', 'j M Y', 'j M y', 'j n Y', 'j n y', 'd F Y', 'd F y', 'j F Y', 'j F y',
	       
	       'Y\u5E74m\u6708j\u65E5', 'Y\u5E74m\u6708d\u65E5', 'Y\u5E74n\u6708j\u65E5', 'Y\u5E74n\u6708d\u65E5', 'y\u5E74m\u6708j\u65E5', 'y\u5E74m\u6708d\u65E5',
	       'm\u6708j\u65E5', 'm\u6708d\u65E5'
	    ];
		
		/*
		 * the formats will use to try to parse time
		 */
		var timeCheckFormats = [		   
		     'H:i:s', 'H:i', 'i:s', 'H:i:s a', 'H:i a', 'H:i:s A', 'H:i A', 
		     'h:i:s', 'h:i',  'h:i:s a', 'h:i a', 'h:i:s A', 'h:i A', 
		     'G:i:s a', 'G:i a', 'G:i:s', 'G:i', 'G:i:s A', 'G:i A',
		     'g:i:s a', 'g:i a', 'g:i:s', 'g:i', 'g:i:s A', 'g:i A',
		     'Gis', 'Gi', 'G', 'gisA', 'giA', 'gA', 'gisa', 'gia', 'ga',
		     'His', 'Hi', 'H'		 
		];
		
		var dateTimeCheckFormats = [
		     'Y-m-d H:i', 'Y-m-d H:i:s', 'Y-m-d H', 'Y-m-d H:i:s A', 'Y-m-d H:i A', 'Y-m-d H:i:s a', 'Y-m-d H:i a',
		     'Y-m-d i:s',  'Y-m-d G:i:s', 'Y-m-d G:i', 
		     'Y-m-d G:i:s', 'Y-m-d G:i' 
		];
		
		var isValidStrInDate = function(str){
			str = str.toLowerCase();
			return !(-1 == Ext.Array.indexOf(SCONST.shortMonthNames_low, str) && -1 == Ext.Array.indexOf(SCONST.fullMonthNames_low, str) && 'am' != str && 'pm' != str);
		};
			
		/*
		 * try to convert a string to a date by trying different date format
		 * return parameter: date
		 */
		var checkingDateStr = function(data, infoRef){
			if(SCOM.nullOrUndefined(data) || '' == data){
				return;
			}
			
			var dateStr = data.toString();
			if (dateStr == null || !Ext.isString(dateStr)) return false;
			dateStr = Ext.String.trim(dateStr);
			var valid = true;
			dateStr.replace(/[a-zA-Z%]+/gi, function(w){
				if(!isValidStrInDate(w)){
					valid = false;
					return false;
				}
			});
			if(!valid)  return;
			
			var withTime = -1 != dateStr.indexOf(':');
			var dateFormat = SCONST.DEFAULT_DATE_FORMAT;		
			try {
	            var date;            
	            for(var i = 0, len = dateFormats.length; i < len; i++){
	                var fm = dateFormats[i];
	                date = Ext.Date.parse(dateStr, fm);
	                if(date && Ext.Date.format(date, fm) == dateStr){
	                	if(Ext.isObject(infoRef)){
	                		infoRef.dfm = fm;
	                	}
	                	if(!withTime) date = Ext.Date.clearTime(date, true);
	                    return date;
	                }
	            }			
			} catch (e) {
				return false;
			}	
		};
		
		var checkingDate = function(data, infoRef){
			var date = checkingDateStr(data, infoRef);
			if(!date){
				if (Ext.isNumber(Number(data))) {
    				var temp = Number(data);
    				var tempDate = new Date(0,0,temp-1);
                    return tempDate;
                }
			}else{
				return date;
			}
		}
		
		/*
		 * try to convert a string to a date by trying different time format
		 */
		var checkingTime = function(data){
			if(SCOM.nullOrUndefined(data) || '' == data){
				return;
			}
			data = data.toString();
			var valid = true;
			data.replace(/[a-zA-Z%]+/gi, function(w){
				if(!isValidStrInDate(w)){
					valid = false;
					return false;
				}
			});
			if(!valid){
				return;
			}
            var ampm = SCOM.getAMPM();
            data = data.replace(/AM/gi, ampm.am);
            data = data.replace(/PM/gi, ampm.pm);
			try{
				var date = new Date(data);
				if(date){
					var str = Ext.Date.format(date, SCONST.DEFAULT_TIME_FORMAT);
					if(str && -1 == str.indexOf('NaN')){
						return date;
					}
				}
				for(var i = 0, len = timeCheckFormats.length; i < len; i++){
					date = Ext.Date.parseDate(data, timeCheckFormats[i]);
					if(date){
						return date;
					}
				}
			}catch(e){}
		};
		
		var checkingDateTime = function(data, infoRef){
			if(SCOM.nullOrUndefined(data) || '' == data){
				return;
			}
			
			var dateStr = data.toString();
			if (dateStr == null || !Ext.isString(dateStr)) return false;
			
			var valid = true;
			dateStr.replace(/[a-zA-Z%]+/gi, function(w){
				if(!isValidStrInDate(w)){
					valid = false;
					return false;
				}
			});
			if(!valid)  return;
			
			var withTime = -1 != dateStr.indexOf(':');
			var dateFormat = SCONST.DEFAULT_DATE_TIME_FORMAT;		
			try {
	            var date;            
	            for(var i = 0, len = dateFormats.length; i < len; i++){
	                var fm = dateTimeCheckFormats[i];
	                date = Ext.Date.parseDate(dateStr, fm);
	                if(date && Ext.Date.format(date, fm) == dateStr){
	                	if(Ext.isObject(infoRef)){
	                		infoRef.dfm = fm;
	                	}
	                    return date;
	                }
	            }			
			} catch (e) {
				return false;
			}	
		};
		
		/*
		 * process the data for cell with trigger or radio/checkbox, even link
		 */
		var floatCellData = function(cell){
			var data = cell['data'];
			var ta = cell.ta ? 'text-align:'+cell.ta+';' : '';
			var height = cell.height+'px', width = cell.width+'px';

			if('normal' == cell.ws){
				ta += 'position:static;';
			}			
			//cell['data'] = '<div class="ss-cell-inside" style="z-index:'+cell.zd+';width:'+width+'px;height:'+height+'px;margin-left:-2px;padding:0px 2px;" >'+
				//'<div class="ss-cell-inside" style="width:'+width+'px;'+ta+'">'+data+'</div></div>';
			
			cell['data'] = '<div class="ss-cell-inside" style="position:absolute;z-index:'+cell.zd+';width:'+width+';height:'+height+';margin-left:-2px;padding:0px 2px;top:2px;" >'+
				'<div class="ss-cell-inside" style="width:'+width+';height:'+height+';display:table-cell;vertical-align:'+cell.va+';'+ta+'">'+data+'</div></div>';
			delete(cell.zd);
			return cell;
		}
				
		this.callParent(arguments);
		
		Ext.apply(this, {	
			/*
			 * try to transfer a value to date 
			 */
			checkingDate : checkingDate,
			
			checkingTime : checkingTime,
			
			checkingDateTime : checkingDateTime,
			
			floatCellData : floatCellData,
			
			/**
		     * change the data of a cell to a special format
		     * @param {object} cell: the cell to change format
		     * @param {string} format: the format type
		     * @return {object}: the cell with the format
		     */
		    transferFormat : function(cell, format){   
		    	var isNumber = false, isBool = true === cell.data || false === cell.data;
		    	
		    	var num = 0, percision = '', dataStr = '', upper = '';	    	
		    	num = isBool ? NaN : Number(cell.data);
		    	
		    	if(!SCOM.nullOrUndefined(cell.data)){
		    		dataStr = cell.data.toString();
		    		upper = dataStr.toUpperCase();
		    		if(!isBool){
		    			isBool = 'TRUE' == upper || 'FALSE' == upper;
		    		}
		    	}
	    		if(Ext.isNumber(num)){	    			
	    			isNumber = true;
	    			/*
	    			 * calcualte the percistion
	    			 */
	    			var numStr = dataStr;
	    			var parts = numStr.split('.');	    			
	    			if(2 == parts.length){
	    				percision = parts[1];		    				
	    			}
	    			
	    			/*
	    			 * special for percent
	    			 */
	    			if(SCONST.FORMAT_PERCENT == format){
	    				num = num*100;    				
	    				
	    				// handle special case  -- 0.01235 ---- really special ...
	    				// 0.08975 ... TODO
	    				var digitalLen = HELPER.getDigitalLen(num);
		                if (digitalLen > 13) num = HELPER.roundUpNonZero(num);
	    				
	    				cell.data = num;
	    				dataStr = num.toString();
	    			}
	    		}
	    		
		    	/*
		    	 * process decimal digital
		    	 */
		    	var dpd = Number(cell.dpd); // this is for case increase / decrease decimal ...
		    	if(Ext.isNumber(dpd)){		    		
		    		if(isNumber) {
		    			// here comes 2 cases, add 0 or round ... user dataStr first 
		    			// transfer to string and process it, so we can add 0 at the end
		    			var numStr = dataStr;
		    			var parts = numStr.split('.');
		    			percision = '';		    			
		    			if(2 == parts.length) {
		    				percision = parts[1];
		    				if (percision.length < dpd) {
		    					// add 0 at the end if need
				    			for(var i = percision.length; i < dpd; i++){
				    				percision += '0';
				    			}
				    			cell.data = parts[0]+'.'+percision;
		    				} else { // now we need round ...
		    					var base = Math.pow(10, dpd);	
		    					cell.data = Math.round(Number(numStr)*base)/base;
		    				}
		    			} else {
		    				cell.data = parts[0];
		    				if(0 < dpd){
		    					cell.data += '.';
		    				}
		    				for(var i = 0; i < dpd; i++){
		    					cell.data += '0';
		    				}
		    			}
		    		}
		    	}
		    	
		    	format = format || 'regular';
		    	if(cell && format && false != SCOM.typeOf(cell.data)){	
		    		var data = cell.data;
                    if(cell.cal && Ext.isDefined(cell.value)){
                        data = cell.value;
                    }
		    		if('regular' == format) {	    			
		    			if(!cell.ta && isNumber) cell.ta = 'right';	    			
		    		} else if('bool' == format) {		    			
		    			if(isBool){
		    				cell.data = upper;
		    				if(!cell.ta) cell.ta = 'right';
		    			}		    			
		    		} else if(SCONST.FORMAT_NUMBER == format){
		    			if(isNumber){	
		    				if(cell.dfm){
			    				var format = cell.dfm; 
		    				    var formatResult = HELPER.formatNumberWithCustom(format, num);	
		    				    cell.data = formatResult.result;
		    				    if (formatResult.color) cell.color = formatResult.color;
		    				}	    				    
	    				    if(!cell.ta) cell.ta = 'right';
		    			}
		    		} else if(SCONST.FORMAT_FRACTION == format){
		    			if(isNumber){	
		    				var format = cell.dfm || SCONST.DEFAULT_FRACTION_FORMAT; 
	    				    var formatResult = HELPER.formatNumberWithCustom(format, num);	
	    				    cell.data = formatResult.result;
	    				    if(!cell.ta) cell.ta = 'right';
		    			}
		    		} else if (SCONST.FORMAT_COMMA == format) {
		    			if(isNumber) {
		    				// fixed bug for negative number ...
		    				if (num < 0) cell.data = '-' + Ext.util.Format.number(-num, SCONST.DEFAULT_COMMA_FORMAT);
		    				else cell.data = Ext.util.Format.number(num, SCONST.DEFAULT_COMMA_FORMAT);
		    				if(!cell.ta) cell.ta = 'right';
		    			}
		    		} else if(SCONST.FORMAT_CURRENCY == format || HELPER.startWith(format, "money|")) {
		    			if(isNumber){
		    				format = (SCONST.FORMAT_CURRENCY == format)? SCONFIG.default_currency : format; // this is for special case ...			    				
		    				var symbol = SCONST.money_code[SCONFIG.default_currency];  
		    				
		    				// it will take care of: money|rmb|2|none
		    				if (HELPER.startWith(format, "money|")) { 		    					
		    					var formatResult = HELPER.formatMoneyWithPrecise(format, num);	    
		    					cell.data = formatResult.data;
		    					if (formatResult.color) cell.color = formatResult.color;
		    				} else { // this is normal case
		    					var result = symbol + Ext.util.Format.number(num, SCONST.DEFAULT_CURRENCY_FORMAT); 
		    					if (num < 0) result = '-' + symbol + Ext.util.Format.number(-num, SCONST.DEFAULT_CURRENCY_FORMAT);
		    					cell.data = result;
			    				// if(percision) cell.data += '.'+percision;		    				
		    				}
		    				
		    				if(!cell.ta) cell.ta = 'right';
		    			}
		    		} else if (SCONST.FORMAT_DATE_TIME == format){ // date and time format ...
		    			// first check whether it include hh:mm format ...
		    			var dateData = data, timeData = null;
		    			if(-1 != data.toString().indexOf(':')) {
		    				var dateTime = HELPER.parseDateTime(data.toString());
		    				if (dateTime) {
			    				dateData = dateTime.date;
			    				timeData = dateTime.time;
		    				}
		    			}
		    			
		    			var dfm = cell.dfm || SCONST.DEFAULT_DATE_TIME_FORMAT;
		    			
		    			// timeData is not null
		    			if (timeData) {
		    				var date = checkingDate(dateData);
		    				var time = checkingTime(timeData);
		    			    if(date && time) {
		    			    	// format to default 'Y-m-d H:i'
		    			    	var dateTimeStr = Ext.Date.format(date, 'Y-m-d') + ' ' + Ext.Date.format(time, 'H:i:s');
		    			    	var formttedDate = Ext.Date.parse(dateTimeStr, "Y-m-d H:i:s"); 
		    			    	cell.data = Ext.Date.format(formttedDate, dfm);
			    				if(!cell.ta) cell.ta = 'right';
		    			    } else 
		    			    	cell.data = data; //'######';
		    			    
		    			} else { // not find : at this case ...
		    			    var date = checkingDateTime(data);
		    			    if (date) {			    			    
			    				cell.data = Ext.Date.format(date, dfm);
			    				if(!cell.ta) cell.ta = 'right';
		    			    } else {
		    			    	date = checkingDate(data);
		    			    	if(date) {
		    			    		cell.data = Ext.Date.format(date, dfm);
		    				        if(!cell.ta) cell.ta = 'right';
		    			    	} else 
		    				        cell.data = data; //'######';
		    			    }
		    			}
			    			
		    		} else if (SCONST.FORMAT_DATE == format){ // date format
		    			// first check whether it include hh:mm format ...
		    			var dateData = data, timeData = null;
		    			if(-1 != data.toString().indexOf(':')) {
		    				var dateTime = HELPER.parseDateTime(data.toString());
		    				if (dateTime) dateData = dateTime.date;
		    			}
		    			
		    			var date = checkingDate(dateData);		    			
		    			if(date){
		    				// check whether dfm there ...
		    				var dfm = cell.dfm || defaultDateFormat;
		    				cell.data = Ext.Date.format(date, dfm);
		    				if(!cell.ta) cell.ta = 'right';
		    			}else if (Ext.isNumber(Number(data))) {
		    				var temp = Number(data);
		    				var tempDate = new Date(0,0,temp-1);
                            var dfm = cell.dfm || defaultDateFormat;
		    				cell.data = Ext.Date.format(tempDate, dfm);
		    				if(!cell.ta) cell.ta = 'right';
		    			}else{
		    				cell.data = data; 	    			
                        }
		    		} else if(SCONST.FORMAT_TIME == format){ // time format
		    			var date = checkingTime(data);
		    			if(!date) date = checkingDate(data);
		    			if(date){
		    				var tfm = cell.dfm || defaultTimeFormat;
		    				cell.data = Ext.Date.format(date, tfm);
		    				if(!cell.ta) cell.ta = 'right';
                        } else {
		    				cell.data = '######';
                        }

		    		} else if(SCONST.FORMAT_PERCENT == format){
		    			if(isNumber) {
		    				var format = cell.dfm || SCONST.DEFAULT_PERCENT_FORMAT; // this is for detail format - should be end with % ...
		    				cell.data = Ext.util.Format.number(cell.data, format.substring(0, format.length-1)) + '%';
		    				if(!cell.ta) cell.ta = 'right';
		    			}
		    		} else if (SCONST.FORMAT_SCIENCE == format){
		    			if(isNumber) {		
		    				var format = cell.dfm || SCONST.DEFAULT_SCIENCE_FORMAT; 
		    				var fractionSize = HELPER.getExpFractionDigits(format);
		    				cell.data = num.toExponential(fractionSize);
		    				if(!cell.ta) cell.ta = 'right';
		    			}
		    		} else if (SCONST.FORMAT_SPECIAL == format){
		    			if(isNumber) {		   				
		    				cell.data = HELPER.applySpecialFormat(num, cell.dfm);
		    				if(!cell.ta) cell.ta = 'right';
		    			}
		    		} else if('text' == format){
		    			cell.ta = '';
		    		}	    			    	
		    	}  
		    	
		    	if(cell.link && Ext.isDefined(cell.data)){
	    			cell.data = '<a class="ss-cell-inside" href="#">'+cell.data+'</a>';
	    		}
		    	
		    	if(!cell.ta && isBool){
		    		cell.ta = 'right';
		    		cell.data = upper;
		    	}
		    	return cell;
		    },
		    
		    /*
		     * sync the value to the format
		     */
		    syncFormat : function(value, fm){
		    	if(SCONST.FORMAT_DATE == fm){
		    		var date = checkingDate(value);
		    		if(date){
						return {
							data: Ext.Date.format(date, 'Y-m-d')
						};
					}
		    	}else if('time' == fm){
		    		var time = checkingTime(value);
					if(time){
						return {
							data: Ext.Date.format(time, 'H:i')
						};
					}
		    	}else if(SCONST.FORMAT_PERCENT == fm || SCONST.FORMAT_COMMA == fm){
		    		return this.transfer2Number(value);
		    	}
		    },
		    
		    /*
		     * decide the format for the input value
		     */
		    decideFormat : function(value){
		    	/*
				 * if not assign text-align
				 */
				if(SCOM.canbeNumber(value)){
					// if it's number, then format will be regular
					return;
				} 
				
				// if value is object ... ignore it ... just continue ...
				// TODO: for example if I entered: =TEXT(#REF!,\"mmm d\")
				// I will be in problem if I did not catch in here ... thanks
				if (Ext.isObject(value)) return;

				var upper = value.toString().toUpperCase();
				
				// if this is formua which start from =, ignore it, just continue ...
				if (HELPER.startWith(upper, "=")) return;			
				if('TRUE' == upper || 'FALSE' == upper) return {fm: 'bool'};

				// check whether it is url ...
				if (value && value.indexOf(' ')==-1 && SCONST['strictUrlReg'].test(value)){
					var url = value;
					// check whether it is mail format 
					if (Ext.form.field.VTypes.email(value)) url = 'mailto:'+url;	
					else if(!SCONST['urlProReg'].test(url)) url = 'http://'+url;				
					return {link: url};
				} else {
					var refObj = {};
					var date = checkingDate(value, refObj); 
					if(date) {
						return {
							fm: SCONST.FORMAT_DATE, 
							data: Ext.Date.format(date, SCONST.DEFAULT_DATE_FORMAT),
							dfm: refObj.dfm
						};
					} else {
						
						// ok, we need check whether it is time format. 
						// At this moment, let us ignore it. Will be back later -- TODO
						// checkingTime have some problem now - for example: 2014 10 
						
						var o = this.transfer2Number(value);
						if(o) return o;
						return;
					}
				}				
		    },
		    
		    /*
		     * try to transfer a string to number, such as 1,000,000.323	    
		     */
		    transfer2Number : function(value){
		    	var raw = value;
		    	var str = value.toString();
		    	var num = Number(str);
		    	
		    	if(Ext.isNumber(num)){
		    		return {
		    			data: num
		    		};
		    	}
		    	
		    	if(!(/[^0-9,.%]+/gi.test(str))){
		    		var nocomma = str.replace(/,/gi, function(){
						return '';
					});
		    		
		    		var nocommaStr = nocomma;
					nocomma = Number(nocomma);
					if(Ext.isNumber(nocomma)){
						var arr = nocommaStr.split('.');
						var len = arr.length;
						if(1 == len){
							num = Ext.util.Format.number(nocomma, '0,0');
						}else if(2 == len){						
							num = Ext.util.Format.number(Number(arr[0]), '0,0');
							num = num+'.'+arr[1];
						}else{
							/*
							 * there should be more than one .
							 */
							return;
						}					
						if(num == value){							
							value = nocomma;
							return {
								data: value,
								fm: 'comma'
							};							
						}
					}else if(Ext.isString(nocommaStr)){
						
						/*
						 * tranfer string such as 9% to a number
						 */
						var len = nocommaStr.length;
						var lastChr = nocommaStr.charAt(len-1);
						if('%' == lastChr){
							var fig = nocommaStr.slice(0, len-1);
							var num = Number(fig);
							if(Ext.isNumber(num)){
								return {
									data: num/100,						
									fm: SCONST.FORMAT_PERCENT
								};
							}
						}
					}
				}
		    }
		});
	}
}, function(){
	SFORMAT = EnterpriseSheet.sheet.data.Format;
});
Ext.define('EnterpriseSheet.sheet.data.reader.CellReader', {
         
    prepareJson : function(o){
        if(Ext.isArray(o)){
            var json = o[3];
            delete(json.timestamp);
            delete(json.value);
            delete(json.cdtVal);
            if(Ext.isNumber(json.afrow)){           
                /*
                 * special process for array formula cells
                 */
                var row = json.afrow+o[1], col = json.afcol+o[2];
                if(row !== o[1] || col !== o[2]){
                    json.data = '='+SCOM.number2Letter(col)+row;
                }
            }
        }else{
            var json = o.json;
            delete(json.timestamp);
            delete(json.value);
            delete(json.cdtVal);
            if(Ext.isNumber(json.afrow)){
                /*
                 * special process for array formula cells
                 */
                var row = json.afrow+o.row, col = json.afcol+o.col;
                if(row !== o.row || col !== o.col){
                    json.data = '='+SCOM.number2Letter(col)+row;
                }
            }
        }
        return o;
    },
           
    readData : function(root) {
    	if(root){
	        for(var i = 0, len = root.length; i < len; i++){
	            var it = root[i];
	           
	            if(Ext.isArray(it)){
	                var json = {'data': it[3]};
	                if(5 == it.length){
	                	json.cal = true;
	                }
	                root[i] = [it[0], it[1], it[2], json];
	           }
	        }
    	}
        return root;
    },
           
    read : function(root) {
    	if(root){
	        for(var i = 0, len = root.length; i < len; i++){
	            var it = root[i];
	           
	            if(Ext.isArray(it)){
	                var obj;
	                var json = it[3] || {};
	                if(Ext.isString(json)){
	                	json = Ext.decode(json);
	                }
	                
	                obj = [it[0], it[1], it[2], json];
	                
	                this.prepareJson(obj);
	                root[i] = obj;
	            }else{
	                if(Ext.isString(it.json)){
	                    it.json = Ext.decode(it.json);
	                }
	                this.prepareJson(it);
	                root[i] = [it.sheet, it.row, it.col, it.json];
	            }
	        }
    	}
        return root;
    },
           
    readSingle : function(it){
        var json = it[3] || {};
        if(Ext.isString(json)){
        	json = Ext.decode(json);
        }
        
        it[3] = json;
        this.prepareJson(it);
        return it;
    },
           
    readStyle : function(results){
    	if(results){
	        for(var i = 0, len = results.length; i < len; i++){
	            var it = results[i];
	            var json = it[3] || {};
	            if(Ext.isString(json)){
	            	json = Ext.decode(json);
	            }
	            
	            it[3] = json;
	            this.prepareJson(it);
	            results[i] = it;
	        }
    	}
        return results;
    }
}, function(){
	Ext.apply(EnterpriseSheet.sheet.data.reader.CellReader.prototype, {
		/*
		 * the separate char use to create the record's id
		 */
		separateChar : '$',
		
		getIdBasedData : function(data){
			var separateChar = this.separateChar;
			return data.sheet+separateChar+data.row+separateChar+data.col;
		}
	});	
});
Ext.define('EnterpriseSheet.sheet.calculate.Exception', {
	
	singleton : true,
	
	constructor : function(){
				
		this.callParent(arguments);
		
	},
	
	getExceptionInfo : function(e){
		var title, msg, code = e.code;
        var found = this.exceptionInfo[code];
		if(found){
            var info = found(e);
            if(info){
                title = info.title;
                msg = info.msg;
                code = info.code;
            }
		} else{
			title = SLANG['error'];
			if(Ext.isObject(e)){
				msg = e.code;
			}else{
				msg = e.toString();
			}

			if(-1 != msg.indexOf('ReferenceError')){
				title = SLANG['invalid_refer'];
				code = '#REF!';
			}else{
				code = '#ERROR!';
			}
		}
		
		return {
			e: e,
			code: code,
			title: title,
			msg: msg
		}
	},
    
    addExceptionInfo : function(expName, expFun){
        if(!this.exceptionInfo[expName]){
            this.exceptionInfo[expName] = expFun;
            return true;
        }else{
            return false;
        }
    },
           
    exceptionInfo : {
        'CAL_INCORRECT_COORD': function(e){
            /*
             * means the coord is not valid
             */
            return {
                title: SLANG['invalid_refer'],
                msg: Ext.String.format(SLANG['invalid_refer_display'], e.span[0]),
                code: '#REF!'
            }
        },
        'CAL_INFINATE_LOOP': function(e){
            /*
             * means there is a loop reference in the calculate
             */
            return {
                title: SLANG['circle_refer'],
                msg: SLANG['circle_refer_display'],
                code: '#LOOP!'
            }
        },
        'CAL_PARAM_MISS': function(e){
            /*
             * means the number of parameter is not right
             */
            var cal = e.cal || 'UNKNOWN';
            cal = cal.toUpperCase();

            return {
                title: SLANG['param_miss'],
                msg: Ext.String.format(SLANG['param_number_wrong'], cal),
                code: '#PARAM!'
            }
        },
        'CAL_NO_VALUE': function(e){
            /*
             * means can not calculate the value
             */
            var cal = e.cal, msg;
            if(cal){
                cal = cal.toUpperCase();
                msg = Ext.String.format(SLANG['cannot_calculate_value'], cal);
            }else{
                msg = SLANG['value_of_calculate_invalid'];
            }
           
            return {
                title: SLANG['value_invalid'],
                msg: msg,
                code: '#VALUE!'
            }
        },
        'CAL_INDEX_OUT_PARAM_RANG': function(e){
            /*
             * means refer the parameter in the wrong index
             */
            var msg = Ext.String.format(SLANG['index_out_param_range'], e.cal.toUpperCase());
            return {
                title: SLANG['index_out_range'],
                msg: msg,
                code: '#PARAM!'
            }
        },
        'CAL_PARAM_NEED_BE_NUM': function(e){
            /*
             * means the parameter or the value of the reference need be a number
             */
            var msg = Ext.String.format(SLANG['param_need_be_num'], e.cal.toUpperCase());

            return {
                title: SLANG['param_type_wrong'],
                msg: msg,
                code: '#NUM!'
            }
        },
        'NUM_IS_NOT_RIGHT': function(e){
            /*
             * means the parameter or the value of the reference need be a number
             */
            var msg = Ext.String.format(SLANG['number_not_right'], e.cal.toUpperCase());
           
            return {
                title: SLANG['param_type_wrong'],
                msg: msg,
                code: '#NUM!'
            }
        },
        'CAL_PARAM_NOT_MATCH': function(e){
            var msg = Ext.String.format(SLANG['param_should_be_same'], e.cal.toUpperCase());
           
            return {
                title: SLANG['param_not_match'],
                msg: msg,
                code: '#PARAM!'
            }
        },
        'VALUE_NOT_AVAILABLE': function(e){
            return {
                title: SLANG['error'],
                msg: SLANG['value_not_available'],
                code: '#N/A'
            }
        },
        'SS_ERROR_INFINITY': function(e){
            return {
                title: SLANG['error'],
                msg: SLANG['result_infinity'],
                code: '#DIV/0!'
            }
        },
        'CAL_INVALID_NAME': function(e){
            return {
                title: SLANG['invalid_name'],
                msg: SLANG['invalid_name_in_cal'],
                code: '#NAME!'
            }
        }
    }
}, function(){
	SCALEXP = EnterpriseSheet.sheet.calculate.Exception;
});
Ext.define('EnterpriseSheet.sheet.calculate.Coordinate', {
	
	/* Begin Definitions */
	
	requires: ['EnterpriseSheet.common.Common'],		
	
	/* End Definitions */	
	
	/*
	 * transfer relative coord to absoulte coord
	 */
	transfer2Absolute : function(sheetId, row, col, args){
		var arr = [];
		var lineup = function(bus){
			for(var k = 0, count = bus.length; k < count; k++){
				var it = bus[k];
				if(Ext.isArray(it)){
					lineup(it);
				}else{
					arr.push(it);
				}
			}
		}
		lineup(args);
		
		args = arr;
		arr = [];
		for(var i = 0, len = args.length; i < len; i++){
			var arg = args[i];
			if(Ext.isObject(arg)){
				var span = arg['span'] || arg['SPAN'], type = arg['type'] || arg['TYPE'];
				/*
				 * get the coord from the arg
				 */
				var range = this.transferCoord2MinMax(span, sheetId);
				var min = range.min, max = range.max;
				if(SCONST.ABSOLUTE_COORD == type){
					/*
					 * if it's absolute coord, we don't need add the current coord
					 */
					row = col = 0;
				}else if(SCONST.ABSOLUTE_COL_COORD == type){
					/*
					 * if it's absolute coord, we don't need add the current coord
					 */
					col = 0;
				}else if(SCONST.ABSOLUTE_ROW_COORD == type){
					/*
					 * if it's absolute coord, we don't need add the current coord
					 */
					row = 0;
				}
				var minrow = '' === min[1] ? 0 : row+min[1], 
					mincol = '' === min[2] ? 0 : col+min[2], 
					maxrow = '' === max[1] ? 0 : row+max[1], 
					maxcol = '' === max[2] ? 0 : col+max[2];
				arr.push([min[0], minrow, mincol, maxrow, maxcol]);
			}else{
				arr.push(arg);
			}						
		}
		return arr;
	}
}, function(){
    /*
    var reg = /("[^\"]+"([^!\"\']+|$))|('[^\']+([^!\'\"]+|$)')|((((("[^\"]+")|('[^\']+')|([^\=\)\(\+\-\*\/\^\>\<\,\!]+))!)?(\$)?([a-zA-Z]+):(\$)?([a-zA-Z]+)([\s,\}\]\)\+\-\*\/\>\<\=\&]|!=|$))|(((("[^\"]+")|('[^\']+')|([^\=\)\(\+\-\*\/\^\>\<\,\!]+))!)?(\$)?([a-zA-Z]+)(\$)?([0-9]+)(:(\$)?([a-zA-Z]+)(\$)?([0-9]+))?([\s,\}\]\)\+\-\*\/\>\<\=\&]|!=|$))|(((("[^\"]+")|('[^\']+')|([^\=\)\(\+\-\*\/\^\>\<\,\!]+))!)?(\$)?([0-9]+):(\$)?([0-9]+)([\s,\}\]\)\+\-\*\/\>\<\=\&]|!=|$)))/g;
	
    
    var str = '=TEXT("2014-09-07","m/d/yy H:M am/pm"!$B:$D,"sheet2"!1:2)';
    str.replace(reg, function(w){
        console.log([arguments]);
        console.log(w)
    });
    */  
	
	/*
	 * add method to prototype
	 */
	Ext.apply(EnterpriseSheet.sheet.calculate.Coordinate.prototype, {
		dot : '!',
		
		separator : '$',
		
        // sheetNameReg : /^[^\=\)\(\+\-\*\/\^\>\<\!]+$/i,
        
        sheetNameReg : /^[^\=\)\(\+\*\/\^\>\<\!]+$/i,
        
		//sheetNameReg : /^[\w\s\u4e00-\u9eff]+$/i, // add handle for chinese character
		
		//spanReg : /((([\'\"\w\s]+)!)?([a-zA-Z]+):([a-zA-Z]+)([\s,\}\]\)\+\-\*\/\>\<\=\&]|$))|((([\'\"\w\s]+)!)?([a-zA-Z]+)([0-9]+)(:([a-zA-Z]+)([0-9]+))?([\s,\}\]\)\+\-\*\/\>\<\=\&]|$))|((([\'\"\w\s]+)!)?([0-9]+):([0-9]+)([\s,\}\]\)\+\-\*\/\>\<\=\&]|$))|((([\'\"\w\s]+)!)?\$([a-zA-Z]+):\$([a-zA-Z]+)([\s,\}\]\)\+\-\*\/\>\<\=\&]|$))|((([\'\"\w\s]+)!)?\$([a-zA-Z]+)\$([0-9]+)(:\$([a-zA-Z]+)\$([0-9]+))?([\s,\}\]\)\+\-\*\/\>\<\=\&]|$))|((([\'\"\w\s]+)!)?\$([0-9]+):\$([0-9]+)([\s,\}\]\)\+\-\*\/\>\<\=\&]|$))|((([\'\"\w\s]+)!)?\$([a-zA-Z]+)([0-9]+)(:\$([a-zA-Z]+)([0-9]+))?([\s,\}\]\)\+\-\*\/\>\<\=\&]|$))|((([\'\"\w\s]+)!)?([a-zA-Z]+)\$([0-9]+)(:([a-zA-Z]+)\$([0-9]+))?([\s,\}\]\)\+\-\*\/\>\<\=\&]|$))/g,
		
		//spanReg : /((([\'\"\w\s]+)!)?([a-zA-Z]+):([a-zA-Z]+)([\s,\}\]\)\+\-\*\/\>\<\=\&]|!=|$))|((([\'\"\w\s]+)!)?([a-zA-Z]+)([0-9]+)(:([a-zA-Z]+)([0-9]+))?([\s,\}\]\)\+\-\*\/\>\<\=\&]|!=|$))|((([\'\"\w\s]+)!)?([0-9]+):([0-9]+)([\s,\}\]\)\+\-\*\/\>\<\=\&]|!=|$))|((([\'\"\w\s]+)!)?\$([a-zA-Z]+):\$([a-zA-Z]+)([\s,\}\]\)\+\-\*\/\>\<\=\&]|!=|$))|((([\'\"\w\s]+)!)?\$([a-zA-Z]+)\$([0-9]+)(:\$([a-zA-Z]+)\$([0-9]+))?([\s,\}\]\)\+\-\*\/\>\<\=\&]|!=|$))|((([\'\"\w\s]+)!)?\$([0-9]+):\$([0-9]+)([\s,\}\]\)\+\-\*\/\>\<\=\&]|!=|$))|((([\'\"\w\s]+)!)?\$([a-zA-Z]+)([0-9]+)(:\$([a-zA-Z]+)([0-9]+))?([\s,\}\]\)\+\-\*\/\>\<\=\&]|!=|$))|((([\'\"\w\s]+)!)?([a-zA-Z]+)\$([0-9]+)(:([a-zA-Z]+)\$([0-9]+))?([\s,\}\]\)\+\-\*\/\>\<\=\&]|!=|$))/g,
		
        //spanReg : /((([\'\"\w\s\#]+)!)?([a-zA-Z]+):([a-zA-Z]+)([\s,\}\]\)\+\-\*\/\>\<\=\&]|!=|$))|((([\'\"\w\s\#]+)!)?([a-zA-Z]+)([0-9]+)(:([a-zA-Z]+)([0-9]+))?([\s,\}\]\)\+\-\*\/\>\<\=\&]|!=|$))|((([\'\"\w\s\#]+)!)?([0-9]+):([0-9]+)([\s,\}\]\)\+\-\*\/\>\<\=\&]|!=|$))|((([\'\"\w\s\#]+)!)?\$([a-zA-Z]+):\$([a-zA-Z]+)([\s,\}\]\)\+\-\*\/\>\<\=\&]|!=|$))|((([\'\"\w\s\#]+)!)?\$([a-zA-Z]+)\$([0-9]+)(:\$([a-zA-Z]+)\$([0-9]+))?([\s,\}\]\)\+\-\*\/\>\<\=\&]|!=|$))|((([\'\"\w\s\#]+)!)?\$([0-9]+):\$([0-9]+)([\s,\}\]\)\+\-\*\/\>\<\=\&]|!=|$))|((([\'\"\w\s]+)!)?\$([a-zA-Z]+)([0-9]+)(:\$([a-zA-Z]+)([0-9]+))?([\s,\}\]\)\+\-\*\/\>\<\=\&]|!=|$))|((([\'\"\w\s\#]+)!)?([a-zA-Z]+)\$([0-9]+)(:([a-zA-Z]+)\$([0-9]+))?([\s,\}\]\)\+\-\*\/\>\<\=\&]|!=|$))/g,
		//spanReg : /(((\w+)!)?([a-zA-Z]+)([0-9]+)?(:([a-zA-Z]+)([0-9]+)?)?([,\s\)\+\-\*\/\>\<\=]|$))|(((\w+)!)?\$([a-zA-Z]+)\$([0-9]+)?(:\$([a-zA-Z]+)\$([0-9]+)?)?([,\s\)\+\-\*\/\>\<\=]|$))/g,
              
        //spanReg : /((([^\=\)\(\+\-\*\/\^\>\<\!]+)!)?([a-zA-Z]+):([a-zA-Z]+)([\s,\}\]\)\+\-\*\/\>\<\=\&]|!=|$))|((([^\=\)\(\+\-\*\/\^\>\<\!]+)!)?([a-zA-Z]+)([0-9]+)(:([a-zA-Z]+)([0-9]+))?([\s,\}\]\)\+\-\*\/\>\<\=\&]|!=|$))|((([^\=\)\(\+\-\*\/\^\>\<\!]+)!)?([0-9]+):([0-9]+)([\s,\}\]\)\+\-\*\/\>\<\=\&]|!=|$))|((([^\=\!]+)!)?\$([a-zA-Z]+):\$([a-zA-Z]+)([\s,\}\]\)\+\-\*\/\>\<\=\&]|!=|$))|((([^\=\)\(\+\-\*\/\^\>\<\!]+)!)?\$([a-zA-Z]+)\$([0-9]+)(:\$([a-zA-Z]+)\$([0-9]+))?([\s,\}\]\)\+\-\*\/\>\<\=\&]|!=|$))|((([^\=\)\(\+\-\*\/\^\>\<\!]+)!)?\$([0-9]+):\$([0-9]+)([\s,\}\]\)\+\-\*\/\>\<\=\&]|!=|$))|((([^\=\)\(\+\-\*\/\^\>\<\!]+)!)?\$([a-zA-Z]+)([0-9]+)(:\$([a-zA-Z]+)([0-9]+))?([\s,\}\]\)\+\-\*\/\>\<\=\&]|!=|$))|((([^\=\)\(\+\-\*\/\^\>\<\!]+)!)?([a-zA-Z]+)\$([0-9]+)(:([a-zA-Z]+)\$([0-9]+))?([\s,\}\]\)\+\-\*\/\>\<\=\&]|!=|$))/g,
                                
        //spanReg : /((([^\=\)\(\+\-\*\/\^\>\<\,\!]+)!)?([a-zA-Z]+):([a-zA-Z]+)([\s,\}\]\)\+\-\*\/\>\<\=\&]|!=|$))|((([^\=\)\(\+\-\*\/\^\>\<\,\!]+)!)?([a-zA-Z]+)([0-9]+)(:([a-zA-Z]+)([0-9]+))?([\s,\}\]\)\+\-\*\/\>\<\=\&]|!=|$))|((([^\=\)\(\+\-\*\/\^\>\<\,\!]+)!)?([0-9]+):([0-9]+)([\s,\}\]\)\+\-\*\/\>\<\=\&]|!=|$))|((([^\=\)\(\+\-\*\/\^\>\<\,\!]+)!)?\$([a-zA-Z]+):\$([a-zA-Z]+)([\s,\}\]\)\+\-\*\/\>\<\=\&]|!=|$))|((([^\=\)\(\+\-\*\/\^\>\<\,\!]+)!)?\$([a-zA-Z]+)\$([0-9]+)(:\$([a-zA-Z]+)\$([0-9]+))?([\s,\}\]\)\+\-\*\/\>\<\=\&]|!=|$))|((([^\=\)\(\+\-\*\/\^\>\<\,\!]+)!)?\$([0-9]+):\$([0-9]+)([\s,\}\]\)\+\-\*\/\>\<\=\&]|!=|$))|((([^\=\)\(\+\-\*\/\^\>\<\,\!]+)!)?\$([a-zA-Z]+)([0-9]+)(:\$([a-zA-Z]+)([0-9]+))?([\s,\}\]\)\+\-\*\/\>\<\=\&]|!=|$))|((([^\=\)\(\+\-\*\/\^\>\<\,\!]+)!)?([a-zA-Z]+)\$([0-9]+)(:([a-zA-Z]+)\$([0-9]+))?([\s,\}\]\)\+\-\*\/\>\<\=\&]|!=|$))/g,
        
        //spanReg : /((([^\=\)\(\+\-\*\/\^\>\<\,\!]+)!)?([a-zA-Z]+):([a-zA-Z]+)([\s,\}\]\)\+\-\*\/\>\<\=\&]|!=|$))|((([^\=\)\(\+\-\*\/\^\>\<\,\!]+)!)?([a-zA-Z]+)([0-9]+)(:([a-zA-Z]+)([0-9]+))?([\s,\}\]\)\+\-\*\/\>\<\=\&]|!=|$))|((([^\=\)\(\+\-\*\/\^\>\<\,\!]+)!)?([0-9]+):([0-9]+)([\s,\}\]\)\+\-\*\/\>\<\=\&]|!=|$))|((([^\=\)\(\+\-\*\/\^\>\<\,\!]+)!)?\$([a-zA-Z]+):\$([a-zA-Z]+)([\s,\}\]\)\+\-\*\/\>\<\=\&]|!=|$))|((([^\=\)\(\+\-\*\/\^\>\<\,\!]+)!)?\$([a-zA-Z]+)\$([0-9]+)(:\$([a-zA-Z]+)\$([0-9]+))?([\s,\}\]\)\+\-\*\/\>\<\=\&]|!=|$))|((([^\=\)\(\+\-\*\/\^\>\<\,\!]+)!)?\$([0-9]+):\$([0-9]+)([\s,\}\]\)\+\-\*\/\>\<\=\&]|!=|$))|((([^\=\)\(\+\-\*\/\^\>\<\,\!]+)!)?\$([a-zA-Z]+)([0-9]+)(:\$([a-zA-Z]+)([0-9]+))?([\s,\}\]\)\+\-\*\/\>\<\=\&]|!=|$))|((([^\=\)\(\+\-\*\/\^\>\<\,\!]+)!)?([a-zA-Z]+)\$([0-9]+)(:([a-zA-Z]+)\$([0-9]+))?([\s,\}\]\)\+\-\*\/\>\<\=\&]|!=|$))/g,
        //spanReg: /(((("[^\"]+")|('[^\']+')|([^\=\)\(\+\-\*\/\^\>\<\,\!]+))!)?([a-zA-Z]+):([a-zA-Z]+)([\s,\}\]\)\+\-\*\/\>\<\=\&]|!=|$))|(((("[^\"]+")|('[^\']+')|([^\=\)\(\+\-\*\/\^\>\<\,\!]+))!)?([a-zA-Z]+)([0-9]+)(:([a-zA-Z]+)([0-9]+))?([\s,\}\]\)\+\-\*\/\>\<\=\&]|!=|$))|(((("[^\"]+")|('[^\']+')|([^\=\)\(\+\-\*\/\^\>\<\,\!]+))!)?([0-9]+):([0-9]+)([\s,\}\]\)\+\-\*\/\>\<\=\&]|!=|$))|(((("[^\"]+")|('[^\']+')|([^\=\)\(\+\-\*\/\^\>\<\,\!]+))!)?\$([a-zA-Z]+):\$([a-zA-Z]+)([\s,\}\]\)\+\-\*\/\>\<\=\&]|!=|$))|(((("[^\"]+")|('[^\']+')|([^\=\)\(\+\-\*\/\^\>\<\,\!]+))!)?\$([a-zA-Z]+)\$([0-9]+)(:\$([a-zA-Z]+)\$([0-9]+))?([\s,\}\]\)\+\-\*\/\>\<\=\&]|!=|$))|(((("[^\"]+")|('[^\']+')|([^\=\)\(\+\-\*\/\^\>\<\,\!]+))!)?\$([0-9]+):\$([0-9]+)([\s,\}\]\)\+\-\*\/\>\<\=\&]|!=|$))|(((("[^\"]+")|('[^\']+')|([^\=\)\(\+\-\*\/\^\>\<\,\!]+))!)?\$([a-zA-Z]+)([0-9]+)(:\$([a-zA-Z]+)([0-9]+))?([\s,\}\]\)\+\-\*\/\>\<\=\&]|!=|$))|(((("[^\"]+")|('[^\']+')|([^\=\)\(\+\-\*\/\^\>\<\,\!]+))!)?([a-zA-Z]+)\$([0-9]+)(:([a-zA-Z]+)\$([0-9]+))?([\s,\}\]\)\+\-\*\/\>\<\=\&]|!=|$))/g,
        //spanReg: /(((("[^\"]+")|('[^\']+')|([^\=\)\(\+\-\*\/\^\>\<\,\!]+))!)?(\$)?([a-zA-Z]+):(\$)?([a-zA-Z]+)([\s,\}\]\)\+\-\*\/\>\<\=\&]|!=|$))|(((("[^\"]+")|('[^\']+')|([^\=\)\(\+\-\*\/\^\>\<\,\!]+))!)?(\$)?([a-zA-Z]+)(\$)?([0-9]+)(:(\$)?([a-zA-Z]+)(\$)?([0-9]+))?([\s,\}\]\)\+\-\*\/\>\<\=\&]|!=|$))|(((("[^\"]+")|('[^\']+')|([^\=\)\(\+\-\*\/\^\>\<\,\!]+))!)?(\$)?([0-9]+):(\$)?([0-9]+)([\s,\}\]\)\+\-\*\/\>\<\=\&]|!=|$))/g,
		
        spanReg: /("[^\"]*"([^!\"\']|$))|('[^\']*'([^!\'\"]|$))|((((("[^\"]+")|('[^\']+')|([^\=\)\(\+\-\*\/\^\>\<\,\!]+))!)?(\$)?([a-zA-Z]+):(\$)?([a-zA-Z]+)([\s,\}\]\)\+\-\*\/\>\<\=\&]|!=|$))|(((("[^\"]+")|('[^\']+')|([^\=\)\(\+\-\*\/\^\>\<\,\!]+))!)?(\$)?([a-zA-Z]+)(\$)?([0-9]+)(:(\$)?([a-zA-Z]+)(\$)?([0-9]+))?([\s,\}\]\)\+\-\*\/\>\<\=\&]|!=|$))|(((("[^\"]+")|('[^\']+')|([^\=\)\(\+\-\*\/\^\>\<\,\!]+))!)?(\$)?([0-9]+):(\$)?([0-9]+)([\s,\}\]\)\+\-\*\/\>\<\=\&]|!=|$)))/g,
		
		refNameReg : /[\'\"\w]+/g,
		
		transferReg : /\{[^\{\}]+\}/g,
		
		/**
		 * find the {span: [1, 1, 2, 3, 4], type: 1} piece and tranfer it  
		 */
		transferCoordInStr : function(str, fn, scope){
			if(fn){
				return str.replace(this.transferReg, function(w){
					var coord = Ext.decode(w);
					var ret = fn.call(scope, coord);
					if(undefined !== ret){
						return ret;
					}
				});
			}
		},
		
		/*
		 * transfer absoulte span to relative span
		 */
		absoluteSpan2Relative : function(sheetId, row, col, span){
			var arr = [].concat(span);
			/*
			 * if it's current sheet, then we set to ''
			 */
			if(sheetId == arr[0]){
				arr[0] = '';
			}
			/*
			 * if it's 0 for row or col, means it's for a whole row or whole column
			 * so we can not transfer to relative coord, we just set it as ''
			 */	
			arr[1] = 0 === arr[1] ? '' : arr[1]-row;
			arr[2] = 0 === arr[2] ? '' : arr[2]-col;						    
			arr[3] = 0 === arr[3] ? '' : arr[3]-row; 
			arr[4] = 0 === arr[4] ? '' : arr[4]-col;
			return arr;
		},
		
		relativeSpan2Absolute : function(sheetId, row, col, span){
			var arr = [].concat(span);
			/*
			 * if it's current sheet, then we set to ''
			 */
			if('' == arr[0]){
				arr[0] = sheetId;
			}
			/*
			 * if it's 0 for row or col, means it's for a whole row or whole column
			 * so we can not transfer to relative coord, we just set it as ''
			 */	
			arr[1] = '' === arr[1] ? 0 : arr[1]+row;
			arr[2] = '' === arr[2] ? 0 : arr[2]+col;						    
			arr[3] = '' === arr[3] ? 0 : arr[3]+row; 
			arr[4] = '' === arr[4] ? 0 : arr[4]+col;
			return arr;
		},
		
		/*
		 * normalize the coord array to a 5-tpl array
		 * @param {array} arg: the not completed coord range
		 * @param {int} sheetId: the defaultSheetId
		 * @return {array}: return the 5-tpl array: [sheetId, minRow, minCol, maxRow, maxCol]
		 */
		normalizeCoord : function(arg, defaultSheetId){
			if(false == SCOM.typeOf(defaultSheetId)){
				defaultSheetId = '';
			}
			var arr = [];
			var len = arg.length;
			if(2 == len){
				/*
				 * only one cell, and the sheetId is not defined
				 */
				arr = ([defaultSheetId].concat(arg)).concat(arg);
			}else if(3 == len){		
				arr = [].concat(arg);
				arr.push(arg[1]);
				arr.push(arg[2]);
			}else if(4 == len){
				arr = [defaultSheetId].concat(arg);		
			}else if(5 == len){
				arr = [].concat(arg);
				if('' === arg[0]){
					arr[0] = defaultSheetId;
				}	
			}
			return arr;
		},
		
		/*
		 * transfer the arg to an obj: {min:[], max:[]}
		 * both min and max will be a standard 3 length coord array [sheet, row, col]
		 * @param {array} arg: the not completed coord range
		 * @param {int} sheetId: the defaultSheetId
		 * @return {object}: return the {min:[], max:[]}
		 */
		transferCoord2MinMax : function(arg, defaultSheetId){		
			var min, max;
			arg = this.normalizeCoord(arg, defaultSheetId);
			min = [arg[0], arg[1], arg[2]];
			max = [arg[0], arg[3], arg[4]];	
			return {
				min:min,
				max:max
			}
		},
		
		/*
		 * transfer coord to string
		 */
		coord2String : function(coord, separator, withSheet){
			try{
				var ret = '';
				if(false == SCOM.typeOf(separator)){
					separator = this.separator;
				}
				for(var i = 0, len = coord.length; i < len; i++){
					var it = coord[i];
					var span, ctype;
					if(Ext.isArray(it)){
						span = it;
						ctype = SCONST.ABSOLUTE_COORD;
					}else{
						span = it.span;
						ctype = it.type;
					}
					var mm = this.transferCoord2MinMax(span), min = mm.min, max = mm.max;
					var str = '';
					if(min[1] == max[1] && min[2] == max[2]){
						var arr = [];
						if('' !== min[2] && 0 !== min[2]){
							arr.push(SCOM.number2Letter(min[2]));
						}
						if('' !== min[1] && 0 !== min[1]){
							arr.push(min[1]);
						}			
						if(0 === arr.length){
							str = '';
						}else{
							if(SCONST.ABSOLUTE_COORD == ctype){
								str = separator+arr.join(separator);
							}else if(SCONST.ABSOLUTE_ROW_COORD == ctype){
								str = arr.join(separator);
							}else if(SCONST.ABSOLUTE_COL_COORD == ctype){
								str = separator+arr.join('');
							}else{
								str = arr.join('');
							}
							if('' === min[1] || 0 === min[1] || '' === min[2] || 0 === min[2]){
								/*
								 * for single column or row
								 */
								str = str+':'+str;
							}
						}
					}else{
						var arr = [], arr2 = [];
						if(('' !== min[2] && 0 !== min[2]) || ('' !== max[2] && 0 !== max[2])){
							arr.push(SCOM.number2Letter(min[2]));
							if(0 === max[2] || '' === max[2]){
								arr2.push(SCOM.number2Letter(SCONST.MAX_COLUMN_NUMBER));
							}else{
								arr2.push(SCOM.number2Letter(max[2]));
							}
						}
						if(('' !== min[1] && 0 !== min[1]) || ('' !== max[1] && 0 !== max[1])){
							arr.push(min[1]);
							if(0 === max[1] || '' === max[1]){
								arr2.push(SCONST.MAX_ROW_NUMBER);
							}else{
								arr2.push(max[1]);
							}
						}
												
						if(SCONST.ABSOLUTE_COORD == ctype){
							str = separator+arr.join(separator)+':'+separator+arr2.join(separator);
						}else if(SCONST.ABSOLUTE_ROW_COORD == ctype){
							str = arr.join(separator)+':'+arr2.join(separator);
						}else if(SCONST.ABSOLUTE_COL_COORD == ctype){
							str = separator+arr.join('')+':'+separator+arr2.join('');
						}else{
							str = arr.join('')+':'+arr2.join('');
						}
					}			
					if(withSheet && false != SCOM.typeOf(min[0]) && false !== min[0] && '' !== min[0]){								
						min[0] = this.quoteStr(min[0]);
						str = min[0]+this.dot+str;
					}
					if(i != len-1){
						str += ','
					}
					ret += str;
				}		
				return ret;
			}catch(e){
				return '';
			}
		},
		
		quoteStr : function(str){
			if(str){
				str = str.toString();
				//if(-1 != str.indexOf(' ')){
					var firstChr = str.charAt(0), lastChr = str.charAt(str.length-1);
					if(!(firstChr == lastChr && ('"' == firstChr || "'" == firstChr))){
						if(-1 !== str.indexOf('"')){
							str = '"'+str+'"';
						}else{
							str = "'"+str+"'";
						}
						
					}	
				//}					
			}
			return str;
		},
		
		/*
		 * assemble the coord based on the regexp result
		 */
		assembleCoordByRegResult : function(result){
			var sheet, mincol, minrow, maxcol, maxrow, next, type, flag;			
			//console.log(arguments)
			if(result[17]){
				flag = true;
				/*
				 * means it like Sheet1!F1:F8, it's relative coord
				 */
				sheet = result[19], mincol = result[24], minrow = result[26], maxcol = result[29], maxrow = result[31], next = result[32];
                var minColSep = result[23], minRowSep = result[25], maxColSep = result[28], maxRowSep = result[30];
                if(Ext.isDefined(maxcol)){
                    if(minColSep && maxColSep && minRowSep && maxRowSep){
                        type = SCONST.ABSOLUTE_COORD;
                    }else if(minColSep && maxColSep && !minRowSep && !maxRowSep){
                        type = SCONST.ABSOLUTE_COL_COORD;
                    }else if(!minColSep && !maxColSep && minRowSep && maxRowSep){
                        type = SCONST.ABSOLUTE_ROW_COORD;
                    }else{
                        type = SCONST.RELATIVE_COORD;
                    }
                }else{
                    if(minColSep && minRowSep){
                       type = SCONST.ABSOLUTE_COORD;
                    }else{
                       type = SCONST.RELATIVE_COORD;
                    }
                }
			}else if(result[6]){
				flag = true;
				/*
				 * for column range, means it like Sheet1!C:E
				 */
				sheet = result[8], mincol = result[13], maxcol = result[15], next = result[16];
                var minColSep = result[12], maxColSep = result[14];
                if(minColSep && maxColSep){
                    type = SCONST.ABSOLUTE_COORD;
                }else{
                    type = SCONST.RELATIVE_COORD;
                }
			}else if(result[33]){
				flag = true;
				/*
				 * for row range, means it like Sheet1!1:8, it's relative coord
				 */
				sheet = result[35], minrow = result[40], maxrow = result[42], next = result[43];
                var minRowSep = result[39], maxRowSep = result[41];
                if(minRowSep && maxRowSep){
                    type = SCONST.ABSOLUTE_COORD;
                }else{
                    type = SCONST.RELATIVE_COORD;
                }
			}
			
			if(!flag){
				return;
			}
			
			if(minrow){
				minrow = Number(minrow);
			}else{
				minrow = 0;
			}
			if(maxrow){
				maxrow = Number(maxrow);
			}else{
				maxrow = 0;
			}
			if(mincol){
				mincol = SCOM.letter2Number(mincol);
			}else{
				mincol = 0;
			}			
			if(maxcol){
				maxcol = SCOM.letter2Number(maxcol);
			}else{
				maxcol = 0;
			}
			
			if(0 == maxrow && 0 == maxcol){
				/*
				 * both 0 means only one single cell, such as "A2", not "A2:B3"
				 */
				maxrow = minrow;
				maxcol = mincol;
			}
			if(0 === minrow || (minrow > maxrow && 0 !== maxrow)){
				var tmp = minrow;
				minrow = maxrow;
				maxrow = tmp;
			}
			if(0 === mincol || (mincol > maxcol && 0 !== maxcol)){
				var tmp = mincol;
				mincol = maxcol;
				maxcol = tmp;
			}
			/*
			 * if the maxcol is the max column number then transfer to 0
			 */
			if(maxcol == SCONST.MAX_COLUMN_NUMBER){
				maxcol = 0;
				if(1 == mincol){
					mincol = 0;
				}
			}
			/*
			 * if the maxrow is the max row number then transfer to 0
			 */
			if(maxrow == SCONST.MAX_ROW_NUMBER){
				maxrow = 0;
				if(1 == minrow){
					minrow = 0;
				}
			}
			if(sheet){							
				return {
					span:[sheet, minrow, mincol, maxrow, maxcol],
					next:next,
					type:type
				};
			}else{				
				return {
					/*
					 * set sheetId part as ''
					 */
					span:['', minrow, mincol, maxrow, maxcol],
					next:next,
					type:type
				};		
			}
		},
		
        isCoordSpan : function(val){
            this.spanReg.lastIndex = 0;
            var result = this.spanReg.exec(val);			
			if(result){			
				var obj = this.assembleCoordByRegResult(result);
				if(obj){
					return true;
				}
			}
        },
		
		/*
		 * transfer string to coord
		 */
		string2Coord : function(str, sheetId, forceCoordType){
			var coord = [];
			
			var ps = str.split(',');
			for(var i = 0, len = ps.length; i < len; i++){
				var single = ps[i];
				/*
				 * regexp to parse the string to coord, set the index to 0 so it will search at begin
				 */
				this.spanReg.lastIndex = 0;
				var result = this.spanReg.exec(single);			
				if(result){			
					var obj = this.assembleCoordByRegResult(result);
					if(obj){
                    if(SCOM.isEmptyValue(obj.span[0]) && Ext.isDefined(sheetId)){
                        obj.span[0] = sheetId;
                    }
					coord.push({
						span: obj.span,
                        type: Ext.isDefined(forceCoordType) ? forceCoordType : obj.type
					});			
				}			
			}							
			}							
			return coord;	
		},
		
		/*
		 * transfer a coord str to absolute coord str or relative coord str
		 */
		normalizeCoordStr : function(str, separator){
			separator = separator || '';
			var coord = this.string2Coord(str);				
			return this.coord2String(coord, separator, true);
		},
		
		/**
		 * transfer coord to cell lookup
		 */
		transferCoord2CellLookup : function(coord){
            var lookup = {}, visited = {};
            try{
                var separateChar = EnterpriseSheet.sheet.data.reader.CellReader.prototype.separateChar;
                for(var i = 0, len = coord.length; i < len; i++){
                    var span = coord[i];
                    var cid = span.join(separateChar);
                    if(!visited[cid]){
                        visited[cid] = true;
                        var sheetId = span[0], minrow = span[1], maxrow = span[3], mincol = span[2], maxcol = span[4];
                        if(0 === maxrow){
                        	minrow = 0;
                        }
                        if(0 === maxcol){
                        	mincol = maxcol;
                        }
                        for(var j = minrow; j <= maxrow; j++){
                            for(var k = mincol; k <= maxcol; k++){
                                var arr = [sheetId, j, k];
                                var id = arr.join(separateChar);
                                lookup[id] = arr;
                            }
                        }
                    }
                }
            }catch(e){}
                       
			return lookup;
		},
                       
        /**
         * transfer coord to cell lookup
         */
        transferCoord2CellMap : function(coord){
            var lookup = {}, visited = {};
            var separateChar = EnterpriseSheet.sheet.data.reader.CellReader.prototype.separateChar;
            for(var i = 0, len = coord.length; i < len; i++){
                var span = coord[i];
                var cid = span.join(separateChar);
                if(!visited[cid]){
                    visited[cid] = true;
                    var sheetId = span[0], minrow = span[1], maxrow = span[3], mincol = span[2], maxcol = span[4];
                       
                    for(var j = minrow; j <= maxrow; j++){
                        for(var k = mincol; k <= maxcol; k++){
                            var id = [sheetId, j, k].join(separateChar);
                            lookup[id] = true;
                        }
                    }
                }
            }
            return lookup;
        },
		
		/**
		 * to absolute coord arr
		 */
		toCoordArr : function(coord){
			var arr = [];
			for(var i = 0, len = coord.length; i < len; i++){
				var it = coord[i];
				if(Ext.isObject(it)){
					var span = it['span'] || it['SPAN'];
					arr.push(span);
				}else{
					arr.push(it);
				}
			}
			return arr;
		},
		
		/**
		 * return true if 2 span is overlapped
		 */
		isOverlappedSpan : function(span1, span2){
			if(span1[0] === span2[0]){
				if(((span1[1] <= span2[1] && (span2[1] <= span1[3] || 0 === span1[3])) || (span1[1] <= span2[3] && (span2[3] <= span1[3] || 0 === span1[3]))) &&
					((span1[2] <= span2[2] && (span2[2] <= span1[4] || 0 === span1[4])) || (span1[2] <= span2[4] && (span2[4] <= span1[4] || 0 === span1[4])))){
					return true;
                }else if(((span2[1] <= span1[1] && (span1[1] <= span2[3] || 0 === span2[3])) || (span2[1] <= span1[3] && (span1[3] <= span2[3] || 0 === span2[3]))) &&
                    ((span2[2] <= span1[2] && (span1[2] <= span2[4] || 0 === span2[4])) || (span2[2] <= span1[4] && (span1[4] <= span2[4] || 0 === span2[4])))){
					return true;
				}				
			}
			return false;
		},
                       
        isOverlappedCoord : function(coord1, coord2){
            for(var i = 0, len = coord1.length; i < len; i++){
                var span1 = coord1[i];
                for(var j = 0, count = coord2.length; j < count; j++){
                    if(this.isOverlappedSpan(span1, coord2[j])){
                        return true;
                    }
                }
            }
        },
        
        /**
         * return true if span a includes span b
         */
        isIncludedSpan : function(span1, span2){
            if(span1[0] === span2[0]){
                if(span1[1] <= span2[1] && (span2[3] <= span1[3] || 0 === span1[3])
                    && span1[2] <= span2[2] && (span2[4] <= span1[4] || 0 === span1[4])){
                    return true;
                }
            }
            return false;
		},
                              
        isCellInSpan : function(cell, span){
            if(cell[0] === span[0]){
                if((0 === span[3] || (cell[1] >= span[1] && cell[1] <= span[3]))
                    && (0 === span[4] || (cell[2] >= span[2] && cell[2] <= span[4]))){
                    return true;
                }
            }
            return false;
        },
                       
        isCellInCoord : function(cell, coord){
            for(var i = 0, len = coord.length; i < len; i++){
                var span = coord[i];
                if(this.isCellInSpan(cell, span)){
                    return true;
                }
            }
            return false;
        }
	});
});
Ext.define('EnterpriseSheet.sheet.calculate.Calculate', {
	
	/* Begin Definitions */
	
	extend : 'EnterpriseSheet.sheet.calculate.Coordinate',				
	
	requires: [
        'EnterpriseSheet.common.Helper',
        'EnterpriseSheet.common.FormulaHelper',
        'EnterpriseSheet.sheet.calculate.Exception',
        'EnterpriseSheet.sheet.data.reader.CellReader'
    ],
	
	/* End Definitions */
	lookup : {},
	
	_exposeFns : {},
	
	_exposeScope : {},
	
	_exposeEnv : {},
	
    statics : {
        /*
         * the condition property usually has one more 'c' at start than the origin property
        */
        calGeneratedStyles : ['clink', 'cfm', 'onCellClickFn', 'onCellDoubleClickFn', 'onCellMouseDownFn', 'onCellMouseMoveFn', 'onCellFocusFn', 'onCellBlurFn'],
        calGeneratedStyleMap : {'clink': 'link', 'cfm': 'fm'}
    },
	
	constructor : function(){
		this.callParent();
	},	
	
	/*
	 * init the calculate 
	 */
	init : function(sheet){
		if(this.sheet){
			return;
		}
		this.sheet = sheet;
	},
	
	adjustCalForRemoveRow : function(config){
		var json = config.json, osheetId = config.osheetId, sheetId = config.sheetId, preChanged = config.preChanged, changed = config.changed, 
		minrow = config.minrow, maxrow = config.maxrow, dspan = config.dspan, related = config.related;
		var me = this, store = me.sheet.getStore();
		this.spanReg.lastIndex = 0;
		var arg = json.data.replace(this.spanReg, function(w){	
			var pos = arguments[arguments.length-2];
			var str = arguments[arguments.length-1];						
		
			var ret = me.assembleCoordByRegResult(arguments);
			if(!ret){
				return w;
			}
			var arr = ret.span, next = ret.next, ctype = ret.type, separator = me.separator;
			if(SCONST.RELATIVE_COORD == ctype){
				separator = '';
				if(preChanged){
					changed = true;
				}
			}
			/*
			 * normlize the coord to 5-tpl
			 */
			arr = EnterpriseSheet.sheet.calculate.Coordinate.prototype.normalizeCoord(arr);		
			var withSheetName = ('' !== arr[0] && 'string' == SCOM.typeOf(arr[0])), sheetName = arr[0];
			if(withSheetName){							
				/*
				 * if sheet part is a stirng and not '', means it should be as 'Sheet1', we need transfer the name to id
				 */						
				arr[0] = store.getSheetIdByName(sheetName);
			}	
			
			/*
			 * check whether the remove affect this span
			 */
			if(sheetId === arr[0] || ('' === arr[0] && osheetId == sheetId)){
				var oldEndRow = arr[3];
				if(minrow < arr[1]){
					if(maxrow >= arr[1]){
						arr[1] = minrow;
					}else{
						arr[1] -= dspan;
					}
					if(0 !== arr[3]){
						arr[3] -= dspan;
					}								
					changed = true;
				}else if(minrow <= arr[3]){
					if(maxrow > arr[3]){
						arr[3] = minrow-1;
					}else{
						arr[3] -= dspan;
					}
					changed = true;
				}
                if(changed){
                    if(arr[1] > arr[3] && 0 !== oldEndRow){
                        return '0'+next;
                    }else{
                        arr[0] = sheetName;
                        str = me.coord2String([{
                            span: arr,
                            type: ctype
                        }], separator, withSheetName);
                        return str+next;
                    }
                }else if(0 === arr[1]){
                    related = true;
                }
			}
			return w;
		});
		
		return {
			text: arg,
			changed: changed,
			related: related
		}
	},
	/*
	 * adjust formula for remove row
	 */
	beforeRemoveRow : function(sheetId, minrow, maxrow){			
		var me = this;
		var dspan = maxrow-minrow+1, coord = [[sheetId, minrow, 0, maxrow, 0]];
		var store = this.sheet.getStore(), oldCalCache = {}, curCalCache = {};			
		store.each(function(rd){
			var osheetId = rd.data.sheet, orow = row = rd.data.row, col = rd.data.col, json = rd.data.json, changed = false, related = false,
				/*
				 * for calcualte cell in current sheet, we need preChanged to flag this cell is moved after remove action
				 * so if this cell has relative references, we need set changed to true and reset the calculate
				 */
				preChanged = false;
			if(json.cal){
				flag = true;
				if(row >= minrow && osheetId === sheetId){
					/*
					 * add span for the rows behind the removed span
					 */
					row += dspan;
					preChanged = true;
				}
				if(row < minrow || row > maxrow || osheetId !== sheetId){
					var ret = me.adjustCalForRemoveRow({
						json: json, 
						osheetId: osheetId, 
						sheetId: sheetId, 
						preChanged: preChanged, 
						changed: changed,
						minrow: minrow,
						maxrow: maxrow,
						dspan: dspan,
						related: related
					});
					var arg = ret.text;
					changed = ret.changed;
					related = ret.related;
                   
					if(changed){									
						var o = this.transferCalculate({'data': arg}, store, osheetId, orow, col);
						var cell = store.getCell(osheetId, orow, col, true);
						var curId = store.getIdBasedData({sheet: osheetId, row: orow, col: col}), oldId = curId;
						if(row !== orow){
							oldId = store.getIdBasedData({sheet: osheetId, row: row, col: col});
						}	
						/*
						 * save old cal
						 */
						oldCalCache[oldId] = {
							'sheet': osheetId,
							'row': row,
							'col': col,
							'json': {
								'data': cell.data,
								'arg': cell.arg,
                                'refs': cell.refs
							}							
						};
						store.setCell(osheetId, orow, col, {							
							'data': arg,
							'arg': o.arg,
							'refs': o.refs
						}, null, true);
						/*
						 * save current cal
						 */						
						curCalCache[curId] = {
							'sheet': osheetId,
							'row': orow,
							'col': col,	
							'json': {
								'data': arg,
								'arg': o.arg,
                                'refs': o.refs
							}							
						};
                    }else if(related){
                        var curId = store.getIdBasedData({sheet: osheetId, row: orow, col: col}), oldId = curId;
                        if(row !== orow){
                            oldId = store.getIdBasedData({sheet: osheetId, row: row, col: col});
                        }
                        oldCalCache[oldId] = true;
                        curCalCache[curId] = true;
                    }
				}						
			}
		}, this);	
		var deletedNameRef = {};
		var needRefreshCal = store.checkNameRefForDeleteRow(sheetId, minrow, maxrow, deletedNameRef);
		if(SCOM.countObjMember(oldCalCache) && SCOM.countObjMember(curCalCache)){
			needRefreshCal = true;
		}
		return {
			oldCal: oldCalCache,
			curCal: curCalCache,
			needRefreshCal: needRefreshCal,
			deletedNameRef: deletedNameRef
		};
	},
	
	adjustCalForRemoveColumn : function(config){
		var json = config.json, osheetId = config.osheetId, sheetId = config.sheetId, preChanged = config.preChanged, changed = config.changed, 
		mincol = config.mincol, maxcol = config.maxcol, dspan = config.dspan, related = config.related;
		var me = this, store = me.sheet.getStore();
		
		this.spanReg.lastIndex = 0;
		var arg = json.data.replace(this.spanReg, function(w){	
			var pos = arguments[arguments.length-2];
			var str = arguments[arguments.length-1];						
			                    
			var ret = me.assembleCoordByRegResult(arguments);
			if(!ret){
				return w;
			}
			var arr = ret.span, next = ret.next, ctype = ret.type, separator = me.separator;		
			
			if(SCONST.RELATIVE_COORD == ctype){
				separator = '';
				if(preChanged){
					changed = true;
				}
			}
			/*
			 * normlize the coord to 5-tpl
			 */
			arr = EnterpriseSheet.sheet.calculate.Coordinate.prototype.normalizeCoord(arr);
			var withSheetName = ('' !== arr[0] && 'string' == SCOM.typeOf(arr[0])), sheetName = arr[0];						
			if(withSheetName){							
				/*
				 * if sheet part is a stirng and not '', means it should be as 'Sheet1', we need transfer the name to id
				 */
				arr[0] = store.getSheetIdByName(sheetName);
			}
			
			if(sheetId === arr[0] || ('' === arr[0] && osheetId == sheetId)){		
				var oldEndCol = arr[4];
				if(mincol < arr[2]){
					if(maxcol >= arr[2]){
						arr[2] = mincol;
					}else{
						arr[2] -= dspan;
					}
					if(0 !== arr[4]){
						arr[4] -= dspan;
					}								
					changed = true;
				}else if(mincol <= arr[4]){
					if(maxcol > arr[4]){
						arr[4] = mincol-1;
					}else{
						arr[4] -= dspan;
					}
					changed = true;
				}		
				
				if(arr[2] > arr[4] && 0 !== oldEndCol){
					return '';
				}else{
					arr[0] = sheetName;
					str = me.coord2String([{
						span: arr,
						type: ctype
					}], separator, withSheetName);																
					return str+next;
				}							
			}
			return w;
		});	
		
		return {
			text: arg,
			changed: changed,
			related: related
		}
	},
	
	beforeRemoveColumn : function(sheetId, mincol, maxcol){				
		var me = this;
		var dspan = maxcol-mincol+1;
		var store = this.sheet.getStore(), oldCalCache = {}, curCalCache = {};
		store.each(function(rd){
			var osheetId = rd.data.sheet, row = rd.data.row, ocol = col = rd.data.col, json = rd.data.json, changed = false, preChanged = false;
			if(json.cal){								
				if(col >= mincol && osheetId === sheetId){
					/*
					 * add span for the rows behind the removed span
					 */
					col += dspan;
					preChanged = true;
				}
				if(col < mincol || col > maxcol || osheetId !== sheetId){
					var ret = me.adjustCalForRemoveColumn({
						json: json, 
						osheetId: osheetId, 
						sheetId: sheetId, 
						preChanged: preChanged, 
						changed: changed,
						mincol: mincol,
						maxcol: maxcol,
						dspan: dspan
					});
					var arg = ret.text;
					changed = ret.changed;							
					
					if(changed){									
						var o = this.transferCalculate({'data': arg}, store, osheetId, row, ocol);
						var cell = store.getCell(osheetId, row, ocol, true);
						var curId = store.getIdBasedData({sheet: osheetId, row: row, col: ocol}), oldId = curId;
						if(col !== ocol){
							oldId = store.getIdBasedData({sheet: osheetId, row: row, col: col});
						}	
						/*
						 * save old cal
						 */
						oldCalCache[oldId] = {
							'sheet': osheetId,
							'row': row,
							'col': col,
							'json': {
								'data': cell.data,
								'arg': cell.arg,
                                'refs': cell.refs
							}							
						};
						store.setCell(osheetId, row, ocol, {
							'data': arg,
							'arg': o.arg,
							'refs': o.refs
						}, null, true);
						/*
						 * save current cal
						 */						
						curCalCache[curId] = {
							'sheet': osheetId,
							'row': row,
							'col': ocol,	
							'json': {
								'data': arg,
								'arg': o.arg,
                                'refs': o.refs
							}							
						};
					}
				}						
			}
		}, this);
		var deletedNameRef = {};
		var needRefreshCal = store.checkNameRefForDeleteColumn(sheetId, mincol, maxcol, deletedNameRef);
		if(SCOM.countObjMember(oldCalCache) && SCOM.countObjMember(curCalCache)){
			needRefreshCal = true;			
		}
		
		return {
			oldCal: oldCalCache,
			curCal: curCalCache,
			needRefreshCal: needRefreshCal,
			deletedNameRef: deletedNameRef
		};
	},
	
	adjustCalForRemoveCell : function(config){
		var json = config.json, osheetId = config.osheetId, sheetId = config.sheetId, preChanged = config.preChanged, changed = config.changed, moveDir = config.moveDir, 
		minrow = config.minrow, maxrow = config.maxrow, mincol = config.mincol, maxcol = config.maxcol, rowSpan = config.rowSpan, colSpan = config.colSpan;
		var me = this, store = me.sheet.getStore();
		
		this.spanReg.lastIndex = 0;
		var arg = json.data.replace(this.spanReg, function(w){	
			var pos = arguments[arguments.length-2];
			var str = arguments[arguments.length-1];						
								
			var ret = me.assembleCoordByRegResult(arguments);
			if(!ret){
				return w;
			}
			var arr = ret.span, next = ret.next, ctype = ret.type, separator = me.separator;
			if(SCONST.RELATIVE_COORD == ctype){
				separator = '';
				if(preChanged){
					changed = true;
				}
			}
			/*
			 * normlize the coord to 5-tpl
			 */
			arr = EnterpriseSheet.sheet.calculate.Coordinate.prototype.normalizeCoord(arr);
			var withSheetName = ('' !== arr[0] && 'string' == SCOM.typeOf(arr[0])), sheetName = arr[0]; 
			if(withSheetName){
				/*
				 * if sheet part is a stirng and not '', means it should be as 'Sheet1', we need transfer the name to id
				 */
				arr[0] = store.getSheetIdByName(arr[0]);
			}
			
			if(sheetId === arr[0] || ('' === arr[0] && osheetId == sheetId)){
										
				var oldEndRow = arr[3], oldEndCol = arr[4];
				if(minrow <= arr[1] && arr[3] <= maxrow){								
					if(mincol < arr[2]){
						if('left' == moveDir){
							if(maxcol >= arr[2]){
								arr[2] = mincol;
							}else{
								arr[2] -= colSpan;
							}
							if(0 !== arr[4]){
								arr[4] -= colSpan;
							}											
							changed = true;
						}else{
							if(maxcol >= arr[2] && 0 !== arr[2]){
								arr[2] = maxcol+1;
								changed = true;
							}
						}																		
					}else if(mincol <= arr[4]){
						if('left' == moveDir){
							if(maxcol > arr[4]){
								arr[4] = mincol-1;
							}else{
								arr[4] -= colSpan;
							}			
							changed = true;
						}else{
							if(maxcol > arr[4]){
								arr[4] = mincol-1;	
								changed = true;
							}else if(mincol == arr[2]){
								arr[2] = maxcol+1;
								changed = true;
							}										
						}									
					}
				}else if(mincol <= arr[2] && arr[4] <= maxcol){
					if(minrow < arr[1]){
						if('up' == moveDir){
							if(maxrow >= arr[1]){
								arr[1] = minrow;
							}else{
								arr[1] -= rowSpan;
							}
							if(0 !== arr[3]){
								arr[3] -= rowSpan;
							}										
							changed = true;
						}else{
							if(maxrow >= arr[1] && 0 !== arr[1]){
								arr[1] = maxrow+1;		
								changed = true;
							}
						}																	
					}else if(minrow <= arr[3]){
						if('up' == moveDir){
							if(maxrow > arr[3]){
								arr[3] = minrow-1;
							}else{
								arr[3] -= rowSpan;
							}
							changed = true;
						}else{
							if(maxrow > arr[3]){
								arr[3] = minrow-1;	
								changed = true;
							}else if(minrow == arr[1]){
								arr[1] = maxrow+1;
								changed = true;
							}
						}																	
					}
				}							
				if((arr[2] > arr[4] && 0 !== oldEndCol) || (arr[1] > arr[3] && 0 !== oldEndRow)){
					return next;
				}else{
					arr[0] = sheetName;
					str = me.coord2String([{
						span: arr,
						type: ctype
					}], separator, withSheetName);																
					return str+next;
				}							
			}
			return w;
		});
		
		return {
			text: arg,
			changed: changed
		}
	},
	
	beforeRemoveCell : function(sheetId, minrow, maxrow, mincol, maxcol, moveDir){
		var me = this;			
		var rowSpan = maxrow-minrow+1, colSpan = maxcol-mincol+1;
		var store = this.sheet.getStore(), oldCalCache = {}, curCalCache = {};
		store.each(function(rd){
			var osheetId = rd.data.sheet, orow = row = rd.data.row, ocol = col = rd.data.col, json = rd.data.json;
			if(json.cal){	
				var changed = false, preChanged = false;
				if('up' == moveDir && osheetId === sheetId && row >= minrow && ocol >= mincol && ocol <= maxcol){
					/*
					 * add span for the rows behind the removed span
					 */
					row += rowSpan;
					preChanged = true;
				}
				if('left' == moveDir && osheetId === sheetId && col >= mincol && orow >= minrow && orow <= maxrow){
					/*
					 * add span for the cols behind the removed span
					 */
					col += colSpan;
					preChanged = true;
				}
				if(col < mincol || col > maxcol || row < minrow || row > maxrow || osheetId !== sheetId){		
					var ret = me.adjustCalForRemoveCell({
						json: json, 
						osheetId: osheetId, 
						sheetId: sheetId, 
						preChanged: preChanged, 
						changed: changed,
						minrow: minrow,
						maxrow: maxrow,
						mincol: mincol,
						maxcol: maxcol,
						rowSpan: rowSpan,
						colSpan: colSpan,
						moveDir: moveDir
					});
					var arg = ret.text;
					changed = ret.changed;
					
					if(changed){						
						var o = this.transferCalculate({'data': arg}, store, osheetId, orow, ocol);
						var cell = store.getCell(osheetId, orow, ocol, true);
						var curId = store.getIdBasedData({sheet: osheetId, row: orow, col: ocol}), oldId = curId;
						if(col !== ocol || row !== orow){
							oldId = store.getIdBasedData({sheet: osheetId, row: row, col: col});
						}	
						/*
						 * save old cal
						 */
						oldCalCache[oldId] = {
							'sheet': osheetId,
							'row': row,
							'col': col,
							'json': {
								'data': cell.data,
								'arg': cell.arg,
                                'refs': cell.refs
							}							
						};
						store.setCell(osheetId, orow, ocol, {
							'data': arg,
							'arg': o.arg,
							'refs': o.refs
						}, null, true);
						/*
						 * save current cal
						 */						
						curCalCache[curId] = {
							'sheet': osheetId,
							'row': orow,
							'col': ocol,	
							'json': {
								'data': arg,
								'arg': o.arg,
                                'refs': o.refs
							}							
						};
					}								
				}				
			}
		}, this);
		
		var deletedNameRef = {};
		var needRefreshCal = store.checkNameRefForDeleteCell(sheetId, minrow, maxrow, mincol, maxcol, moveDir, deletedNameRef);
		if(SCOM.countObjMember(oldCalCache) && SCOM.countObjMember(curCalCache)){
			needRefreshCal = true;			
		}
		
		return {
			oldCal: oldCalCache,
			curCal: curCalCache,
			needRefreshCal: needRefreshCal,
			deletedNameRef: deletedNameRef
		};
	},
	
	adjustCalForInsertRow : function(config){
		var json = config.json, osheetId = config.osheetId, sheetId = config.sheetId, preChanged = config.preChanged, changed = config.changed, 
			minrow = config.minrow, rowSpan = config.rowSpan;
		var me = this, store = me.sheet.getStore();
		this.spanReg.lastIndex = 0;
		var arg = json.data.replace(this.spanReg, function(w){
			var pos = arguments[arguments.length-2];
			var str = arguments[arguments.length-1];						

			var ret = me.assembleCoordByRegResult(arguments);
			if(!ret){
				return w;
			}
			var arr = ret.span, next = ret.next, ctype = ret.type, separator = me.separator;
			if(SCONST.RELATIVE_COORD == ctype){
				separator = '';
				if(preChanged){
					changed = true;
				}
			}
									
			var inFun = me.isInFun(str, pos);
			/*
			 * normlize the coord to 5-tpl
			 */
			arr = EnterpriseSheet.sheet.calculate.Coordinate.prototype.normalizeCoord(arr);
			var withSheetName = ('' !== arr[0] && 'string' == SCOM.typeOf(arr[0])), sheetName = arr[0];
			if(withSheetName){
				/*
				 * if sheet part is a stirng and not '', means it should be as 'Sheet1', we need transfer the name to id
				 */
				arr[0] = store.getSheetIdByName(arr[0]);
			}
			
			if(sheetId === arr[0] || ('' === arr[0] && osheetId == sheetId)){							
				if(minrow <= arr[1]){
					arr[1] += rowSpan;
					if(0 !== arr[3]){
						arr[3] += rowSpan;
					}								
					changed = true;
				}else if(minrow <= arr[3]){
					/*
					 * special for something like C1+C3
					 */
					if(arr[1] == arr[3] && !inFun){
						arr[1] += rowSpan;
					}
					arr[3] += rowSpan;
					changed = true;
				}
				arr[0] = sheetName;						
				str = me.coord2String([{
					span: arr,
					type: ctype
				}], separator, withSheetName);															
				
				return str+next;
			}
			return w;
		});
		return {
			text: arg,
			changed: changed			
		};
	},
	
	beforeInsertRow : function(sheetId, minrow, rowSpan, mincol, maxcol){
		var me = this;		
		var maxrow = minrow+rowSpan-1;
		var store = this.sheet.getStore(), oldCalCache = {}, curCalCache = {};
		store.each(function(rd){
			var osheetId = rd.data.sheet, orow = row = rd.data.row, col = rd.data.col, json = rd.data.json;
			if(json.cal){								
				var changed = false, preChanged = false;
				if(row > maxrow && osheetId === sheetId){
					/*
					 * remove span for the rows behind the inserted span
					 */
					row -= rowSpan;
					preChanged = true;
				}
				if(orow < minrow || orow >= maxrow || osheetId !== sheetId){
					var ret = me.adjustCalForInsertRow({
						json: json, 
						osheetId: osheetId, 
						sheetId: sheetId, 
						preChanged: preChanged, 
						changed: changed,
						minrow: minrow,
						rowSpan: rowSpan
					});
					var arg = ret.text;
					changed = ret.changed;
					if(changed){						
						var o = this.transferCalculate({'data': arg}, store, osheetId, orow, col);
						var cell = store.getCell(osheetId, orow, col, true);
						var curId = store.getIdBasedData({sheet: osheetId, row: orow, col: col}), oldId = curId;
						if(row !== orow){
							oldId = store.getIdBasedData({sheet: osheetId, row: row, col: col});
						}	
						/*
						 * save old cal
						 */
						oldCalCache[oldId] = {
							'sheet': osheetId,
							'row': row,
							'col': col,
							'json': {
								'data': cell.data,
								'arg': cell.arg,
                                'refs': cell.refs
							}							
						};
						store.setCell(osheetId, orow, col, {
							'data': arg,
							'arg': o.arg,
							'refs': o.refs
						}, null, true);
						/*
						 * save current cal
						 */						
						curCalCache[curId] = {
							'sheet': osheetId,
							'row': orow,
							'col': col,	
							'json': {
								'data': arg,
								'arg': o.arg,
                                'refs': o.refs
							}							
						};
					}
				}								
			}
		}, this);	
		/*
		 * check name ref change
		 */
		var needRefreshCal = store.checkNameRefForInsertRow(sheetId, minrow, rowSpan);
		if(SCOM.countObjMember(oldCalCache) && SCOM.countObjMember(curCalCache)){
			needRefreshCal = true;			
		}
		return {
			oldCal: oldCalCache,
			curCal: curCalCache,
			needRefreshCal: needRefreshCal
		};
	},
	
	adjustCalForInsertColumn : function(config){
		var json = config.json, osheetId = config.osheetId, sheetId = config.sheetId, preChanged = config.preChanged, changed = config.changed, 
			mincol = config.mincol, colSpan = config.colSpan;
		var me = this, store = me.sheet.getStore();
		this.spanReg.lastIndex = 0;
		var arg = json.data.replace(this.spanReg, function(w){
			var pos = arguments[arguments.length-2];
			var str = arguments[arguments.length-1];
								
			var ret = me.assembleCoordByRegResult(arguments);
			if(!ret){
				return w;
			}
			var arr = ret.span, next = ret.next, ctype = ret.type, separator = me.separator;
			if(SCONST.RELATIVE_COORD == ctype){
				separator = '';
				if(preChanged){
					changed = true;
				}
			}
									
			var inFun = me.isInFun(str, pos);
			/*
			 * normlize the coord to 5-tpl
			 */
			arr = EnterpriseSheet.sheet.calculate.Coordinate.prototype.normalizeCoord(arr);		
			var withSheetName = ('' !== arr[0] && 'string' == SCOM.typeOf(arr[0])), sheetName = arr[0];
			if(withSheetName){
				/*
				 * if sheet part is a stirng and not '', means it should be as 'Sheet1', we need transfer the name to id
				 */
				arr[0] = store.getSheetIdByName(arr[0]);
			}
			
			if(sheetId === arr[0] || ('' === arr[0] && osheetId == sheetId)){							
				if(mincol <= arr[2]){
					arr[2] += colSpan;
					if(0 !== arr[4]){
						arr[4] += colSpan;
					}								
					changed = true;
				}else if(mincol <= arr[4]){								
					/*
					 * special for something like C1+C3
					 */
					if(arr[2] == arr[4] && !inFun){
						arr[2] += colSpan;
					}
					arr[4] += colSpan;
					changed = true;
				}
				arr[0] = sheetName;						
				str = me.coord2String([{
					span: arr,
					type: ctype
				}], separator, withSheetName);															
				return str+next;
			}
			return w;
		});
		return {
			text: arg,
			changed: changed			
		};
	},
	
	beforeInsertColumn : function(sheetId, mincol, colSpan, minrow, maxrow){
		var me = this;		
		var maxcol = mincol+colSpan-1;
		var store = this.sheet.getStore(), oldCalCache = {}, curCalCache = {};
		store.each(function(rd){
			var osheetId = rd.data.sheet, row = rd.data.row, ocol = col = rd.data.col, json = rd.data.json;
			if(json.cal){					
				var changed = false, preChanged = false;
				if(col > maxcol && osheetId === sheetId){
					/*
					 * remove span for the cols behind the inserted span
					 */
					col -= colSpan;
					preChanged = true;
				}
				if(ocol < mincol || ocol >= maxcol || osheetId !== sheetId){
					var ret = me.adjustCalForInsertColumn({
						json: json, 
						osheetId: osheetId, 
						sheetId: sheetId, 
						preChanged: preChanged, 
						changed: changed,
						mincol: mincol,
						colSpan: colSpan
					});
					var arg = ret.text;
					changed = ret.changed;
					
					if(changed){						
						var o = this.transferCalculate({'data': arg}, store, osheetId, row, ocol);
						var cell = store.getCell(osheetId, row, ocol, true);
						var curId = store.getIdBasedData({sheet: osheetId, row: row, col: ocol}), oldId = curId;
						if(col !== ocol){
							oldId = store.getIdBasedData({sheet: osheetId, row: row, col: col});
						}	
						/*
						 * save old cal
						 */
						oldCalCache[oldId] = {
							'sheet': osheetId,
							'row': row,
							'col': col,
							'json': {
								'data': cell.data,
								'arg': cell.arg,
                                'refs': cell.refs
							}							
						};
						store.setCell(osheetId, row, ocol, {
							'data': arg,
							'arg': o.arg,
							'refs': o.refs
						}, null, true);
						/*
						 * save current cal
						 */						
						curCalCache[curId] = {
							'sheet': osheetId,
							'row': row,
							'col': ocol,	
							'json': {
								'data': arg,
								'arg': o.arg,
                                'refs': o.refs
							}							
						};
					}
				}								
			}
		}, this);
		var needRefreshCal = store.checkNameRefForInsertColumn(sheetId, mincol, colSpan);
		if(SCOM.countObjMember(oldCalCache) && SCOM.countObjMember(curCalCache)){
			needRefreshCal = true;			
		}
		return {
			oldCal: oldCalCache,
			curCal: curCalCache,
			needRefreshCal: needRefreshCal
		};
	},
	
	adjustCalForInsertCell : function(config){
		var json = config.json, osheetId = config.osheetId, sheetId = config.sheetId, preChanged = config.preChanged, changed = config.changed, 
			minrow = config.minrow, rowSpan = config.rowSpan, mincol = config.mincol, colSpan = config.colSpan, moveDir = config.moveDir,
			maxrow = minrow+rowSpan-1, maxcol = mincol+colSpan-1;
		var me = this, store = me.sheet.getStore();
		
		this.spanReg.lastIndex = 0;
		var arg = json.data.replace(this.spanReg, function(w){	
			var pos = arguments[arguments.length-2];
			var str = arguments[arguments.length-1];						
		
			var ret = me.assembleCoordByRegResult(arguments);
			if(!ret){
				return w;
			}
			var arr = ret.span, next = ret.next, ctype = ret.type, separator = me.separator;
			if(SCONST.RELATIVE_COORD == ctype){
				separator = '';
				if(preChanged){
					changed = true;
				}
			}
			/*
			 * normlize the coord to 5-tpl
			 */
			arr = EnterpriseSheet.sheet.calculate.Coordinate.prototype.normalizeCoord(arr);
			var withSheetName = ('' !== arr[0] && 'string' == SCOM.typeOf(arr[0])), sheetName = arr[0];
			if(withSheetName){
				/*
				 * if sheet part is a stirng and not '', means it should be as 'Sheet1', we need transfer the name to id
				 */
				arr[0] = store.getSheetIdByName(arr[0]);
			}
			
			if(sheetId === arr[0] || ('' === arr[0] && osheetId == sheetId)){								
				if(minrow <= arr[1] && arr[3] <= maxrow){
					if(mincol < arr[2]){
						if('right' == moveDir){
							arr[2] += colSpan;
							if(0 !== arr[4]){
								arr[4] += colSpan;
							}										
							changed = true;
						}else if(maxcol >= arr[4] && 0 !== arr[4]){
							arr[1] += rowSpan;
							arr[3] += rowSpan;
							changed = true;
						}									
					}else if(mincol <= arr[4]){
						if('right' == moveDir){
							arr[4] += colSpan;
							changed = true;
						}									
					}																							
				}else if(mincol <= arr[2] && arr[4] <= maxcol){
					if(minrow < arr[1]){
						if('down' == moveDir){
							arr[1] += rowSpan;
							if(0 !== arr[3]){
								arr[3] += rowSpan;
							}										
							changed = true;
						}else if(maxrow >= arr[3] && 0 !== arr[3]){
							arr[1] += colSpan;
							arr[3] += colSpan;
							changed = true;
						}									
					}else if(minrow <= arr[3]){
						if('down' == moveDir){
							arr[3] += rowSpan;
							changed = true;
						}
					}								
				}							
				arr[0] = sheetName;						
				str = me.coord2String([{
					span: arr,
					type: ctype
				}], separator, withSheetName);															
				return str+next;
			}
			return w;
		});
		
		return {
			text: arg,
			changed: changed			
		};
	},
	
	beforeInsertCell : function(sheetId, minrow, mincol, rowSpan, colSpan, moveDir){
		var me = this;			
		var maxrow = minrow+rowSpan-1, maxcol = mincol+colSpan-1;
		var store = this.sheet.getStore(), oldCalCache = {}, curCalCache = {};
		store.each(function(rd){
			var osheetId = rd.data.sheet, orow = row = rd.data.row, ocol = col = rd.data.col, json = rd.data.json;
			if(json.cal){	
				var changed = false, preChanged = false;
				flag = true;
				if('down' == moveDir && osheetId === sheetId && row > maxrow && ocol >= mincol && maxcol >= ocol){
					/*
					 * remove span for the rows behind the inserted span
					 */
					row -= rowSpan;
					preChanged = true;
				}
				if('right' == moveDir && osheetId === sheetId && col > maxcol && orow >= minrow && maxrow >= orow){
					/*
					 * remove span for the cols behind the inserted span
					 */
					col -= colSpan;
					preChanged = true;
				}
				
				if(ocol < mincol || ocol >= maxcol || orow < minrow || orow >= maxrow || osheetId !== sheetId){
					var ret = me.adjustCalForInsertCell({
						json: json, 
						osheetId: osheetId, 
						sheetId: sheetId, 
						preChanged: preChanged, 
						changed: changed,
						minrow: minrow,
						rowSpan: rowSpan,
						mincol: mincol,
						colSpan: colSpan,
						moveDir: moveDir
					});
					var arg = ret.text;
					changed = ret.changed;
					if(changed){						
						var o = this.transferCalculate({'data': arg}, store, osheetId, orow, ocol);
						var cell = store.getCell(osheetId, orow, ocol, true);
						var curId = store.getIdBasedData({sheet: osheetId, row: orow, col: ocol}), oldId = curId;
						if(col !== ocol || row != orow){
							oldId = store.getIdBasedData({sheet: osheetId, row: row, col: col});
						}	
						/*
						 * save old cal
						 */
						oldCalCache[oldId] = {
							'sheet': osheetId,
							'row': row,
							'col': col,
							'json': {
								'data': cell.data,
								'arg': cell.arg,
                                'refs': cell.refs
							}							
						};
						store.setCell(osheetId, orow, ocol, {
							'data': arg,
							'arg': o.arg,
							'refs': o.refs
						}, null, true);
						/*
						 * save current cal
						 */						
						curCalCache[curId] = {
							'sheet': osheetId,
							'row': orow,
							'col': ocol,	
							'json': {
								'data': arg,
								'arg': o.arg,
                                'refs': o.refs
							}							
						};
					}								
				}				
			}
		}, this);
		
		var needRefreshCal = store.checkNameRefForInsertCell(sheetId, minrow, mincol, rowSpan, colSpan, moveDir);
		if(SCOM.countObjMember(oldCalCache) && SCOM.countObjMember(curCalCache)){
			needRefreshCal = true;			
		}
		
		return {
			oldCal: oldCalCache,
			curCal: curCalCache,
			needRefreshCal: needRefreshCal
		};		
	},
	
	/*
	 * when row/col/cell is removed we need refresh the cdt, and return false to cancel the removerow/insertrow/removecolumn/insertcolumn event of store
	 * so the region no need refresh the UI again
	 */
	holdChange : function(e){		
		e.calCdt = true;
	},	
		
	/*
	 * _private
	 * provide a way to loop the cells in the calculate arguments for calculating
	 * @param {int} sheetId: the default sheetId
	 * @param {int} row: the row index of the calculate cell
	 * @param {int} col: the column index of the calculate cell
	 * @param {array} args: the args of the calculate, which actually contains the cell coord info
	 * @param {function} fn: the callback function
	 * @param {object} scope: the scope of fn
	 */
	each : function(sheetId, row, col, args, fn, scope, skipEmpty){
		var me = this;
		var store = this.sheet.getStore();
		var cacheRow = row, cacheCol = col;
		var index = 0;
		
		var processCoordObj = function(coord){
			var span = coord['span'] || coord['SPAN'], type = coord['type'] || coord['TYPE'];
			/*
			 * get the coord from the arg
			 */				
			var range = me.transferCoord2MinMax(span, sheetId);
			var min = range.min, max = range.max;
			if(SCONST.ABSOLUTE_COORD == type){
				/*
				 * if it's absolute coord, we don't need add the current coord
				 */
				row = col = 0;
			}else if(SCONST.ABSOLUTE_ROW_COORD == type){
				/*
				 * if it's absolute coord, we don't need add the current coord
				 */
				row = 0;
				col = cacheCol;
			}else if(SCONST.ABSOLUTE_COL_COORD == type){
				/*
				 * if it's absolute coord, we don't need add the current coord
				 */
				col = 0;
				row = cacheRow;
			}else{
				/*
				 * set back to the cached value
				 */
				row = cacheRow;
				col = cacheCol;
			}
			var minrow = '' === min[1] ? 0 : row+min[1], 
				mincol = '' === min[2] ? 0 : col+min[2], 
				maxrow = '' === max[1] ? 0 : row+max[1], 
				maxcol = '' === max[2] ? 0 : col+max[2];
			var span = [min[0], minrow, mincol, maxrow, maxcol];
			store.walkRange([span], function(rd){
				if(fn){
					return fn.call(scope, [rd.data.sheet, rd.data.row, rd.data.col], 'span', index++, argIndex++, span);
				}
			}, this);
		};
		for(var i = 0, len = args.length; i < len; i++){
			var arg = args[i];
			var argIndex = 0;
			if(me.isSingleCoordObj(arg)){
				processCoordObj(arg);			
			}else if(Ext.isArray(arg)){
				var argIndex = 0;
				for(var j = 0, alen = arg.length; j < alen; j++){	
					var it = arg[j];
					if(me.isSingleCoordObj(it)){
						processCoordObj(it);
					}else{
						fn.call(scope, arg[j], 'array', index++, argIndex++, arg);
					}					
				}
			}else{
				var argIndex = 0;
				fn.call(scope, arg, 'value', index++, argIndex++, arg);
			}												
		}
	},		
	
	/*
	 * reset the data property of cell based on the arg property
	 */
	resetData : function(obj, store, sheetId, row, col, oldSheetId, oldRow, oldCol, reverse, changedTabName){
		var calStr = obj.data, arg = obj.arg, refs = obj.refs;		
		calStr = calStr.toString();
		var me = this;		
		/*
		 * need save the coords for further using
		 
		var coordArr = [];
		this.transferCoordInStr(arg, function(coord){
			coordArr.push(coord);
		}, this);
		*/
		var rowOffset = row-oldRow, colOffset = col-oldCol;
		var index = 0, changed = false;
		this.spanReg.lastIndex = 0;
		var newCalStr = calStr.replace(this.spanReg, function(w){
			var pos = arguments[arguments.length-2];
			var str = arguments[arguments.length-1];						
					
			var ret = me.assembleCoordByRegResult(arguments);
			if(!ret){
				return w;
			}
			
			var arr = ret.span, next = ret.next, ctype = ret.type, separator = me.separator;	
			/*
			 * normlize the coord to 5-tpl
			 */
			arr = EnterpriseSheet.sheet.calculate.Coordinate.prototype.normalizeCoord(arr);								
			
			if(SCONST.ABSOLUTE_COORD == ctype){
				if('' !== arr[0] && 'string' == SCOM.typeOf(arr[0])){		
					var oldSheetName = arr[0];
					var relatedSheetId = store.getSheetIdByName(arr[0], undefined, true);
					if(!Ext.isNumber(relatedSheetId)){
						//return '0'+next;
                        arr[0] = '"#REF"';
					}else{
						arr[0] = store.getSheetNameById(relatedSheetId);
					}					
					if(arr[0] !== oldSheetName){
						changed = true;
					}
				}
				if(arr[0]  === changedTabName){
					changed = true;
				}
				if(changed){
					str = me.coord2String([{
						span: arr,
						type: ctype
					}], separator, true);		
				//index++;
					return str+next;
				}else{
				return w;
				}
			}else{
				/*
				 * transfer to absoluate coord
				 */
				if(SCONST.RELATIVE_COORD == ctype){
                    if(0 !== arr[1]){
                        arr[1] += rowOffset;
                    }else{
                        changed = true;
                    }
                    if(0 !== arr[2]){
                        arr[2] += colOffset;
                    }else{
                        changed = true;
                    }
                    if(0 !== arr[3]){
                        arr[3] += rowOffset;
                    }else{
                        changed = true;
                    }
                    if(0 !== arr[4]){
                        arr[4] += colOffset;
                    }else{
                        changed = true;
                    }
					if(reverse){
						/*
						 * need reverse the row and col for the references in this formula
						 */
						var rowMinOff = arr[1]-row, rowMaxOff = arr[3]-row, colMinOff = arr[2]-col, colMaxOff = arr[4]-col;
						arr[1] = row+colMinOff;
						arr[3] = row+colMaxOff;
						arr[2] = col+rowMinOff;
						arr[4] = col+rowMaxOff;
						changed = true;
					}
					separator = '';
				}else if(SCONST.ABSOLUTE_COL_COORD == ctype){
					arr[1] += rowOffset;								
					arr[3] += rowOffset;				
				}else if(SCONST.ABSOLUTE_ROW_COORD == ctype){		
					arr[2] += colOffset;										
					arr[4] += colOffset;
				}
										
				if(arr[1] == arr[3]){
					if(0 > arr[1]){
						arr[1] = arr[3] = 0;
						changed = true;
					}
				}else{
					if(0 >= arr[1]){
						arr[1] = 1;
						changed = true;
					}
					if(0 >= arr[3]){
						arr[3] = 1;
						changed = true;
					}
				}
				if(arr[2] == arr[4]){
					if(0 > arr[2]){
						arr[2] = arr[4] = 0;
						changed = true;
					}
				}else{
					if(0 >= arr[2]){
						arr[2] = 1;
						changed = true;
					}
					if(0 >= arr[4]){
						arr[4] = 1;
						changed = true;
					}
				}
				/*
				 * transfer span to str
				 */
				/*
				var relatedSheetId = coordArr[index]['span'][0];
				if(Ext.isNumber(relatedSheetId)){
					arr[0] = store.getSheetNameById(relatedSheetId);
					if(SCOM.nullOrUndefined(arr[0])){
						index++;
						return '0'+next;
					}
				}*/
				if('' !== arr[0] && 'string' == SCOM.typeOf(arr[0])){					
					var oldSheetName = arr[0];
					var relatedSheetId = store.getSheetIdByName(arr[0], undefined, true);
					if(!Ext.isNumber(relatedSheetId)){
						//return '0'+next;
                        arr[0] = '"#REF"';
					}else{
						arr[0] = store.getSheetNameById(relatedSheetId);
					}					
					if(arr[0] !== oldSheetName){
						changed = true;
					}
				}
				if(arr[0]  === changedTabName){
					changed = true;
				}
				str = me.coord2String([{
					span: arr,
					type: ctype
				}], separator, true);		
				//index++;
				return str+next;
			}							
		});
		
        if(changed || newCalStr !== calStr){
			/*
			 * means the calculate is changed, need recalculate the arg
			 */
			var tmp = Ext.apply({}, obj);
			tmp.data = newCalStr;
            var trObj = this.transferCalculate(tmp, store, sheetId, row, col);
			return {
				data: newCalStr,
				arg: trObj.arg,
                refs: trObj.refs
			};
		}else{
			return {
				data: newCalStr,
				arg: arg,
				refs: refs
			};
		}
	},
	
	
	
	/*
	 * add quote for these sheet name included blank
	 */
	addQuoteForSheetName : function(o, store){
		var me = this;

		this.spanReg.lastIndex = 0;
		var data = o.data.replace(this.spanReg, function(w){
			var pos = arguments[arguments.length-2];
			var str = arguments[arguments.length-1];						
			
			var ret = me.assembleCoordByRegResult(arguments);
			if(!ret){
				return w;
			}
			
			var arr = ret.span, next = ret.next, ctype = ret.type;	
			/*
			 * normlize the coord to 5-tpl
			 */
			arr = EnterpriseSheet.sheet.calculate.Coordinate.prototype.normalizeCoord(arr);
			
			if(arr[0]){
				var sheetId = store.getSheetIdByName(arr[0]);
				if(Ext.isNumber(sheetId)){
					arr[0] = store.getSheetNameById(sheetId);
				}
				arr[0] = me.quoteStr(arr[0]);
			}
			separator = SCONST.RELATIVE_COORD == ctype ? '' : me.separator;
			
			var str = me.coord2String([{
				span: arr,
				type: ctype
			}], separator, true);		
			
			return str+next;
		});
		o.data = data;
	},		
	
	/**
	 * _private, check whether the position is in or not in '' or ""
	 */
	isInQuote : function(str, pos, startPos){
		startPos = startPos || 0;
		var s = 0, d = 0;
		for(var i = startPos; i < pos; i++){
			var chr = str.charAt(i);
			if('"' == chr){
				s++;
			}
			if("'" == chr){
				d++;
			}
		}
		if(0 !== s%2 || 0 !== d%2){
			return true;
		}
		return false;
	},
	
	/*
	 * process some special case for the calculate string
	 */
	specialCaseForCalculateStr : function(calStr, ignoreQuote){
		var me = this;
		/*
		 * transfer = to ==
		 */
		var arg = calStr.replace(/[=]+/gi, function(w){
			var index = arguments[arguments.length-2];
			if('=' == w && (ignoreQuote || !me.isInQuote(calStr, index))){
				var lastChr = 0 < index ? calStr.charAt(index-1) : '';				
				if('!' != lastChr && '<' != lastChr && '>' != lastChr){
					return '==';
				}
			}
			return w;
		});
		/*
		 * transfer <> to !=
		 */
		calStr = arg.replace(/\<\>/gi, function(w){
			var index = arguments[arguments.length-2];
			if(ignoreQuote || !me.isInQuote(arg, index)){
				return '!=';
			}
			return w;
		});
		/*
		 * transfer 4% to 0.04
		 */
		calStr = arg.replace(/[-.0-9]+%/gi, function(w){
			var index = arguments[arguments.length-2];
			if(ignoreQuote || !me.isInQuote(arg, index)){
				var num = w.slice(0, w.length-1);
				num = Number(num);
				if(Ext.isNumber(num)){
					return num/100;
				}
			}
			return w;
		});
		
		return calStr;
	},
	
	/**
	 * process the calcaulte cell, calculate the result if need
	 * @param {object} o: the cell data object, if o.cal is not null/undefined, then will calculate the value
	 * @param {object} scope: the scope of the calculate function
	 * Notice: in scope, we need pass: 
	 * "store":which use for get cell data to calculate;
	 * "sheet":the sheet index of the calculate cell we process;
	 * "row":the row index of the calculate cell;
	 * "col":the column index of the calculate cell;
	 * "timestamp": the timestamp to check whether the o.value is valid or not, we will compare the o.timestamp with timestamp,
	 * if equal, then mean the o.value is the newest value, we can use it directly, or means the value is not valid, we need calculate
	 * it again; if timestamp is undefined/null, then no need compare, just assume the value is valid, and use it directly.
	 * @param {boolean} skipUpdateValue: true to not up value in calculate
	 */
	processCalculate : function(o, scope, skipUpdateValue, callerId){
		var store = scope.store, sheetId = scope.sheet, row = scope.row, col = scope.col, timestamp = scope.timestamp;
		var separateChar = EnterpriseSheet.sheet.data.reader.CellReader.prototype.separateChar;
		/*
		 * generate the id based on scope, we will use it to detect the infinate loop
		 */					
		callerId = callerId || store.getIdBasedData({sheet: sheetId, row: row, col: col});

		
		if(0 == row || 0 == col){
			return {};
		}
		if(!o.data){
			return o;
		}		
		
		var args = o.arg;			
		if(o.cal){
			if(!this.lookup[callerId]){
				this.lookup[callerId] = [sheetId, row, col];
				if(store.isLoadingCells() || false != SCOM.typeOf(o.value)){
					o.data = o.value;
				}else{							
					/*
					 * add this to the scope
					 */
					scope = Ext.applyIf({
						me:this,
                        isArrayFormula: Ext.isNumber(o.afrow)
					}, scope);
                   
					var oldVal = o.value;
					Ext.apply(o, this.evalCal(args, scope, o));
                    
					//var sm = this._exposeFns.sum;
					//o.data = sum({"span":["",1,1,2,1],"type":1});
					/*
					 * here we set back the value and timestamp to store without fire the event
					 */							
					var modified = {};
					//console.log(skipUpdateValue)
					if(!skipUpdateValue || oldVal !== o.data){
						var val = o.data;
						modified['value'] = val;						
					}					
                    o.value = o.data;

					/*
					 * update the cell in store after calculate
					 */
					store.setCell(sheetId, row, col, modified, null, true);
				}
			} else {
				/*
				 * if get here means there is an infinate loop, so clean the lookup and then throw an exception
				 */
				var arr = this.lookup[callerId];
				this.lookup = {};				
				throw {
					code: 'CAL_INFINATE_LOOP',
					span: [arr[0], arr[1], arr[2], arr[1], arr[2]]
				};
			}
			delete(this.lookup[callerId]);
		}
		return o;
	},
	
	/**
	 * get data for a cell
	 */
	getCellData : function(sheetId, row, col, scope){
		var store = scope.store;
        var separateChar = EnterpriseSheet.sheet.data.reader.CellReader.prototype.separateChar;
		var cid = store.getIdBasedData({sheet: sheetId, row: row, col: col});
        var cd = {}, rec = store.getByMapId(cid);
        if(rec){
            var json = rec.data.json;
            if(!SCOM.isEmptyValue(json.data)){
                //cd = store.getCellData(sheetId, row, col);
                cd = Ext.apply({}, json);
            }
        }
		/*
		 * escape the merged cell, only calculate once
		 */
		if(store.isMergedCell(cd, sheetId, row, col) && !(0 == cd.minrow && 0 == cd.mincol)){
			if(Ext.isObject(cd.data) && cd.data._isExp){
				throw cd.data;
			}
			cd.value = 0;
			cd.data = 0;
			return cd;
		}	
		
		/*
		 * call process calculate, cause it also could be a calculate
		 */
		var newScope = {
			store: store,
			sheet: sheetId,
			row: row,
			col: col,
			timestamp: scope.timestamp,
			originScope: Ext.apply({}, scope)
		};
        
		cd = this.processCalculate(cd, newScope, undefined, cid);
		if(Ext.isObject(cd.data) && cd.data._isExp){
			throw cd.data;
		}
        
        if(Ext.isNumber(cd.aerow)){
            var afrow = cd.afrow+row, afcol = cd.afcol+col, aerow = cd.aerow+row, aecol = cd.aecol+col;
            if(scope.row >= afrow && scope.row <= aerow && scope.col >= afcol && scope.col <= aecol){
            	return cd;
            }
        }
        cd = this.processArrayFormulaResult(cd, row, col);
		return cd;
	},
           
    /**
     * process for array formula
     */
    processArrayFormulaResult : function(cell, row, col){
        if(Ext.isArray(cell.data) && Ext.isNumber(cell.afrow)){
            var afrow = cell.afrow+row, afcol = cell.afcol+col;
            var rowIndex = row-afrow, colIndex = col-afcol;
            var data = cell.data;

            if(!Ext.isArray(data)){
                data = [data];
            }
            var colLen = data.length, rowLen = false;
            if(Ext.isArray(data[0])){
                rowLen = data[0].length;
            }
            colIndex = colIndex%colLen;
            if(false === rowLen){
                cell.data = data[colIndex];
            }else if(rowIndex < rowLen){
                cell.data = data[colIndex][rowIndex];
            }else{
                cell.data = '#N/A';
            }
        }
        return cell;
	},
	
	/*
	 * eval the string to calcualte the value
	 * @param {string} calStr: the calculate express string
	 * @param {object} scope: the scope apply for all functions in calculate
	 * @return {string/number}: the value of the express
	 */
	evalCal : function(calStr, scope, cellObj){
		try{
			var me = this, calculates = me.calculates;
			
			var exposeFns = me._exposeFns, exposeScope = me._exposeScope;
			/*
			 * apply scope to exposeScope
			 */
			var scopeCache = Ext.apply({}, exposeScope);
			for(var p in exposeScope){
				if(exposeScope.hasOwnProperty(p)){
					delete(exposeScope[p]);
				}				
			}
			Ext.apply(exposeScope, scope);
			
			var upperCaseReserved = this.upperCaseReserved;
			return (function(){		
				/*
				 * set the calculate string to uppercase too
				 */
				calStr = upperCaseReserved(calStr);	

				var envStr = 'var _curSheetId='+scope.sheet+';'+me.prepareEnv();
                
                var refStr = me.sheet.getStore().prepareFileConfigReference();
                    
				calStr = envStr+refStr+calStr;
                //console.log(calStr)
                /*
                 * here we embrace the eval into a function to insulate the vars and funcs in the calStr
                 */
                var v = (function(){
                    return eval(calStr);
                })();
                    
				var valOfFlag = false;							
				/*
				 * if the result is an object, we may need try to get the val of that range
				 */
                if(Ext.isFunction(v)){
                    v = v.call(exposeScope);
                }
                    
                if(Ext.isObject(v)){
                    /*
                     * means it's an exception
                     */
                    if(!v.code){
                        valOfFlag = true;
                    }
				}else if(Ext.isArray(v) && 1 == v.length && !scope.isArrayFormula){
					v = v[0];
                    if(me.isSingleCoordObj(v)){
                    	valOfFlag = true;
                    }
				}
                
				if(valOfFlag){
					calStr = envStr+' VALOF('+Ext.encode(v)+');';
                    v = (function(){
                        return eval(calStr);
                    })();
				}
				/*
				 * here need resume the exposeScope
				 */
				for(var p in exposeScope){
					if(exposeScope.hasOwnProperty(p)){
						delete(exposeScope[p]);
					}				
				}
				Ext.apply(exposeScope, scopeCache);
				
				if(Ext.isFunction(v) || Ext.isArray(v) || Ext.isObject(v)){
                    
                    if(v.code){
                        throw v;
                    }else{
                        if(Ext.isArray(v) && cellObj && Ext.isNumber(cellObj.afrow)){
                            if(Ext.isNumber(cellObj.aerow)){
                                v = HELPER.singleArr2ToArr1(v);
                                if(cellObj.afcol === cellObj.aecol && !Ext.isArray(v[0])){
                                    v = [v];
                                }
                            }
                        }else{
                            /*
                             * if it's a function
                             */
                            throw {
                                code: 'CAL_NO_VALUE'
                            };
                        }
                    }
                    
				}
                try{
                    // add one more condition as customer raised - infinity - change to "#DIV/0!"
                    if (v.toString() == 'Infinity')  throw {code: 'SS_ERROR_INFINITY'};
                }catch(e){
                    throw {code: 'CAL_INVALID_NAME'};
                }
				return {
					data:v
				};
			})();			
		}catch(e){
			if(Ext.isObject(e)){
				e._isExp = true;
			}else{
				e = {
					code: e.toString(),
					_isExp: true
				};
			}
			return {
				data: e
			};			
		}		
	},
	
	/*
	 * make a function or express op name or some reserved words to UPPERCASE, such as: 'if' to 'IF'
	 */		
	upperCaseReserved : function(calStr){		
		//calStr = calStr.replace(/(^|[,\s\)\+\-\*\/\>\<\=\(\)])(false|true|if|and|or|int)($|[,\s\)\+\-\*\/\>\<\=\(\)])/gi, function(w){
		//calStr = calStr.replace(/(^|[\,\s\+\-\*\/\>\<\=\(\)])(false|true|if|and|or|not|int)(\s*\()/gi, function(w){
		calStr = calStr.replace(/[a-z0-9]+/gi, function(w){
			var lw = w.toLowerCase();
			if('true' == lw || 'false' == lw){
				return lw;
			}
			return w;
		});
		calStr = calStr.replace(/[a-z0-9]+\s*\(/gi, function(w){			
			var lw = w.toLowerCase().slice(0, w.length-1);
			if('false' == lw || 'true' == lw || 'if' == lw || 'and' == lw || 'or' == lw ||
				'not' == lw || 'int' == lw || 'date' == lw || 'text' == lw){
				return w.toUpperCase();
			}
			return w;
		});
		
		return calStr;
	},
	
	/*
	 * process for iferror 
	 * Updated: iserror, isna - special case which return error information ...
	 */
	escapeErrorResult : function(calStr){
		var marks = [];
        calStr.replace(/(("[^\"]+")|('[^\']+')|((^|[,\s\+\-\*\/\>\<\=\(\)])(iferror|iserror|isna|ifna|iserr|IF)))/gi, function(w){
            if(arguments[4]){
            	var index = arguments[arguments.length-2]+w.length;
            	if('(' === calStr.charAt(index)){
            		marks.push(index+1);
            	}
            }
        });
        
		if(0 < marks.length){			
			for(var i = marks.length-1; 0 <= i; i--){
				var pos = marks[i], match = 0;
				var strLen = calStr.length;
				var pts = [];
				pts.push(pos);
				var j = pos;
				for(; j < strLen; j++){
					var ch = calStr[j];				
					if('(' == ch){
						match++;
					}else if(')' == ch){
						match--;
					}
					if(0 > match){
						break;
					}else if(0 == match && ',' == ch){
                        pts.push(j);
                        var k = j+1;
                        while(k < strLen){
                            if(!calStr[k]){
                                k++;
                            }else{
                                pts.push(k);
                                break;
                            }
                        }
					}
				}
				if(j < strLen){
					pts.push(j);
				}
				var len = pts.length;
				if(0 < len){
					var parts = []; 
					for(var k = 0; k < len; k++){
						if(0 == k){
							parts.push(calStr.slice(0, pts[k]));
						}
						if(0 == k%2){
							parts.push('function(){return (');
						}else{
							parts.push(')}');
						}
						if(k < len-1){
							parts.push(calStr.slice(pts[k], pts[k+1]));
						}else{				
							parts.push(calStr.slice(pts[k], strLen));
						}
						if(1 === len){
							parts.push(')}');
						}
					}
					//console.log(calStr)
					
					//console.log(parts.join(''))
					calStr = parts.join('');
				}
			}			
		}	
		return calStr;
	},
	
	/*
	 * check the passed string is an express or not
	 */
	isExpress : function(str){
		return /^\s*[\!\<\>\=]/gi.test(str);
	},
	
	/*
	 * private
	 * prepare env for eval
	 */	
	prepareEnv : function(){
		var me = this, pro = EnterpriseSheet.sheet.calculate.Calculate.prototype, escapeErrorFuncs = pro.escapeErrorFuncs;
        
		if(!me._exposeEnv.envStr){
			var calculates = me.calculates, exposeFns = me._exposeFns, exposeScope = me._exposeScope;
			var expose = [];
			for(var p in calculates){
				if(calculates.hasOwnProperty(p) && 'function' == Ext.typeOf(calculates[p])){
					var name = p.toString(), lowName = name.toLowerCase();
					/*
					 * set the expose fns to uppercase
					 */					
					var NAME = name.toUpperCase();
					
					var fn = calculates[name];
                    if(escapeErrorFuncs[lowName]){
                        exposeFns[name] = Ext.Function.bind(fn, exposeScope);
                    }else{
                        exposeFns[name] = Ext.Function.bind(function(){
                            for(var i = 0, len = arguments.length; i < len; i++){
                                var it = arguments[i];
                                if(Ext.isFunction(it)){
                                    arguments[i] = it.call(this.scope);
                                }
                            }
                            return this.func.apply(this.scope, arguments);
                        }, {
                            func: fn,
                            scope: exposeScope
                        });
                    }
									
					expose.push('var '+name+' = exposeFns.'+name+';var '+NAME+' = '+name+';');
				}					
			}
			me._exposeEnv.envStr = expose.join('');			
		}
		
		return me._exposeEnv.envStr;
	},
                       
    /*
     * private
     * fake env for eval
     */
    fakeEnv : function(){
        var me = this, pro = EnterpriseSheet.sheet.calculate.Calculate.prototype;
        if(!me._exposeEnv.fakeEnvStr){
            var calculates = me.calculates;
            var expose = [];
            for(var p in calculates){
                if(calculates.hasOwnProperty(p) && 'function' == Ext.typeOf(calculates[p])){
                    var name = p.toString();
                    var fn = calculates[name];
                       
                    /*
                     * set the expose fns to uppercase
                     */
                    var NAME = name.toUpperCase();
                    expose.push('var '+name+' = function(){};var '+NAME+' = function(){};');
                }
            }
            me._exposeEnv.fakeEnvStr = expose.join('');
                       
        }
        return me._exposeEnv.fakeEnvStr;
    },
		
	/*
	 * change absolute coord to relative coord
	 */
	absolute2Relative : function(span, row, col, coordType){
		
		if(SCONST.RELATIVE_COORD == coordType){
			span[1] -= row;
			span[2] -= col;
			span[3] -= row;
			span[4] -= col;
		}else if(SCONST.ABSOLUTE_ROW_COORD == coordType){
			span[2] -= col;
			span[4] -= col;
		}else if(SCONST.ABSOLUTE_COL_COORD == coordType){
			span[1] -= row;
			span[3] -= row;
		}
		
		return span;
	},
	
	/*
	 * reset the cache, 
	 * the cache will use to store the min and max of different condition,
	 * the idea is to avoid repeat the calculate for the same range 
	 */
	resetCache : function(){
		this.cache = {};
	},
	
	/*
	 * save the min/max of a condition range, so we can reuse next time
	 * @param {string} arg: the encode range of the condition, so every different range have a different string
	 * @param {string} timestamp: the timestamp imply the valid of this item, only when the timestamp fits, the min/max in cache is valid
	 * @param {object} data: the data for the cache	 
	 */
	keep2Cache : function(arg, timestamp, data){
		this.cache = this.cache || {};
		this.cache[arg] = {
			timestamp:timestamp,
			data:Ext.apply({}, data)
		}
	},
	
	/*
	 * get the min/max from the cache for a special condition range
	 */
	getFromCache : function(arg, timestamp){
		if(this.cache){
			var o = this.cache[arg];
			if(o && o.timestamp == timestamp){
				/*
				 * only if the timestamp is the same, the cache data can be use, or it's invalid 
				 */
				return o.data;
			}
		}
	},
	
	/*
	 * _private
	 * walk the range
	 */
	walkRange : function(store, sheet, row, col, range, fn){
		store.walkRange(range, function(rd, span){
			fn.call(this, rd.data.sheet, rd.data.row, rd.data.col);
		}, this);		
	},
	
	/*
	 * find the min and max in some ranges
	 * @param {string} timestamp: the timestamp string, to check the valid of calculate value and condition cache item
	 * @param {object} store: the store ref
	 * @param {int} sheet: the sheet id of the cell we calculating
	 * @param {int} row: the row index of the cell we calculating
	 * @param {int} col: the column index of the cell we calculating
	 * @param {array} range: the array of the range of the condition
	 * @param {object} addOnScope: the propertys add on scope
	 * @return {object}: return the min value and max value, such as {min:10, max:100} 
	 */
	findMinMaxInCondition : function(timestamp, store, sheet, row, col, range, addOnScope){
		/*
		 * @notice here we define a tmp obj instead of define min and max
		 * because in the sub-calling will overwrite the min and max
		 */
		var tmp = {
			min: false,
			max: false
		};			
		var fn = function(s, r, c){
			var cell = this.getCellData(s, r, c, Ext.apply({
				store:store,
				sheet:sheet,
				row:row,
				col:col,
				timestamp:timestamp
			}, addOnScope));
						
			if(SCOM.canbeNumber(cell.data)){				
				var n = Number(cell.data);
				
				if(false === tmp.min || tmp.min > n){
					tmp.min = n;
				}
				if(false === tmp.max || tmp.max < n){
					tmp.max = n;
				}
			}
		};
		
		this.walkRange(store, sheet, row, col, range, fn);		
		return tmp;
	},
	
	/*
	 * For this formula only
	 * @param {array} range: the range array
	 * @param {object} scope: the scope object
	 * @return {object}: return the min/max value
	 */
	minMaxVal : function(range, scope){				
		var me = scope.me, calculates = me.calculates;
		var min = false, max = false, minOrigData = 0, maxOrigData = 0;
		
		// ok, we need loop and get the each item ...
		var rangeObjs = calculates.rangeObjsOf.call(scope, range);
		for(var i = 0, len = rangeObjs.length; i < len; i++){
			var data = rangeObjs[i];
			if (data === undefined || data === "" || data === null)  continue;
			if (HELPER.isBoolean(data)) data = HELPER.convertBoolean2Int(data);	
			var num = Number(data);
			if(Ext.isNumber(num)) {
				// do nothing ...
			} else {
				var checkDate = SFORMAT.checkingDate(data);
				if(checkDate) num = HELPER.convertDateToNum(checkDate);
				else continue;
			}
			
			if(false === min || min > num) {
				min = num;
				minOrigData = data;
			}
			if(false === max || max < num){
				max = num;
				maxOrigData = data;
			}
		}
		
		return {
			min:minOrigData,
			max:maxOrigData				
		};
	},

    /*
	 * get the min/max value in the range of condition
	 * it will check the cache first, if not found then recalculate it and save in cache
	 * @param {array} range: the range array
	 * @param {object} scope: the scope object
	 * @param {object} addOnScope: the propertys add on scope
	 * @return {object}: return the min/max value
	 */
	getMinMax : function(range, scope, addOnScope){				
		var store = scope.store, timestamp = scope.timestamp, sheet = scope.sheet, row = scope.row, col = scope.col;						
		var coord = [], min = false, max = false;
		for(var i = 0, len = range.length; i < len; i++){
			var it = range[i];
			if(Ext.isObject(it) && it.span){
				coord.push(it);
			}else{
				if (it === undefined || it === "" || it === null)  throw { code: 'CAL_NO_VALUE', cal: 'min/max' };
				var num = Number(it);
				if(Ext.isNumber(num)){
					if(false === min || min > num){
						min = num;
					}
					if(false === max || max < num){
						max = num;
					}
				} else
					throw { code: 'CAL_NO_VALUE', cal: 'min/max' };
			}
		}
		/*
		 * get the min max value, first check the cache, 
		 * if not find in cache, then need re-calculate, and set the value to cache for future use 
		 */
		coord = this.transfer2Absolute(sheet, row, col, coord);
		var str = Ext.encode(coord);
				
		var data = this.getFromCache(str, timestamp);
		if(!data || false == SCOM.typeOf(data.min) || false == SCOM.typeOf(data.max)){							
			data = this.findMinMaxInCondition(timestamp, store, sheet, row, col, coord, addOnScope);
			
			this.keep2Cache(str, timestamp, {
				min:data.min, 
				max:data.max
			});
		}
		if(false === min || (Ext.isNumber(data.min) && min > data.min)){
			min = data.min;
		}
		if(false === max || (Ext.isNumber(data.max) && max < data.max)){
			max = data.max;
		}
		return {
			min:min,
			max:max				
		};
	},
	
	/*
	 * count the non empty cell in some ranges
	 * @param {string} timestamp: the timestamp string, to check the valid of calculate value and condition cache item
	 * @param {object} store: the store ref
	 * @param {int} sheet: the sheet id of the cell we calculating
	 * @param {int} row: the row index of the cell we calculating
	 * @param {int} col: the column index of the cell we calculating
	 * @param {array} range: the array of the range of the condition
	 * @param {object} addOnScope: the propertys add on scope
	 * @return {object}: return the average value
	 */
	findCountInCondition : function(timestamp, store, sheet, row, col, range, addOnScope){
		var tmp = {
			count : 0
		};
		var fn = function(s, r, c){
			var cell = this.getCellData(s, r, c, Ext.apply({
				store:store,
				sheet:sheet,
				row:row,
				col:col,
				timestamp:timestamp
			}, addOnScope));
			
			if(false != SCOM.typeOf(cell.data) && SCOM.canbeNumber(cell.data)){				
				tmp.count++;
			}
		};
		
		this.walkRange(store, sheet, row, col, range, fn);		
		return tmp.count;		
	},
	
	/*
	 * get the count value in the range of condition
	 * it will check the cache first, if not found then recalculate it and save in cache
	 * @param {array} range: the range array
	 * @param {object} scope: the scope object
	 * @param {object} addOnScope: the propertys add on scope
	 * @return {number}: return the average value of the range
	 */
	getCount : function(range, scope, addOnScope){		
		
		var store = scope.store, timestamp = scope.timestamp, sheet = scope.sheet, row = scope.row, col = scope.col;						
		var coord = [], count = 0;
		for(var i = 0, len = range.length; i < len; i++){
			var it = range[i];
			if(Ext.isObject(it) && it.span){
				coord.push(it);
			}else{
				count++;
			}
		}
		/*
		 * get the min max value, first check the cache, 
		 * if not find in cache, then need re-calculate, and set the value to cache for future use 
		 */
		coord = this.transfer2Absolute(sheet, row, col, coord);
		var str = Ext.encode(coord);
		var data = this.getFromCache(str, timestamp);
		if(!data || false == SCOM.typeOf(data.count)){			
			
			var c = this.findCountInCondition(timestamp, store, sheet, row, col, coord, addOnScope);
			count += c;
			this.keep2Cache(str, timestamp, {
				count:c
			});
		}else{
			count += data.count;
		}
		
		return count;
	},
	
	/*
	 * find the average values in some ranges
	 * @param {string} timestamp: the timestamp string, to check the valid of calculate value and condition cache item
	 * @param {object} store: the store ref
	 * @param {int} sheet: the sheet id of the cell we calculating
	 * @param {int} row: the row index of the cell we calculating
	 * @param {int} col: the column index of the cell we calculating
	 * @param {array} range: the array of the range of the condition
	 * @param {object} addOnScope: the propertys add on scope
	 * @return {object}: return the average value
	 */
	findAverageInCondition : function(timestamp, store, sheet, row, col, range, addOnScope){
		var tmp = {
			sum: 0,
			count: 0
		};
				
		var fn = function(s, r, c){
			var cell = this.getCellData(s, r, c, Ext.apply({
				store:store,
				sheet:sheet,
				row:row,
				col:col,
				timestamp:timestamp
			}, addOnScope));
			
			if(SCOM.canbeNumber(cell.data)){
				tmp.sum += Number(cell.data);
				tmp.count++;
			}
		};
		
		// TODO .. need check all item are not number - at this case we need return 
		// check to see argsAllNaN - if yes means all the value are text or
		// empty only care number
		// if (argsAllNaN) throw 'SS_ERROR_INFINITY';
		
		this.walkRange(store, sheet, row, col, range, fn);		
		if(0 < tmp.count){
			return {
				sum: tmp.sum,
				count: tmp.count,
				average: tmp.sum/tmp.count
			};
		}else{
			return {
				sum: 0,
				count: 0,
				average: 0
			};
		}		
	},
	
	/*
	 * get the average value in the range of condition
	 * it will check the cache first, if not found then recalculate it and save in cache
	 * @param {array} range: the range array
	 * @param {object} scope: the scope object
	 * @param {object} addOnScope: the propertys add on scope
	 * @return {number}: return the average value of the range
	 */
	getAverage : function(range, scope, addOnScope){			
		var store = scope.store, timestamp = scope.timestamp, sheet = scope.sheet, row = scope.row, col = scope.col;						
		var coord = [], sum = 0, count = 0;
		for(var i = 0, len = range.length; i < len; i++){
			var it = range[i];
			if(Ext.isObject(it) && it.span){
				coord.push(it);
			}else{
				var num = Number(it);
				if(Ext.isNumber(num)){
					sum += num;
					count++;
				}
			}
		}
		
		/*
		 * get the min max value, first check the cache, 
		 * if not find in cache, then need re-calculate, and set the value to cache for future use 
		 */
		coord = this.transfer2Absolute(sheet, row, col, coord);		
		var str = Ext.encode(coord);
		var data = this.getFromCache(str, timestamp), average;
		if(!data || false == SCOM.typeOf(data.average)){			
			var res = this.findAverageInCondition(timestamp, store, sheet, row, col, coord, addOnScope);
			sum += res.sum;
			count += res.count;
			var average = 0 === count ? 0 : sum/count;
			this.keep2Cache(str, timestamp, res);
		}else{
			sum += data.sum;
			count += data.count;
			average = 0 === count ? 0 : sum/count;
		}
		
		return average;
	},
	
	
	/*
	 * check a coord whether it's valid
	 */
	checkCoordValid : function(args){		
		var coord = [];
		if(Ext.isArray(args)){
			for(var i = 0, len = args.length; i < len; i++){
				var arg = args[i];
				if(this.isCoordObj(arg)){
					coord.push(arg);
				}else if(Ext.isArray(arg)){
					for(var j = 0, count = arg.length; j < count; j++){
						var it = arg[j];
						if(this.isCoordObj(it)){
							coord.push(it);
						}
					}
				}
			}
		}else{
			coord.push(args);
		}		
        if(0 === coord.length){
            return args;
        }
		for(var i = 0, len = coord.length; i < len; i++){
			var span = coord[i].span;			
			if(Ext.isArray(span)){
				if(!(Ext.isNumber(span[0]) || '' === span[0])){
					return span;
				}
			}			
		}
		return true;
	},	
	
	/*
	 * transfer all parameters to absolute coord 
	 */
	transferAll2Absolute : function(args, sheet, row, col){
		var me = this;
		/*
		 * transfer all coord span to absolute coord
		 */				
		for(var i = 0, len = args.length; i < len; i++){
			var arg = args[i];
			if(this.isCoordObj(arg)){
				arg.span = me.transfer2Absolute(sheet, row, col, [arg])[0];
				arg.type = SCONST['ABSOLUTE_COORD'];						
			}else if(Ext.isArray(arg)){
				for(var j = 0, count = arg.length; j < count; j++){
					var it = arg[j];
					if(this.isCoordObj(it)){
						it.span = me.transfer2Absolute(sheet, row, col, [it])[0];
						it.type = SCONST['ABSOLUTE_COORD'];
					}
				}
			}
		}
		return args;
	},
	
	/*
	 * check the passed params whehter have the same length
	 * @param {array} params: the params array to check
	 * @param {int} rangeLen: the length of the range, if undefined then all params only have the same length
	 * @param {boolean} isRow: true for row range, false for not row range
	 * @param {boolean} isCol: true for col range, false for not col range
	 */
	checkRangeMatch : function(params, rangeLen, isRow, isCol){
		var rowLen, colLen;		
		for(var i = 0, len = params.length; i < len; i++){
			var it = params[i];
			if(this.isCoordObj(it)){
				var span = it.span;
				var rlen = span[3]-span[1]+1, clen = span[4]-span[2]+1;
				if(!Ext.isDefined(isRow)){
					isRow = (0 == span[1]);
				}else if(isRow != (0 == span[1])){
					return false;
				}
				if(!Ext.isDefined(isCol)){
					isCol = (0 == span[2]);
				}else if(isCol != (0 == span[2])){
					return false;
				}
				if(!Ext.isDefined(rowLen)){
					rowLen = rlen;
				}else if(rowLen != rlen){
					return false;
				}
				if(!Ext.isDefined(colLen)){
					colLen = clen;
				}else if(colLen != clen){
					return false;
				}
				if(!Ext.isDefined(rangeLen)){
					rangeLen = rlen*clen;
				}else if(rangeLen != rlen*clen){
					return false;
				}
			}else if(Ext.isArray(it)){
				if(isRow || isCol){
					return false;
				}
				var ilen = it.length;
				if(!Ext.isDefined(rangeLen)){
					rangeLen = ilen;
				}else if(rangeLen != ilen){
					return false;
				}
			}else{
				if(isRow || isCol){
					return false;
				}
				if(!Ext.isDefined(rangeLen)){
					rangeLen = 1;
				}else if(rangeLen != 1){
					return false;
				}
			}
		}
		return true;
	},
	
	/*
	 * judg whether the passed obj is a coord obj
	 */
	isCoordObj : function(obj){
        if(Ext.isArray(obj)){
            if(1 === obj.length){
                obj = obj[0];
            }
        }
		if(Ext.isObject(obj)){
			var span = obj['span'] || obj['SPAN'];
			if(Ext.isArray(span) && 5 == span.length){
				return true;
			}
		}
		return false;
	},
	
	isSingleCoordObj : function(obj){
        if(Ext.isObject(obj)){
            var span = obj['span'] || obj['SPAN'];
            if(Ext.isArray(span) && 5 == span.length){
                return true;
            }
        }
        return false;
	},
	
	/**
	 * this is for sumxmy functions 
	 */
	sumxmyCommon : function(arguments, option, myScope) {
		var me = myScope.me, isheet = myScope.sheet, irow = myScope.row, icol = myScope.col, calculates = me.calculates;		
		var len = arguments.length; 		
		if (len != 2) throw {code: 'CAL_PARAM_MISS', cal: option};
		var result = this.checkCoordValid(arguments);
		if(true !== result) throw {code: 'CAL_INCORRECT_COORD',span: result};	
		
		var xArrary = arguments[0], yArrary = arguments[1];
		
		// check whether it is array ...
		if (Ext.isArray(xArrary)) {
			// do nothing ....		
		} else if (Ext.isString(xArrary) || Ext.isNumber(Number(xArrary))) {
			xArrary = [xArrary];
		} else {
			xArrary = calculates.rangeObjsOf.call(myScope, [xArrary]);	
		}
		
		if (Ext.isArray(yArrary)) {
			// do nothing ...		
		} else if (Ext.isString(yArrary) || Ext.isNumber(Number(yArrary))) {
			yArrary = [yArrary];
		} else {
			yArrary = calculates.rangeObjsOf.call(myScope, [yArrary]);	
		}
		
		if (yArrary.length != yArrary.length) throw {code: 'CAL_PARAM_NOT_MATCH', cal: option};
		
		if (xArrary.length == yArrary.length && xArrary.length > 0) {
		    var result = 0;
		    for(var i = 0; i < xArrary.length; i++){
		    	
		    	var xVal = Number(xArrary[i]);
		    	if (HELPER.isBoolean(xArrary[i])) xVal = 1;
		    	else if (!Ext.isNumber(xVal)) continue;
		    	
  			    var yVal = Number(yArrary[i]);
  			    if (HELPER.isBoolean(yArrary[i])) yVal = 1;
		    	else if (!Ext.isNumber(yVal)) continue;
				
				if (option == "sumxmy2")  result += Math.pow(xVal-yVal, 2);
				if (option == "sumx2py2")  result += Math.pow(xVal, 2) + Math.pow(yVal, 2);
				if (option == "sumx2my2")  result += Math.pow(xVal, 2) - Math.pow(yVal, 2);
			}
			
			xArrary = [];
			yArrary = [];			
			return result;
		}
		
		xArrary = [];
		yArrary = [];
		throw {code: 'VALUE_NOT_AVAILABLE', cal: option};
	},
	
	/**
	 * this is a general function for calculate related math formula 
	 * @param {string} - args
     * @param {string} - option. Should be: even, odd, degrees, fact, int, abs, exp, iseven, isodd, sign, sqrtpi
	 */
	mathCommonFunction2 : function(arguments, option, myScope) {
		
		var me = myScope.me, isheet = myScope.sheet, irow = myScope.row, icol = myScope.col;		
		var len = arguments.length; 		
		if (len != 1) throw {code: 'CAL_PARAM_MISS', cal: option};
		
		var result = this.checkCoordValid(arguments);
		if(true !== result) throw {code: 'CAL_INCORRECT_COORD',span: result};			
		
		var val = arguments[0];
		if(this.isCoordObj(val)) {
			var args = this.transferAll2Absolute(arguments, isheet, irow, icol);
			var arg = args[0];							
			if(this.checkRangeMatch(args, 1, false, false)){
				var span = arg.span;
				if(span){
					var cell = me.getCellData(span[0], span[1], span[2], myScope);
					val = cell.data;
					
					// need do more check ...
					if (val && val == "#N/A") throw {code: 'VALUE_NOT_AVAILABLE',cal: option};
					
					// check whether it is date format ..TODO
					var checkDate = SFORMAT.checkingDate(val);
					if(checkDate){
						// as google spreadsheet did, we need convert it day start with 1900
						val = HELPER.convertDateToNum(checkDate);
					}
				}
			} else throw {code: 'CAL_NO_VALUE',cal: option};
				
		} else {
			if (val === undefined || val === "" || SCOM.isEmptyStr(val)) {
				throw {code: 'CAL_NO_VALUE',cal: option};
				return false;
			}
		}
		
		// handle special case for isodd ...
		if (val === undefined || val === "" || SCOM.isEmptyStr(val)) {
			if (option == 'isodd') return false;
		}
		
		if(SCOM.canbeNumber(val)){
			
			// check whether it is true / false - if yes, for isEven and isOdd throw error
			if (HELPER.isBoolean(val) && (option == 'iseven' || option == 'isodd' || option == 'sqrtpi')) throw {code: 'CAL_NO_VALUE',cal: option};
			
			var num = Number(val);		
			if (option == 'even') {
				if (num < 0) {
					num = Math.ceil(Math.abs(num));
					if(num % 2>0) num = num + (2 - num%2);
					num=-num;
				 }  else {
					 num = Math.ceil(num);
					 if(num % 2>0) num = num + (2 - num%2);
				 }
			} else if (option == 'odd') {
			    if (num <  0) {
					num = Math.ceil(Math.abs(num));
					if(num % 2==0) num = num + 1;
					num=-num;
				 }  else {
					num = Math.ceil(num);
					if (num % 2==0) num = num + 1;
				 }
			} else if (option == 'fact') {
			    if (num < 0) throw {code: 'CAL_PARAM_NEED_BE_NUM', cal: option};
				var fact = 1;	 
				num = Math.floor(num);
				for(var i=1;i<=num;i++) { fact = fact*i;}
				num = fact;
			} else if (option == 'factdouble') {
			    if (num < 0) throw {code: 'CAL_PARAM_NEED_BE_NUM', cal: option};
				var fact = 1;	 
				num = Math.floor(num);
				for(var i=num; i>1; i=i-2) { if (i>1) fact = fact*i;}
				num = fact;
			} else if (option == 'iseven') {
			    num = (num > 0)?Math.floor(num):Math.ceil(num);
			    if(num%2==0) return true;
				else return false;
	        } else if (option == 'isodd') {
			    num = (num > 0)?Math.floor(num):Math.ceil(num);
			    if(num%2==0) return false;
				else return true;
	        } else if (option == 'sign') {
			    if(num>0) num = 1; 
				else if(num<0) num = -1;
				else num = 0;
	        }
	        else if (option == 'sqrtpi') { if(num < 0) throw {code: 'CAL_PARAM_NEED_BE_NUM', cal: option};  num = Math.sqrt(num*Math.PI); }		
			else if (option == 'sqrt') { if(num < 0) throw {code: 'CAL_PARAM_NEED_BE_NUM', cal: option};  num = Math.sqrt(num); }
			else if (option == 'degrees')  num = 180*(num/Math.PI);
			else if (option == 'exp')  num = Math.exp(num);
			else if (option == 'abs')  num = Math.abs(num);
			else if (option == 'int')  num = Math.floor(num);
			else if (option == 'radians')  num = Math.PI*(num/180);
			
			return num;
		}
		
		throw {code: 'CAL_NO_VALUE',cal: option};
	},
	
	/**
	 * this is a general function for calculate related math formula 
	 * @param {string} - args
     * @param {string} - option. Should be: floor, ceiling, mod etc
	 */
	mathCommonFunction4 : function(arguments, option, myScope) {
		
		var me = myScope.me, isheet = myScope.sheet, irow = myScope.row, icol = myScope.col, calculates = me.calculates;		
		var len = arguments.length; 		
		if (len != 2) {
			throw {code: 'CAL_PARAM_MISS', cal: option};
		}
		
		var result = this.checkCoordValid(arguments);
		if(true !== result) throw {code: 'CAL_INCORRECT_COORD',span: result};			
		
		var val1 = arguments[0], val2 = arguments[1]; 	
		if(me.isCoordObj(val1)) val1 = calculates.valof.call(myScope, val1);
		if(me.isCoordObj(val2)) val2 = calculates.valof.call(myScope, val2);
		
		// try to check whether it is true / false - special case 
		if (HELPER.isBoolean(val1)) {
		    if (option == 'quotient') throw {code: 'CAL_NO_VALUE',cal: option};
		    val1 = HELPER.convertBoolean2Int(val1);
		}
		
		if (HELPER.isBoolean(val2)) {
		    if (option == 'quotient') throw {code: 'CAL_NO_VALUE',cal: option};
		    val2 = HELPER.convertBoolean2Int(val2);
		}
		
		var num = Number(val1);
		var num2 = Number(val2);
		if(!Ext.isNumber(num)) throw {code: 'CAL_NO_VALUE',cal: option};
		if(!Ext.isNumber(num2)) throw {code: 'CAL_NO_VALUE',cal: option};
		
		// check whether val is true / false 
		if (option != 'mod') { 
			if (HELPER.isBoolean(val1)) throw {code: 'CAL_NO_VALUE',cal: option};
			if (HELPER.isBoolean(val2)) throw {code: 'CAL_NO_VALUE',cal: option};
		}
		
		if (option == 'ceiling') {
			if (num2 == 0) throw {code: 'SS_ERROR_INFINITY',cal: option};
			if(num2<0&&num*num2 < 0){
			     throw {code: 'CAL_PARAM_NEED_BE_NUM',cal: option};
			}
            var snum2 = num2+'';
			var times = 1;
			if(snum2.indexOf('.')>0){
				 snum2 = snum2.substring(snum2.indexOf('.')+1,snum2.length);
				 times = Math.pow(10,snum2.length);
			}
			
			if(num2<0&&num<0){
			   num = Math.ceil(Math.abs(num*times));
			   num2 = Math.abs(num2 *times);
			   if(num %num2!=0){
				num = num + (num2 - num %num2);
			}
			   num=-num;
			}else if(num<0){
				num2 = Math.abs(num2 *times);
				num = Math.abs(Math.ceil(num*times));
				if(num%num2==0){
				  num=-num;
				}else{
				  num=-(num-num%num2);
				}				
			}else{
			   num2 = Math.abs(num2 *times);
			   num = Math.abs(Math.ceil(num*times));
			   if(num %num2!=0){
			   	num = (num + (num2 - num %num2));
			   }
			}
			num=num/times;
			//if(Number(val)<0) num=-num;

		} else if (option == 'floor') {
			//=FLOOR(-2.5, 2)
		    if (num2 == 0) throw {code: 'SS_ERROR_INFINITY',cal: option};
			//if (num*num2 < 0) throw 'SS_ERROR_NUM';
		    if(num2<0&&num*num2 < 0){
			     throw {code: 'CAL_PARAM_NEED_BE_NUM',cal: option};
			}
            var snum2 = num2+'';
			var times = 1;
			if(snum2.indexOf('.')>0){
				 snum2 = snum2.substring(snum2.indexOf('.')+1,snum2.length);
				 times = Math.pow(10,snum2.length);
			}
			
			if(num2<0&&num<0){
			     num=Math.floor(Math.abs(num))*times;
			     num2 = Math.abs(num2 *times);
				 if(num%num2!=0){
				  num = num - num %num2;
				 }
				 num=-num;
				 
			}else if(num<0){
				 num=Math.abs(Math.floor(num)*times);
				 num2 = Math.abs(num2 *times);
				 if(num%num2==0){
				    num=-num;
				 }else{
				   num = -(num + (num2 - num %num2));
				 }
			}else{
			num = num *times;
			   num2 = Math.abs(num2 *times);
			   num = num - num%num2;
			}
			num=num/times;
		} else if (option == 'mod') {
		    if (num2 == 0) throw {code: 'SS_ERROR_INFINITY',cal: option};
			num=num-num2*(-(Math.ceil(-(num/num2))));
		} else if (option == 'randbetween') {
		    if (num > num2) throw {code: 'CAL_PARAM_NEED_BE_NUM',cal: option};
		    num = Math.floor(Math.random()*(num2 - num +1)+num);	    
		} else if (option == 'quotient') {
		    if (num2 == 0) throw {code: 'SS_ERROR_INFINITY',cal: option};
		    num = num / num2;
			num = (num > 0)? Math.floor(num) : Math.ceil(num);
		} else if (option == 'atan2') {
		    if (num2 == 0 && num == 0) throw {code: 'SS_ERROR_INFINITY',cal: option};
		    num = Math.atan2(num2,num);
		} 
			
		// check the case ... 1.6105100000000000001 at this case we need chop. Example: =POWER(1.1,5)
		var digitalLen = HELPER.getDigitalLen(num);
		if (digitalLen > 13) num = HELPER.roundUpNonZero(num);
        
		return num;
	},
	
	/**
	 * @public
     *  this is the function to calculate the math function floor, ceiling, mod (2 parameters) etc
     *  @param {string} - args
     *  @param {string} - option. Should be: round, roundup. rounddown
	 **/
	mathCommonRound : function(arguments, option, myScope) {
		var me = myScope.me, isheet = myScope.sheet, irow = myScope.row, icol = myScope.col, calculates = me.calculates;		
		var len = arguments.length; 		
		if (len != 2 && len != 1) throw {code: 'CAL_PARAM_MISS', cal: option};
		
		var result = this.checkCoordValid(arguments);
		if(true !== result) throw {code: 'CAL_INCORRECT_COORD',span: result};	
		
		var digital = 0;
		if (2 == len) digital = arguments[1];
		if(me.isCoordObj(digital)){
			digital = calculates.valof.call(myScope, digital);
		}
		
		// throw error if empty
		if (digital === undefined || digital === "") throw {code: 'CAL_PARAM_MISS', cal: option};
		digital = Number(digital);
		if(Ext.isNumber(digital)) {
			if (option != 'mround') {
				if (digital >= 0) digital = Math.floor(digital);
				else digital = Math.ceil(digital);
			}
		} else throw {code: 'CAL_PARAM_MISS', cal: option};		
		
		var posOffset = arguments[0];
		if(me.isCoordObj(posOffset)){
			posOffset = calculates.valof.call(myScope, posOffset);
		}
		if (posOffset === undefined || posOffset === "") throw {code: 'CAL_PARAM_MISS', cal: option};
		
		var num = Number(posOffset);
		if(Ext.isNumber(num)){
			var base = Math.pow(10, digital);
			var result = num;
			
			if (option == 'round') {	
				result = Math.round(Math.abs(num)*base)/base;
				if(num<0) result=-result;			
			} else if (option == 'rounddown') {
				if(num>0) result = Math.floor(num*base)/base ;
				else result = - Math.floor(Math.abs(num)*base)/base;				
		    } else if (option == 'roundup') {	
		    	if(num>0) result = Math.ceil(num*base)/base;
		    	else result = Math.floor(num*base)/base;
			} else if (option == 'mround') {	
		    	if (num === 0 || digital === 0) return 0;
		    	if ((num < 0 && 0 < digital) || (digital < 0 && 0 < num)) throw {code: 'NUM_IS_NOT_RIGHT', cal: option};
		    	result = Math.floor(num / digital + 0.5) * digital;		    	
		    	var digitalLen = HELPER.getDigitalLen(result);
		        if (digitalLen > 13) result = HELPER.roundUpNonZero(result);
			}
			
			return result;
		} else throw {code: 'CAL_NO_VALUE', cal: option};	
	},
	
	/**
	 * this is a general function for calculate related math formula 
	 * @param {string} - args
     * @param {string} - option. Should be: ln, log10, tanh
	 */
	mathCommonFunction5 : function(arguments, option, myScope) {	
		var me = myScope.me, isheet = myScope.sheet, irow = myScope.row, icol = myScope.col, calculates = me.calculates;				
		if (1 != arguments.length) throw {code: 'CAL_PARAM_MISS', cal: option};

		var num = arguments[0];
		if(me.isCoordObj(num)) num = calculates.valof.call(myScope, num);
		if (num === undefined || num == null ) num = 0;
		else if (Ext.isNumber(Number(num))) num = Number(num);
		else throw {code: 'CAL_PARAM_NEED_BE_NUM', cal: option};
		
		//var num = calculates.numberof.call(myScope, arguments[0]);
		//if (num === undefined || num === "")  throw {code: 'CAL_PARAM_NEED_BE_NUM', cal: option};
		
	    if (option == "LOG10" || option == "LN") {
	    	if(num <= 0) throw {code: 'NUM_IS_NOT_RIGHT', cal: option};
	    }
	    
	    if (option == "ACOSH") { 
	    	if(num < 1) throw {code: 'NUM_IS_NOT_RIGHT', cal: option}; 
	    }
	    
	    if (option == "ATANH" || option == "ACOS" || option == "ATANH" || option == "ASIN") { 
	    	if(num < -1 || num > 1) throw {code: 'NUM_IS_NOT_RIGHT', cal: option}; 
	    }
	    
	    if (option == "COT" && num == 0) throw {code: 'SS_ERROR_INFINITY', cal: option}; 

	    var result = 0;
	    if (option == "LOG10") result = Math.log(num);
	    else if (option == "LN") result = Math.log(num) / Math.log(2.71828182845904);
	    else if (option == "TANH") result = (Math.exp(num) - Math.exp(-num)) / (Math.exp(num) + Math.exp(-num));
	    else if (option == 'ACOS') result = Math.acos(num);
		else if (option == 'ASIN') result = Math.asin(num);
		else if (option == 'ATAN') result = Math.atan(num);
	    else if (option == 'ATANH') result = 0.5 * Math.log((1 + num) / (1 - num));
	    else if (option == 'CSC') result = 1/Math.sin(num);
	    else if (option == 'CSCH') result = 2 / (Math.exp(num) - Math.exp(-num));
		else if (option == 'SIN') result = Math.sin(num);
	    else if (option == 'SINH') result = (Math.exp(num) - Math.exp(-num)) / 2;
		else if (option == 'COS') result = Math.cos(num);
	    else if (option == 'SEC') result = 1/Math.cos(num);
	    else if (option == 'SECH') result = 2 / (Math.exp(num) + Math.exp(-num));
	    else if (option == 'COSH') result = (Math.exp(num) + Math.exp(-num)) / 2;
		else if (option == 'TAN') result = Math.tan(num);
	    else if (option == 'ACOSH') result = Math.log(num + Math.sqrt(num * num - 1));
	    else if (option == 'ASINH') result = Math.log(num + Math.sqrt(num * num + 1));
	    else if (option == 'COT') result = Math.tan(Math.PI/2-num);
	    else if (option == 'COTH') result = (Math.exp(num) + Math.exp(-num)) / (Math.exp(num) - Math.exp(-num));
	    else if (option == 'ACOT') result = Math.PI/2 - Math.atan(num);
	    
	    if (result == 'Infinity' || result == '-Infinity') throw {code: 'SS_ERROR_INFINITY', cal: option}; 
	    
	    var digitalLen = HELPER.getDigitalLen(result);
		if (digitalLen > 13) result = HELPER.roundUpNonZero(result);			
		return result;		
	},
	
	stringCommon1 : function(arguments, option, myScope) {
		var me = myScope.me, isheet = myScope.sheet, irow = myScope.row, icol = myScope.col, calculates = me.calculates;		
		var len = arguments.length; 		
		if (len != 1) throw {code: 'CAL_PARAM_MISS', cal: option};
		
		var val = arguments[0];
		var result = this.checkCoordValid(arguments);
		if(true !== result) throw {code: 'CAL_INCORRECT_COORD',span: result};	
		if(me.isCoordObj(val)) val = calculates.valof.call(myScope, val);

		if (val == "#DIV/0!") throw {code:'SS_ERROR_INFINITY'};
		else if (val == "#N/A") throw { code:'VALUE_NOT_AVAILABLE', cal: option };
		else if (val == "#VALUE!") throw { code: 'CAL_NO_VALUE', cal: option};
		else if (val == "#NUM!") throw { code: 'NUM_IS_NOT_RIGHT', cal: option};
		else if (val == "#ERROR") throw { code: 'SS_ERROR', cal: option};
		
		if (option == 'upper')  {
		    if(Ext.isBoolean(val)||Ext.isNumber(val)) return val;
		    return val.toUpperCase();
		} else if (option == 'lower') {
		    if(Ext.isBoolean(val)||Ext.isNumber(val)) return val;
		    return val.toLowerCase();
		} else if (option == 'proper') { // 
		    if(Ext.isBoolean(val)||Ext.isNumber(val)) return val;
		    return val.replace(/\w\S*/g, function(txt){return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();});
		} else if (option == 'len') return val.toString().length;

	},
	
	/**
	 * this is for im formula ...
	 */
	imMathCommonFunction : function(arguments, option, myScope) {	
		var me = myScope.me, isheet = myScope.sheet, irow = myScope.row, icol = myScope.col, calculates = me.calculates;				
		if (1 != arguments.length) throw {code: 'CAL_PARAM_MISS', cal: option};
		
		var inumber = arguments[0];
	    if(me.isCoordObj(inumber)) inumber = calculates.valof.call(myScope, inumber);
	    
	    if (option == "IMSIN" || option == "IMCOS" || option == "IMCOSH" || option == "IMCOT"
	    	|| option == "IMCSC" || option == "IMCSCH" || option == "IMSINH" || option == "IMSEC"
	    	|| option == "IMSECH") {
	        if (inumber === true || inumber === false) throw { code: 'VALUE_NOT_AVAILABLE', cal: option };
	    }
	    
	    inumber = inumber.toString(); 
	    
	    if (option == "IMARGUMENT") {
	    	return HELPER.IMARGUMENT(inumber);
	    } else if (option == "IMAGINARY") {
	    	return HELPER.IMAGINARY(inumber);
	    } else if (option == "IMREAL") {
			return HELPER.IMREAL(inumber);
		} 
	    
		var x = HELPER.IMREAL(inumber);
		var y = HELPER.IMAGINARY(inumber);
		
		var unit = inumber.substring(inumber.length - 1);
        unit = (unit === 'i' || unit === 'j') ? unit : 'i';
			  
		// Return error if either coefficient is not a number
		if (x === '#NUM!' || y === '#NUM!') throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: option };
			
		var result;
		if (option == "IMSIN") {
			result = HELPER.COMPLEX(Math.sin(x) * (Math.exp(y) + Math.exp(-y)) / 2, Math.cos(x) * (Math.exp(y) - Math.exp(-y)) / 2, unit);
		} else if (option == "IMCOS") {
			result = HELPER.COMPLEX(Math.cos(x) * (Math.exp(y) + Math.exp(-y)) / 2, - Math.sin(x) * (Math.exp(y) - Math.exp(-y)) / 2, unit);
		} else if (option == "IMLOG10") {
			result = HELPER.COMPLEX(Math.log(Math.sqrt(x * x + y * y)) / Math.log(10), Math.atan(y / x) / Math.log(10), unit);
		} else if (option == "IMLOG2") {
			result = HELPER.COMPLEX(Math.log(Math.sqrt(x * x + y * y)) / Math.log(2), Math.atan(y / x) / Math.log(2), unit);	
		} else if (option == "IMABS") {
		    result = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));	
		} else if (option == "IMLN") {
		    result = HELPER.COMPLEX(Math.log(Math.sqrt(x * x + y * y)), Math.atan(y / x), unit);
		} else if (option == "IMEXP") {
			var e = Math.exp(x);
		    result = HELPER.COMPLEX(e * Math.cos(y), e * Math.sin(y), unit);
		} else if (option == "IMCONJUGATE") {
			return (y !== 0) ? HELPER.COMPLEX(x, -y, unit) : inumber;
		} else if (option == "IMCOSH") {
			return HELPER.COMPLEX(Math.cos(y) * (Math.exp(x) + Math.exp(-x)) / 2, Math.sin(y) * (Math.exp(x) - Math.exp(-x)) / 2, unit);
		} else if (option == "IMCOT") {
			var val1 = HELPER.COMPLEX(Math.cos(x) * (Math.exp(y) + Math.exp(-y)) / 2, - Math.sin(x) * (Math.exp(y) - Math.exp(-y)) / 2, unit);
			var val2 = HELPER.COMPLEX(Math.sin(x) * (Math.exp(y) + Math.exp(-y)) / 2, Math.cos(x) * (Math.exp(y) - Math.exp(-y)) / 2, unit);
			return HELPER.IMDIV(val1, val2);
		} else if (option == "IMCSC") {
			var val2 = HELPER.COMPLEX(Math.sin(x) * (Math.exp(y) + Math.exp(-y)) / 2, Math.cos(x) * (Math.exp(y) - Math.exp(-y)) / 2, unit);
			return HELPER.IMDIV('1', val2);
		} else if (option == "IMCSCH") {
			var val2 = HELPER.COMPLEX(Math.cos(y) * (Math.exp(x) - Math.exp(-x)) / 2, Math.sin(y) * (Math.exp(x) + Math.exp(-x)) / 2, unit);
			return HELPER.IMDIV('1', val2);
		} else if (option == "IMSINH") {
			return HELPER.COMPLEX(Math.cos(y) * (Math.exp(x) - Math.exp(-x)) / 2, Math.sin(y) * (Math.exp(x) + Math.exp(-x)) / 2, unit);
		} else if (option == "IMSEC") {
			var val2 = HELPER.COMPLEX(Math.cos(x) * (Math.exp(y) + Math.exp(-y)) / 2, - Math.sin(x) * (Math.exp(y) - Math.exp(-y)) / 2, unit);
			return HELPER.IMDIV('1', val2);
		} else if (option == "IMSECH") {
			var val2 = HELPER.COMPLEX(Math.cos(y) * (Math.exp(x) + Math.exp(-x)) / 2, Math.sin(y) * (Math.exp(x) - Math.exp(-x)) / 2, unit);
			return HELPER.IMDIV('1', val2);
		} else if (option == "IMSQRT") {
			var absVal = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));	
			var s = Math.sqrt(absVal);
            var t = HELPER.IMARGUMENT(inumber);
            return HELPER.COMPLEX(s * Math.cos(t / 2), s * Math.sin(t / 2), unit);
		} else if (option == "IMTAN") {
			var val1 = HELPER.COMPLEX(Math.sin(x) * (Math.exp(y) + Math.exp(-y)) / 2, Math.cos(x) * (Math.exp(y) - Math.exp(-y)) / 2, unit);
			var val2 = HELPER.COMPLEX(Math.cos(x) * (Math.exp(y) + Math.exp(-y)) / 2, - Math.sin(x) * (Math.exp(y) - Math.exp(-y)) / 2, unit);
			return HELPER.IMDIV(val1, val2);
		} 
 				
		return result;		
	},
	
	/**
	 * this is for im formula ...
	 */
	imMathCommonFunction2 : function(arguments, option, myScope) {	
		var me = myScope.me, isheet = myScope.sheet, irow = myScope.row, icol = myScope.col, calculates = me.calculates;				
		if (2 > arguments.length) throw {code: 'CAL_PARAM_MISS', cal: option};
		
		var result = arguments[0];
	    if(me.isCoordObj(result)) result = calculates.valof.call(myScope, result);
	    result = result.toString();  
	    	    
		for (var i = 1; i < arguments.length; i++) {
		    // Lookup coefficients of two complex numbers
		    var a = HELPER.IMREAL(result);
		    var b = HELPER.IMAGINARY(result);
		    
		    var inumber2 = arguments[i];
	        if(me.isCoordObj(inumber2)) inumber2 = calculates.valof.call(myScope, inumber2);
	        inumber2 = inumber2.toString(); 
		    
		    var c = HELPER.IMREAL(inumber2);
		    var d = HELPER.IMAGINARY(inumber2);
		 
		    // Return error if either coefficient is not a number
		    if (a === '#NUM!' || b === '#NUM!' || c === '#NUM!' || d === '#NUM!') throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: option };
		    
		    // Complute product of two complex numbers
		    if (option == "IMSUM") {
		         result = HELPER.COMPLEX(a + c, b + d);
		    } else if (option == "IMPRODUCT") {
		    	 result = HELPER.COMPLEX(a * c - b * d, a * d + b * c);
		    } 
		}
		
		return result;		
	},
	
	/**
	 * @public
     *  this is the function to check statistical formula
     *  @param {string} - args
     *  @param {string} - option. Should be: isText
	 **/
	statisticalCommon : function(arguments, option, myScope) {
		var me = myScope.me, isheet = myScope.sheet, irow = myScope.row, icol = myScope.col, calculates = me.calculates;		
		var len = arguments.length; 		
		if (len != 1) {
			throw {code: 'CAL_PARAM_MISS', cal: option};
		}
		
		var val = arguments[0];
		var result = this.checkCoordValid(arguments);
		if(true !== result) throw {code: 'CAL_INCORRECT_COORD',span: result};	

		if(me.isCoordObj(val)) val = calculates.valof.call(myScope, val);
		
		if (val === undefined || val === "" || SCOM.isEmptyStr(val)) {
		    if (option == "istext" || option == "isnumber" || option == "islogical") return false;
			else if (option == "isblank" ) return true;
			else if (option == "n" ) return 0;
		}
		
		// catch for isblank
		if (option == "isblank") return false;	
		if (HELPER.isBoolean(val)) {
		    if (option == "islogical") return true;
			else if (option == "istext" || option == "isnumber") return false;
			else if (option == "n" ) {
				var result = HELPER.getBoolean(val);
			    if (result) return 1; 
				else return 0;
			};
		}
		
		// check for special case for N - if it is string ...
		if (option == "n"  && Ext.isString(val)) return 0;
		if (option == "istext" && Ext.isString(val)) return true;
		
	    // check whether it is date - --- TODO
		/**
		var checkDate = ds.prepareDate(val);
		if(checkDate){
			val = Ext.ss.common.Helper.convertDateToNum(checkDate);
		}
		**/

		var num = Number(val);
		if(!Ext.isNumber(num)) {
			
		    if (option == "n" ) {
			    if (val == "#DIV/0!") throw {code: 'SS_ERROR_INFINITY', cal: option};
				else if (val == "#N/A") throw {code: 'VALUE_NOT_AVAILABLE', cal: option};
				else if (val == "#VALUE!") throw {code: 'CAL_NO_VALUE', cal: option};
				else if (val == "#NUM!") throw {code: 'CAL_PARAM_NEED_BE_NUM', cal: option};
				else return 0;
			}
		    if (option == "istext") return true;
		} else {
		    if (option == "n" ) return num;
		    if (option == "isnumber") return true;
		}
		
		return false;
	},
	
	/**
	 * this is a general function for calculate related math formula 
	 * @param {string} - args
     * @param {string} - option. Should be: floor, ceiling, mod etc
	 */
	stdevCommonFunction : function(arguments, option, myScope) {
		
		var me = myScope.me, isheet = myScope.sheet, irow = myScope.row, icol = myScope.col, calculates = me.calculates;		
		var len = arguments.length; 		
		if(0 == len) throw {code: 'CAL_PARAM_MISS', cal: option};
		
		var result = this.checkCoordValid(arguments);
		if(true !== result) throw {code: 'CAL_INCORRECT_COORD',span: result};	
		
		var arrObj = calculates.rangeNumsOf2.call(myScope, arguments, option);
		if ( arrObj.length == 0 || arrObj.length == 1 ) throw {code: 'SS_ERROR_INFINITY',cal: option};	
		
		var mean = 0, sum = 0, sumdev = 0;
		for (var i=0; i<arrObj.length; i++) {
			sum += arrObj[i];
		}
		mean = sum / arrObj.length;
		
		// calculate 
		for (var i=0; i<arrObj.length; i++) {
			sumdev += (arrObj[i]-mean)*(arrObj[i]-mean);
		}
		
		var baseVal = arrObj.length - 1;
		if (option == "stdev.p" || option == "var.p") baseVal = arrObj.length;
		var result = sumdev / baseVal;
		
		if (option == "stdev.p" || option == "stdev.s" || option == "stdev") return Math.sqrt(result);	
		if (option == "var.p" || option == "var.s" || option == "var") return result;	
	},
	
   /**
	 * this is a general function for calculate related math formula 
	 * @param {string} - args
     * @param {string} - option. Should be: floor, ceiling, mod etc
	 */
	rankCommonFunction : function(arguments, option, myScope) {
		var me = myScope.me, isheet = myScope.sheet, irow = myScope.row, icol = myScope.col, calculates = me.calculates;		
		var len = arguments.length; 		
		if(0 == len) throw {code: 'CAL_PARAM_MISS', cal: option};
		
		var result = this.checkCoordValid(arguments);
		if(true !== result) throw {code: 'CAL_INCORRECT_COORD',span: result};
                       
        if (2 != len && 3 != len) throw {code: 'CAL_PARAM_MISS',cal: option};
        var inumber = arguments[0];
	    if(me.isCoordObj(inumber)) inumber = calculates.numberof.call(myScope, inumber);
	        
	    var iorder = 0; // default - descending order
        if (len == 3) {
        	iorder = arguments[2];
			if(me.isCoordObj(iorder)) iorder = calculates.valof.call(myScope, iorder);
        	if (iorder && iorder != 0 && iorder != "0") iorder = 1;
        }
	        
        // get ref now ...
        var posOffset = arguments[1], arrObj = [];
		if (Ext.isArray(posOffset)) {
			arrObj = posOffset;
		} else {
			var key = posOffset.span.join("-");
			if (key.charAt(0) == "-") key = isheet + key;
			arrObj = HELPER.getValueFromCache(key);
			if (!arrObj || arrObj.length == 0) {					
				arrObj = calculates.rangeNumsOf2.call(myScope, [posOffset], option);
				HELPER.addValueToCache(key, arrObj);
			}
		}

	    if (arrObj.length == 0) throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: option};
	    if (iorder == 0) arrObj = HELPER.sortNumberArray(arrObj, "desc");
	    else arrObj = HELPER.sortNumberArray(arrObj, "asc");
	    
	    // The difference between these two functions occurs when there are duplicates in the list of values. 
	    // The Rank.Eq function returns the lower rank, whereas the Rank.Avg function returns the average rank.
	    var result = 0, total = 0;
        for ( var i = 0; i < arrObj.length; i++) {
        	if (arrObj[i] == inumber) {
        		if (option == "rank.eq") return i+1;
        		else {
        			result = result + i+1;
        			total = total + 1;
        		}
        	}
        }
        
        if (total > 0) return result / total; 
	        
	    throw { code: 'VALUE_NOT_AVAILABLE', cal: 'RANK'};
	},
	
	coupCommonFn : function(arguments, option, myScope) {	
		var me = myScope.me, isheet = myScope.sheet, irow = myScope.row, icol = myScope.col, calculates = me.calculates;
        var len = arguments.length; 
		if(3 != len && 4 != len) throw { code: 'CAL_PARAM_MISS', cal: option };
		
		var result = me.checkCoordValid(arguments);
		if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
		var settlement = arguments[0], maturity = arguments[1], frequency = arguments[2], basis = 0;
		if(me.isCoordObj(frequency)) frequency = calculates.numberof.call(myScope, frequency);
			
		if (len == 4) {
			basis = arguments[3];
			if(me.isCoordObj(basis)) basis = calculates.numberof.call(myScope, arguments[3]);
		}
			
		if (frequency != 1 && frequency != 2 && frequency != 4) throw { code: 'NUM_IS_NOT_RIGHT', cal: 'frequency' };
		if (basis > 4 || basis < 0) throw { code: 'NUM_IS_NOT_RIGHT', cal: 'basis' };

		if(me.isCoordObj(settlement)) settlement = calculates.valof.call(myScope, settlement);	
		settlement = SFORMAT.checkingDate(settlement);
		if(settlement == null) throw {code: 'CAL_NO_VALUE', cal: option};	

		if(me.isCoordObj(maturity)) maturity = calculates.valof.call(myScope, maturity);	
		maturity = SFORMAT.checkingDate(maturity);
		if(maturity == null) throw {code: 'CAL_NO_VALUE', cal: option};
		
		if (HELPER._compare2Date(settlement, maturity) > 0) throw {code: 'NUM_IS_NOT_RIGHT', cal: option};	
		
		var months = 12 / frequency, preSettleDate = maturity, nextSettleDate = maturity, count = 0;
		while (HELPER._compare2Date(settlement, preSettleDate) < 0) {
			nextSettleDate = preSettleDate;
			preSettleDate = Ext.Date.add(preSettleDate, Ext.Date.MONTH, 0 - months); 
			count++;
		}
		
		if (option == "couppcd") {
			result = preSettleDate;
		} else if (option == "coupncd") {
			result = nextSettleDate;
		} else if (option == "coupnum") {
			return count;
		} else if (option == "coupdays") {
			// ok, need check basis
			return HELPER.calDiffDateByMethod(nextSettleDate, preSettleDate, basis, frequency);
		} else if (option == "coupdaysnc") {
			// ok, need check basis
			return HELPER.calDiffDateByMethod(nextSettleDate, settlement, basis, frequency);
		} 
			
		return Ext.Date.format(result, SCONST.DEFAULT_DATE_FORMAT);
	},
                       
    /**
     * add new calculate
     * return true if add the new calculate successfully, or return false
     * it will return false if there is already existed a calculate with the same name
     */
    addCalculate : function(calName, calFun){
        if(!this.calculates[calName]){
            this.calculates[calName] = calFun;            
            delete(this._exposeEnv.envStr);
            
            return true;
        }else{
            return false;
        }
    },
	
	/******************************************************
	 * below are the specifical calculate methods
	 * all calculate need put in calcualtes object
	 ******************************************************/
	calculates : {
		
		/*========================================================================================
		 * The following method are for general function ...
		 *========================================================================================*/
        'beval': function(coord){
            return coord;
        },
        
		/*
		 * get the value of a cell, only work when the coord is a single cell
		 * @param {object} coord:the coord object, such as : {span:[0, 1,1,1,1], type:2}
		 */
		'valof' : function(coord, notThrowFlag){
            if(0 === arguments.length){
                if(!notThrowFlag){
                    throw { code: 'CAL_PARAM_MISS', cal: 'valof' };
                }
                return;
            }
			var me = this.me;
			var store = this.store;					
			if(Ext.isArray(coord)){
				coord = coord[0];
			}
			var span = coord['SPAN'] || coord['span'], type = coord['TYPE'] || coord['type'];
			var result = me.checkCoordValid(coord);
            if(true !== result){
                if(!notThrowFlag){
                    throw {code: 'CAL_INCORRECT_COORD',span: result};
                }
                return;
            }

			var sheet = '' === span[0] ? this.sheet : span[0], row = span[1], col = span[2], erow = span[3], ecol = span[4];				
				if(SCONST.RELATIVE_COORD == type){
					row += this.row;
                    erow += this.row;
					col += this.col;
                    ecol += this.col;
				}else if(SCONST.ABSOLUTE_ROW_COORD == type){
					col += this.col;
                    ecol += this.col;
				}else if(SCONST.ABSOLUTE_COL_COORD == type){
					row += this.row;
                    erow += this.row;
				}
			var cell = store.getCell(sheet, row, col);
			if(false != SCOM.typeOf(cell.minrow)){
				var abMinRow = row+cell.minrow, abMaxRow = row+cell.maxrow, abMinCol = col+cell.mincol, abMaxCol = col+cell.maxcol;				
				
				if(abMinRow === row && abMaxRow === erow && abMinCol === col && abMaxCol === ecol){
					erow = abMinRow;
					ecol = abMinCol;
				}
			}
			if(row == erow && col == ecol){				
				
				if(0 != row && 0 != col){
					/*
					 * avoid corner, row and column
					 */
					var cell = me.getCellData(sheet, row, col, this);								
					
					var data;
					if(SCOM.nullOrUndefined(cell.data)) data = "";
					else data = cell.data;	

					return data;
				}				
			}
            if(!notThrowFlag){
                throw {code: 'CAL_NO_VALUE',span: span};
            }
		},		
		
		'cellof' : function(coord, getWay){
			var me = this.me, store = this.store;					
			if(Ext.isArray(coord)){
				coord = coord[0];
			}
			var span = coord['SPAN'] || coord['span'], type = coord['TYPE'] || coord['type'];
			var result = me.checkCoordValid(coord);
            if(true !== result){
                throw {code: 'CAL_INCORRECT_COORD',span: result};
            }

			var sheet = '' === span[0] ? this.sheet : span[0], row = span[1], col = span[2], erow = span[3], ecol = span[4];				
			if(SCONST.RELATIVE_COORD == type){
				row += this.row;
                erow += this.row;
				col += this.col;
                ecol += this.col;
			}else if(SCONST.ABSOLUTE_ROW_COORD == type){
				col += this.col;
                ecol += this.col;
			}else if(SCONST.ABSOLUTE_COL_COORD == type){
				row += this.row;
                erow += this.row;
			}
			var cell = 'getCellData' === getWay ? store.getCellData(sheet, row, col) : store.getCell(sheet, row, col);
			return cell;
		},		
		
		/*
		 * get the value of a cell, only work when the coord is a single cell
		 * @param {object} coord:the coord object, such as : {span:[0, 1,1,1,1], type:2}
		 */
		'numberof' : function(coord, booleanIsNotNum){
			if(0 == arguments.length) throw { code: 'CAL_PARAM_MISS', cal: 'numberof' };
			var me = this.me;				
			if(Ext.isArray(coord)){
				coord = coord[0];
			}
			var span = coord['SPAN'] || coord['span'], type = coord['TYPE'] || coord['type'];
			
			// is single number
			if(true !== me.isCoordObj(coord)) return Number(coord);

			if(span[1] == span[3] && span[2] == span[4]){				
				var sheet = '' === span[0] ? this.sheet : span[0], row = span[1], col = span[2];				
				if(SCONST.RELATIVE_COORD == type){
					row += this.row;
					col += this.col;
				}else if(SCONST.ABSOLUTE_ROW_COORD == type){
					col += this.col;
				}else if(SCONST.ABSOLUTE_COL_COORD == type){
					row += this.row;
				}
				if(0 != row && 0 != col){	
					var cell = me.getCellData(sheet, row, col, this);	
					var data = cell.data;	
					if(SCOM.nullOrUndefined(data)) throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'numberof' };
					
					// check whether it is boolean
					if (HELPER.isBoolean(data)) {
						if (booleanIsNotNum) throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'numberof' };
						data = HELPER.convertBoolean2Int(data);
					}
					
					data = HELPER.convertPercent2num2(data);
					var numberObj = Number(data);
					if (!Ext.isNumber(numberObj)) throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'numberof' };
					
					return numberObj;
				}				
			}
			throw {code: 'CAL_NO_VALUE',span: span};
		},				
		
		/**
		 * this will return a range of cood back
		 */
		'rangeObjsOf' : function(coord){
			var arrObj = new Array();
			
			var me = this.me;				

			var result = me.checkCoordValid(coord);
			if(true !== result) throw {code: 'CAL_INCORRECT_COORD',span: result};
			
			me.each(this.sheet, this.row, this.col, coord, function(obj, itemType, index, insideIndex, item){	
				var data;
				if('span' == itemType){
					var sheet = obj[0], row = obj[1], col = obj[2];
					if(Ext.isNumber(sheet)){
						var cell = me.getCellData(sheet, row, col, this);									
						data = cell.data;
					}				
				}else data = obj; // if pass only 1 argument means it's a direct value
				
				arrObj.push(data);
			}, this);
			
			return arrObj;
		},
		
		/**
		 * this will return a rnage of cood back
		 */
		'rangeNumsOf2' : function(coord, formulaName){
			var arrObj = new Array();
			
			var me = this.me;
			var result = me.checkCoordValid(coord);
			if(true !== result) throw {code: 'CAL_INCORRECT_COORD',span: result};
			
			var arrObj = new Array();
			me.each(this.sheet, this.row, this.col, coord, function(obj, itemType, index, insideIndex, item){	
				var data;
				if('span' == itemType){
					var sheet = obj[0], row = obj[1], col = obj[2];
					if(Ext.isNumber(sheet)){
						var cell = me.getCellData(sheet, row, col, this);									
						data = cell.data;
						data = Number(data);		
						if (Ext.isNumber(data)) arrObj.push(data);
					}				
				} else {
					data = obj; // if pass only 1 argument means it's a direct value
				    data = Number(data);
				    if (Ext.isNumber(data)) arrObj.push(data);
				    else throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: formulaName};
				}			
			}, this);
			
			return arrObj;
		},
		
		/**
		 * this will return a rnage of cood back
		 */
		'rangeNumsOf' : function(coord){
			var arrObj = new Array();
			
			var me = this.me;
			//var result = me.checkCoordValid(coord);
			//if(true !== result) throw {code: 'CAL_INCORRECT_COORD',span: result};
			
			me.each(this.sheet, this.row, this.col, coord, function(obj, itemType, index, insideIndex, item){	
				var data;
				if('span' == itemType){
					var sheet = obj[0], row = obj[1], col = obj[2];
					if(Ext.isNumber(sheet)){
						var cell = me.getCellData(sheet, row, col, this);									
						data = cell.data;
					}				
				}else data = obj; // if pass only 1 argument means it's a direct value
				
				// TODO -- need make this work
				// data = data.replace(/,/g, '');
				
				data = Number(data);		
				if (Ext.isNumber(data)) arrObj.push(data);
			    else arrObj.push(0);
			}, this);
			
			return arrObj;
		},
		
		'rangeNumsOf3' : function(coord){
			var arrObj = new Array();
			
			var me = this.me;
			me.each(this.sheet, this.row, this.col, coord, function(obj, itemType, index, insideIndex, item){	
				var data;
				if('span' == itemType){
					var sheet = obj[0], row = obj[1], col = obj[2];
					if(Ext.isNumber(sheet)){
						var cell = me.getCellData(sheet, row, col, this);									
						data = cell.data;
					}				
				}else data = obj; // if pass only 1 argument means it's a direct value
				data = Number(data);		
				if (Ext.isNumber(data)) arrObj.push(data);
			}, this);
			
			return arrObj;
		},
		
		
		/**
		 * this will return a range with 2 dimension array ...
		 */
		'rangeVal2Dimension' : function(coord){
			var dimensionArray = [];
			
			var me = this.me;				

			var result = me.checkCoordValid(coord);
			if(true !== result) throw {code: 'CAL_INCORRECT_COORD',span: result};
			
			var preRow = null;
			var subArray = [];
			me.each(this.sheet, this.row, this.col, coord, function(obj, itemType, index, insideIndex, item){	
				var data;
				if('span' == itemType){
					var sheet = obj[0], row = obj[1], col = obj[2];
					if(Ext.isNumber(sheet)){
						var cell = me.getCellData(sheet, row, col, this);									
						data = cell.data;
					}
					
					// now check whether row changed ...
					if (preRow != null && preRow != row) {
						dimensionArray.push(subArray);
						subArray = [];			
						preRow = row;
					}
					
					if (preRow == null) preRow = row; 
					subArray.push(data);
				}else if('array' == itemType){
					
				}
			}, this);
			
			dimensionArray.push(subArray);
			
			return dimensionArray;
		},
		
		/*========================================================================================
		 * The following formulas are related to Mathematical
		 *========================================================================================*/
		// this is for couple of math function ...
		'odd' : function() {
			return this.me.mathCommonFunction2(arguments, 'odd', this);
		},
		'even' : function() {
			return this.me.mathCommonFunction2(arguments, 'even', this);
		},
		'abs' : function() {
			return this.me.mathCommonFunction2(arguments, 'abs', this);
		},
		'sqrt' : function() {
			return this.me.mathCommonFunction2(arguments, 'sqrt', this);
		},
		'sqrtpi' : function() {
			return this.me.mathCommonFunction2(arguments, 'sqrtpi', this);
		},	
		'degrees' : function() {
			return this.me.mathCommonFunction2(arguments, 'degrees', this);
		},
		'exp' : function() {
			return this.me.mathCommonFunction2(arguments, 'exp', this);
		},
		'fact' : function() {
			return this.me.mathCommonFunction2(arguments, 'fact', this);
		},
		'factdouble' : function() {
			return this.me.mathCommonFunction2(arguments, 'factdouble', this);
		},
		'int' : function() {
			return this.me.mathCommonFunction2(arguments, 'int', this);
		},
		'radians' : function() {
			return this.me.mathCommonFunction2(arguments, 'radians', this);
		},	
		'sign' : function() {
			return this.me.mathCommonFunction2(arguments, 'sign', this);
		},
		
		// this is for floor, ceiling, mod, quotient, randbetween etc
		'floor' : function() {
			return this.me.mathCommonFunction4(arguments, 'floor', this);
		},
		'ceiling' : function() {
			return this.me.mathCommonFunction4(arguments, 'ceiling', this);
		},
		'mod' : function() {
			return this.me.mathCommonFunction4(arguments, 'mod', this);
		},
		'randbetween' : function() {
			return this.me.mathCommonFunction4(arguments, 'randbetween', this);
		},
		'quotient' : function() {
			return this.me.mathCommonFunction4(arguments, 'quotient', this);
		},
		'atan2' : function() {
			return this.me.mathCommonFunction4(arguments, 'atan2', this);
		},
		
		// for math round, rouddown, roundup, mround
		'round' : function() {
			return this.me.mathCommonRound(arguments, 'round', this);
		},
		'rounddown' : function() {
			return this.me.mathCommonRound(arguments, 'rounddown', this);
		},
		'roundup' : function() {
			return this.me.mathCommonRound(arguments, 'roundup', this);
		},
		'mround' : function() {
			return this.me.mathCommonRound(arguments, 'mround', this);
		},
		
		'pi' : function() {
			if (arguments.length != 0)  throw {code: 'CAL_PARAM_MISS', cal: "pi"};
			return Math.PI;
		},
		'rand' : function() {
			if (arguments.length != 0) throw {code: 'CAL_PARAM_MISS', cal: "RAND"};
			return Math.random();
		},
		
		/**
		 * Returns the number of combinations for a given number of items. Use COMBIN 
		 * to determine the total possible number of groups for a given number of items.
		 * Syntax
		 *       COMBIN(number,number_chosen)
	     */
		'combin' : function() {
			var me = this.me, calculates = me.calculates;
			var len = arguments.length; 
			if(2 != len) throw {code: 'CAL_PARAM_MISS', cal: 'combin'};
			
			var number = calculates.numberof.call(this, arguments[0]);
			var choose = calculates.numberof.call(this, arguments[1]);		
			if (number === undefined || number === "") throw {code: 'CAL_NO_VALUE', cal: 'combin'};
			if (choose === undefined || choose === "") throw {code: 'CAL_NO_VALUE', cal: 'combin'};
			if (number < 0 || choose < 0 || number < choose) throw {code: 'NUM_IS_NOT_RIGHT', cal: 'combin'};
	
			var sum1 = 1, sum2 = 1;
			for ( var i = Math.floor(number); i > Math.floor(number) - Math.floor(choose); i--)  sum1 = sum1 * i;
			for ( var i = 1; i <= Math.floor(choose); i++)  sum2 = sum2 * i;
	
			return Math.floor(sum1 / sum2);
		},
		
		/**
		 * Returns the number of combinations (with repetitions) for a given number of items.
		 * result is: (n+r-1)!/r!*(n-1)!
		 */
		'combina' : function() {
			var me = this.me, calculates = me.calculates;
			var len = arguments.length; 
			if(2 != len) throw {code: 'CAL_PARAM_MISS', cal: 'combina'};
			
			var number = calculates.numberof.call(this, arguments[0]);
			var choose = calculates.numberof.call(this, arguments[1]);		
			if (number === undefined || number === "") throw {code: 'CAL_NO_VALUE', cal: 'combina'};
			if (choose === undefined || choose === "") throw {code: 'CAL_NO_VALUE', cal: 'combina'};
			if (number < 0 || choose < 0 || number < choose) throw {code: 'NUM_IS_NOT_RIGHT', cal: 'combina'};
	
			var sum1 = 1, sum2 = 1, sum3 = 1;
			var nADDrMIN1 = Math.floor(number + choose -1), nMIN1 = Math.floor(number - 1);
			for ( var i = 1; i <= nADDrMIN1; i++)  sum1 = sum1 * i;
			for ( var i = 1; i <= nMIN1; i++)  sum2 = sum2 * i;
			for ( var i = 1; i <= Math.floor(choose); i++)  sum3 = sum3 * i;
	
			return Math.floor(sum1 / (sum2*sum3));
		},
		
		'power' : function(){
			var me = this.me, calculates = me.calculates;
			var len = arguments.length; 
			if(2 != len) throw {code: 'CAL_PARAM_MISS', cal: 'power'};
			
			var mi = arguments[1];
		    if (mi === undefined || mi === "") throw {code: 'CAL_NO_VALUE', cal: 'power'};		
			mi = calculates.numberof.call(this, mi);

			var base = calculates.numberof.call(this, arguments[0]);
			if (base === 0) return 0;

			var result = 0;
			// check whether base is boolean, if yes true -> 1, false -> 0
			if (HELPER.isBoolean(base)) base = HELPER.getBoolean(base);	
			if(Ext.isNumber(base) && Ext.isNumber(mi)) result = Math.pow(base, mi);
			else throw {code: 'CAL_PARAM_NEED_BE_NUM', cal: 'power'};
			
			// check the case ... 1.6105100000000000001 at this case we need chop. Example: =POWER(1.1,5)
			var digitalLen = HELPER.getDigitalLen(result);
			if (digitalLen > 14) result = HELPER.roundUpNonZero(result);

			return result;
		},
		
		/*
		 * Multiplies its arguments, it can be more than one param
		 * {span:[0, 1, 2, 3, 4], type: 2}, {span:[2, 1, 2, 3, 4], type: 1}, ...
		 */
		'product' : function(){		
			var len = arguments.length; 
			if(0 == len) throw {code: 'CAL_PARAM_MISS', cal: 'PRODUCT'};

			var me = this.me, store = this.store, timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw {code: 'CAL_INCORRECT_COORD', span: result};
					
			var res = 1;	
			// check to see whether all args are text
		    var allArgsNaN = true;
			me.each(this.sheet, this.row, this.col, arguments, function(obj, itemType, index, insideIndex, item){	
				var data;
				if('span' == itemType){
					var sheet = obj[0], row = obj[1], col = obj[2];
					if(Ext.isNumber(sheet)){
						var cell = me.getCellData(sheet, row, col, this);									
						data = cell.data;
					}				
				}else data = obj;
				
				num = Number(data);
				if(Ext.isNumber(num) && '' != data) {
					res *= num;
					allArgsNaN = false;
				} // else throw {code: 'CAL_NO_VALUE', span: result};				
			}, this);
			
			if (allArgsNaN) res = 0;
			
			// check the case ... 1.6105100000000000001 at this case we need chop. Example: =POWER(1.1,5)
			var digitalLen = HELPER.getDigitalLen(res);
			if (digitalLen > 14) res = HELPER.roundUpNonZero(res);
			
			return res;			
		},	
		
		'log' : function() {
			var len = arguments.length, me = this.me, calculates = me.calculates;
			if(0 == len || len > 2) throw {code: 'CAL_PARAM_MISS', cal: 'LOG'};
			var me = this.me;
			
			var logNum = calculates.numberof.call(this, arguments[0]);
		    if (logNum === undefined || logNum === "" || logNum <= 0)  throw {code: 'CAL_PARAM_NEED_BE_NUM', cal: 'LOG'};		
			
			var base = 10;
			if (len == 2) {
				var base = calculates.numberof.call(this, arguments[1]);
			}
			
			var result = Math.log(logNum) / Math.log(base);
			// check the case ... 1.6105100000000000001 at this case we need chop. Example: =POWER(1.1,5)
			var digitalLen = HELPER.getDigitalLen(result);
			if (digitalLen > 14) result = HELPER.roundUpNonZero(result);
			
			return result;			
		},
		
		'log10' : function() {
			return this.me.mathCommonFunction5(arguments, 'LOG10', this);	
		},	
		'ln' : function() {
			return this.me.mathCommonFunction5(arguments, 'LN', this);	
		},
		'tanh' : function() {
			return this.me.mathCommonFunction5(arguments, 'TANH', this);	
		},
		'acos' : function() {
			return this.me.mathCommonFunction5(arguments, 'ACOS', this);	
		},
		'asin' : function() {
			return this.me.mathCommonFunction5(arguments, 'ASIN', this);	
		},
		'atan' : function() {
			return this.me.mathCommonFunction5(arguments, 'ATAN', this);	
		},
		'atanh' : function() {
			return this.me.mathCommonFunction5(arguments, 'ATANH', this);	
		},
		'sin' : function() {
			return this.me.mathCommonFunction5(arguments, 'SIN', this);	
		},
		'sinh' : function() {
			return this.me.mathCommonFunction5(arguments, 'SINH', this);	
		},
		'cos' : function() {
			return this.me.mathCommonFunction5(arguments, 'COS', this);	
		},
		'cosh' : function() {
			return this.me.mathCommonFunction5(arguments, 'COSH', this);	
		},
		'csc' : function() {
			return this.me.mathCommonFunction5(arguments, 'CSC', this);	
		},
		'csch' : function() {
			return this.me.mathCommonFunction5(arguments, 'CSCH', this);	
		},
		'sec' : function() {
			return this.me.mathCommonFunction5(arguments, 'SEC', this);	
		},
		'sech' : function() {
			return this.me.mathCommonFunction5(arguments, 'SECH', this);	
		},
		'acosh' : function() {
			return this.me.mathCommonFunction5(arguments, 'ACOSH', this);	
		},
		'tan' : function() {
			return this.me.mathCommonFunction5(arguments, 'TAN', this);	
		},
		'cot' : function() {
			return this.me.mathCommonFunction5(arguments, 'COT', this);	
		},
		'coth' : function() {
			return this.me.mathCommonFunction5(arguments, 'COTH', this);	
		},
		'acot' : function() {
			return this.me.mathCommonFunction5(arguments, 'ACOT', this);	
		},
		'asinh' : function() {
			return this.me.mathCommonFunction5(arguments, 'ASINH', this);	
		},
		
		/*
		 * calculate sum of a range, it can be more than one param
		 * {span:[0, 1, 2, 3, 4], type: 2}, {span:[2, 1, 2, 3, 4], type: 1}, ...
		 */
		'sum' : function(){
			if(0 == arguments.length) throw {code: 'CAL_PARAM_MISS', cal: 'SUM'};

			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result)  throw {code: 'CAL_INCORRECT_COORD', span: result};
					
			var sum = 0;
			var maxDigNum = 0;
			
			var rangeObjs = calculates.rangeNumsOf.call(this, arguments);
            if(this.isArrayFormula && 1 === arguments.length && Ext.isArray(arguments[0])){
                return rangeObjs;
            }
			for(var i = 0, len = rangeObjs.length; i < len; i++){
				var data = rangeObjs[i];
				if (HELPER.isBoolean(data)) data = HELPER.convertBoolean2Int(data);				
				var dn = HELPER.getDigitalLen(data);
				if (dn > maxDigNum) maxDigNum = dn;
				sum += data;
			}
			
			var dn = HELPER.getDigitalLen(sum);
			if (dn > maxDigNum) sum = Ext.util.Format.round(sum, maxDigNum);
			return sum;			
		},
		
		/*
		 * Returns the sum of the squares of the arguments
		 */
		'sumsq' : function(){
			if(0 == arguments.length) throw {code: 'CAL_PARAM_MISS', cal: 'SUMSQ'};
			
			var me = this.me;
			var store = this.store, timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result)  throw {code: 'CAL_INCORRECT_COORD', span: result};
			
			var sum = 0;					
			me.each(this.sheet, this.row, this.col, arguments, function(obj, itemType, index, insideIndex, item){	
				var data;
				if('span' == itemType){
					var sheet = obj[0], row = obj[1], col = obj[2];
					if(Ext.isNumber(sheet)){
						var cell = me.getCellData(sheet, row, col, this);									
						data = cell.data;
					}				
				}else data = obj;
				
				data = Number(data);
				if(Ext.isNumber(data)) sum += Math.pow(data, 2);
				// else throw {code: 'CAL_NO_VALUE', cal: 'SUMSQ'};
			}, this);
			
			// check the case ... 1.6105100000000000001 at this case we need chop. Example: =POWER(1.1,5)
			var digitalLen = HELPER.getDigitalLen(sum);
			if (digitalLen > 14) sum = HELPER.roundUpNonZero(sum);
			
			return sum;			
		},
		
		/**
		 * This is for sum if function .... the SUMIF function adds all numbers in a
		 * range of cells, based on a given criteria.
		 * 
		 * SUMIF(range, criteria, [sum_range])
		 * 
		 * Example: =SUMIF(B2:B25,">5")  =SUMIF(B2:B5, "John", C2:C5)
		 * 
		 *          =SUMIF(A2:A5,">" & C2,B2:B5) - not working now ...
		 *          =SUMIF(B2:B7,"*es",C2:C7)
		 *          =SUMIF(A2:A7,"",C2:C7)
		 *
		 * range - Required. The range of cells that you want evaluated by criteria. 
		 *         Cells in each range must be numbers or names, arrays, or references that contain numbers. 
		 *         Blank and text values are ignored.
		 *         
		 * criteria - Required. The criteria in the form of a number, expression, a cell reference, text, or 
		 *            a function that defines which cells will be added. For example, criteria can be expressed 
		 *            as 32, ">32", B5, 32, "32", "apples", or TODAY().
		 *         
		 */
		'sumif' : function(){	
			var alen = arguments.length;
			if(2 > alen || alen > 3) throw {code: 'CAL_PARAM_MISS', cal: 'SUMIF'};
			var me = this.me, sheetId = this.sheet, row = this.row, col = this.col, timestamp = this.timestamp;			
			var store = this.store;
			
			var result = me.checkCoordValid(arguments);
			if(true !== result)  throw {code: 'CAL_INCORRECT_COORD', span: result};
			
			var args = me.transferAll2Absolute(arguments, sheetId, row, col);
			var checkSpan = args[0], standSpan = args[1], resultSpan = args[2];
			/*
			 * process stand
			 */
			var stand, standData, standVal;
			if(me.isCoordObj(standSpan)){
				stand = standSpan.span;							
				/*
				 * get the standard value
				 */
				standData = me.getCellData(stand[0], stand[1], stand[2], this);							
				standVal = standData.data;
			}else{
				standVal = standSpan;
			}
			
			if(!Ext.isDefined(standVal)) throw {code: 'CAL_NO_VALUE', cal: 'SUMIF'};

			var isExpress = false;
			if(Ext.isString(standVal)){
				isExpress = me.isExpress(standVal);		
				if(isExpress) standVal = me.specialCaseForCalculateStr(standVal, true);
			}
			
			/*
			 * process check span
			 */
			var check = checkSpan.span;			
			/*
			 * process result span
			 */
			var result;
			if(resultSpan){
				result = resultSpan.span;				
			}else{
				result = [].concat(check);
			}					
			
			var rowOffset = result[1]-check[1], colOffset = result[2]-check[2];
			var sum = 0;
			/*
			 * loop the check span to get the sum
			 */
			store.walkRange([check], function(rd, span, store){				
				var cell = me.getCellData(rd.data.sheet, rd.data.row, rd.data.col, this);		
				var match = false;
				/*
				 * check whether match
				 */
				if(isExpress){
					var num = Number(cell.data);
					
					if(Ext.isNumber(num)){
						match = eval(num+standVal);
					}else{
						match = eval('"'+cell.data+'"'+standVal);
					}
				}else{
					if(cell.data == standVal || SCOM.kmpCompare(cell.data, standVal)){
						match = true;					
					}
				}				
				if(match){
					var rsRow = rd.data.row+rowOffset, rsCol = rd.data.col+colOffset;
					var rsCell = me.getCellData(result[0], rsRow, rsCol, this);					
					if(SCOM.canbeNumber(rsCell.data)){
						sum += Number(rsCell.data);
					}
				}
			}, this);
			
			return sum;
		},
		
		/**
		 * Adds the cells in a range that meet multiple criteria.
		 * 
		 * Examples: =SUMIFS(A1:A20, B1:B20, ">0", C1:C20, "<10")
		 * SUMIFS(sum_range, criteria_range1, criteria1, [criteria_range2, criteria2],
		 * 
		 * sum_range    Required. One or more cells to sum, including numbers or names, ranges, or cell references that contain numbers. Blank and text values are ignored.
		 * criteria_range1    Required. The first range in which to evaluate the associated criteria.
		 * criteria1    Required. The criteria in the form of a number, expression, cell reference, or text that define which cells in the criteria_range1 argument will be added. For example, criteria can be expressed as 32, ">32", B4, "apples", or "32."
		 * 
		 * Each cell in the sum_range argument is summed only if all of the corresponding criteria specified are true for that cell.
		 * Cells in the sum_range argument that contain TRUE evaluate to 1; cells in sum_range that contain FALSE evaluate to 0 (zero).
		 * Unlike the range and criteria arguments in the SUMIF function, in the SUMIFS function, each criteria_range argument must contain the same number of rows and columns as the sum_range argument.
		 * 
		 */
		'sumifs' : function() {
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp, isheet = this.sheet, irow = this.row, icol = this.col;
			var len = arguments.length; 		
			if (len < 3 || len % 2 == 0) throw {code: 'CAL_PARAM_MISS',cal: 'sumifs'};

			var result = me.checkCoordValid(arguments);
			if(true !== result) throw {code: 'CAL_INCORRECT_COORD',span: result};  // should be 3, 5, 7 ...
			
			var sumRange = arguments[0];
			if (Ext.isObject(sumRange)) {
				sumRange = calculates.rangeVal2Dimension.call(this, [sumRange]);
			} 
			if (sumRange == null || sumRange.length == 0)  throw { code: 'CAL_NO_VALUE', cal: 'sumifs' };
			var sumRangeXlength = sumRange.length;
		    var sumRangeYlength = sumRange[0].length;
		    
	        // now we need go through criteria ...
			var criteriaRangeArr = [], criteriaArr = [];
			
			var i = 1;
			while (i < len) {
				// loop through each item ...
				var criteraRange = arguments[i];
				if (Ext.isObject(arguments[i])) {
					criteraRange = calculates.rangeVal2Dimension.call(this, [arguments[i]]); 
				} 
				if (criteraRange == null || criteraRange.length == 0) throw { code: 'CAL_NO_VALUE', cal: 'sumifs' };
				var criteraRangeXlength = criteraRange.length;
				var criteraRangeYlength = criteraRange[0].length;
				
				// add condition - each criteria_range argument must contain the same number of rows and columns as the sum_range argument.
	            if (sumRangeXlength != criteraRangeXlength || sumRangeYlength != criteraRangeYlength) throw { code: 'CAL_NO_VALUE', cal: 'sumifs' };
				criteriaRangeArr[criteriaRangeArr.length] = criteraRange;
				i = i + 1;
				
				// get condition now ...
				var cond = arguments[i];
				if(me.isCoordObj(cond)) cond = calculates.valof.call(this, cond);
				if (Ext.isString(cond))  {
					cond = Ext.util.Format.htmlDecode(cond);
					// add one more condition for cond --- if it is =A* => this as: A*
				    cond = HELPER.changeCondSpecialCase(cond);	
				    // convert condition ...
				    if (HELPER.isExpress(cond)) {
			    		// check to see whether criteria is single =,
						// case: >=, <=, !=, <>, and = >. If it is only =, make it double ...
						cond = HELPER.updateCompareCondition(cond);
				    }
				}		
				criteriaArr[criteriaArr.length] = cond;		
				i = i + 1;
			}		    
			
			// now start to calculate result 
			var result = 0;
			for ( var i = 0; i < sumRangeXlength; i++) {
				for ( var j = 0; j < sumRangeYlength; j++) {
					
					// check condition now ... loop each criteria same position
					var flag = true;
					for (var k=0; k < criteriaRangeArr.length; k++) {
						var criteraRange = criteriaRangeArr[k];
						// get related value now 
						var data = criteraRange[i][j];
						data = HELPER.convertPercent2num2(data); // check special case ...if it is %
						
						// get criteria value ...
						var cond = criteriaArr[k];
						var condflag = false;
						
						/*
						 * check whether it's a compare function - <> = ! start with ...
						 */
						if (HELPER.isExpress(cond)) {	
							if (Ext.isNumber(Number(data)))
								condflag = eval(data + cond);
							else {
								condflag = eval('"' + data + '"' + cond);
							}
						} else if (SCOM.kmpCompare(data.toString(), cond.toString())) {
							condflag = true;
						}
					    flag = flag && condflag;			
					}
					
					// if flag is true --- ok condition meet
					if (flag) {
						var sumData = sumRange[i][j];
						sumData = Number(sumData);
						if (Ext.isNumber(sumData)) {
							result += sumData;
						}
					}
				}
			}
			
			return result;
		},
		
		/**
		 * the SUMPRODUCT function multiplies the corresponding items in the arrays
		 * and returns the sum of the results.
		 *        =SUMPRODUCT({1,2;3,4}, {5,6;7,8})
		 * The array arguments must have the same dimensions. If they do not,
		 * SUMPRODUCT returns the #VALUE! error value.
		 * SUMPRODUCT treats array entries that are not numeric as if they were zeros.
		 *
		 * Another case: =SUMPRODUCT(B2:B11*C2:C11)
		 *               =SUMPRODUCT(B2:B11/C2:C11)
		 *
		 * TODO: You may include a criterion within a SUMPRODUCT formula.
		 * Applying a Criterion to SUMPRODUCT:
		 * 
		 * Special case: 
		 *     =SUMPRODUCT((C2:C11*D2:D11)*(B2:B11="HR")) 
		 * SUMPRODUCT With Multiple Criteria
		 *     =SUMPRODUCT((D2:D11*E2:E11)*(B2:B11="HR")*(C2:C11="Client B"))
		 **/
		'sumproduct' : function(){
			var me = this.me, calculates = me.calculates, sheetId = this.sheet;	
			var len = arguments.length; 		
			if (0 == len) throw {code: 'CAL_PARAM_MISS',cal: 'sumproduct'};
						
			var varArrs = [];
			for ( var k = 0; k < len; k++) {
				var posOffset = arguments[k];
				if (Ext.isArray(posOffset)) {
					// check whether it 2 dimesion array 
					if (Ext.isArray(posOffset[0])) varArrs.push(posOffset);
					else varArrs.push([posOffset]); // this should be a 2-dimesnion array ..
				} else if (Ext.isString(posOffset) || Ext.isNumber(Number(posOffset))) { 
					if (HELPER.isBoolean(posOffset)) throw {code: 'CAL_NO_VALUE', cal: 'sumproduct'};
				    var tempArr = [[posOffset]]; // this is 2 -dimension array ...
					varArrs.push(tempArr);
			    } else {							
			    	var key = posOffset.span.join("-");
					if (key.charAt(0) == "-") key = sheetId + key;
					var tempArr = HELPER.getValueFromCache(key)
					if (!tempArr || tempArr.length == 0) {					
						tempArr = calculates.rangeVal2Dimension.call(this, [posOffset]);
						HELPER.addValueToCache(key, tempArr);
					}
			        if (tempArr && tempArr.length == 1 && tempArr[0].length == 1 && HELPER.isBoolean(tempArr[0][0])) 
			        	throw {code: 'CAL_NO_VALUE', cal: 'sumproduct'};
			        	
			        varArrs.push(tempArr);
				}
			}
			
			if (varArrs.length == 0) throw {code: 'CAL_NO_VALUE', cal: 'sumproduct'};
			
			var total = HELPER.getSumProduct(varArrs, 'sumproduct');
			varArrs = []; // clean array - free memory
			
			return total;
		},
		
		'sumxmy2' : function() {
			return this.me.sumxmyCommon(arguments, 'sumxmy2', this);	
		},
		
		'sumx2py2' : function() {
			return this.me.sumxmyCommon(arguments, 'sumx2py2', this);	
		},
		
		'sumx2my2' : function() {
			return this.me.sumxmyCommon(arguments, 'sumx2my2', this);	
		},
		
		// MMULT function returns the matrix product of two arrays.
		'mmult' : function() {
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp, isheet = this.sheet, irow = this.row, icol = this.col;
			var len = arguments.length; 		
			if (2 !== len) throw {code: 'CAL_PARAM_MISS',cal: 'mmult'};

			var result = me.checkCoordValid(arguments);
			if(true !== result) throw {code: 'CAL_INCORRECT_COORD',span: result};
			
			var twoDimensionArray1 = calculates.rangeVal2Dimension.call(this, [arguments[0]]);
			var twoDimensionArray2 = calculates.rangeVal2Dimension.call(this, [arguments[1]]);
			
			if (twoDimensionArray1 == null || twoDimensionArray1.length == 0 ||
					twoDimensionArray2 == null || twoDimensionArray2.length == 0 )  throw { code: 'CAL_NO_VALUE', cal: 'mmult' };
			var array1ColCount = twoDimensionArray1[0].length;
			var array1RowCount = twoDimensionArray1.length;
			var array2ColCount = twoDimensionArray2[0].length;
		    var array2RowCount = twoDimensionArray2.length;
		    
		    if (array1ColCount !== array2RowCount) throw { code: 'CAL_NO_VALUE', cal: 'mmult' };
		    
            var result = [];
            for (var i = 0; i < array1RowCount; i++) {
                for (var j = 0; j < array1ColCount; j++) {
                    var value = twoDimensionArray1[i][j];
                    var num = Number(value);
				    if(!Ext.isNumber(num)) throw { code: 'CAL_NO_VALUE', cal: 'mmult' };                   
                }
            }
            
            for (var i = 0; i < array2RowCount; i++) {
                for (var j = 0; j < array2ColCount; j++) {
                    var value = twoDimensionArray2[i][j];
                    var num = Number(value);
				    if(!Ext.isNumber(num)) throw { code: 'CAL_NO_VALUE', cal: 'mmult' };                   
                }
            }
            
            for (var i2 = 0; i2 < array1RowCount; i2++) {
                result[i2] = [array2ColCount];
                for (var j2 = 0; j2 < array2ColCount; j2++){
                    var sum = 0.0;
                    for (var k = 0; k < array2RowCount; k++){
                        sum += twoDimensionArray1[i2][k] * twoDimensionArray2[k][j2];
                    }
                    result[i2][j2] = sum;
                }
            }
            
            // get an array of result ...
            return result;
		},
		
		/**
		 * Returns a subtotal in a list or database. It is generally easier to create a list with subtotals by using 
		 * the Subtotal command in the Outline group on the Data tab. Once the subtotal list is created, you can modify 
		 * it by editing the SUBTOTAL function.
		 *   Function_num     is the number 1 to 11 (includes hidden values) or 101 to 111 (ignores hidden values) that 
		 *   specifies which function to use in calculating subtotals within a list.
		 *   
		 * 1 101 AVERAGE   2 102 COUNT   3 103 COUNTA    4 104 MAX
		 * 5 105 MIN    6 106 PRODUCT    7 107 STDEV   8 108 STDEVP   9 109 SUM   10 110 VAR    11 111 VARP
		 */
		'subtotal' : function() {
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp, isheet = this.sheet, irow = this.row, icol = this.col;
			var len = arguments.length; 		
			if (2 > len) throw {code: 'CAL_PARAM_MISS',cal: 'subtotal'};
			
			// get function_num ... 1-11 at this moment
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw {code: 'CAL_INCORRECT_COORD',span: result};
			
			var function_num = calculates.numberof.call(this, arguments[0]);
		    if (function_num<1 || function_num>11)  throw {code: 'CAL_PARAM_NEED_BE_NUM', cal: 'subtotal'};
		    
		    // remvove first parameters ... and pass to the related function 
		    var params = Array.prototype.slice.call(arguments);
            params.shift();
		    
		    // get function and call related formula ...
		    if (function_num == 1) return calculates.average.call(this, params);
		    else if (function_num == 2) return calculates.count.call(this, params);
		    else if (function_num == 3) return calculates.counta.call(this, params);
		    else if (function_num == 4) return me.minMaxVal(params, this).max;
		    else if (function_num == 5) return me.minMaxVal(params, this).min;
		    else if (function_num == 6) return calculates.product.call(this, params);
		    else if (function_num == 7) return calculates.stdev.call(this, params);
		    else if (function_num == 8) return calculates.stdevp.call(this, params);
		    else if (function_num == 9) return calculates.sum.call(this, params);
		    else if (function_num == 10) return calculates.var_orig.call(this, params);
		    else if (function_num == 11) return calculates.varp.call(this, params);
		},
		
		// need care for option ...
		'aggregate' : function() {
			var me = this.me, calculates = me.calculates;
			var store = this.store, isheet = this.sheet, irow = this.row, icol = this.col, len = arguments.length; 			
			if (2 > len) throw {code: 'CAL_PARAM_MISS',cal: 'need'};
			
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw {code: 'CAL_INCORRECT_COORD',span: result};
			
			var function_num = calculates.numberof.call(this, arguments[0]);
		    if (function_num<1 || function_num>19)  throw {code: 'CAL_PARAM_NEED_BE_NUM', cal: 'aggregate'};
		    
		    var options = calculates.numberof.call(this, arguments[1]);
		    if (options<1 || options>6)  throw {code: 'CAL_PARAM_NEED_BE_NUM', cal: 'aggregate'};
		    
		    var params = Array.prototype.slice.call(arguments);
            params.shift();
            params.shift();
            
            if (function_num == 1) return calculates.average.call(this, params);
            else if (function_num == 2) return calculates.count.call(this, params);
		    else if (function_num == 3) return calculates.counta.call(this, params);
		    else if (function_num == 4) return me.minMaxVal(params, this).max;
		    else if (function_num == 5) return me.minMaxVal(params, this).min;
            else if (function_num == 6) return calculates.product.call(this, params);
		    else if (function_num == 7) return calculates.stdev.call(this, params);
		    else if (function_num == 8) return calculates.stdevp.call(this, params);
		    else if (function_num == 9) return calculates.sum.call(this, params);
            else if (function_num == 10) return calculates.var_orig.call(this, params);
		    else if (function_num == 11) return calculates.varp.call(this, params);
            else if (function_num == 12) return calculates.median.call(this, params);
            else if (function_num == 13) return calculates.mode.call(this, params);
            else if (function_num == 14) return calculates.large.call(this, params);
            else if (function_num == 15) return calculates.small.call(this, params);
            else if (function_num == 16) return calculates.percentile_inc.call(this, params);
            else if (function_num == 17) return calculates.quartile_inc.call(this, params);
            else if (function_num == 18) return calculates.percentile_exc.call(this, params);
            else if (function_num == 19) return calculates.quartile_exc.call(this, params);
		},
		
		/*========================================================================================
		 * The following formulas are related to statistical
		 *========================================================================================*/
		
		/*
		 * calculate sum of a range, it can be more than one param
		 * {span:[0, 1, 2, 3, 4], type: 2}, {span:[2, 1, 2, 3, 4], type: 1}, ...
		 */
		'average' : function() {
			if(0 == arguments.length) throw { code: 'CAL_PARAM_MISS', cal: 'average'};
			var me = this.me;
			var result = me.checkCoordValid(arguments);
			if(true !== result)  throw { code: 'CAL_INCORRECT_COORD', span: result };
					
			var sum = 0, count = 0, argsAllNaN = true; // all args are not number stuff ...
			me.each(this.sheet, this.row, this.col, arguments, function(obj, itemType, index, insideIndex, item){	
				var data;
				if('span' == itemType){
					var sheet = obj[0], row = obj[1], col = obj[2];
					if(Ext.isNumber(sheet)){
						var cell = me.getCellData(sheet, row, col, this);									
						data = cell.data;
					}				
				}else data = obj; // if pass only 1 argument means it's a direct value
				
				data = Number(data);
				if(Ext.isNumber(data)){
					sum += data;
					argsAllNaN = false;
					count++;
				}
			}, this);
			
			// check to see argsAllNaN - if yes means all the value are text or empty only care number
			if (argsAllNaN) throw { code: 'SS_ERROR_INFINITY', cal: 'average'};
			
			return (sum / count * 100) / 100;	
		},
		
		/**
		 * This is formula for averageIf - return the average of all cells in a range that meet 
		 * a given criteria.
		 * 
		 * AVERAGEIF(range, criteria, Average_range)
		 * 
		 * Range   averageRange  final Range
		 * A1:B4   C1:C2         C1:D4
		 * A1:A5   B1:B3         B1:B5
		 * 
		 */
		'averageif' : function() {
			if(2 > arguments.length || arguments.length > 3) throw { code: 'CAL_PARAM_MISS', cal: 'averageif'};
			var me = this.me;
			var result = me.checkCoordValid(arguments);
			if(true !== result)  throw { code: 'CAL_INCORRECT_COORD', span: result };
			var sheetId = this.sheet, row = this.row, col = this.col, timestamp = this.timestamp;	
			
			var args = me.transferAll2Absolute(arguments, sheetId, row, col);
			var checkSpan = args[0], standSpan = args[1], resultSpan = args[2];
			
			var stand, standData, standVal;
			if(me.isCoordObj(standSpan)){
				stand = standSpan.span;							
				standData = me.getCellData(stand[0], stand[1], stand[2], this);							
				standVal = standData.data;
			}else{
				standVal = standSpan;
			}
			
			if(!Ext.isDefined(standVal)) throw {code: 'CAL_NO_VALUE', cal: 'averageif'};
			
			var isExpress = false;
			if(Ext.isString(standVal)){
				standVal = Ext.util.Format.htmlDecode(standVal);
				standVal = HELPER.changeCondSpecialCase(standVal);
				isExpress = me.isExpress(standVal);		
				if(HELPER.isExpress(standVal)) {
					standVal = me.specialCaseForCalculateStr(standVal, true);
					// check to see whether criteria is single =,
					// case: >=, <=, !=, <>, and = >. If it is only =, make it
					// double ...
					standVal = HELPER.updateCompareCondition(standVal);
				}
			}
			
			/*
			 * process check span
			 */
			var check = checkSpan.span;			
			/*
			 * process result span
			 */
			var result;
			if(resultSpan){
				result = resultSpan.span;				
			}else{
				result = [].concat(check);
			}	
			
			var rowOffset = result[1]-check[1], colOffset = result[2]-check[2];
			var sum = 0, count = 0;
			/*
			 * loop the check span to get the sum
			 */
			store.walkRange([check], function(rd, span, store){				
				var cell = me.getCellData(rd.data.sheet, rd.data.row, rd.data.col, this);		
				var match = false;
				/*
				 * check whether match
				 */
				if(isExpress){
					var data = HELPER.convertPercent2num2(cell.data); // check special case ...if it is %
					var num = Number(data);
				
					if(Ext.isNumber(num)){
						match = eval(num+standVal);
					}else{
						match = eval('"'+cell.data+'"'+standVal);
					}
				}else{
					if(cell.data == standVal || SCOM.kmpCompare(cell.data, standVal)){
						match = true;					
					}
				}	
				
				if(match){
					var rsRow = rd.data.row+rowOffset, rsCol = rd.data.col+colOffset;
					var rsCell = me.getCellData(result[0], rsRow, rsCol, this);					
					if(SCOM.canbeNumber(rsCell.data)){
						sum += Number(rsCell.data);
						count += 1;
					}
				}
			}, this);
			
			if (count == 0) throw {code: 'SS_ERROR_INFINITY',cal: 'averageif'};
			return (sum / count * 100) / 100;
		},
		
		/**
		 * Returns the average (arithmetic mean) of all cells that meet multiple criteria.
		 * 
		 * Examples: =AVERAGEIFS(A1:A20, B1:B20, ">0", C1:C20, "<10")
		 * AVERAGEIFS(average_range, criteria_range1, criteria1, [criteria_range2, criteria2],
		 * 
		 * Average_range     is one or more cells to average, including numbers or names, arrays, or references that contain numbers.
		 * criteria_range1    Required. The first range in which to evaluate the associated criteria.
		 * criteria1    Required. The criteria in the form of a number, expression, cell reference, or text that define which cells in the criteria_range1 argument will be added. For example, criteria can be expressed as 32, ">32", B4, "apples", or "32."
		 * 
		 * If average_range is a blank or text value, AVERAGEIFS returns the #DIV0! error value.
	     * If a cell in a criteria range is empty, AVERAGEIFS treats it as a 0 value.
	     * Cells in range that contain TRUE evaluate as 1; cells in range that contain FALSE evaluate as 0 (zero).
	     * Each cell in average_range is used in the average calculation only if all of the corresponding criteria specified are true for that cell.
	     * Unlike the range and criteria arguments in the AVERAGEIF function, in AVERAGEIFS each criteria_range must be the same size and shape as sum_range.
	     * If cells in average_range cannot be translated into numbers, AVERAGEIFS returns the #DIV0! error value.
	     * If there are no cells that meet all the criteria, AVERAGEIFS returns the #DIV/0! error value.
	     * You can use the wildcard characters, question mark (?) and asterisk (*), in criteria. A question mark matches any single character; an asterisk matches any sequence of characters. If you want to find an actual question mark or asterisk, type a tilde (~) before the character.
	     **/
		'averageifs' : function() {
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp, isheet = this.sheet, irow = this.row, icol = this.col;
			var len = arguments.length; 		
			if (len < 3 || len % 2 == 0) throw {code: 'CAL_PARAM_MISS',cal: 'averageifs'}; // should be 3, 5, 7 ...

			var result = me.checkCoordValid(arguments);
			if(true !== result) throw {code: 'CAL_INCORRECT_COORD',span: result};  
			
			var averageRange = arguments[0];
			if (Ext.isObject(averageRange)) {
				averageRange = calculates.rangeVal2Dimension.call(this, [averageRange]);
			} 
			if (averageRange == null || averageRange.length == 0)  throw { code: 'CAL_NO_VALUE', cal: 'averageifs' };
			var averageRangeXlength = averageRange.length;
		    var averageRangeYlength = averageRange[0].length;
		    
	        // now we need go through criteria ...
			var criteriaRangeArr = [], criteriaArr = [];
			
			var i = 1;
			while (i < len) {
				// loop through each item ...
				var criteraRange = arguments[i];
				if (Ext.isObject(arguments[i])) {				
					var key = criteraRange.span.join("-");
					if (key.charAt(0) == "-") key = isheet + key;
					criteraRange = HELPER.getValueFromCache(key);
					if (!criteraRange || criteraRange.length == 0) {					
						criteraRange = calculates.rangeVal2Dimension.call(this, [arguments[i]]);
						HELPER.addValueToCache(key, criteraRange);
					}
				} 
				
				if (criteraRange == null || criteraRange.length == 0) throw { code: 'CAL_NO_VALUE', cal: 'averageifs' };
				var criteraRangeXlength = criteraRange.length;
				var criteraRangeYlength = criteraRange[0].length;
				
				// add condition - each criteria_range argument must contain the same number of rows and columns as the sum_range argument.
	            if (averageRangeXlength != criteraRangeXlength || averageRangeYlength != criteraRangeYlength) throw { code: 'CAL_NO_VALUE', cal: 'averageifs' };
				criteriaRangeArr[criteriaRangeArr.length] = criteraRange;
				i = i + 1;
				
				// get condition now ...
				var cond = arguments[i];
				if(me.isCoordObj(cond)) cond = calculates.valof.call(this, cond);
				if (Ext.isString(cond))  {
					cond = Ext.util.Format.htmlDecode(cond);
					// add one more condition for cond --- if it is =A* => this as: A*
				    cond = HELPER.changeCondSpecialCase(cond);	
				    // convert condition ...
				    if(HELPER.isExpress(cond)) {
			    		// check to see whether criteria is single =,
						// case: >=, <=, !=, <>, and = >. If it is only =, make it double ...
						cond = HELPER.updateCompareCondition(cond);
				    }
				}
				
				criteriaArr[criteriaArr.length] = cond;		
				i = i + 1;
			}
			
	        // now start to calculate result 
			var result = 0, totalCount = 0;
			for ( var i = 0; i < averageRangeXlength; i++) {
				for ( var j = 0; j < averageRangeYlength; j++) {
					
					// check condition now ... loop each criteria same position
					var flag = true;
					for (var k=0; k < criteriaRangeArr.length; k++) {
						var criteraRange = criteriaRangeArr[k];
						// get related value now 
						var data = criteraRange[i][j];
						if (data === undefined || data == null || data == "") {
							flag = false;
							break;
						}
					
						// get criteria value ...
						var cond = criteriaArr[k];
						var condflag = false;
						
						/*
						 * check whether it's a compare function - <> = ! start with ...
						 */
						var compareFlag = /^\s*[!<>=]/gi.test(cond);
						if (compareFlag) {
							data = HELPER.convertPercent2num2(data); // check special case ...if it is %
							if (Ext.isNumber(Number(data)))
								condflag = eval(data + cond);
							else {
								condflag = eval('"' + data + '"' + cond);
							}
						} else if (SCOM.kmpCompare(data.toString(), cond.toString())) {
							condflag = true;
						}
					    
                        if (condflag == false) {
						    flag = false;
						    break;
						}		
					}
					
					// if flag is true --- ok condition meet
					if (flag) {
						var sumData = averageRange[i][j];
						sumData = Number(sumData);
						if (Ext.isNumber(sumData)) {
							result += sumData;
							totalCount += 1;
						}
					}
				}
			}
			
			// clean 
			criteriaRangeArr = [], criteriaArr = [];
			
			if (totalCount == 0) throw { code: 'SS_ERROR_INFINITY', cal: 'averageifs' };	
			return (result / totalCount * 100) / 100;			
		},
		
		/*
		 * count the non-empty cell of a range, it can be more than one param
		 * {span:[0, 1, 2, 3, 4], type: 2}, {span:[2, 1, 2, 3, 4], type: 1}, ...
		 */
		'count' : function(){
			if(0 == arguments.length) throw {code: 'CAL_PARAM_MISS',cal: 'COUNTA'};
			var me = this.me, calculates = me.calculates;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };		
			var rangeObjs = calculates.rangeObjsOf.call(this, arguments);
			
			// TODO -- need add to check whether it is DATE ....
			
			var res = 0;
			for(var i = 0, len = rangeObjs.length; i < len; i++){
				var data = Number(rangeObjs[i]);		
				if (Ext.isNumber(data)) res++;
			}
			return res;
		},
		
		'counta' : function(){
			if(0 == arguments.length) throw {code: 'CAL_PARAM_MISS',cal: 'COUNTA'};
			var me = this.me, calculates = me.calculates;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };		
			var rangeObjs = calculates.rangeObjsOf.call(this, arguments);	
			var res = 0;
			for(var i = 0, len = rangeObjs.length; i < len; i++){
				var cell = rangeObjs[i];
				if (cell != undefined && cell != "") res++;
			}
			return res;
		},
		
		'countblank' : function(){
			if(0 == arguments.length) throw {code: 'CAL_PARAM_MISS',cal: 'COUNTA'};
			var me = this.me, calculates = me.calculates;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };		
			var rangeObjs = calculates.rangeObjsOf.call(this, arguments);	
			var res = 0;
			for(var i = 0, len = rangeObjs.length; i < len; i++){
				var cell = rangeObjs[i];
				if (cell == undefined || cell == "") res++;
			}
			return res;
		},
		
		/*
		 * get the max value of a range, it can be more than one param
		 * {span:[0, 1, 2, 3, 4], type: 2}, {span:[2, 1, 2, 3, 4], type: 1}, ...
		 */
		'max' : function(){
			if(0 == arguments.length) throw {code: 'CAL_PARAM_MISS',cal: 'MAX'};
			var me = this.me;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			return me.minMaxVal(arguments, this).max;
		},
		
		/*
		 * get the min value of a range, it can be more than one param
		 * {span:[0, 1, 2, 3, 4], type: 2}, {span:[2, 1, 2, 3, 4], type: 1}, ...
		 */
		'min' : function(){
			if(0 == arguments.length) throw {code: 'CAL_PARAM_MISS',cal: 'MIN'};
			var me = this.me;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			return me.minMaxVal(arguments, this).min;
		},
		
		/*
		 * Returns the median of the given numbers
		 */
		'median' : function(){
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var len = arguments.length; 
			if(0 == len) throw {code: 'CAL_PARAM_MISS',cal: 'median'};
				
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
				
			var arr = calculates.rangeNumsOf2.call(this, arguments, 'median');		
			if(0 == arr.length) throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'median'};
			
			return HELPER.getMedianfromArr(arr);
		},
		
		// this is function to get small formula - Returns the k-th smallest value in a data set. 
		// Use this function to return values with a particular relative standing in a data set.
		// For example: =small(A1:A5, 2)
		'small' : function() {			
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp, isheet = this.sheet, irow = this.row, icol = this.col;
			var len = arguments.length; 		
			if(2 != len) throw {code: 'CAL_PARAM_MISS',cal: 'small'};	
			
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var range = [];
			var posOffset = arguments[0];
			if (Ext.isObject(posOffset)) {
				range = calculates.rangeObjsOf.call(this, [posOffset]);	
			} else {
			    // check to see whether it is array ...=small({1,2}, 1)
				if (Ext.isArray(posOffset)) {
					range = posOffset;
				} else {
					if (HELPER.isEmptyStr(posOffset)) throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'small'};
					var num = Number(posOffset);
					range.push(num);
				}
			}
			
			var position = calculates.numberof.call(this, arguments[1]);
			if (0 >= position || position > range.length) throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'small'};
			
			var tmp = [];
			for ( var i = 0; i < range.length; i++) {
				var val = range[i];
				// check whether it is empty boolean etc 
				if (val === undefined || val === "" || HELPER.isEmptyStr(val) 
						|| HELPER.isBoolean(val)) continue;
				
				var numberObj = Number(val);
				if (Ext.isNumber(numberObj)) tmp.push(numberObj);
			}
			
			if (tmp.length == 0) throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'small'};
			HELPER.sortNumberArray(tmp, "asc");
			
			if (position > tmp.length) throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'small'};
		    return tmp[position - 1];
		},
		
		'large' : function() {			
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp, isheet = this.sheet, irow = this.row, icol = this.col;
			var len = arguments.length; 		
			if(2 != len) throw {code: 'CAL_PARAM_MISS',cal: 'large'};	
			
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var range = [];
			var posOffset = arguments[0];
			if (Ext.isObject(posOffset)) {
				range = calculates.rangeObjsOf.call(this, [posOffset]);	
			} else {
			    // check to see whether it is array ...=small({1,2}, 1)
				if (Ext.isArray(posOffset)) {
					range = posOffset;
				} else {
					if (HELPER.isEmptyStr(posOffset)) throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'large'};
					var num = Number(posOffset);
					range.push(num);
				}
			}
			
			var position = calculates.numberof.call(this, arguments[1]);
			if (0 >= position || position > range.length) throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'large'};
			
			var tmp = [];
			for ( var i = 0; i < range.length; i++) {
				var val = range[i];
				// check whether it is empty boolean etc 
				if (val === undefined || val === "" || HELPER.isEmptyStr(val) 
						|| HELPER.isBoolean(val)) continue;
				
				var numberObj = Number(val);
				if (Ext.isNumber(numberObj)) tmp.push(numberObj);
			}
			
			if (tmp.length == 0) throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'large'};
			HELPER.sortNumberArray(tmp, "desc");
			
			if (position > tmp.length) throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'large'};
		    return tmp[position - 1];
		},
		
		/**
		 * The Excel GEOMEAN function calculates the geometric mean of a supplied set of values.
		 */
		'geomean' : function() {
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var len = arguments.length; 
			if(0 == len) throw {code: 'CAL_PARAM_MISS',cal: 'geomean'};
				
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
				
			var arr = [];					
			me.each(this.sheet, this.row, this.col, arguments, function(obj, itemType, index, insideIndex, item){	
				var data;
				if('span' == itemType){
					var sheet = obj[0], row = obj[1], col = obj[2];
					if(Ext.isNumber(sheet)){
						var cell = me.getCellData(sheet, row, col, this);									
						data = cell.data;
						if(Ext.isNumber(Number(data))) arr.push(Number(data)); 
					}				
				} else {
				    data = Number(obj);
				    if(Ext.isNumber(data)) arr.push(data);
				    else throw {code: 'CAL_NO_VALUE',cal: 'geomean'};
				}
			}, this);
			
			var alen = arr.length;
			if(0 == alen) throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'geomean'};
			else {
				var sumProduct = 1;
				for(var i = 0; i < alen; i++){
					if (arr[i] < 0) throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'geomean'};
					sumProduct *= arr[i];
				}
				
				return Math.pow(sumProduct, 1.0 / alen);
			} 
		},
		
		/**
		 * The Excel HARMEAN function Returns the harmonic mean of a data set. 
		 * The harmonic mean is the reciprocal of the arithmetic mean of reciprocals.
		 */
		'harmean' : function() {
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var len = arguments.length; 
			if(0 == len) throw {code: 'CAL_PARAM_MISS',cal: 'harmean'};
				
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
				
			var arr = [];					
			me.each(this.sheet, this.row, this.col, arguments, function(obj, itemType, index, insideIndex, item){	
				var data;
				if('span' == itemType){
					var sheet = obj[0], row = obj[1], col = obj[2];
					if(Ext.isNumber(sheet)){
						var cell = me.getCellData(sheet, row, col, this);									
						data = cell.data;
						if(Ext.isNumber(Number(data))) arr.push(Number(data)); 
					}				
				} else {
				    data = Number(obj);
				    if(Ext.isNumber(data)) arr.push(data);
				    else throw {code: 'CAL_NO_VALUE',cal: 'harmean'};
				}
			}, this);
			
			var alen = arr.length;
			if(0 == alen) throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'harmean'};
			else {
				var sum = 1;
				for(var i = 0; i < alen; i++){
					if (arr[i] <= 0) throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'harmean'};
					sum += 1/arr[i];
				}
				
				return alen/sum;
			} 
		},
		
		/**
		 * Returns the slope of the linear regression line through data points in known_y's and known_x's. 
		 * The slope is the vertical distance divided by the horizontal distance between any two points on 
		 * the line, which is the rate of change along the regression line.
		 */
		'slope' : function() {
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var len = arguments.length; 
			if(2 !== len) throw {code: 'CAL_PARAM_MISS',cal: 'slope'};
				
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
				
			var rangeY = [], posOffset = arguments[0];
			if (Ext.isObject(posOffset)) {
				rangeY = calculates.rangeObjsOf.call(this, [posOffset]);	
			} else {
			    // check to see whether it is array ...=small({1,2})
				if (Ext.isArray(posOffset)) rangeY = posOffset;
				else rangeY.push(Number(posOffset));
			}
			
			var rangeX = [], posOffset = arguments[1];
			if (Ext.isObject(posOffset)) {
				rangeX = calculates.rangeObjsOf.call(this, [posOffset]);	
			} else {
			    // check to see whether it is array ...=small({1,2})
				if (Ext.isArray(posOffset)) rangeX = posOffset;
				else rangeX.push(Number(posOffset));
			}
			
			var lengthY = rangeY.length, lengthX = rangeX.length;
			if (lengthY !== lengthX) throw {code: 'VALUE_NOT_AVAILABLE',cal: 'slope'};
			
			var sumy = 0, sumx = 0, sumxx = 0, sumxy = 0, total = 0;
			for (var i = 0; i < lengthY; i++) {
                var y = Number(rangeY[i]), x = Number(rangeX[i]);
                if (Ext.isNumber(y) && Ext.isNumber(x)) {                   
                    sumy += y;
                    sumx += x;
                    sumxx += x * x;
                    sumxy += x * y;
                    total++;
                }
            }
			if (total * sumxx - sumx * sumx === 0) throw {code: 'SS_ERROR_INFINITY',cal: 'slope'};		
			return (total * sumxy - sumx * sumy) / (total * sumxx - sumx * sumx);
		},
		
		/**
		 * Returns the standard error of the predicted y-value for each x in the regression. 
		 * The standard error is a measure of the amount of error in the prediction of y for an individual x.
		 */
		'steyx' : function() {
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var len = arguments.length; 
			if(2 !== len) throw {code: 'CAL_PARAM_MISS',cal: 'steyx'};
				
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
				
			var rangeY = [], posOffset = arguments[0];
			if (Ext.isObject(posOffset)) {
				rangeY = calculates.rangeObjsOf.call(this, [posOffset]);	
			} else {
			    // check to see whether it is array ...=small({1,2})
				if (Ext.isArray(posOffset)) rangeY = posOffset;
				else rangeY.push(Number(posOffset));
			}
			
			var rangeX = [], posOffset = arguments[1];
			if (Ext.isObject(posOffset)) {
				rangeX = calculates.rangeObjsOf.call(this, [posOffset]);	
			} else {
			    // check to see whether it is array ...=small({1,2})
				if (Ext.isArray(posOffset)) rangeX = posOffset;
				else rangeX.push(Number(posOffset));
			}
			
			var lengthY = rangeY.length, lengthX = rangeX.length;
			if (lengthY !== lengthX) throw {code: 'VALUE_NOT_AVAILABLE',cal: 'steyx'};
			
			var sumy = 0, sumyy = 0, sumx = 0, sumxx = 0, sumxy = 0, total = 0;
			for (var i = 0; i < lengthY; i++) {
                var y = Number(rangeY[i]), x = Number(rangeX[i]);
                if (Ext.isNumber(y) && Ext.isNumber(x)) {             	
                	sumy += y;
                    sumyy += y * y;
                    sumx += x;
                    sumxx += x * x;
                    sumxy += x * y;
                    total++;
                }
            }
			
			// If known_y's and known_x's are empty or have less than three data points, STEYX returns the #DIV/0! 
			if (total < 3 || (total * sumxx - sumx * sumx === 0.0) ) throw {code: 'SS_ERROR_INFINITY',cal: 'steyx'};	
			
			if (total * sumxx - sumx * sumx === 0) throw {code: 'SS_ERROR_INFINITY',cal: 'steyx'};		
			return Math.sqrt((total * sumyy - sumy * sumy - (total * sumxy - sumx * sumy) * (total * sumxy - sumx * sumy) / (total * sumxx - sumx * sumx)) / (total * (total - 2)));
		},
		
		/**
		 * Returns the average of the absolute deviations of data points from their mean. 
		 * AVEDEV is a measure of the variability in a data set.
		 */
		'avedev' : function() {
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var len = arguments.length; 
			if(0 == len) throw {code: 'CAL_PARAM_MISS',cal: 'avedev'};

			var arrObj = calculates.rangeNumsOf2.call(this, arguments, 'avedev');
		    if ( arrObj.length == 0 ) throw {code: 'SS_ERROR_INFINITY',cal: 'avedev'};	
			
			var mean = 0, sum = 0, sumdev = 0;
			for (var i=0; i<arrObj.length; i++) {
				sum += arrObj[i];
			}
			mean = sum / arrObj.length;
			// calculate 
			for (var i=0; i<arrObj.length; i++) {
				sumdev += Math.abs(mean - arrObj[i]);
			}
			
			return sumdev / arrObj.length;
		},
		
		/**
		 * Returns the sum of squares of deviations of data points from their sample mean.
		 */
		'devsq' : function() {
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var len = arguments.length; 
			if(0 == len) throw {code: 'CAL_PARAM_MISS',cal: 'devsq'};

			var arrObj = calculates.rangeNumsOf2.call(this, arguments, 'devsq');
		    if ( arrObj.length == 0 ) throw {code: 'SS_ERROR_INFINITY',cal: 'devsq'};	
			
			var mean = 0, sum = 0, sumdevsq = 0;
			for (var i=0; i<arrObj.length; i++) {
				sum += arrObj[i];
			}
			mean = sum / arrObj.length;
			// calculate 
			for (var i=0; i<arrObj.length; i++) {
				sumdevsq += (arrObj[i] - mean) * (arrObj[i] - mean);
			}
			
			return sumdevsq;
		},
		
		'fisher' : function() {
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var len = arguments.length; 
			if(1 !== len) throw {code: 'CAL_PARAM_MISS',cal: 'fisher'};
			
			var num = calculates.numberof.call(this, arguments[0]);
		    if (num === undefined || num === "" || num <= -1 || num >= 1)  throw {code: 'CAL_PARAM_NEED_BE_NUM', cal: 'fisher'};		
			
			var result = Math.log((1.0 + num) / (1.0 - num)) / 2.0;		
			return result;			
		},
		
		/**
		 * Returns the inverse of the Fisher transformation. Use this transformation when analyzing correlations between 
		 * ranges or arrays of data. If y = FISHER(x), then FISHERINV(y) = x.
		 */
		'fisherinv' : function() {
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var len = arguments.length; 
			if(1 !== len) throw {code: 'CAL_PARAM_MISS',cal: 'fisherinv'};
			
			var num = calculates.numberof.call(this, arguments[0]);
		    if (num === undefined || num === "")  throw {code: 'CAL_PARAM_NEED_BE_NUM', cal: 'fisherinv'};	
		    
		    var p1 = Math.exp(2.0 * num) - 1.0;
            var p2 = Math.exp(2.0 * num) + 1.0;
            var result = p1 / p2;	
            
            // check the case ... 1.6105100000000000001 at this case we need chop. Example: =POWER(1.1,5)
			var digitalLen = HELPER.getDigitalLen(result);
			if (digitalLen > 14) result = HELPER.roundUpNonZero(result);

			return result;
		},
		
		/**
		 * Returns the correlation coefficient of the array1 and array2 cell ranges. Use the correlation coefficient 
		 * to determine the relationship between two properties. For example, you can examine the relationship between a 
		 * location's average temperature and the use of air conditioners.
		 */
		'correl' : function() {		
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var len = arguments.length; 
			if(2 !== len) throw {code: 'CAL_PARAM_MISS',cal: 'correl'};
				
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			// If an array or reference argument contains text, logical values, or empty cells, 
			// those values are ignored; however, cells with the value zero are included.
			var rangeX = calculates.rangeNumsOf2.call(this, [arguments[0]], 'correl');
		    if ( rangeX.length == 0 ) throw {code: 'SS_ERROR_INFINITY',cal: 'correl'};	
				
			var rangeY = calculates.rangeNumsOf2.call(this, [arguments[1]], 'correl');
		    if ( rangeY.length == 0 ) throw {code: 'SS_ERROR_INFINITY',cal: 'correl'};	

			var lengthY = rangeY.length, lengthX = rangeX.length;
			if (lengthY !== lengthX) throw {code: 'VALUE_NOT_AVAILABLE',cal: 'correl'};
			
			var meanX = 0, sumX = 0;
			for (var i=0; i<lengthX; i++) {
				sumX += rangeX[i];
			}
			meanX = sumX / lengthX;
			
			var meanY = 0, sumY = 0;
			for (var i=0; i<lengthY; i++) {
				sumY += rangeY[i];
			}
			meanY = sumY / lengthY;
			
			// sum of (x-meanX)(y-meanY)
			var sumxy = 0, sumxx = 0; sumyy = 0;
			for (var i=0; i<lengthX; i++) {
				var tempX = rangeX[i]-meanX, tempY = rangeY[i]-meanY;
				sumxy += tempX * tempY;
				sumxx += tempX * tempX;
				sumyy += tempY * tempY;
			}
			if (sumxx == 0 || sumyy == 0) throw {code: 'SS_ERROR_INFINITY',cal: 'correl'};
			
			var result = sumxy / Math.sqrt(sumxx * sumyy);
			return result;
		},
		
		/**
		 * Returns the square of the Pearson product moment correlation coefficient through data points 
		 * in known_y's and known_x's. For more information, see the PEARSON function. The r-squared 
		 * value can be interpreted as the proportion of the variance in y attributable to the variance in x.
		 */
		'rsq' : function() {		
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var len = arguments.length; 
			if(2 !== len) throw {code: 'CAL_PARAM_MISS',cal: 'rsq'};
				
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			// If an array or reference argument contains text, logical values, or empty cells, 
			// those values are ignored; however, cells with the value zero are included.
			var rangeX = calculates.rangeNumsOf2.call(this, [arguments[0]], 'rsq');
		    if ( rangeX.length == 0 ) throw {code: 'SS_ERROR_INFINITY',cal: 'rsq'};	
				
			var rangeY = calculates.rangeNumsOf2.call(this, [arguments[1]], 'rsq');
		    if ( rangeY.length == 0 ) throw {code: 'SS_ERROR_INFINITY',cal: 'rsq'};	

			var lengthY = rangeY.length, lengthX = rangeX.length;
			if (lengthY !== lengthX) throw {code: 'VALUE_NOT_AVAILABLE',cal: 'rsq'};
			if (lengthY == 1) throw {code: 'SS_ERROR_INFINITY',cal: 'rsq'};
			
			var meanX = 0, sumX = 0;
			for (var i=0; i<lengthX; i++) {
				sumX += rangeX[i];
			}
			meanX = sumX / lengthX;
			
			var meanY = 0, sumY = 0;
			for (var i=0; i<lengthY; i++) {
				sumY += rangeY[i];
			}
			meanY = sumY / lengthY;
			
			// sum of (x-meanX)(y-meanY)
			var sumxy = 0, sumxx = 0; sumyy = 0;
			for (var i=0; i<lengthX; i++) {
				var tempX = rangeX[i]-meanX, tempY = rangeY[i]-meanY;
				sumxy += tempX * tempY;
				sumxx += tempX * tempX;
				sumyy += tempY * tempY;
			}
			if (sumxx == 0 || sumyy == 0) throw {code: 'SS_ERROR_INFINITY',cal: 'rsq'};
			
			// this is the only different from CORREL ...
			var result = sumxy / Math.sqrt(sumxx * sumyy);
			return result * result;
		},
		
		/**
		 * Return the gamma function value. We only support gamma > 0 case ...
		 */
		'gamma' : function() {
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var len = arguments.length; 
			if(1 !== len) throw {code: 'CAL_PARAM_MISS',cal: 'gamma'};
			
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var x = calculates.numberof.call(this, arguments[0]);
		    if (x <= 0)  throw {code: 'CAL_PARAM_NEED_BE_NUM', cal: 'gamma'};		    
		    if (x > 171) throw {code: 'NUM_IS_NOT_RIGHT', cal: 'gamma'};	
		    
		    return FORMULA_HELPER.gamma(x);
		},
		
		'gammaln' : function() {
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var len = arguments.length; 
			if(1 !== len) throw {code: 'CAL_PARAM_MISS',cal: 'gammaln'};
			
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var x = calculates.numberof.call(this, arguments[0]);
		    if (x <= 0)  throw {code: 'CAL_PARAM_NEED_BE_NUM', cal: 'gammaln'};		    
		   
		    var result = FORMULA_HELPER.gamma(x);
		    return Math.log(result) / Math.log(2.71828182845904);
		},
		
		'stdev_s' : function() { 
            return this.me.stdevCommonFunction(arguments, 'stdev.s', this);
	    },
	    
	    'stdev_p' : function() { 
            return this.me.stdevCommonFunction(arguments, 'stdev.p', this);
	    },

	    // Estimates variance based on a sample (ignores logical values and text in the sample).
	    'var_s' : function() { 
            return this.me.stdevCommonFunction(arguments, 'var.s', this);
	    },
	    
	    'var_p' : function() { 
            return this.me.stdevCommonFunction(arguments, 'var.p', this);
	    },
	    
	    /**
	     * Returns the k-th percentile of values in a range, where k is in the range 0..1, inclusive.
	     */
	    'percentile_inc' : function() {
	    	var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var len = arguments.length; 
			if(2 !== len) throw {code: 'CAL_PARAM_MISS',cal: 'percentile.inc'};
			
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var rangeX = calculates.rangeNumsOf2.call(this, [arguments[0]], 'percentile.inc');
		    if ( rangeX.length == 0 ) throw {code: 'CAL_PARAM_NEED_BE_NUM',cal: 'percentile.inc'};	
			
			var k = calculates.numberof.call(this, arguments[1]);
		    if (k < 0 || k > 1)  throw {code: 'CAL_PARAM_NEED_BE_NUM', cal: 'percentile.inc'};	
		    
		    rangeX = HELPER.sortNumberArray(rangeX, "asc");
		    var index = k * (rangeX.length - 1);
		    var reminder = index % 1.0;
            var index = parseInt(index.toString(), 10);
            if (reminder === 0.0)  return rangeX[index];
                   
            return rangeX[index] + reminder * (rangeX[index + 1] - rangeX[index]);
	    },
	    
	    'percentile_exc' : function() {
	    	var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var len = arguments.length; 
			if(2 !== len) throw {code: 'CAL_PARAM_MISS',cal: 'percentile.exc'};
			
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var rangeX = calculates.rangeNumsOf2.call(this, [arguments[0]], 'percentile.exc');
		    if ( rangeX.length == 0 ) throw {code: 'CAL_PARAM_NEED_BE_NUM',cal: 'percentile.exc'};	
		    var n = rangeX.length;
			
			var k = calculates.numberof.call(this, arguments[1]);
		    if (k <= 1/n || k >= (1 - 1/n))  throw {code: 'CAL_PARAM_NEED_BE_NUM', cal: 'percentile.exc'};	
		    
		    rangeX = HELPER.sortNumberArray(rangeX, "asc");
		    var index = k * (rangeX.length + 1);
		    var reminder = index % 1.0;
            var index = parseInt(index.toString(), 10);
            if (reminder === 0.0)  throw {code: 'CAL_PARAM_NEED_BE_NUM', cal: 'percentile.exc'};
                   
            return rangeX[index-1] + reminder * (rangeX[index] - rangeX[index-1]);
	    },
	    
	    // Returns the quartile of a data set, based on percentile values from 0..1, inclusive.
	    'quartile_inc' : function() {
	    	var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var len = arguments.length; 
			if(2 !== len) throw {code: 'CAL_PARAM_MISS',cal: 'quartile.inc'};
			
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var quart = calculates.numberof.call(this, arguments[1]);
		    if (quart < 0 || quart > 4)  throw {code: 'CAL_PARAM_NEED_BE_NUM', cal: 'quartile.inc'};	
		    quart = parseInt(quart);

		    // if it is 2 ...
		    if (quart == 2) return calculates.median.call(this, arguments[0]);
		    
		    // for 1 and 3 ...0 and 4
		    var rangeX = calculates.rangeNumsOf2.call(this, [arguments[0]], 'quartile.inc');
		    if ( rangeX.length == 0 ) throw {code: 'CAL_PARAM_NEED_BE_NUM',cal: 'quartile.inc'};
		    if ( rangeX.length == 1 ) return rangeX[0];
		    
		    // sort arrary ...
		    rangeX = HELPER.sortNumberArray(rangeX, "asc");
		    var total = rangeX.length;
		    if (quart == 0) return rangeX[0];
		    if (quart == 4) return rangeX[total - 1];
		    
		    var position = (total - 1) * 0.75; 
		    if (quart == 1) position = (total - 1) * 0.25;
		    
		    var part1 = parseInt(position), part2 = position - part1;
		    var val1 = 0, val2 = 0;
		    if (part1 > 0 && part1 < total) {
		    	val1 = rangeX[part1];
		    	val2 = rangeX[part1+1];
		    } else if (part1 > total) {
		    	val1 = rangeX[part1];
		    } else {
		        val2 = rangeX[part1+1];
		    }
		    
		    return val1*(1-part2) + val2*part2;		    
	    },
	    
	    // Returns the quartile of a data set, based on percentile values from 0..1, inclusive.
	    'quartile_exc' : function() {
	    	var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var len = arguments.length; 
			if(2 !== len) throw {code: 'CAL_PARAM_MISS',cal: 'quartile.exc'};
			
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var quart = calculates.numberof.call(this, arguments[1]);
		    if (quart < 1 || quart >= 4)  throw {code: 'CAL_PARAM_NEED_BE_NUM', cal: 'quartile.exc'};	
		    quart = parseInt(quart);

		    // if it is 2 ...
		    if (quart == 2) return calculates.median.call(this, arguments[0]);
		    
		    // for 1 and 3 ...0 and 4
		    var rangeX = calculates.rangeNumsOf2.call(this, [arguments[0]], 'quartile.exc');
		    if ( rangeX.length == 0 ) throw {code: 'CAL_PARAM_NEED_BE_NUM',cal: 'quartile.exc'};
		    if ( rangeX.length == 1 ) return rangeX[0];
		    
		    // sort arrary ...
		    rangeX = HELPER.sortNumberArray(rangeX, "asc");
		    var total = rangeX.length;
		    
		    var position = (total + 1) * 0.75; 
		    if (quart == 1) position = (total + 1) * 0.25;
		    
		    var part1 = parseInt(position), part2 = position - part1;
		    var val1 = 0, val2 = 0;
		    if (part1 > 0 && part1 < total) {
		    	val1 = rangeX[part1-1];
		    	val2 = rangeX[part1];
		    } else if (part1 > total) {
		    	val1 = rangeX[part1-1];
		    } else {
		        val2 = rangeX[part1];
		    }
		    
		    return val1*(1-part2) + val2*part2;		    
	    },
	    
	    // EXPON.DIST(x,lambda,cumulative)
	    'expon_dist' : function() {
	    	var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var len = arguments.length; 
			if(3 !== len) throw {code: 'CAL_PARAM_MISS',cal: 'expon.dist'};
			
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var x = calculates.numberof.call(this, arguments[0]);
		    if (x < 0)  throw {code: 'CAL_PARAM_NEED_BE_NUM', cal: 'expon.dist'};
		    
		    var lambda = calculates.numberof.call(this, arguments[1]);  
		    if (0 >= lambda)  throw {code: 'CAL_PARAM_NEED_BE_NUM', cal: 'expon.dist'};
		    var cumulative = arguments[2];
		    if(me.isCoordObj(cumulative)) cumulative = calculates.valof.call(this, cumulative);
		    
		    var result;
		    if (HELPER.isBoolean(cumulative)) {
		    	cumulative = HELPER.getBoolean(cumulative);
		    	if (cumulative)  result = 1 - Math.exp(-lambda*x);
		    	else result = lambda*Math.exp(-lambda*x);
		    	return result;
		    }
		    
		    throw {code: 'CAL_PARAM_NEED_BE_NUM', cal: 'expon.dist'};
	    },
	    
	    // Returns the individual term binomial distribution probability.
	    // BINOM.DIST (number_s,trials,probability_s,cumulative)
	    'binomdist' : function() {
	    	var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var len = arguments.length; 
			if(4 !== len) throw {code: 'CAL_PARAM_MISS',cal: 'binom.dist'};
			
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var number_s = calculates.numberof.call(this, arguments[0]);
		    if (number_s < 0)  throw {code: 'CAL_PARAM_NEED_BE_NUM', cal: 'binom.dist'};
		    
		    var trials = calculates.numberof.call(this, arguments[1]);
		    trials = parseInt(trials);
		    
		    var probability_s = calculates.numberof.call(this, arguments[2]);
		    if (probability_s < 0 || probability_s > 1)  throw {code: 'CAL_PARAM_NEED_BE_NUM', cal: 'binom.dist'};
		    
		    var cumulative = arguments[3];
		    if(me.isCoordObj(cumulative)) cumulative = calculates.valof.call(this, cumulative);
		    if (!HELPER.isBoolean(cumulative)) {
		    	throw {code: 'CAL_PARAM_NEED_BE_NUM', cal: 'binom.dist'};
		    }		    
		    cumulative = HELPER.getBoolean(cumulative);
		    
		    if (cumulative == false) return HELPER.calculateBinom(number_s, trials, probability_s);
		    else {
		    	var sum = 0;
		    	for (var loop=0; loop<=number_s; loop++) {
		    		sum = sum + HELPER.calculateBinom(loop, trials, probability_s);
		    	}
		    	return sum;
		    }
	    },
	    
	    'pearson' : function() {
	    	var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp, len = arguments.length; 
			if(2 !== len) throw {code: 'CAL_PARAM_MISS',cal: 'pearson'};
			
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
		    
            var arr1 = calculates.rangeNumsOf3.call(this, [arguments[0]], 'pearson');		
			if(0 == arr1.length) throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'pearson'};
			
			var arr2 = calculates.rangeNumsOf3.call(this, [arguments[1]], 'pearson');		
			if(0 == arr2.length) throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'pearson'};
			
			var lengthX = arr1.length, lengthY = arr2.length;
			if (lengthX !== lengthY) throw {code: 'VALUE_NOT_AVAILABLE',cal: 'pearson'};
			
			var meanX = 0, sumX = 0;
			for (var i=0; i<lengthX; i++) {
				sumX += arr1[i];
			}
			meanX = sumX / lengthX;
			
			var meanY = 0, sumY = 0;
			for (var i=0; i<lengthY; i++) {
				sumY += arr2[i];
			}
			meanY = sumY / lengthY;
			
			var num = 0, den1 = 0, den2 = 0;
	        for (var i = 0; i < lengthX; i++) {
	            num += (arr1[i] - meanX) * (arr2[i] - meanY);
	            den1 += Math.pow(arr1[i] - meanX, 2);
	            den2 += Math.pow(arr2[i] - meanY, 2);
	        }
	        return num / Math.sqrt(den1 * den2);
	    },
		
		/*========================================================================================
		 * The following formulas are related to information
		 *========================================================================================*/
		 // this is for statistical Common
		'isblank' : function() {
			return this.me.statisticalCommon(arguments, 'isblank', this);
		},
		'isnumber' : function() {
			return this.me.statisticalCommon(arguments, 'isnumber', this);
		},
		'istext' : function() {
			return this.me.statisticalCommon(arguments, 'istext', this);
		},
		'islogical' : function() {
			return this.me.statisticalCommon(arguments, 'islogical', this);
		},
		// Returns a value converted to a number.
		'n' : function() {
			return this.me.statisticalCommon(arguments, 'n', this);
		},		
		'iseven' : function() {
			return this.me.mathCommonFunction2(arguments, 'iseven', this);
		},
		'isodd' : function() {
			return this.me.mathCommonFunction2(arguments, 'isodd', this);
		},	
		'na' : function() {
			var len = arguments.length; 
			if(0 != len) throw {code: 'CAL_PARAM_MISS',cal: 'NA'};			
			throw {code: 'VALUE_NOT_AVAILABLE',cal: 'NA'};
		},
		
		// see escapeErrorResult function ...
		'iserror' : function() {		
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp, isheet = this.sheet, irow = this.row, icol = this.col;
			var len = arguments.length; 
			if(1 != len) throw {code: 'CAL_PARAM_MISS',cal: 'ISERROR'};
				
			var expressFn = arguments[0], val;
			if(Ext.isFunction(expressFn)){
				try{
					val = expressFn.call(this);
					if (val == 'Infinity' || val == '#NUM!' || val == '#N/A' || val == '#PARAM!' || val == '#LOOP!' 
					    || val == '#DIV/0!' || val == '#VALUE!' || val == '#ERROR!' || val == '#REF!') {
						return true;
					} 
				}catch(e){
					return true;
				}
			}else{
				val = expressFn;
			}
			
			// check whether val is null or empty
			if (val === undefined || val === "") return false;
	
			// check the value now in here ...
			if (val == 'Infinity') {
				return true;
			}
	
			return false;
		},
		
		// see escapeErrorResult function ...
		'iserr' : function() {		
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp, isheet = this.sheet, irow = this.row, icol = this.col;
			var len = arguments.length; 
			if(1 != len) throw {code: 'CAL_PARAM_MISS',cal: 'ISERR'};
				
			var expressFn = arguments[0], val;
			if(Ext.isFunction(expressFn)){
				try{
					val = expressFn.call(this);
					if (val == 'Infinity' || val == '#NUM!' || val == '#PARAM!' || val == '#LOOP!' 
					    || val == '#DIV/0!' || val == '#VALUE!' || val == '#ERROR!' || val == '#REF!') {
						return true;
					} 
				}catch(e){
					if (e.code && e.code == "VALUE_NOT_AVAILABLE") return false;
					return true;
				}
			}else{
				val = expressFn;
			}
			
			// check whether val is null or empty
			if (val === undefined || val === "") return false;
	
			// check the value now in here ...
			if (val == 'Infinity') {
				return true;
			}
	
			return false;
		},
		
		// see escapeErrorResult function ...
		'isna' : function() {
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp, isheet = this.sheet, irow = this.row, icol = this.col;
			var len = arguments.length; 
			if(1 != len) throw {code: 'CAL_PARAM_MISS',cal: 'ISNA'};
				
			var expressFn = arguments[0], val;
			if(Ext.isFunction(expressFn)){
				try{
					val = expressFn.call(this); // this will always through exception .... do not know why ...
					if ( val == '#N/A') {
						return true;
					} 
				}catch(e){
					// ok - check exception ...
					if (e.code && e.code == "VALUE_NOT_AVAILABLE") return true;
					return false;
				}
			}
			if (expressFn == '#N/A') return true;
			return false;
		},
		
		// check type formula ...
		// Returns the type of value. Use TYPE when the behavior of another function depends on the type of value in a particular cell.
		// One case can not handle:
		//    =type(b2+1)   -- b2 is "ok"
		'type' : function() {
			var errorVal = 16, arrayVal = 64, logicalVal = 4, textVal = 2, numVal = 1;	
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp, isheet = this.sheet, irow = this.row, icol = this.col;
			var len = arguments.length; 
			if(1 != len) {
				if(Ext.isArray(arguments[0])) return arrayVal;
				throw {code: 'CAL_PARAM_MISS',cal: 'TYPE'};
			}
						
			var val = arguments[0];			
			try{
				if(Ext.isArray(val)) return arrayVal;
				else if(me.isCoordObj(val)) val = calculates.valof.call(this, val);
				else if(Ext.isFunction(val)){					
					val = val.call(this);
					if (val == 'Infinity' || val == '#NUM!' || val == '#N/A'  || val == '#PARAM!' || val == '#LOOP!' ||
					    val == '#DIV/0!' || val == '#VALUE!' || val == '#ERROR!' || val == '#REF!') {
						return errorVal;
					} 	
				}
			}catch(e){
				return errorVal;
			}
			
			try {
				if (val === undefined || val === "" || SCOM.isEmptyStr(val)) return numVal;
				if (HELPER.isBoolean(val)) return logicalVal;
				if (Ext.isString(val)) return textVal;
				if (Ext.isNumber(val)) return numVal;				
	        }catch(e){
			    return errorVal;
	        }
	        
	        return errorVal;
		},
		
		/**
		 * the COUNTIF function counts the number of cells in a range, that meets a
		 * given criteria.
		 * 
		 * COUNTIF( range, criteria )
		 * 
		 * special case: =countif(A1:A5, "<>"&B1) --- need deal with it ... convert
		 * 
		 * & -> ,. See DataSource.js file.
		 * TODO: question mark (?) and asterisk (*) - headache
		 * http://office.microsoft.com/en-ca/excel-help/countif-HP005209029.aspx
		 **/
		'countif' : function(){	
			if(2 != arguments.length) throw { code: 'CAL_PARAM_MISS', cal: 'COUNTIF' };
			var me = this.me, calculates = me.calculates;
			var isheet = this.sheet, irow = this.row, icol = this.col;	
			
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw {code: 'CAL_INCORRECT_COORD',span: result};				
					
			var criteraRange = arguments[0];
			if (Ext.isObject(arguments[0])) {					
				var key = criteraRange.span.join("-");
				if (key.charAt(0) == "-") key = isheet + key;
				criteraRange = HELPER.getValueFromCache(key);
				if (!criteraRange || criteraRange.length == 0) {					
					criteraRange = calculates.rangeVal2Dimension.call(this, [arguments[0]]);
					HELPER.addValueToCache(key, criteraRange);
				}
			} 
			
			// get condition now ...
			var cond = arguments[1];
			if(me.isCoordObj(cond)) cond = calculates.valof.call(this, cond);
			if (Ext.isString(cond))  {
				cond = Ext.util.Format.htmlDecode(cond);
				// add one more condition for cond --- if it is =A* => this as: A*
			    cond = HELPER.changeCondSpecialCase(cond);	
			    if (HELPER.isExpress(cond)) {
		    		// check to see whether criteria is single =,
					// case: >=, <=, !=, <>, and = >. If it is only =, make it double ...
					cond = HELPER.updateCompareCondition(cond);
			    }
			}		
			
            // now start to calculate result 
			var result = 0, sumRangeXlength = criteraRange.length, sumRangeYlength = criteraRange[0].length;
			for ( var i = 0; i < sumRangeXlength; i++) {
				for ( var j = 0; j < sumRangeYlength; j++) {
					var data = criteraRange[i][j], flag = false;
					if (data === undefined || data == null || Ext.String.trim(data.toString()) == "") {
						continue;
					}
				
					if (HELPER.isExpress(cond)) {
						data = HELPER.convertPercent2num2(data); // check special case ...if it is %
						if ( Ext.isNumber(Number(data)) ) {
							flag = eval(data + cond);
						} else {
							flag = eval('"' + data + '"' + cond);
						}
					} else if (SCOM.kmpCompare(data.toString(), cond.toString())) {
						flag = true;
					}
					
				    if (flag) result++;
				}
			}
			
			criteraRange = [];
			return result;
		},
		
		
		/**
		 * Applies criteria to cells across multiple ranges and counts the number of times all criteria are met.
		 * 
		 * Examples: =countIFS(A1:A20, ">0", C1:C20, "<10")
		 * countifs(criteria_range1, criteria1, [criteria_range2, criteria2],
		 * 
		 * criteria_range1    Required. The first range in which to evaluate the associated criteria.
		 * criteria1    Required. The criteria in the form of a number, expression, cell reference, or text that define which cells in the criteria_range1 argument will be added. For example, criteria can be expressed as 32, ">32", B4, "apples", or "32."
		 * 
		 */
		'countifs' : function() {
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp, isheet = this.sheet, irow = this.row, icol = this.col;
			var len = arguments.length; 		
			if (len < 2 || len % 2 == 1) throw {code: 'CAL_PARAM_MISS',cal: 'countifs'};

			var result = me.checkCoordValid(arguments);
			if(true !== result) throw {code: 'CAL_INCORRECT_COORD',span: result};  
		    
	        // now we need go through criteria ...
			var criteriaRangeArr = [], criteriaArr = [];
			
			var sumRangeXlength = 0, sumRangeYlength = 0;			
			var i = 0;
			while (i < len) {
				// loop through each item ...
				var criteraRange = arguments[i];
				if (Ext.isObject(arguments[i])) {					
					var key = criteraRange.span.join("-");
					if (key.charAt(0) == "-") key = isheet + key;
					criteraRange = HELPER.getValueFromCache(key);
					if (!criteraRange || criteraRange.length == 0) {					
						criteraRange = calculates.rangeVal2Dimension.call(this, [arguments[i]]);
						HELPER.addValueToCache(key, criteraRange);
					}
				} 
				
				if (criteraRange == null || criteraRange.length == 0) throw { code: 'CAL_NO_VALUE', cal: 'countifs' };
				var criteraRangeXlength = criteraRange.length;
				var criteraRangeYlength = criteraRange[0].length;
				
				if (i == 0) {
					sumRangeXlength = criteraRangeXlength;
					sumRangeYlength = criteraRangeYlength;
				}
				
				// add condition - each criteria_range argument must contain the same number of rows and columns as the sum_range argument.
	            if (sumRangeXlength != criteraRangeXlength || sumRangeYlength != criteraRangeYlength) throw { code: 'CAL_NO_VALUE', cal: 'countifs' };
				criteriaRangeArr[criteriaRangeArr.length] = criteraRange;
				i = i + 1;
				
				// get condition now ...
				var cond = arguments[i];
				if(me.isCoordObj(cond)) cond = calculates.valof.call(this, cond);
				if (Ext.isString(cond))  {
					cond = Ext.util.Format.htmlDecode(cond);
					// add one more condition for cond --- if it is =A* => this as: A*
				    cond = HELPER.changeCondSpecialCase(cond);	
				    if (HELPER.isExpress(cond)) {
			    		// check to see whether criteria is single =,
						// case: >=, <=, !=, <>, and = >. If it is only =, make it double ...
						cond = HELPER.updateCompareCondition(cond);
				    }
				}		
				criteriaArr[criteriaArr.length] = cond;		
				i = i + 1;
			}		    
			
			// now start to calculate result 
			var result = 0;
			for ( var i = 0; i < sumRangeXlength; i++) {
				for ( var j = 0; j < sumRangeYlength; j++) {
					
					// check condition now ... loop each criteria same position
					var flag = true;
					for (var k=0; k < criteriaRangeArr.length; k++) {
						var criteraRange = criteriaRangeArr[k];
						var data = criteraRange[i][j];
						if (data === undefined || data == null || Ext.String.trim(data.toString()) == "" ) {
							flag = false;
							break;
						}

						// get criteria value ...
						var cond = criteriaArr[k];
						var condflag = false;
						
						/*
						 * check whether it's a compare function - <> = ! start with ...
						 */
						if (HELPER.isExpress(cond)) {
							data = HELPER.convertPercent2num2(data); // check special case ...if it is %
							if ( Ext.isNumber(Number(data)) ) {
								condflag = eval(data + cond);
							} else {
								condflag = eval('"' + data + '"' + cond);
							}
						} else if (SCOM.kmpCompare(data.toString(), cond.toString())) {
							condflag = true;
						}
						
						// anyone failed, wrong and break ...
						if (condflag == false) {
						    flag = false;
						    break;
						}			
					}
					
					// if flag is true --- ok condition meet
					if (flag) result++;
				}
			}
			
			criteriaRangeArr = [], criteriaArr = []
			return result;
		},
		
			
		/*
		 * Returns the most common value in a data set
		 */
		'mode' : function(){
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var len = arguments.length; 
			if(0 == len) throw { code: 'CAL_PARAM_MISS', cal: 'mode'};
			
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
				
			var arr = [];					
			me.each(this.sheet, this.row, this.col, arguments, function(obj, itemType, index, insideIndex, item){	
				var data;
				if('span' == itemType){
					var sheet = obj[0], row = obj[1], col = obj[2];
					if(Ext.isNumber(sheet)){
						var cell = me.getCellData(sheet, row, col, this);											
						data = cell.data;
					}				
				} else data = obj;
				
				if (HELPER.isBoolean(data)) throw { code: 'CAL_NO_VALUE', cal: 'mode'};	
				var pos = Number(data);
				if (Ext.isNumber(pos)) arr.push(pos);
			}, this);
			
			var alen = arr.length;		
			if (0 == alen) throw { code: 'CAL_NO_VALUE', cal: 'mode'};		
			if(2 > alen) throw { code: 'VALUE_NOT_AVAILABLE', cal: 'mode'};
			
			if(2 == alen){
				if(arr[0] == arr[1]) return arr[0];
				throw { code: 'VALUE_NOT_AVAILABLE', cal: 'mode'};
			}else{
				var lookup = {};
				for(var i = 0; i < alen; i++){
					var v = arr[i];
					lookup[v] = lookup[v] || 0;
					lookup[v]++;
				}
				var max = -1, found;
				for(var p in lookup){
					if(max < lookup[p]){
						found = p;
						max = lookup[p];
					}
				}
				if (1 >= max) throw { code: 'VALUE_NOT_AVAILABLE', cal: 'mode'};
				return found;
			}
		},
		
		
		/*
		 * Returns the least common multiple
		 */
		'lcm': function(){
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var len = arguments.length; 
			if(0 == len) throw {code: 'CAL_PARAM_MISS',cal: 'lcm'};
				
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw {code: 'CAL_INCORRECT_COORD',span: result};
				
			var arr = [];					
			me.each(this.sheet, this.row, this.col, arguments, function(obj, itemType, index, insideIndex, item){	
				var data;
				if('span' == itemType){
					var sheet = obj[0], row = obj[1], col = obj[2];
					if(Ext.isNumber(sheet)){
						var cell = me.getCellData(sheet, row, col, this);										
						data = cell.data;
					}				
				}else{
					data = obj;
				}	
				
				// check whether it is boolean
				if (HELPER.isBoolean(data)) throw {code: 'CAL_NO_VALUE',cal: 'lcm'};
				
				data = Number(data);
				if(Ext.isNumber(data)){
					arr.push(Math.floor(data));
				}
			}, this);
			
			var alen = arr.length;
			if(0 == alen) throw {code: 'CAL_NO_VALUE',cal: 'lcm'};		
			for ( var i = 0; i < alen; i++) {
				if (arr[i] < 0 || arr[i] == null) throw {code: 'CAL_PARAM_NEED_BE_NUM',cal: 'lcm'};
			}
			
			if(1 == alen) return arr[0];

			var lookup = {};
			for(var i = 0; i < alen; i++){
				var v = arr[i];
				lookup[v] = true;						
			}
			
			var fset = {};
			for(var num in lookup){						
				var factors = SCOM.factorizeNum(num);
				for(var f in factors){
					fset[f] = fset[f] || 0;
					if(fset[f] < factors[f]){
						fset[f] = factors[f];
					}
				}						
			}
			var mut = 1;
			for(var p in fset){
				mut *= Math.pow(p, fset[p]);
			}
			return mut;
		},
		
		/*
		 * Returns the least common multiple
		 */
		'gcd': function(){
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var len = arguments.length; 
			if(0 == len) throw {code: 'CAL_PARAM_MISS',cal: 'gcd'};
				
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw {code: 'CAL_INCORRECT_COORD',span: result};
				
			var arr = [];					
			me.each(this.sheet, this.row, this.col, arguments, function(obj, itemType, index, insideIndex, item){	
				var data;
				if('span' == itemType){
					var sheet = obj[0], row = obj[1], col = obj[2];
					if(Ext.isNumber(sheet)){
						var cell = me.getCellData(sheet, row, col, this);										
						data = cell.data;
					}				
				}else{
					data = obj;
				}	
				
				// check whether it is boolean
				if (HELPER.isBoolean(data)) throw {code: 'CAL_NO_VALUE',cal: 'lcm'};			
				data = Number(data);
				if (data < 0) throw {code: 'NUM_IS_NOT_RIGHT',cal: 'lcm'};
				
				if(Ext.isNumber(data)){
					var roundNum = Math.floor(data);
					if (roundNum > 0) arr.push(Math.floor(data));
				}
			}, this);
			
			var alen = arr.length;
			if(0 == alen) throw {code: 'CAL_NO_VALUE',cal: 'lcm'};		
			for ( var i = 0; i < alen; i++) {
				if (arr[i] < 0 || arr[i] == null) throw {code: 'CAL_PARAM_NEED_BE_NUM',cal: 'lcm'};
			}
			
			if (arr == null || arr.length == 0) return 0;		
			if(1 == alen) return arr[0];
			
			arr.sort(function(a, b) {
				return a - b;
			});
			
			res = arr[0];
			while (res > 0) {
				var counts = 0;
				for (i = 0; i < arr.length; i++) {
					if (arr[i] % res == 0) counts++;
				}
				if (counts == arr.length) {
					break;
				}
				res--;
			}
	
			return res;
		},
		
		
		
		/*========================================================================================
		 * The following formulas are related to Date / Time
		 *========================================================================================*/
		
		/*
		 * Converts a serial number to a year
		 */
		'year' : function(){
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp, isheet = this.sheet, irow = this.row, icol = this.col;
			var len = arguments.length; 
			if(1 != len) throw {code: 'CAL_PARAM_MISS', cal: 'YEAR'};

			var result = me.checkCoordValid(arguments);
			if(true !== result) throw {code: 'CAL_INCORRECT_COORD',span: result};
			
			var myDate = arguments[0];
			if(me.isCoordObj(myDate)) myDate = calculates.valof.call(this, myDate);

		    if(SCOM.canbeNumber(myDate)) {
		    	if (Number(myDate) < 0) throw {code: 'NUM_IS_NOT_RIGHT', cal: 'YEAR'};
		    	if (myDate == 0) myDate = 1; // special case
		    	
		    	// now we know this is day .... it is start from Jan 1, 1900
				// 0 means January ...
				var newDate = new Date();
				newDate.setFullYear(1900, 0, myDate);
				if (newDate.getFullYear() > 9999) throw {code: 'CAL_PARAM_NEED_BE_NUM', cal: 'YEAR'};
				return newDate.getFullYear();
		    }
		    
		    var date = SFORMAT.checkingDate(myDate);
			if(date){
				return Ext.Date.format(date, 'Y');
			}
			
		    // check to see whether myDate is include min and hours
		    date = new Date(myDate);
		    if (date) return Ext.Date.format(date, 'Y');
			
			throw {code: 'CAL_NO_VALUE', cal: 'YEAR'};
		},
		
		/*
		 * Converts a serial number to month
		 */
		'month' : function(){
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp, isheet = this.sheet, irow = this.row, icol = this.col;
			var len = arguments.length; 
			if(1 != len) throw {code: 'CAL_PARAM_MISS', cal: 'MONTH'};

			var result = me.checkCoordValid(arguments);
			if(true !== result) throw {code: 'CAL_INCORRECT_COORD',span: result};
			
			var val = arguments[0];
			if(me.isCoordObj(val)) val = calculates.valof.call(this, val);
			
			// check whether it is boolean
		    if (HELPER.isBoolean(val)) return 1;

		    if(SCOM.canbeNumber(val)) {
		    	if (val === 0) return 1; // special cases ...
		    	if (Number(val) < 0) throw {code: 'NUM_IS_NOT_RIGHT', cal: 'MONTH'};
		    	
		    	// now we know this is day .... it is start from Jan 1, 1900
				var myDate = new Date();
				myDate.setFullYear(1900, 0, val);
				if (myDate.getFullYear() > 9999) throw {code: 'NUM_IS_NOT_RIGHT', cal: 'MONTH'};
				return myDate.getMonth() + 1;
		    }

		    var date = SFORMAT.checkingDate(val);
			if(date) return date.getMonth() + 1;
			
			// check to see whether myDate is include min and hours
		    date = new Date(val);
		    if (date) return date.getMonth() + 1;
			
			throw {code: 'CAL_NO_VALUE', cal: 'MONTH'};
		},
		
		/*
		 * Returns the serial number of a particular date
		 */
		'date' : function(){			
			if(3 != arguments.length) throw { code: 'CAL_PARAM_MISS', cal: 'date' };

			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp, isheet = this.sheet, irow = this.row, icol = this.col;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var year = arguments[0], month = arguments[1], day = arguments[2];
			if(me.isCoordObj(year)) year = calculates.numberof.call(this, year);
			if(me.isCoordObj(month)) month = calculates.numberof.call(this, month);
			if(me.isCoordObj(day)) day = calculates.numberof.call(this, day);

			try{			
				if (HELPER.isBoolean(year)) year = HELPER.convertBoolean2Int(year);
				if (HELPER.isBoolean(month)) month = HELPER.convertBoolean2Int(month);
				if (HELPER.isBoolean(day)) day = HELPER.convertBoolean2Int(day);
				
				if (year < 0) throw { code: 'NUM_IS_NOT_RIGHT', cal: 'date' };		
				var date = new Date(year, month - 1, day);
				return Ext.Date.format(date, SCONST.DEFAULT_DATE_FORMAT);
			}catch(e){
				throw {code: 'CAL_NO_VALUE',cal: 'date'};
			}	
		},
		
		'today' : function(){
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp, isheet = this.sheet, irow = this.row, icol = this.col;
			var len = arguments.length; 
			if(0 != len) throw {code: 'CAL_PARAM_MISS', cal: 'TODAY'};
			
			var today = new Date();
			
			// ok, we need add format to the cell ...
			
			return Ext.Date.format(today, SCONST.DEFAULT_DATE_FORMAT);
		},
		
		'now' : function(){
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp, isheet = this.sheet, irow = this.row, icol = this.col;
			var len = arguments.length; 
			if(0 != len) throw {code: 'CAL_PARAM_MISS', cal: 'NOW'};
			
			var today = new Date();
			return Ext.Date.format(today, SCONST.DEFAULT_DATE_TIME_FORMAT);
		},
		
        /**
		 * European standard and US standard are different ...
		 * We will base on US standard. 
		 * 
		 * The WEEKNUM function considers the week containing January 1 to be the first week of the year.
		 * 
		 * =weeknum(serial_num, return_type)
		 */
		'weeknum' : function() {
			if(1 != arguments.length && 2 != arguments.length) throw { code: 'CAL_PARAM_MISS', cal: 'weeknum' };

			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp, isheet = this.sheet, irow = this.row, icol = this.col;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var returnType = 1; // Sunday - Sat		
			var val = arguments[0];
			if(me.isCoordObj(val)) val = calculates.valof.call(this, val);
			
			val = SFORMAT.checkingDate(val);
			if(!val) throw {code: 'CAL_NO_VALUE', cal: 'weeknum'};
			
			if (arguments.length == 2) {
				returnType = arguments[1];
				if(me.isCoordObj(returnType)) returnType = calculates.valof.call(this, returnType);
			}
			
			if (returnType === undefined) throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'weeknum' };
			if (returnType != 1 && returnType != 2) throw { code: 'NUM_IS_NOT_RIGHT', cal: 'weeknum' };
			
			// ok, now we need calculate ...
			var janOne = new Date(val.getFullYear(), 0, 1);
			
			// based on return type 1 or 2 ...
			var offsetVal = 0;
			if (returnType === 1) offsetVal = 1;
	
			return Math.ceil( (((val - janOne) / 86400000) + janOne.getDay() + offsetVal) / 7 );
		},
		
		'isoweeknum' : function() {
			if(1 != arguments.length) throw { code: 'CAL_PARAM_MISS', cal: 'isoweeknum' };

			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp, isheet = this.sheet, irow = this.row, icol = this.col;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var val = arguments[0];
			if(me.isCoordObj(val)) val = calculates.valof.call(this, val);
			
			val = SFORMAT.checkingDate(val);
			if(!val) throw {code: 'CAL_NO_VALUE', cal: 'isoweeknum'};	
			
			// ok, now we need calculate ...
			var janOne = new Date(val.getFullYear(), 0, 1);
			var offsetVal = 0;
	
			return Math.ceil( (((val - janOne) / 86400000) + janOne.getDay() + offsetVal) / 7 );
		},
		
		'day' : function() {
			if(1 != arguments.length) throw { code: 'CAL_PARAM_MISS', cal: 'DAY' };

			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp, isheet = this.sheet, irow = this.row, icol = this.col;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var returnType = 1; // Sunday - Sat		
			var val = arguments[0];
			if(me.isCoordObj(val)) val = calculates.valof.call(this, val);		
			if (val == "0" || val == 0) return 0;
			
			var dateObj = SFORMAT.checkingDate(val);
			if(dateObj){
				return dateObj.getDate();
			} else if (Ext.isNumber(Number(val))) {
				var baseDate = new Date("1904-01-02");
			    if (val == ""|| Number(val) < 0) throw { code: 'NUM_IS_NOT_RIGHT', cal: 'DAY' };
			    baseDate.setDate(baseDate.getDate()+ (Number(val)-1));
			    return baseDate.getDate();
			} 
			
			// check to see whether myDate is include min and hours
		    var date = new Date(val);
		    if (date) return date.getDate();
			
			throw {code: 'CAL_NO_VALUE', cal: 'day'};
		},
		
		/**
		 * Returns the number of days between two dates.
		 * DAYS(end_date, start_date)
		 */
		'days' : function() {
			if(2 != arguments.length) throw { code: 'CAL_PARAM_MISS', cal: 'days' };

			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp, isheet = this.sheet, irow = this.row, icol = this.col;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };

			var startDate = arguments[1], startDateNum = 0;
			if(me.isCoordObj(startDate)) startDate = calculates.valof.call(this, startDate);	
			var dateObj = SFORMAT.checkingDate(startDate);
			if(dateObj) startDateNum = HELPER.convertDateToNum(dateObj);
			else if (Ext.isNumber(Number(startDate))) startDateNum = startDate;
			else throw {code: 'CAL_NO_VALUE', cal: 'days'};
			
			var endDate = arguments[0], endDateNum = 0;
			if(me.isCoordObj(endDate)) endDate = calculates.valof.call(this, endDate);	
			dateObj = SFORMAT.checkingDate(endDate);
			if(dateObj) endDateNum = HELPER.convertDateToNum(dateObj);
			else if (Ext.isNumber(Number(endDate))) endDateNum = endDate;
			else throw {code: 'CAL_NO_VALUE', cal: 'days'};
			
			return endDateNum - startDateNum;
		},
		
		// days360(start, end, [method])
		'days360' : function() {
			var len = arguments.length;
			if(2 > len || 3 < len) throw { code: 'CAL_PARAM_MISS', cal: 'days360' };

			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp, isheet = this.sheet, irow = this.row, icol = this.col;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };

			var startdate = arguments[0];
			if(me.isCoordObj(startdate)) startdate = calculates.valof.call(this, startdate);	
			startdate = SFORMAT.checkingDate(startdate);
			if(startdate == null) throw {code: 'CAL_NO_VALUE', cal: 'days360'};
			
			var enddate = arguments[1];
			if(me.isCoordObj(enddate)) enddate = calculates.valof.call(this, enddate);	
			enddate = SFORMAT.checkingDate(enddate);
			if(enddate == null)  throw {code: 'CAL_NO_VALUE', cal: 'days360'};
			
			var method = false;
			if (len == 3) {
				method = arguments[2];
				if(me.isCoordObj(method)) method = calculates.valof.call(this, method);	
			}
			
			return HELPER.calDifferentDateByMethod(enddate, startdate, method);
		},
		
		/**
		 * The DATEVALUE function converts a date that is stored as text to a serial number that Excel recognizes as a date
		 */ 
		'datevalue' : function() {
			if(1 != arguments.length) throw { code: 'CAL_PARAM_MISS', cal: 'datevalue' };

			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp, isheet = this.sheet, irow = this.row, icol = this.col;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };

			var val = arguments[0];
			if(me.isCoordObj(val)) val = calculates.valof.call(this, val);
			
			val = SFORMAT.checkingDate(val);
			if(!val) throw {code: 'CAL_NO_VALUE', cal: 'datevalue'};
			
			return HELPER.convertDateToNum(val);
		},
		
		/**
		 * time value
		 */
		'timevalue' : function() {
			if(1 != arguments.length) throw { code: 'CAL_PARAM_MISS', cal: 'timevalue' };

			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp, isheet = this.sheet, irow = this.row, icol = this.col;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };

			var val = arguments[0];
			if(me.isCoordObj(val)) val = calculates.valof.call(this, val);
			
			val = SFORMAT.checkingTime(val);
			if(!val) throw {code: 'CAL_NO_VALUE', cal: 'timevalue'};
			
			return HELPER.convertDateToTimeVal(val);
		},
		
		/**
		 * NETWORKDAYS - Returns the number of whole working days between start_date and end_date. Working days exclude 
		 * weekends and any dates identified in holidays. Use NETWORKDAYS to calculate employee benefits that accrue based 
		 * on the number of days worked during a specific term.
		 */
		'networkdays' : function() {
			var len = arguments.length;
			if(2 > len || 3 < len) throw { code: 'CAL_PARAM_MISS', cal: 'networkdays' };
			
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp, isheet = this.sheet, irow = this.row, icol = this.col;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var startdate = arguments[0];
			if(me.isCoordObj(startdate)) startdate = calculates.valof.call(this, startdate);	
			startdate = SFORMAT.checkingDate(startdate);
			if(startdate == null) throw {code: 'CAL_NO_VALUE', cal: 'networkdays'};			
			
			var endDate = arguments[1];
			if(me.isCoordObj(endDate)) endDate = calculates.valof.call(this, endDate);	
			endDate = SFORMAT.checkingDate(endDate);
			if(endDate == null)  throw {code: 'CAL_NO_VALUE', cal: 'networkdays'};
			
			// ok, we need check 3rd parameters ...can be array ...
			var holidays = [];	
			if (arguments[2]) {
				me.each(this.sheet, this.row, this.col, [arguments[2]], function(obj, itemType, index, insideIndex, item){	
					var data;
					if('span' == itemType){
						var sheet = obj[0], row = obj[1], col = obj[2];
						if(Ext.isNumber(sheet)){
							var cell = me.getCellData(sheet, row, col, this);										
							data = cell.data;
						}				
					} else data = obj;	
					
					var holiday = SFORMAT.checkingDate(data);
					if(holiday && HELPER.isArrayIncludeDateObj(holidays, holiday) == false) holidays.push(holiday);
				}, this);	
			}
	
			return HELPER.calculateNetworkDays(startdate, endDate, holidays);
		},
		
		'networkdays_intl' : function() {
			var len = arguments.length;
			if(2 > len || 4 < len) throw { code: 'CAL_PARAM_MISS', cal: 'networkdays.intl' };
			
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp, isheet = this.sheet, irow = this.row, icol = this.col;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var startdate = arguments[0];
			if(me.isCoordObj(startdate)) startdate = calculates.valof.call(this, startdate);	
			startdate = SFORMAT.checkingDate(startdate);
			if(startdate == null) throw {code: 'CAL_NO_VALUE', cal: 'networkdays.intl'};			
			
			var endDate = arguments[1];
			if(me.isCoordObj(endDate)) endDate = calculates.valof.call(this, endDate);	
			endDate = SFORMAT.checkingDate(endDate);
			if(endDate == null)  throw {code: 'CAL_NO_VALUE', cal: 'networkdays.intl'};
			
			var weekend_type = 1;
			if (len > 2)  weekend_type = calculates.numberof.call(this, arguments[2]);	
			if (weekend_type<0 || weekend_type>17 || (weekend_type>7 && weekend_type < 11) ) throw {code: 'CAL_NO_VALUE', cal: 'networkdays.intl'};
			
			var holidays = [];	
			if (len == 4) {
				me.each(this.sheet, this.row, this.col, [arguments[3]], function(obj, itemType, index, insideIndex, item){	
					var data;
					if('span' == itemType){
						var sheet = obj[0], row = obj[1], col = obj[2];
						if(Ext.isNumber(sheet)){
							var cell = me.getCellData(sheet, row, col, this);										
							data = cell.data;
						}				
					} else data = obj;	
					
					var holiday = SFORMAT.checkingDate(data);
					if(holiday && HELPER.isArrayIncludeDateObj(holidays, holiday) == false) holidays.push(holiday);
				}, this);	
			}
			
			return HELPER.calculateNetworkDaysIntl(startdate, endDate, weekend_type, holidays);
		},
		
		/**
		 * workday - Returns a number that represents a date that is the indicated number of working days before or 
		 * after a date (the starting date). Working days exclude weekends and any dates identified as holidays.
		 */
		'workday' : function() {
			var len = arguments.length;
			if(2 > len || 3 < len) throw { code: 'CAL_PARAM_MISS', cal: 'workday' };
			
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp, isheet = this.sheet, irow = this.row, icol = this.col;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var startdate = arguments[0];
			if(me.isCoordObj(startdate)) startdate = calculates.valof.call(this, startdate);	
			startdate = SFORMAT.checkingDate(startdate);
			if(startdate == null) throw {code: 'CAL_NO_VALUE', cal: 'workday'};			
			
			var days = arguments[1];
			if(me.isCoordObj(days)) days = calculates.numberof.call(this, days);
			
			// ok, we need check 3rd parameters ...can be array ...
			var holidays = [];	
			if (arguments[2]) {
				me.each(this.sheet, this.row, this.col, [arguments[2]], function(obj, itemType, index, insideIndex, item){	
					var data;
					if('span' == itemType){
						var sheet = obj[0], row = obj[1], col = obj[2];
						if(Ext.isNumber(sheet)){
							var cell = me.getCellData(sheet, row, col, this);										
							data = cell.data;
						}				
					} else data = obj;	
					
					var holiday = SFORMAT.checkingDate(data);
					if(holiday && HELPER.isArrayIncludeDateObj(holidays, holiday) == false) holidays.push(holiday);
				}, this);	
			}
	
			var dueDate = HELPER.calculateWorkDay(startdate, days, holidays);
			
			return HELPER.convertDateToNum(dueDate);
		},
		
		'workday_intl' : function() {
			var len = arguments.length;
			if(2 > len || 4 < len) throw { code: 'CAL_PARAM_MISS', cal: 'workday.intl' };
			
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp, isheet = this.sheet, irow = this.row, icol = this.col;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var startdate = arguments[0];
			if(me.isCoordObj(startdate)) startdate = calculates.valof.call(this, startdate);	
			startdate = SFORMAT.checkingDate(startdate);
			if(startdate == null) throw {code: 'CAL_NO_VALUE', cal: 'workday.intl'};			
			
			var days = arguments[1];
			if(me.isCoordObj(days)) days = calculates.numberof.call(this, days);
			
			var weekend_type = 1;
			if (len > 2)  weekend_type = calculates.numberof.call(this, arguments[2]);	
			if (weekend_type<0 || weekend_type>17 || (weekend_type>7 && weekend_type < 11) ) throw {code: 'CAL_NO_VALUE', cal: 'workday.intl'};		
			
			// ok, we need check 3rd parameters ...can be array ...
			var holidays = [];	
			if (len > 3) {
				me.each(this.sheet, this.row, this.col, [arguments[3]], function(obj, itemType, index, insideIndex, item){	
					var data;
					if('span' == itemType){
						var sheet = obj[0], row = obj[1], col = obj[2];
						if(Ext.isNumber(sheet)){
							var cell = me.getCellData(sheet, row, col, this);										
							data = cell.data;
						}				
					} else data = obj;	
					
					var holiday = SFORMAT.checkingDate(data);
					if(holiday && HELPER.isArrayIncludeDateObj(holidays, holiday) == false) holidays.push(holiday);
				}, this);	
			}
	
			var dueDate = HELPER.calculateWorkDayIntl(startdate, days, weekend_type, holidays);
			
			return HELPER.convertDateToNum(dueDate);
		},
		
		/**
		 * Calculates the fraction of the year represented by the number of whole days between two dates (the start_date and the end_date). Use the YEARFRAC worksheet function to identify the proportion of a whole year's benefits or obligations to assign to a specific term.
		 */
		'yearfrac' : function() {
			var len = arguments.length;
			if(2 > len || 3 < len) throw { code: 'CAL_PARAM_MISS', cal: 'yearfrac' };

			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp, isheet = this.sheet, irow = this.row, icol = this.col;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };

			var startdate = arguments[0];
			if(me.isCoordObj(startdate)) startdate = calculates.valof.call(this, startdate);	
			startdate = SFORMAT.checkingDate(startdate);
			if(startdate == null) throw {code: 'CAL_NO_VALUE', cal: 'yearfrac'};
			
			var enddate = arguments[1];
			if(me.isCoordObj(enddate)) enddate = calculates.valof.call(this, enddate);	
			enddate = SFORMAT.checkingDate(enddate);
			if(enddate == null)  throw {code: 'CAL_NO_VALUE', cal: 'yearfrac'};
			
			var basic = 0;
			if (len == 3) {
				basic = calculates.numberof.call(this, arguments[2]);	
			}
			
			if (basic > 4 || basic < 0) throw {code: 'NUM_IS_NOT_RIGHT', cal: 'yearfrac'};
			
			/**
			 * 0 or omitted	US (NASD) 30/360
			 * 1	Actual/actual
			 * 2	Actual/360
			 * 3	Actual/365
			 * 4	European 30/360
             */
			if (basic == 0 || basic == 4) {
				var method = true;
				if (basic == 0) method = false;
				var days = HELPER.calDifferentDateByMethod(enddate, startdate, method);
				return Math.abs(days/360);
			}
			
			var actualDays = HELPER.convertDateToNum(enddate) - HELPER.convertDateToNum(startdate);
			if (basic == 2) return Math.abs(actualDays/360);
			else if (basic == 3) return Math.abs(actualDays/365);
			else if (basic == 1) {
				// get actual year date ...
				var actual = HELPER._actualDaysPerYear(startdate, enddate);
				return Math.abs(actualDays/actual);
			}
			
			throw {code: 'NUM_IS_NOT_RIGHT', cal: 'yearfrac'};
		},
		
		/**
		 * Returns the day of the week corresponding to a date. The day is given as an integer, 
		 * ranging from 1 (Sunday) to 7 (Saturday), by default.
		 * 
		 * WEEKDAY(serial_number,[return_type])
		 * 
		 * Serial_number  Required. A sequential number that represents the date of the day you are trying to find. 
		 *                Dates should be entered by using the DATE function, or as results of other formulas or functions.
		 * Return_type    Optional. A number that determines the type of return value.
		 * 
		 * TODO: will add other 11 - 17 
		 * 
		 * 1 or omitted	Numbers 1 (Sunday) through 7 (Saturday). Behaves like previous versions of Microsoft Excel.
			2	Numbers 1 (Monday) through 7 (Sunday).
			3	Numbers 0 (Monday) through 6 (Sunday).
			11	Numbers 1 (Monday) through 7 (Sunday).
			12	Numbers 1 (Tuesday) through 7 (Monday).
			13	Numbers 1 (Wednesday) through 7 (Tuesday).
			14	Numbers 1 (Thursday) through 7 (Wednesday).
			15	Numbers 1 (Friday) through 7 (Thursday).
			16	Numbers 1 (Saturday) through 7 (Friday).
			17	Numbers 1 (Sunday) through 7 (Saturday).
		 */
		'weekday' : function() {
			var len = arguments.length;
			if (1 != len && 2 != len) throw { code: 'CAL_PARAM_MISS', cal: 'WEEKDAY' };
			
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp, isheet = this.sheet, irow = this.row, icol = this.col;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var enterDate = arguments[0];
			var retVal = 1;
			if (len == 2) {
				retVal = arguments[1];
			    if(me.isCoordObj(retVal)) retVal = calculates.valof.call(this, retVal);		
			}
			if (retVal === undefined) throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'WEEKDAY' };
			if (retVal != 1 && retVal != 2 && retVal != 3) throw { code: 'NUM_IS_NOT_RIGHT', cal: 'WEEKDAY' };
	
			if(me.isCoordObj(enterDate)) enterDate = calculates.valof.call(this, enterDate);		
			if (enterDate === undefined || HELPER.isEmptyStr(enterDate)) throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'WEEKDAY' };
			
			// check whether it is boolean ...
			if (HELPER.isBoolean(enterDate)) enterDate = HELPER.convertBoolean2Int(enterDate);
	
			// ok, this should be date format ...
			var checkDate = SFORMAT.checkingDate(enterDate);
			if (checkDate) {
				// 1 - 1 (Sunday) to 7 (Saturday).
				// 2 - 1 (Monday) to 7 (Sunday).
				// 3 - 0 (Monday) to 6 (Sunday).
				var result = checkDate.getDay(); // sunday = 0, monday = 1 - default ...
				
				if (retVal == 1) result += 1;
				else if (retVal == 2 && result == 0) result = 7; // for case 2 ...
				else if (retVal == 3) {
					result -= 1;
					if (result == -1) result = 6;
				}
				return result;
			} else {
				// check to see whether it is number ...
				var val = Number(enterDate);
	    	    if (Ext.isNumber(enterDate)) {
	    	    	
	    	    	if (enterDate < 0)  throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'WEEKDAY' };	    	
	    	    	var result = Math.floor((enterDate + 6) % 7);
	    	    	if (retVal == 1) result += 1;
					else if (retVal == 2 && result == 0) result = 7; // for case 2 ...
					else if (retVal == 3) {
						result -= 1;
						if (result == -1) result = 6;
					}
					return result;
	    	    }
				
				 throw { code: 'CAL_NO_VALUE', cal: 'WEEKDAY' };
			}
		},
		
		// this is hour formula ...
		'hour' : function() {
			var len = arguments.length;
			if (1 != len) throw { code: 'CAL_PARAM_MISS', cal: 'hour' };
			
			var maxDigNum = 0;
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp, isheet = this.sheet, irow = this.row, icol = this.col;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
	
			var posOffset = arguments[0];
			if(me.isCoordObj(posOffset)) posOffset = calculates.valof.call(this, posOffset);
			if (HELPER.isBoolean(posOffset)) return 0;
	
			var posTmp = Number(posOffset);
			
			if (Ext.isNumber(posTmp) && posTmp < 0) throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'hour' };	
			else if (Ext.isNumber(posTmp) && posTmp >= 0) {
				posTmp = posTmp.toString();
				var as = posTmp.match(/(\.\d+)$/);
				if (as) {
					// example 2.3354
					var sumSecond = Number(as[1]) * 1440;
					return (sumSecond - (sumSecond % 60)) / 60;
				} else {
					// posOffset is positive integer
					return 0;
				}
			} else if (posOffset.indexOf('.') > -1) {
				throw { code: 'CAL_NO_VALUE', cal: 'HOUR' };
			} else {
				// example hour 2012 -12 -23 11:08:09 PM, 2012 -12 -23 11:08:09
				// ,11:08:09 PM, 11:08:09
				if ((/(\d+)\s*:\s*(\d+)\s*:\s*(\d+)(\s+[P|A]M){0,1}/i).test(posOffset)) {
					var date = posOffset.replace(/(\d+)\s*:\s*(\d+)\s*:\s*(\d+)(\s+[P|A]M){0,1}/i, "");
					date = date.replace(/\s+/g, '');
					var pm = posOffset.match(/(\d+)\s*:\s*(\d+)\s*:\s*(\d+)(\s+[P|A]M){0,1}/i);
					if (!date) {
						if (!Ext.isDate(new Date(date))) throw { code: 'CAL_NO_VALUE', cal: 'HOUR' };
					}
					var h = Number(pm[1]);
					if (h < 0) throw { code: 'CAL_NO_VALUE', cal: 'HOUR' };
					
					var m = Number(pm[2]);
					var s = Number(pm[3]);
					if (pm[4]) {
						if (m > -1 && m < 60 && s > -1 && s < 60 && h > -1 && h < 13) {
							if ((/pm/i).test(pm[4])) {
								if (h == 12) return 12;
								else return h + 12;
							} else {
								if (h == 12) return 0;
								else return h;
							}
						} else throw { code: 'CAL_NO_VALUE', cal: 'HOUR' };
					} else {
						if (h > 24) return h % 12;
						else return h;
					}
				} else if ((/(\d+)\s*:\s*(\d+)\s*(\s+[P|A]M){0,1}$/i)
						.test(posOffset)) { // example hour 2012 -12 -23 11:08 PM,
											// 2012 -12 -23 11:08 ,11:08 PM, 11:08
					var date = posOffset.replace(/(\d+)\s*:\s*(\d+)\s*(\s+[P|A]M){0,1}$/i, "");
					date = date.replace(/\s+/g, '');
					var pm = posOffset.match(/(\d+)\s*:\s*(\d+)\s*(\s+[P|A]M){0,1}$/i);
					if (!date) {
						if (!Ext.isDate(new Date(date)))  throw 'SS_ERROR_VALUE';
					}
					var h = Number(pm[1]);			
					if (h < 0) throw { code: 'CAL_NO_VALUE', cal: 'HOUR' };
					 
					var m = Number(pm[2]);
					if (pm[3]) {
						if (m > -1 && m < 60 && h > -1 && h < 13) {
							if ((/pm/i).test(pm[3])) {
								if (h == 12)  return 12;
								else  return h + 12;
							} else {
								if (h == 12) return 0;
								else return h;
							}
						} else {
							throw { code: 'CAL_NO_VALUE', cal: 'HOUR' };
						}
					} else {
						if (h > 24) return h % 12;
						else return h;
					}
				}
			}
		},
		
		// this is for get minute ...
		'minute' : function() {
			var len = arguments.length;
			if (1 != len) throw { code: 'CAL_PARAM_MISS', cal: 'minute' };

			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp, isheet = this.sheet, irow = this.row, icol = this.col;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var maxDigNum = 0;
			
			var posOffset = arguments[0];
			if(me.isCoordObj(posOffset)) posOffset = calculates.valof.call(this, posOffset);
			if (HELPER.isBoolean(posOffset)) return 0;
	
			var posTmp = Number(posOffset);
			if (Ext.isNumber(posTmp) && posTmp > 0) {
				posTmp = posTmp.toString();
				if (posTmp.indexOf('.') > -1) {
					/*
					 * example 2.3354
					 */
					return Math.floor((Number(posTmp) * 1440) % 60);
				} else {
					// posOffset is positive integer
					return 0;
				}
			} else if (posOffset.indexOf('.') > -1) {
				throw { code: 'CAL_NO_VALUE', cal: 'minute' };
			} else {
				// example hour 2012 -12 -23 11:08:09 PM, 2012 -12 -23 11:08:09
				// ,11:08:09 PM, 11:08:09
				if ((/(\d+)\s*:\s*(\d+)\s*:\s*(\d+)(\s+[P|A]M){0,1}/i).test(posOffset)) {
					var date = posOffset.replace(
							/(\d+)\s*:\s*(\d+)\s*:\s*(\d+)(\s+[P|A]M){0,1}/i, "");
					date = date.replace(/\s+/g, '');
					var pm = posOffset.match(/(\d+)\s*:\s*(\d+)\s*:\s*(\d+)(\s+[P|A]M){0,1}/i);
					if (date) {
						if (!Ext.isDate(new Date(date))) {
							throw { code: 'CAL_NO_VALUE', cal: 'minute' };
						}
					}
					var h = Number(pm[1]);
					var m = Number(pm[2]);
					var s = Number(pm[3]);
					if (m > -1 && m < 60 && s > -1 && s < 60) {
						if (pm[4] && (h < 0 || h > 12)) {
							throw { code: 'CAL_NO_VALUE', cal: 'minute' };
						}
						return m;
					} else {
						throw { code: 'CAL_NO_VALUE', cal: 'minute' };
					}
				} else if ((/(\d+)\s*:\s*(\d+)\s*(\s+[P|A]M){0,1}$/i).test(posOffset)) {// example hour 2012 -12 -23 11:08 PM,
											// 2012 -12 -23 11:08 ,11:08 PM, 11:08
											// =MINUTE("15:30" )
					var date = posOffset.replace(
							/(\d+)\s*:\s*(\d+)\s*(\s+[P|A]M){0,1}$/i, "");
					date = date.replace(/\s+/g, '');
					var pm = posOffset
							.match(/(\d+)\s*:\s*(\d+)\s*(\s+[P|A]M){0,1}$/i);
					if (date) {
						if (!Ext.isDate(new Date(date))) {
							throw { code: 'CAL_NO_VALUE', cal: 'minute' };
						}
					}
					var h = Number(pm[1]);
					var m = Number(pm[2]);
					if (m > -1 && m < 60) {
						if (pm[3] && (h < 0 || h > 12)) {
							throw { code: 'CAL_NO_VALUE', cal: 'minute' };
						}
						return m;
					} else {
						throw { code: 'CAL_NO_VALUE', cal: 'minute' };
					}
				}
			}
		},
		
		'second' : function() {
			var len = arguments.length;
			if (1 != len) throw { code: 'CAL_PARAM_MISS', cal: 'second' };

			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp, isheet = this.sheet, irow = this.row, icol = this.col;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var posOffset = arguments[0];
			if(me.isCoordObj(posOffset)) posOffset = calculates.valof.call(this, posOffset);
			if (HELPER.isBoolean(posOffset)) return 0;
			
			var posTmp = Number(posOffset);
			if (Ext.isNumber(posTmp) && posTmp > 0) {
				posTmp = posTmp.toString();
				if (posTmp.indexOf('.') > -1) {
					/*
					 * example 2.3354
					 */
					var mpos = (Number(posTmp) * 1440) % 60;
					var s = Math.floor((mpos - Math.floor(mpos)) * 60);
					return s;
				} else {
					// posOffset is positive integer
					return 0;
				}
			} else if (posOffset.indexOf('.') > -1) {
				throw { code: 'CAL_NO_VALUE', cal: 'second' };
			} else {
				// example hour 2012 -12 -23 11:08:09 PM, 2012 -12 -23 11:08:09
				// ,11:08:09 PM, 11:08:09
				if ((/(\d+)\s*:\s*(\d+)\s*:\s*(\d+)(\s+[P|A]M){0,1}/i)
						.test(posOffset)) {
					var date = posOffset.replace(
							/(\d+)\s*:\s*(\d+)\s*:\s*(\d+)(\s+[P|A]M){0,1}/i, "");
					date = date.replace(/\s+/g, '');
					var pm = posOffset
							.match(/(\d+)\s*:\s*(\d+)\s*:\s*(\d+)(\s+[P|A]M){0,1}/i);
					if (date) {
						if (!Ext.isDate(new Date(date))) throw { code: 'CAL_NO_VALUE', cal: 'second' };
					}
					var h = Number(pm[1]);
					var m = Number(pm[2]);
					var s = Number(pm[3]);
					if (m > -1 && m < 60 && s > -1 && s < 60) {
						if (pm[4] && (h < 0 || h > 12)) throw { code: 'CAL_NO_VALUE', cal: 'second' };
						return s;
					} else {
						throw { code: 'CAL_NO_VALUE', cal: 'second' };
					}
				} else if ((/(\d+)\s*:\s*(\d+)\s*(\s+[P|A]M){0,1}$/i)
						.test(posOffset)) {// example hour 2012 -12 -23 11:08 PM,
											// 2012 -12 -23 11:08 ,11:08 PM, 11:08
											// =MINUTE("15:30" )
					var date = posOffset.replace(
							/(\d+)\s*:\s*(\d+)\s*(\s+[P|A]M){0,1}$/i, "");
					date = date.replace(/\s+/g, '');
					var pm = posOffset
							.match(/(\d+)\s*:\s*(\d+)\s*(\s+[P|A]M){0,1}$/i);
					if (date) {
						if (!Ext.isDate(new Date(date))) throw { code: 'CAL_NO_VALUE', cal: 'second' };
					}
					var h = Number(pm[1]);
					var m = Number(pm[2]);
					if (m > -1 && m < 60) {
						if (pm[3] && (h < 0 || h > 12)) throw { code: 'CAL_NO_VALUE', cal: 'second' };
						return 0;
					} else throw { code: 'CAL_NO_VALUE', cal: 'second' };
				}
			}
		},
		
		'time' : function() {
			var len = arguments.length;
			if (3 != len) throw { code: 'CAL_PARAM_MISS', cal: 'time' };

			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp, isheet = this.sheet, irow = this.row, icol = this.col;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var hourPart = calculates.numberof.call(this, arguments[0]);
			var minutePart = calculates.numberof.call(this, arguments[1]);
			var secondPart = calculates.numberof.call(this, arguments[2]);
			
			if (hourPart < 32768 && minutePart < 32768 && secondPart < 32768) {
				minutePart += Math.floor(secondPart / 60);
				hourPart = Math.floor(hourPart);
				var sumMin = minutePart + hourPart * 60;
				var hsm = sumMin % 60;
				hourPart = (sumMin - hsm) / 60;
				minutePart = hsm % 60;
				var hm = hourPart % 24;
				var zone = "AM";
				if (hm > 11) zone = "PM";
				hourPart = hm % 12;
				if (hourPart == 0) hourPart = 12;
	
				minutePart = Math.floor(minutePart);
				if (minutePart < 10) minutePart = "0" + minutePart;
	
				secondPart = Math.floor(secondPart % 60);
				if (secondPart < 10) secondPart = "0" + secondPart;
	
				return hourPart + ":" + minutePart + ":" + secondPart + " " + zone;
			}
			
			throw { code: 'CAL_NO_VALUE', cal: 'time' };
		},
		
		/**
		 * Returns the serial number that represents the date that is the indicated number of months before or after 
		 * a specified date (the start_date). Use EDATE to calculate maturity dates or due dates that fall on the 
		 * same day of the month as the date of issue.
		 * 
		 * Example: EDATE(start_date, months)
		 */
		'edate' : function() {
            var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp, isheet = this.sheet, irow = this.row, icol = this.col;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var len = arguments.length;
			if (2 != len) throw { code: 'CAL_PARAM_MISS', cal: 'edate' };
			
			var startDate = arguments[0];
			if(me.isCoordObj(startDate)) startDate = calculates.valof.call(this, startDate);		
			if (startDate === undefined || HELPER.isEmptyStr(startDate)) throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'edate' };
			
			// check for 2nd parameters ...
			var months = calculates.numberof.call(this, arguments[1]);
			
			// ok, this should be date format ...
			var checkDate = SFORMAT.checkingDate(startDate);
			if (checkDate) {			
				var newDate = Ext.Date.add(checkDate, Ext.Date.MONTH, months);	
				return HELPER.convertDateToNum(newDate);
			} else if (Ext.isNumber(Number(startDate))) {
				var temp = Number(startDate);
				var date = new Date(0, 0, temp-1);
				var newDate = Ext.Date.add(date, Ext.Date.MONTH, months);	
				return HELPER.convertDateToNum(newDate);
			}
			
			throw { code: 'CAL_NO_VALUE', cal: 'edate' };
		},
			
		/**
		 * Returns the serial number for the last day of the month that is the indicated number of months before or after start_date. 
		 * Use EOMONTH to calculate maturity dates or due dates that fall on the last day of the month.
		 * Example: EOMONTH(start_date, months)
		 */
		'eomonth' : function() {
            var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp, isheet = this.sheet, irow = this.row, icol = this.col;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var len = arguments.length;
			if (2 != len) throw { code: 'CAL_PARAM_MISS', cal: 'eomonth' };
			
			var startDate = arguments[0];
			if(me.isCoordObj(startDate)) startDate = calculates.valof.call(this, startDate);		
			if (startDate === undefined || HELPER.isEmptyStr(startDate)) throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'eomonth' };
			
			// check for 2nd parameters ...
			var months = calculates.numberof.call(this, arguments[1]);
			
			// ok, this should be date format ...
			var checkDate = SFORMAT.checkingDate(startDate);
			if (checkDate) {			
				var newDate = Ext.Date.add(checkDate, Ext.Date.MONTH, months);				
				return HELPER.convertDateToNum(Ext.Date.getLastDateOfMonth(newDate));
			} 
			
			throw { code: 'CAL_NO_VALUE', cal: 'eomonth' };
		},
		
		// ===================================================================================================
		
		// In Excel, the MID function extracts a substring from a string (starting
	    // at any position).
	    // MID( text, start_position, number_of_characters )
		'mid' : function(){
			if(3 != arguments.length) throw { code: 'CAL_PARAM_MISS', cal: 'mid' };
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp, isheet = this.sheet, irow = this.row, icol = this.col;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var args = me.transferAll2Absolute(arguments, isheet, irow, icol);
			if(me.checkRangeMatch(args, 1, false, false)){
				var arr = [];					
				me.each(isheet, irow, icol, args, function(obj, itemType, index, insideIndex, item){	
					var data;
					if('span' == itemType){
						var sheet = obj[0], row = obj[1], col = obj[2];
						if(Ext.isNumber(sheet)){
							var cell = me.getCellData(sheet, row, col, this);										
							data = cell.data;
						}				
					}else data = obj;						
					arr.push(data);
				}, this);
				
				var str = arr[0], startPos = Number(arr[1]), charNum = Number(arr[2]);
				if((Ext.isString(str) || Ext.isNumber(str))
					&& Ext.isNumber(startPos) && Ext.isNumber(charNum) && 0 < startPos && 0 < charNum){
					str = str.toString();
					return str.substr(startPos-1, charNum);
				} 
			}
			
			throw { code: 'CAL_NO_VALUE', cal: 'mid' };	
		},
		
		/*
		 * Finds one text value within another (case-sensitive)
		 */
		'find' : function(){
			var len = arguments.length;
			if(2 > len || 3 < len) throw { code: 'CAL_PARAM_MISS', cal: 'find'};

			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp, isheet = this.sheet, irow = this.row, icol = this.col;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var source = arguments[0], target = arguments[1];	
			if(me.isCoordObj(target)) target = calculates.valof.call(this, target);	
			if (target === undefined || HELPER.isEmptyStr(target)) throw {code: 'CAL_NO_VALUE',cal: 'FIND'};
			
			if(me.isCoordObj(source)) source = calculates.valof.call(this, source);	
			if (source === undefined || HELPER.isEmptyStr(source)) throw {code: 'CAL_NO_VALUE',cal: 'FIND'};
			
			// get start ...
			var start = 0;
			if (3 == len) {
				start = calculates.numberof.call(this, arguments[2]);
			    if (start < 1) throw {code: 'CAL_NO_VALUE',cal: 'FIND'};
			}
			
			if ((Ext.isNumber(source) || Ext.isString(source)) && (Ext.isNumber(target) || Ext.isString(target))) {
				source = source.toString();
				target = target.toString();
				if (0 < start) {
					start = start - 1;
					target = target.slice(start, target.length);
				} else
					start = 0;
				var index = target.indexOf(source);
				if (-1 == index) {
					index = target.indexOf(source.trim());
					if (-1 == index) throw {code: 'CAL_NO_VALUE',cal: 'FIND'};
				}
				return index + 1 + start;
			} else
				throw {code: 'CAL_NO_VALUE',cal: 'FIND'};
		},
		
		/*
		 * Repeats text a given number of times
		 */
		'rept' : function(){
			var len = arguments.length;
			if(2 != len) throw { code: 'CAL_PARAM_MISS', cal: 'rept' };
			
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp, isheet = this.sheet, irow = this.row, icol = this.col;
			var result = me.checkCoordValid(arguments);
			if(true !== result)  throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var repeatTimes = calculates.numberof.call(this, arguments[1]);
			if (repeatTimes < 0) throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'rept' };
			if (repeatTimes == 0) return "";
			
			var repeatText = arguments[0];
			if(me.isCoordObj(repeatText)) repeatText = calculates.valof.call(this, repeatText);
			
			if(Ext.isString(repeatText) || Ext.isNumber(repeatText) || HELPER.isBoolean(repeatText)){
				repeatText = repeatText.toString();					
				var tmp = [];
				for(var i = 0; i < repeatTimes; i++){
					tmp.push(repeatText);
				}
				return tmp.join('');
			}
			
			throw { code: 'CAL_NO_VALUE', cal: 'rept' };
		},
		
		// REPLACE function replaces a sequence of characters in a string with another set of characters.
		'replace' : function() {
			var len = arguments.length;
			if(4 != len) throw { code: 'CAL_PARAM_MISS', cal: 'replace' };
			
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp, isheet = this.sheet, irow = this.row, icol = this.col;
			var result = me.checkCoordValid(arguments);
			if(true !== result)  throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var old_text = arguments[0];
			if(me.isCoordObj(old_text)) old_text = calculates.valof.call(this, old_text);
			var start_num = calculates.numberof.call(this, arguments[1]);
			var num_chars = calculates.numberof.call(this, arguments[2]);
			var new_text = arguments[3];
			if(me.isCoordObj(new_text)) new_text = calculates.valof.call(this, new_text);
		
			// check condition ...	
			var str = old_text;
			old_text = old_text.toString();
			new_text = new_text.toString();
			if (old_text.length < start_num) str = old_text.concat(new_text);	
			else {
				var part1 = old_text.substr(0, start_num - 1);
				var part2 = old_text.substr(start_num + num_chars - 1, old_text.length);
				str = part1.concat(new_text).concat(part2);
			}
			return str;
		},
		
		// this will set value now
		// Text can be in any of the constant number, date, or time formats
		// recognized by Microsoft Excel.
		// For example:
		// =value("$3000")
		'value' : function(){
			var len = arguments.length;
			if(1 != len) throw { code: 'CAL_PARAM_MISS', cal: 'value' };
			
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp, isheet = this.sheet, irow = this.row, icol = this.col;
			var result = me.checkCoordValid(arguments);
			if(true !== result)  throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var val = arguments[0];
			if(me.isCoordObj(val)) val = calculates.valof.call(this, val);
			if (val === undefined || HELPER.isEmptyStr(val) || HELPER.isBoolean(val) ) throw { code: 'CAL_NO_VALUE', cal: 'value' };
			
			var checkDate = SFORMAT.checkingDate(val);
			if (checkDate) {
				// as google spreadsheet did, we need convert it day start with 1900
				return HELPER.convertDateToNum(checkDate);
			}
			
			val = HELPER.getValueFromMoneyData(val);

			var num = Number(val);
			if (!Ext.isNumber(num)) throw { code: 'CAL_NO_VALUE', cal: 'value' };
	
			return num;		
		},
		
		/*
		 * return the true value
		 */
		'TRUE' : function(){
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp, isheet = this.sheet, irow = this.row, icol = this.col;
			var len = arguments.length; 
			if(0 == len){
				return true;
			}else{
				throw { code: 'CAL_PARAM_MISS', cal: 'TRUE'};
			}
		},
		
		/*
		 * return the false value
		 */
		'FALSE' : function(){
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp, isheet = this.sheet, irow = this.row, icol = this.col;
			var len = arguments.length; 
			if(0 == len){
				return false;
			}else{
				throw { code: 'CAL_PARAM_MISS', cal: 'FALSE' };
			}
		},
		
		/*========================================================================================
		 * The following formulas are related to logical
		 *========================================================================================*/
		
		/*
		 * the IF function
		 * if the passed cond is true then return trueVal, or return falseVal
		 */
		'IF' : function(conditionRef, trueValRef, falseValRef){
			var me = this.me, calculates = me.calculates;
			
			// 2015 03 08 - also 2 parameter is ok
			var len = arguments.length;
			if(3 != len && 2 != len) throw { code: 'CAL_PARAM_MISS', cal: 'IF' };
			
            if(Ext.isFunction(conditionRef)){
                conditionRef = conditionRef.call(this);
            }
			// fixed the bug for judge formulas like: =if(and(1>1.2), "ok", "wrong")
			if (typeof conditionRef == 'string') {				
				if (conditionRef.toLowerCase() == "true") conditionRef = true;
				else if ( Ext.isNumber(Number(conditionRef)) ) {
				    if (Number(conditionRef) == 0) conditionRef = false;
				    else conditionRef = true;
				} else {
					// check whether it is date format ...
					var checkDate = SFORMAT.checkingDate(conditionRef);
					if(checkDate) conditionRef = true;
					else conditionRef = false;
				}			
			} else if ( Ext.isNumber(Number(conditionRef)) ) {
			    if (Number(conditionRef) == 0) conditionRef = false;
			    else conditionRef = true;
			}
			
		    // check whether it is ref ...
			if(me.isCoordObj(conditionRef)) conditionRef = calculates.valof.call(this, conditionRef);

			// if 2 parameter and falseValRef is empty ...
			if (!conditionRef && len == 2) return false;
			if (conditionRef == 0) conditionRef = false;

			if(conditionRef) {
				if(Ext.isFunction(trueValRef)) {
					trueValRef  = trueValRef.call(this);	
				}
				return trueValRef;
			} else {
				if(Ext.isFunction(falseValRef)) {
					falseValRef  = falseValRef.call(this);	
				}
				return falseValRef;
			}
		},
		
		/*
		 * Returns TRUE if all of its arguments are TRUE
		 */
		'AND' : function(){
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp, isheet = this.sheet, irow = this.row, icol = this.col;
			var len = arguments.length; 
			if(0 == len) throw {code: 'CAL_PARAM_MISS',cal: 'AND'};
			
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
					
			// check to see whether all are not number
		    var allArgsAreNotNumber = null;
			
			var arr = [];					
			me.each(this.sheet, this.row, this.col, arguments, function(obj, itemType, index, insideIndex, item){	
				var data;
				if('span' == itemType){
					var sheet = obj[0], row = obj[1], col = obj[2];
					if(Ext.isNumber(sheet)){
						var cell = me.getCellData(sheet, row, col, this);										
						data = cell.data;
					}				
				}else data = obj;
					
				if(Ext.isArray(data)) arr = arr.concat(data);
				else arr.push(data);
			}, this);
			
			for(var i = 0, len = arr.length; i < len; i++){
				var num = arr[i];
				
				// check whether it is Infinity ...
				if (num == "Infinity") throw { code: 'SS_ERROR_INFINITY', span: "AND" };
				
				if (null == num || num === undefined || num === "") {
					if (allArgsAreNotNumber == null) allArgsAreNotNumber = true;
				} else if (0 == num || "0" == num || 'false' == num || 'FALSE' == num) {
					return 'FALSE';
				} else if ('true' == num || 'TRUE' == num) {

				} else if (HELPER.isEmptyStr(num)) {
					if (allArgsAreNotNumber == null) allArgsAreNotNumber = true;
				} else if (Ext.isNumber(Number(num))) {
					allArgsAreNotNumber = false;
				} else {
					if (allArgsAreNotNumber == null) allArgsAreNotNumber = true;
				}
			}
			
			if (allArgsAreNotNumber && allArgsAreNotNumber == true) throw {code: 'CAL_NO_VALUE',cal: 'AND'};
			
			return true;
		},
		
		/*
		 * Returns TRUE if one of its arguments are TRUE
		 */
		'OR' : function(){		
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp, isheet = this.sheet, irow = this.row, icol = this.col;
			var len = arguments.length; 
			if(0 == len) throw {code: 'CAL_PARAM_MISS',cal: 'OR'};
			
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
								
			var arr = [];					
			me.each(this.sheet, this.row, this.col, arguments, function(obj, itemType, index, insideIndex, item){	
				var data;
				if('span' == itemType){
					var sheet = obj[0], row = obj[1], col = obj[2];
					if(Ext.isNumber(sheet)){
						var cell = me.getCellData(sheet, row, col, this);
										
						data = cell.data;
					}				
				}else data = obj;
				
				var str = data.toString().toUpperCase();
				if ('FALSE' == str) data = 'false';
			    else if ('TRUE' == str) data = 'true';
			    else {
			    	var num = Number(str);
					if (!Ext.isNumber(num)) throw {code: 'CAL_NO_VALUE',cal: 'OR'};
			    }
				
				if(Ext.isArray(data)) arr = arr.concat(data);
				else arr.push(data);
			}, this);
			
			for(var i = 0, len = arr.length; i < len; i++){
				if(arr[i] && 'false' !== arr[i] && 'FALSE' != arr[i] && 0 !== Number(arr[i])){
					return true;
				}
			}
			
			return false;
		},
		
		'NOT' : function(){
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp, isheet = this.sheet, irow = this.row, icol = this.col;
			var len = arguments.length; 
			if(1 != len) throw {code: 'CAL_PARAM_MISS',cal: 'NOT'};
			
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
            var num = arguments[0];
			if(me.isCoordObj(num)) num = calculates.valof.call(this, num);
			
			if (num == undefined || num == 'true' || num == 'false'
					|| !isNaN(num) || num == 'TRUE' || num == 'FALSE') {
				return (!num || 'false' == num || 0 == num || 'FALSE' == num) ? 'TRUE'
						: 'FALSE';
			} else
				throw {code: 'CAL_NO_VALUE',cal: 'NOT'};
			
		    return true;
		},
		
		
		/*
		 * Returns a value you specify if a formula evaluates to an error; otherwise, returns the result of the formula
		 */
		'iferror' : function(){
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp, isheet = this.sheet, irow = this.row, icol = this.col;
			var len = arguments.length; 
			if(2 != len) throw {code: 'CAL_PARAM_MISS',cal: 'IFERROR'};
				
			var expressFn = arguments[0], errVal = arguments[1];		
			var val, errFlag;
			if(Ext.isFunction(expressFn)){
				try{
					val = expressFn.call(this);
					if (val == 'Infinity' || val == '#NUM!' || val == '#N/A'  || val == '#PARAM!' || val == '#LOOP!' ||
					    val == '#DIV/0!' || val == '#VALUE!' || val == '#ERROR!' || val == '#REF!') {
                        errFlag = true;
					} 
				}catch(e){
                    errFlag = true;
				}
			}else{
				val = expressFn;
			}
            if(!errFlag){
                // check whether val is null or empty
                if (val === undefined || val === ""){
                    val = 0;
                }else if (val == 'Infinity' ) {
                    errFlag = true;
                }
            }
            if(errFlag){
                if(Ext.isFunction(errVal)){
                    errVal = errVal.call(this);
                }
                if(me.isCoordObj(errVal)){
                    var args = me.transferAll2Absolute([errVal], isheet, irow, icol);
                    var arg = args[0];
                    if(me.checkRangeMatch(args, 1, false, false)){
                        var span = arg.span;
                        if(span){
                            var cell = me.getCellData(span[0], span[1], span[2], this);
                            errVal = cell.data;
                        }
                    }else throw { code: 'CAL_NO_VALUE', cal: 'IFERROR' };
                }
                return errVal;
            }
			return val;
		},
		
		'ifna' : function(){
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp, isheet = this.sheet, irow = this.row, icol = this.col;
			var len = arguments.length; 
			if(2 != len) throw {code: 'CAL_PARAM_MISS',cal: 'IFNA'};
				
			var expressFn = arguments[0], errVal = arguments[1];
			
			var val;
			if(Ext.isFunction(expressFn)){
				try{
					val = expressFn.call(this); 
					if ( val == '#N/A') {
						expressFn = '#N/A';
					} 
				}catch(e){
					// ok - check exception ...
                    if (e.code && e.code == "VALUE_NOT_AVAILABLE"){
                        expressFn = '#N/A';
                    };
				}
			}else{
				val = expressFn;
			}
			
            if (expressFn == '#N/A'){
                if(Ext.isFunction(errVal)){
                    errVal = errVal.call(this);
                }
                if(me.isCoordObj(errVal)){
                    var args = me.transferAll2Absolute([errVal], isheet, irow, icol);
                    var arg = args[0];
                    if(me.checkRangeMatch(args, 1, false, false)){
                        var span = arg.span;
                        if(span){
                            var cell = me.getCellData(span[0], span[1], span[2], this);
                            errVal = cell.data;
                        }
                    }else throw { code: 'CAL_NO_VALUE', cal: 'IFNA' };
                }
                return errVal;
            };
	
			return val;
		},
		
		/*========================================================================================
		 * The following formulas are related to String / Text
		 *========================================================================================*/
		
		// this is for upper and lower case, len etc
		'upper' : function() {
			return this.me.stringCommon1(arguments, 'upper', this);
		},
		'lower' : function() {
			return this.me.stringCommon1(arguments, 'lower', this);
		},
		// PROPER function sets the first character in each word to uppercase and the rest to lowercase.
		'proper' : function() { 
			return this.me.stringCommon1(arguments, 'proper', this);
		},
		'len' : function() {
			return this.me.stringCommon1(arguments, 'len', this);
		},
		
	    // EXACT function compares two strings and returns TRUE if both values are the same. And it is case-sensitive.
		'exact' : function() {
			var len = arguments.length;
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp, isheet = this.sheet, irow = this.row, icol = this.col;
			var len = arguments.length; 
			if(2 != len) throw {code: 'CAL_PARAM_MISS', cal: 'exact'};
			
			var text1 = arguments[0];
			var text2 = arguments[1];
			if(me.isCoordObj(text1)) text1 = calculates.valof.call(this, text1);
			if(me.isCoordObj(text2)) text2 = calculates.valof.call(this, text2);
			
			if (text1 == text2)  return true;
			else return false;
		},		
		
		'trim': function(){
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp, isheet = this.sheet, irow = this.row, icol = this.col;
			var len = arguments.length; 
			if(1 != len) throw {code: 'CAL_PARAM_MISS', cal: 'trim'};
			
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var cell = arguments[0];
			if(me.isCoordObj(cell)) cell = calculates.valof.call(this, cell);
			
			cell = cell.toString();
			if (Ext.isDefined(cell) && '' !== cell) {
				return Ext.String.trim(cell);
			}
			if (cell == "") return "";

			throw {code: 'CAL_NO_VALUE', cal: 'trim' };
		},
		
		'code': function(){
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp, isheet = this.sheet, irow = this.row, icol = this.col;
			var len = arguments.length; 
			if(1 != len) throw {code: 'CAL_PARAM_MISS', cal: 'code'};
			
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var cell = arguments[0];
			if(me.isCoordObj(cell)) cell = calculates.valof.call(this, cell);
			
			cell = cell.toString();
			if (Ext.isDefined(cell) && '' !== cell) {
				return new String(cell.substr(0, 1)).charCodeAt(0);
			}

			throw {code: 'CAL_NO_VALUE', cal: 'code' };
		},
		
		/*
		 * Truncates a number to an integer
		 */
		'trunc' : function(){
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp, isheet = this.sheet, irow = this.row, icol = this.col;
			var len = arguments.length; 
			if(0 == len || len > 2) throw {code: 'CAL_PARAM_MISS', cal: 'TRUNC'};
			
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var digital = arguments[1];
			if(me.isCoordObj(digital)) digital = calculates.valof.call(this, digital);
			var posOffset = arguments[0];
			if(me.isCoordObj(posOffset)) posOffset = calculates.valof.call(this, posOffset);
			if (posOffset === undefined) return 0;
			
			// check whether it is boolean
		    if (HELPER.isBoolean(posOffset)) posOffset = HELPER.convertBoolean2Int(posOffset);
		    
		    if (!digital || digital == undefined) {
				digital = 0;
				posOffset += '';
				var nDx = posOffset.indexOf('.');
				if (nDx == 0) {
					return 0;
				} else if (nDx > 0) {
					posOffset = posOffset.substring(0, nDx);
				}
			}

			var num = Number(posOffset);
			digital = Number(digital);
			if (!Ext.isNumber(digital) || !Ext.isNumber(num) || HELPER.isEmptyStr(posOffset)) throw {code: 'CAL_NO_VALUE', cal: 'TRUNC' };
			else if (num == 0 || digital < 0) return 0;
			
			if (digital > 0) {
				var maxIdx = 10;// ms excel positive maxlength of 11;
				if (num < 0) maxIdx = 11; // ms excel negative maxlength of 12;
				num += '';
				var base = Math.floor(digital);
				var idx = num.indexOf('.');
				if (idx > -1) {
					var leg = num.length;
					if (idx >= maxIdx) {
						num = Math.round(num);
					} else {
						if ((leg - idx - 1) > base) {
							var a = '1';
							for ( var k = 0; k < base - 1; k++) {
								a += '0';
							}
	
							a = Number(a);
							num = num.substring(0, idx + base + 1);
							if ((maxIdx - 1) == idx) {
								num = parseFloat(Math.round(num * a)) / a;
							}
						} else {
							var a = '1';
							for ( var k = 0; k < maxIdx - idx; k++) {
								a += '0';
							}
							a = Number(a);
							num = num.substring(0, maxIdx + 2);
							num = parseFloat(Math.round(num * a)) / a;
						}
					}
				}
			}
			return num;
		},
		
		/*
		 * Returns the leftmost characters from a text value
		 */
		'left' : function(){
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp, isheet = this.sheet, irow = this.row, icol = this.col;
			var len = arguments.length; 
			if(1 != len && 2 != len) throw {code: 'CAL_PARAM_MISS', cal: 'LEFT'};
			
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var args = me.transferAll2Absolute(arguments, isheet, irow, icol);					
			if(me.checkRangeMatch(args, 1, false, false)){
				var arr = [];					
				me.each(isheet, irow, icol, args, function(obj, itemType, index, insideIndex, item){	
					var data;
					if('span' == itemType){
						var sheet = obj[0], row = obj[1], col = obj[2];
						if(Ext.isNumber(sheet)){
							var cell = me.getCellData(sheet, row, col, this);									
							data = cell.data;
						}				
					}else{					
						data = obj;
					}						
					arr.push(data);
				}, this);
				var alen = arr.length;
				if(1 == alen){
					var source = arr[0];
					if(SCOM.canbeNumber(source) || Ext.isString(source)){
						return source.toString().slice(0, 1);
					}
				}else if(2 == alen){
					var source = arr[0], strLen = Number(arr[1]);
					if((SCOM.canbeNumber(source) || Ext.isString(source)) && Ext.isNumber(strLen)){
						source = source.toString();
						return source.slice(0, strLen);
					}
				}
			}
			
			throw {code: 'CAL_NO_VALUE',cal: 'LEFT'};
		},
		
		/*
		 * Returns the rightmost characters from a text value
		 */
		'right' : function(){
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp, isheet = this.sheet, irow = this.row, icol = this.col;
			var len = arguments.length; 
			if(1 != len && 2 != len) throw {code: 'CAL_PARAM_MISS', cal: 'RIGHT'};
			
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var args = me.transferAll2Absolute(arguments, isheet, irow, icol);					
			if(me.checkRangeMatch(args, 1, false, false)){
				var arr = [];					
				me.each(isheet, irow, icol, args, function(obj, itemType, index, insideIndex, item){	
					var data;
					if('span' == itemType){
						var sheet = obj[0], row = obj[1], col = obj[2];
						if(Ext.isNumber(sheet)){
							var cell = me.getCellData(sheet, row, col, this);									
							data = cell.data;
						}				
					}else{					
						data = obj;
					}						
					arr.push(data);
				}, this);
				var alen = arr.length;
				if(1 == alen){
					var source = arr[0];
					if(SCOM.canbeNumber(source) || Ext.isString(source)){
						var source = source.toString();
						var strLen = source.length;
						return source.slice(strLen-1, strLen);
					}
				}else if(2 == alen){
					var source = arr[0], strPos = Number(arr[1]);
					if((SCOM.canbeNumber(source) || Ext.isString(source)) && Ext.isNumber(strPos)){
						source = source.toString();
						var strLen = source.length;
						var start = strLen-strPos;
						if(0 > start){
							start = 0;
						}
						return source.slice(start, strLen);
					}
				}
			}
		    throw {code: 'CAL_NO_VALUE',cal: 'RIGHT'};
		},
		
		/*
		 * Joins several text items into one text item
		 */
		'concatenate' : function(){
			if(0 == arguments.length) throw { code: 'CAL_PARAM_MISS', cal: 'concatenate' };

			var me = this.me;
			var store = this.store, timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
					
			var arr = [];					
			me.each(this.sheet, this.row, this.col, arguments, function(obj, itemType, index, insideIndex, item){	
				var data;
				if('span' == itemType){
					var sheet = obj[0], row = obj[1], col = obj[2];
					if(Ext.isNumber(sheet)){
						var cell = me.getCellData(sheet, row, col, this);
										
						data = cell.data;
					}				
				}else{
					/*
					 * if pass only 1 argument means it's a direct value
					 */
					data = obj;
				}						
				if(Ext.isArray(data)){
					arr = arr.concat(data);
				}else if(!Ext.isObject(data) && !SCOM.nullOrUndefined(data)){
					var str = data.toString();
					if(str){
						arr.push(str);
					}
				}
			}, this);
			return arr.join('');	
		},
		
		// Removes all nonprintable characters from text. 
		'clean' : function() {
			var len = arguments.length;
			if(len != 1) throw { code: 'CAL_PARAM_MISS', cal: 'CLEAN' };
			
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var val = arguments[0];
			if(me.isCoordObj(val)) val = calculates.valof.call(this, val);

			var result = [];
			if ('string' == SCOM.typeOf(val)) {
				for (var i = 0; i < val.length; i++) {
					var ch = val.charCodeAt(i);
					if ((0x0 <= ch && ch <= 0x1F) || (0x7F === ch) || (0x80 <= ch && ch <= 0x9F)) {
						// DO NOTHING 
					} else result.push(val[i]);
				}
				return result.join("");
			} else throw { code: 'CAL_NO_VALUE', cal: 'CLEAN' };
		},
		
		'fixed' : function() {
			var len = arguments.length;
			if(len < 2 || len > 3) throw { code: 'CAL_PARAM_MISS', cal: 'FIXED' };

			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
	
			var nocommas = false;
			if (len == 3)  nocommas = arguments[2];
	
			var num = calculates.numberof.call(this, arguments[0]);
			var decimals = calculates.numberof.call(this, arguments[1]);
			decimals = Math.floor(decimals);
	
			var str = [];
			num = Math.round(num * Math.pow(10, decimals)) / Math.pow(10, decimals);
			if (nocommas) {
				if (nocommas == 'true' || nocommas) nocommas = true;
				else nocommas = false;
			}
			
			var text = new String(num);
			if (!nocommas) {
				var idx = text.length - text.indexOf('.');
				for ( var i = text.length - 1; i >= 0; i--) {
					var s = text.substr(i, 1);
					str.unshift(s);
					var p1 = text.length - i;
					var p2 = text.length - i - idx;
					if ((p1) > idx && (p2 - idx) % 3 == 1 && i > 0) {
						str.unshift(',');
					}
				}
				return str.join('');
			} else {
				return text;
			}
		},
		
		// the CHAR function returns the character based on the ASCII value.
		'char' : function() {
			var len = arguments.length;
			if(1 != len) throw { code: 'CAL_PARAM_MISS', cal: 'CHAR' };

			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };

			var asc = calculates.numberof.call(this, arguments[0]);
			
			if (asc<1 || asc>255) throw {code: 'CAL_NO_VALUE', cal: 'CHAR' };			
			var chr = String.fromCharCode(asc);
			return chr;
		},
					
		// the DOLLAR function converts a number to text, using a currency format.
		// The format used is $#,##0.00_);($#,##0.00).
		'dollar' : function() {
			var len = arguments.length;
			if(1 > len || len > 2) throw { code: 'CAL_PARAM_MISS', cal: 'DOLLAR' };

			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var decimals = 2;
			if (len == 2) {
				decimals = arguments[1];
				if(me.isCoordObj(decimals)) decimals = calculates.numberof.call(this, decimals);
			}	
			
			var num = calculates.numberof.call(this, arguments[0]);
			
			decimals = Number(decimals);
			num = Number(num);
		    if (!Ext.isNumber(decimals) || !Ext.isNumber(num)) throw { code: 'CAL_NO_VALUE', cal: 'DOLLAR' };
		    
		    decimals = Math.floor(decimals);
		    // if decimal is > 0 then ...
			var format = "$0,000";
			if (decimals > 0) {
				format = format + ".";
				for ( var i = 0; i < decimals; i++) format = format + "0";
				return Ext.util.Format.number(num, format); 
			}
			
			// this is decimals < 0
			num = Math.round(num * Math.pow(10, decimals)) / Math.pow(10, decimals);
			return Ext.util.Format.number(num, format); 
		},
		
		// In Excel, the Text function returns a value converted to text with a
		// specified format.
		'text' : function() {
			var len = arguments.length;
			if(2 != len) throw { code: 'CAL_PARAM_MISS', cal: 'TEXT' };

			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var val = arguments[0], fm = arguments[1];
			if(me.isCoordObj(val)) val = calculates.valof.call(this, val);
			if(me.isCoordObj(fm)) fm = calculates.valof.call(this, fm);
			
			// check val is boolean or not
		    if (HELPER.isBoolean(val)) return HELPER.getBoolean(val);
		    
		    // there are different kind of things, we only handle simplest things in
			// here
			// See:
			// http://office.microsoft.com/en-us/excel-help/text-function-HP010062580.aspx
			// At this moment, we need follow:
			// Guidelines for number formats
			// Guidelines for date and time formats
			// Guidelines for currency, percentages, and scientific notation format
			// Guidelines for including text and adding spacing
			// need re-write the following item ...
			var num = Number(val);
			
			if (!Ext.isNumber(num)) {			
				var date = SFORMAT.checkingDate(val);
				if(date){
					fm = HELPER.replaceDateFm(fm);
					return Ext.Date.format(date, fm);
				} else return val;
			} else {
				if (fm.indexOf("yy") > -1 || fm.indexOf("dd") > -1 || fm.indexOf("m") > -1) {
				    var myDate = new Date(1900, 0, num-1);
				    fm = HELPER.replaceDateFm(fm);
					return Ext.Date.format(myDate, fm);
				}
				return HELPER.formatNumber(val, fm);
			}
	    },
	    
	    // the SUBSTITUTE function replaces a set of characters with another.
		// SUBSTITUTE( text, old_text, new_text, [nth_appearance] )
		'substitute' : function() {			
			var len = arguments.length;
			if(len > 4 || len < 3) throw { code: 'CAL_PARAM_MISS', cal: 'SUBSTITUTE' };

			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };

			var text = arguments[0];
			var old_text = arguments[1];
			var new_text = arguments[2];
			var instance_num = 0;
			if (len == 4) instance_num = calculates.numberof.call(this, arguments[3]);;
			
			if(me.isCoordObj(text)) text = calculates.valof.call(this, text);
			if(me.isCoordObj(old_text)) old_text = calculates.valof.call(this, old_text);
			if(me.isCoordObj(new_text)) new_text = calculates.valof.call(this, new_text);
			
			// if text is empty ... return empty
			if (Ext.isString(text)) {
				var temp = HELPER.strTrim(text);
				if (temp == "" || temp.length == 0) return "";
			}
			
			var str = '';
			if (instance_num == 0) str = text.replace(new RegExp(old_text, 'g'), new_text);
			else {
				var pos = 0;
				for ( var i = 0; i < instance_num; i++) {
					pos = text.indexOf(old_text, pos) + 1;
				}
				if (pos > 0) {
					pos--;
					str = text.substr(0, pos) + new_text + text.substr(pos + old_text.length, text.length);
				} else {
					str = text;
				}
			}
	
			return str;
		},
		
		/*========================================================================================
		 * The following formulas are related to financial
		 *========================================================================================*/
		/***************************************************************************
		 * Returns the periodic payment for an annuity with constant interest rates.
		 * Rate is the periodic interest rate. NPER is the number of periods in
		 * which annuity is paid. PV is the present value (cash value) in a sequence
		 * of payments. FV (optional) is the desired value (future value) to be
		 * reached at the end of the periodic payments. Type (optional) defines
		 * whether the payment is due at the beginning (1) or the end (0) of a
		 * period.
		 * 
		 * PMT(rate,nper,pv,fv,type)
		 **************************************************************************/
		'pmt' :  function(){
			var len = arguments.length;
			if(3 > len|| len > 5) throw { code: 'CAL_PARAM_MISS', cal: 'PMT' };

			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var fv = 0, type = 0;
			if (4 == len)  fv = arguments[3];
			else if (5 == len) {
				fv = arguments[3];
				type = arguments[4];
			}
			
			var rate = calculates.numberof.call(this, arguments[0]);
			var nper = calculates.numberof.call(this, arguments[1], true);
			var pv = calculates.numberof.call(this, arguments[2], true);
			fv = calculates.numberof.call(this, fv);
			type = calculates.numberof.call(this, type);
			
			rate = parseFloat(rate);
			if (rate == 0) rate = 0.000001; // this is special case ... do not know whether this will be problem ...
			
			nper = parseFloat(nper);
			pv = parseFloat(pv);
			type = parseFloat(type);
			fv = parseFloat(fv);
			var pmt1 = Math.round(pv * (rate * Math.pow((1 + rate), (nper - type)))
					/ (Math.pow((1 + rate), nper) - 1) * 100) / 100;
			var ir = 0;
			if (1 == type) {
				for ( var i = 1; i <= nper; i++) {
					ir = ir + Math.pow((rate + 1), i);
				}
			} else {
				ir = 1;
				for ( var i = 1; i < nper; i++) {
					ir = ir + Math.pow((rate + 1), i);
				}
			}
			var pmt2 = Math.round(fv / ir * 100) / 100;
			var result = -(pmt1 + pmt2);
	
			return Number(Ext.util.Format.number(result, '0.00'));
		},
		
		/**		 
		 * 
		 * ppmt (rate, per, Nper, Pv, Fv, Type) per: required the period and must be
		 * 1 to nper
		 */
		'ppmt' :  function(){
			var len = arguments.length;
			if(4 > len|| len > 6) throw { code: 'CAL_PARAM_MISS', cal: 'PPMT' };

			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var fv = 0, type = 0;
			if (5 == len) fv = arguments[4];
			if (6 == len) {
				fv = arguments[4];
				type = arguments[5];
			}
			
			var rate = calculates.numberof.call(this, arguments[0]);
			var per = calculates.numberof.call(this, arguments[1]);
			// check per value it must be in range 1 and nper ..
		    if (per < 1) throw { code: 'NUM_IS_NOT_RIGHT', cal: 'PPMT' };
			
			var nper = calculates.numberof.call(this, arguments[2]);
			var pv = calculates.numberof.call(this, arguments[3], true);
			fv = calculates.numberof.call(this, fv);
			type = calculates.numberof.call(this, type);
			
			rate = parseFloat(rate);
			if (rate == 0) rate = 0.000001; // this is special case ... do not know whether this will be problem ...
			
			nper = parseFloat(nper);
			per = parseFloat(per);
			pv = parseFloat(pv);
			type = parseFloat(type);
			fv = parseFloat(fv);
			pv = pv + fv;
			var ppmt = 0 - Math.round(pv * (rate * Math.pow((1 + rate), (per - 1 - type)))
					/ (Math.pow((1 + rate), nper) - 1) * 10000) / 10000;
	
			return Number(Ext.util.Format.number(ppmt, '0.00'));
		},
		
		// TODO, calculate result has a little bit different with Google Spreadsheet
		// However, it is the same result as Excel
		// =IPMT(6%/52, 30, 4*52, 8000, 0 ,1)
		'ipmt' : function() {
			var len = arguments.length;
			if(4 > len|| len > 6) throw { code: 'CAL_PARAM_MISS', cal: 'IPMT' };
			
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var rate = arguments[0], per = arguments[1], nper = arguments[2], pv = arguments[3], fv = 0, type = 0;
			if (5 == len) fv = arguments[4];
			if (6 == len) {
				fv = arguments[4];
				type = arguments[5];
			}
			
			rate = calculates.numberof.call(this, rate);
			per = calculates.numberof.call(this, per);
			nper = calculates.numberof.call(this, nper);
			pv = calculates.numberof.call(this, pv, true);
			fv = calculates.numberof.call(this, fv);
			type = calculates.numberof.call(this, type);
	
			rate = parseFloat(rate);
			nper = parseFloat(nper);
			per = parseFloat(per);
			pv = parseFloat(pv);
			type = parseFloat(type);
			fv = parseFloat(fv);
			pv = pv + fv;
			var ppmt = -Math.round(pv
					* (rate * Math.pow((1 + rate), (per - 1 - type)))
					/ (Math.pow((1 + rate), nper) - 1) * 100) / 100;
			var pmt1 = Math.round(pv * (rate * Math.pow((1 + rate), (nper - type)))
					/ (Math.pow((1 + rate), nper) - 1) * 100) / 100;
			var ir = 0;
			if (1 == type) {
				for ( var i = 1; i <= nper; i++) {
					ir = ir + Math.pow((rate + 1), i);
				}
			} else {
				ir = 1;
				for ( var i = 1; i < nper; i++) {
					ir = ir + Math.pow((rate + 1), i);
				}
			}
			var pmt2 = Math.round(fv / ir);
			var pmt = -(pmt1 + pmt2);
			var result = pmt - ppmt;	
			return Number(Ext.util.Format.number(result, '0.00'));
		},
		
		/**
		 * Returns the interest rate per period of an annuity. RATE is calculated by iteration and can have zero or more solutions. 
		 * If the successive results of RATE do not converge to within 0.0000001 after 20 iterations, RATE returns the #NUM! error value.
		 * RATE(nper, pmt, pv, [fv], [type], [guess])
		 */
		'rate' : function() {
			var len = arguments.length;
			if(3 > len|| len > 6) throw { code: 'CAL_PARAM_MISS', cal: 'RATE' };

			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var fv = 0, type = 0, guess = 0.1;
			if (4 == len) fv = arguments[3];
			if (5 == len) {
				fv = arguments[3];
				type = arguments[4];
			}
			if (6 == len) {
				fv = arguments[3];
				type = arguments[4];
				guess = arguments[5];
			}
			
			var nper = calculates.numberof.call(this, arguments[0], true);
			var pmt = calculates.numberof.call(this, arguments[1]);
			var pv = calculates.numberof.call(this, arguments[2], true);
			fv = calculates.numberof.call(this, fv);
			type = calculates.numberof.call(this, type);
			guess = calculates.numberof.call(this, guess);
	
			nper = parseFloat(nper) ? parseFloat(nper) : 0;
			pmt = parseFloat(pmt) ? parseFloat(pmt) : 0;
			pv = parseFloat(pv) ? parseFloat(pv) : 0;
			type = parseFloat(type) ? parseFloat(type) : 0;
			fv = parseFloat(fv) ? parseFloat(fv) : 0;
			guess = parseFloat(guess) ? parseFloat(guess) : 0.1; // default is 10%
			var maxrate = 0;
			var minrate = Math.abs(((pmt * nper + fv) + pv) / pv / nper);
			
			// check whether the pmt - payment is positive and pv > 0... if yes, throw exception
			if (pmt > 0 && pv > 0) throw { code: 'NUM_IS_NOT_RIGHT', cal: 'PMT' };
			if (pmt < 0 && pv < 0) throw { code: 'NUM_IS_NOT_RIGHT', cal: 'PMT' };
			if (Math.abs(minrate) > 1) throw { code: 'NUM_IS_NOT_RIGHT', cal: 'PMT' };
	
			if (Math.abs(pmt * nper + fv) < Math.abs(pv)) {
				maxrate = -Math.abs(minrate);
				minrate = -1;
			} else maxrate = 1;
			
			// Rate cycles through the calculation until the result is accurate to within 0.00001 percent. 
			var minRate = 0.0000001;
	
			var rate = maxrate;
			for ( var irup = 1; irup < 50; irup++) {
	
				var ir = 0;
				for ( var i = 1; i <= nper; i++) {
					ir = ir + pmt * Math.pow((rate + 1), i);
				}
	
				var trypv = -(ir / Math.pow((rate + 1), nper + 1 - type) + fv
						/ Math.pow((rate + 1), nper));
				if (pmt > 0) {
					if (trypv < pv) {
						minrate = rate;
						rate = (rate + maxrate) / 2;
						if (1 - Math.abs(rate) < minRate) throw { code: 'NUM_IS_NOT_RIGHT', cal: 'PMT' };
					} else if (trypv > pv) {
						maxrate = rate;
						rate = (rate + minrate) / 2;
						if (1 - Math.abs(rate) < minRate) throw { code: 'NUM_IS_NOT_RIGHT', cal: 'PMT' };
					} else if (trypv = pv) {
						return Math.round(rate * 10000000) / 10000000;
					}
				} else {
					if (trypv > pv) {
						minrate = rate;
						rate = (rate + maxrate) / 2;
						if (1 - Math.abs(rate) < minRate) throw { code: 'NUM_IS_NOT_RIGHT', cal: 'PMT' };
					} else if (trypv < pv) {
						maxrate = rate;
						rate = (rate + minrate) / 2;
						if (1 - Math.abs(rate) < minRate) throw { code: 'NUM_IS_NOT_RIGHT', cal: 'PMT' };
					} else if (trypv = pv) {
						return Math.round(rate * 10000000) / 10000000;
					}
				}
				irup++;
			}
			
			// do not return with % - otherwise =rate(..)*12 will not work ...
			var formatVal = Ext.util.Format.number(rate, "0.0000");
			return Number(formatVal);
		},
		
		// the MIRR function returns the modified internal rate of return for a
		// series of cash flows.
		// The internal rate of return is calculated by using both the cost of the
		// investment and the interest received by reinvesting the cash.
		// 
		// MIRR(values,finance_rate,reinvest_rate):
		//   Values must contain at least one positive value and one negative value to calculate the modified internal rate of return. Otherwise, MIRR returns the #DIV/0! error value.
		'mirr' : function() {
			var len = arguments.length;
			if(len != 3) throw { code: 'CAL_PARAM_MISS', cal: 'MIRR' };

			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
	
			var values = arguments[0];
			var frate = arguments[1];
			var rrate = arguments[2];
			var nums = [], positive = [], negative = [];
	
			if (Ext.isObject(values)) {
				nums = calculates.rangeNumsOf.call(this, [values]);
			} else if (Ext.isString(values)) {
				if (values.charAt(0) == '{' && values.charAt(values.length - 1) == '}') {
					var str = values.slice(1, values.length - 1);
					nums = str.split(',');
				} else
					throw { code: 'VALUE_NOT_AVAILABLE', cal: 'MIRR' };
			} else {
				throw { code: 'SS_ERROR_INFINITY', cal: 'MIRR' };
			}
	
			frate = calculates.numberof.call(this, frate);
			rrate = calculates.numberof.call(this, rrate);
	
			// set flag ... to check all number are positive or negative
			var totalNegativeNum = 0, totalPositiveNum = 0;
			for ( var ii = 0; ii < nums.length; ii++) {
				if (!Ext.isNumber(nums[ii]))
					throw { code: 'CAL_NO_VALUE', cal: 'MIRR' };
				if (nums[ii] < 0) {
					positive[positive.length] = 0;
					negative[negative.length] = nums[ii];
					totalNegativeNum = totalNegativeNum + 1;
				} else {
					negative[negative.length] = 0;
					positive[positive.length] = nums[ii];
					totalPositiveNum = totalPositiveNum + 1;
				}
			}
			
			// Values must contain at least one positive value and one negative value
			if (totalNegativeNum == 0 || totalPositiveNum == 0) {
				throw { code: 'SS_ERROR_INFINITY', cal: 'MIRR' };
			}
			
			frate = parseFloat(frate) ? parseFloat(frate) : 0;
			rrate = parseFloat(rrate) ? parseFloat(rrate) : 0;

			var fnpv = 0;
			for(var k = 0; k < negative.length; k++){			
				var val1 = negative[k]; 	
		        if(me.isCoordObj(val1)) val1 = calculates.valof.call(this, negative[k]);
				var num = Number(val1);
				if(Ext.isNumber(num)){
					fnpv =  fnpv + (num/(Math.pow((1+frate),k+1)));
				}
			}
			
			var rnpv = 0;
			for(var k = 0; k < positive.length; k++){			
				var val1 = positive[k]; 	
		        if(me.isCoordObj(val1)) val1 = calculates.valof.call(this, positive[k]);
				var num = Number(val1);
				if(Ext.isNumber(num)){
					rnpv =  rnpv + (num/(Math.pow((1+rrate),k+1)));
				}
			}
			var mirr = Math.pow(-rnpv * Math.pow((1 + rrate), nums.length) / (fnpv * (1 + frate)), (1 / (nums.length - 1))) - 1;
	
			return Number(Ext.util.Format.number(mirr, "0.0000"));
		},
		
		// the IRR function returns the internal rate of return for a series of cash
		// flows.
		// The cash flows must occur at regular intervals,
		// but do not have to be the same amounts for each interval.
		// In most cases you do not need to provide guess for the IRR calculation.
		// If guess is omitted, it is assumed to be 0.1 (10 percent).
		// Excel tries to recalculate the IRR until the result is accurate within
		// 0.00001 percent. If after 20 tries Excel has not calculated an accurate
		// value, it will return the #NUM! error.
		// =IRR(A1:A5)
		'irr' : function() {
			var len = arguments.length;
			if(len > 2) throw { code: 'CAL_PARAM_MISS', cal: 'IRR' };

			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var values = arguments[0], guess = 0.1, nums = [];
			var MAX_LOOP = 55;
	
			if (2 == len) guess = calculates.numberof.call(this, arguments[1]);
			
			if (Ext.isObject(values)) {
				// this function get a list of nums ...
				nums = calculates.rangeNumsOf.call(this, [values]);
			} else if (Ext.isNumber(values))  throw { code: 'NUM_IS_NOT_RIGHT', cal: 'IRR' };
			else if (Ext.isString(values)) {
				if (values.charAt(0) == '{' && values.charAt(values.length - 1) == '}') {
					var str = values.slice(1, values.length - 1);
					nums = str.split(',');
				} else throw { code: 'VALUE_NOT_AVAILABLE', cal: 'IRR' };
			} 
			
			// check whether it is boolean
			if (HELPER.isBoolean(guess)) throw { code: 'VALUE_NOT_AVAILABLE', cal: 'IRR' };
			if (HELPER.isBoolean(values)) throw { code: 'CAL_NO_VALUE', cal: 'IRR' };
			
			var fsum = 0, zsum = 0;
			for ( var ii = 0; ii < nums.length; ii++) {
				if (!Ext.isNumber(nums[ii])) throw { code: 'CAL_NO_VALUE', cal: 'IRR' };
				nums[ii] = parseFloat(nums[ii]);
				if (nums[ii] < 0)
					fsum = fsum + nums[ii];
				else
					zsum = zsum + nums[ii];
			}
			guess = parseFloat(guess);
	
			var irr = guess, lawirr = 0, maxirr = 0, b = false, ir = 0, lastir = 0, testirr = 0;
			for ( var i = 0; i < nums.length; i++) {
				if (nums[i] != 0) ir = ir + nums[i] / Math.pow((irr + 1), i);
			}
			
			if (ir == 0) {
				return Math.round(irr * 10000000) / 10000000;
			} else if (ir < 0) {
				lastir = ir;
				ir = 0;
				testirr = irr - guess;
				for ( var i = 0; i < nums.length; i++) {
					if (nums[i] != 0) ir = ir + nums[i] / Math.pow((testirr + 1), i);
				}
				if (ir < lastir) b = true;
	
				var count = 0;
				do {
					ir = 0;
					if (b) {
						lawirr = irr;
						irr = irr + guess;
					} else {
						maxirr = irr;
						irr = irr - guess;
					}
					
					for ( var i = 0; i < nums.length; i++) {
						if (nums[i] != 0) ir = ir + nums[i] / Math.pow((irr + 1), i);
					}
					
					// if it is more than 20 time calculate, throw Error
					if (count > MAX_LOOP) throw { code: 'NUM_IS_NOT_RIGHT', cal: 'IRR' };					
					count++;
					
				} while (ir < 0);
				
				if (b) maxirr = irr;
				else  lawirr = irr;
				
			} else if (ir > 0) {
				lastir = ir;
				ir = 0;
				testirr = irr + guess;
				for ( var i = 0; i < nums.length; i++) {
					if (nums[i] != 0) ir = ir + nums[i] / Math.pow((testirr + 1), i);
				}
				if (ir > lastir) b = true;
	 
				var count = 0;
				do {
					ir = 0;
					if (b) {
						maxirr = irr;
						irr = irr - guess;
					} else {
						lawirr = irr;
						irr = irr + guess;
					}
					for ( var i = 0; i < nums.length; i++) {
						if (nums[i] != 0) ir = ir + nums[i] / Math.pow((irr + 1), i);
					}
					// if it is more than 20 time calculate, throw Error
					if (count > MAX_LOOP) throw { code: 'NUM_IS_NOT_RIGHT', cal: 'IRR' };					
					count++;
					
				} while (ir > 0);
				
				if (b) {
					lawirr = irr;
				} else {
					maxirr = irr;
				}
			}
			
			irr = lawirr;
			for ( var irup = 1; irup < 50; irup++) {
				var ir = 0;
				for ( var i = 0; i < nums.length; i++) {
					ir = ir + nums[i] / Math.pow((irr + 1), i);
				}
				if (ir == 0) {
					return Math.round(irr * 10000000) / 10000000;
				}
				if (b) {
					if (ir < 0) {
						lawirr = irr;
						irr = (maxirr + irr) / 2;
					} else {
						maxirr = irr;
						irr = (irr + lawirr) / 2;
					}
	
				} else {
					if (ir < 0) {
						maxirr = irr;
						irr = (irr + lawirr) / 2;
					} else {
						lawirr = irr;
						irr = (maxirr + irr) / 2;
					}
				}
				irup++;
			}
	
			return Number(Ext.util.Format.number(irr, '0.0000'));
		},
		
		
		// In Excel, the NPER function returns the number of periods for an
		// investment based on an interest rate and a constant payment schedule.
		// NPer(rate, pmt, pv [, fv ] [, type ] )
		'nper' : function() {
			var len = arguments.length;
			if(3 > len|| len > 5) throw { code: 'CAL_PARAM_MISS', cal: 'NPER' };

			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var rate = arguments[0], pmt = arguments[1], pv = arguments[2], fv = 0, type = 0;
			if (4 == len) {
				fv = arguments[3];
				if(me.isCoordObj(fv)) fv = calculates.numberof.call(this, fv);
				if (fv === undefined || HELPER.isEmptyStr(fv)) fv = 0;			
				fv = parseFloat(fv) ? parseFloat(fv) : 0;
			} else if (5 == len) {
				fv = arguments[3];
				if(me.isCoordObj(fv)) fv = calculates.numberof.call(this, fv);
				if (fv === undefined || HELPER.isEmptyStr(fv)) fv = 0;	
				
				type = arguments[4];
				if(me.isCoordObj(type)) type = calculates.numberof.call(this, type);
				if (type === undefined || HELPER.isEmptyStr(type)) type = 0;	
				
				fv = parseFloat(fv) ? parseFloat(fv) : 0;
				type = parseFloat(type) ? parseFloat(type) : 0;
			}
			
			if(me.isCoordObj(rate)) rate = calculates.numberof.call(this, rate, true);
			if(me.isCoordObj(pmt)) pmt = calculates.numberof.call(this, pmt);
			if(me.isCoordObj(pv)) pv = calculates.numberof.call(this, pv, true);
	
			rate = parseFloat(rate) ? parseFloat(rate) : 0.0001; // rate can not be zero ... make it really small
			pmt = parseFloat(pmt) ? parseFloat(pmt) : 0;
			
			// add one more condition
			if (HELPER.isBoolean(pv)) pv = HELPER.convertBoolean2Int(pv);
			pv = parseFloat(pv) ? parseFloat(pv) : 0;
	
			var minnper = (-fv - pv) / pmt;
			minnper = (-fv / Math.pow((1 + rate), (minnper - type)) - pv) / pmt;
			var maxnper = (-fv - (pv * Math.pow((1 + rate), (minnper - type)))) / pmt;
	
			var nper = maxnper;
			for ( var irup = 1; irup < 50; irup++) {			
				var calpmt = (-fv / Math.pow((1 + rate), nper) - pv)
						* (rate * Math.pow((1 + rate), (nper - type)))
						/ (Math.pow((1 + rate), nper) - 1);	
				if (calpmt == pmt) return Math.round(calpmt * 10000000) / 10000000;
				else {
					if (nper < 0) {
						if (Math.abs(calpmt) < Math.abs(pmt)) {
							minnper = nper;
							nper = (maxnper + nper) / 2;
						} else {
							maxnper = nper;
							nper = (nper + minnper) / 2;
						}
					} else {
						if (Math.abs(calpmt) < Math.abs(pmt)) {
							maxnper = nper;
							nper = (nper + minnper) / 2;
						} else {
							minnper = nper;
							nper = (maxnper + nper) / 2;
						}
					}
					if (maxnper == minnper)
						throw { code: 'NUM_IS_NOT_RIGHT', cal: 'NPER' };
				}
				irup++;
			}
	
			return Math.round(nper * 10000000) / 10000000;
		},
		
		// Returns the present value of an investment.
		// The present value is the total amount that a series of future payments is
		// worth now.
		// For example, when you borrow money, the loan amount is the present value
		// to the lender.
		// PV( interest_rate, number_payments, payment, [FV], [Type] )
		'pv' : function() {
			var len = arguments.length;
			if(3 > len|| len > 5) throw { code: 'CAL_PARAM_MISS', cal: 'PV' };

			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
	
			var fv = 0, type = 0;
			var rate = calculates.numberof.call(this, arguments[0], true);
			var nper = calculates.numberof.call(this, arguments[1], true);
			var payment = calculates.numberof.call(this, arguments[2], true);
			
			if (4 == len) {
				fv = arguments[3];
				if (fv === undefined || HELPER.isEmptyStr(fv)) fv = 0;
			} else if (5 == len) {
				fv = arguments[3];
				if (fv === undefined || HELPER.isEmptyStr(fv)) fv = 0;
				type = arguments[4];
				if (type === undefined || HELPER.isEmptyStr(type)) type = 0;
			}

			fv = calculates.numberof.call(this, fv);
			type = calculates.numberof.call(this, type);
	
			rate = parseFloat(rate);
			nper = parseFloat(nper);
			payment = parseFloat(payment);
			type = parseFloat(type);
			fv = parseFloat(fv);
	
			var ir = 0;
			// handle special case if nper is less than 1 .... something wrong in here ...
			if (nper < 1) throw { code: 'NUM_IS_NOT_RIGHT', cal: 'PV' }; // at least one time ...
			
			for ( var i = 1; i <= nper; i++) {
				ir = ir + payment * Math.pow((rate + 1), i);
			}
	
			var pv = -(ir / Math.pow((rate + 1), nper + 1 - type) + fv / Math.pow((rate + 1), nper));	
			if (isNaN(pv) || pv > 99999999999999999999) throw { code: 'SS_ERROR_INFINITY', cal: 'PV' };
			return Number(Ext.util.Format.number(pv, '0.00'));
		},		
		
		// In Excel, the NPV function returns the net present value of an
		// investment.
		// NPV( discount_rate, value1, [value2, ... value_n] )
		// we need handle format like:
		// NPV(rate, [array])
		'npv' : function() {			
			var len = arguments.length;
			if(2 > len) throw { code: 'CAL_PARAM_MISS', cal: 'NPV' };

			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };		
	
			var npv = 0; // get all the count of number ...
			var rate = arguments[0];
			if(me.isCoordObj(rate)) rate = calculates.valof.call(this, rate);
			
			// check whether it is boolean
			if (HELPER.isBoolean(rate)) rate = HELPER.convertBoolean2Int(rate);
			
			var rate = Number(rate);
			if (!Ext.isNumber(rate)) throw { code: 'CAL_NO_VALUE', cal: 'NPV' };

			var total = 1, coord = [];
			for ( var k = 1; k < len; k++) {
				coord.push(arguments[k]);
			}
			
			var rangeObjs = calculates.rangeNumsOf.call(this, coord);
			for(var i = 0, len = rangeObjs.length; i < len; i++){
				var data = rangeObjs[i];
				if (HELPER.isBoolean(data)) data = HELPER.convertBoolean2Int(data);				
				npv = npv + (data / (Math.pow((1 + rate), total)));
				total = total + 1;
			}
	
			return Number(Ext.util.Format.number(npv, '0.00'));
	    },
	    
	    // the FV function returns the future value of an investment based on an
		// interest rate and a constant payment schedule.
		// FV( interest_rate, number_payments, payment, [PV], [Type] )
		'fv' : function() {
			var len = arguments.length;
			if(3 > len|| len > 5) throw { code: 'CAL_PARAM_MISS', cal: 'FV' };

			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var rate = arguments[0], nper = arguments[1], payment = arguments[2], pv = 0, type = 0;
			if (4 == len) {
				pv = arguments[3];
				if (pv === undefined || HELPER.isEmptyStr(pv)) pv = 0;
			}
			if (5 == len) {
				pv = arguments[3];
				if (pv === undefined || HELPER.isEmptyStr(pv)) pv = 0;
				type = arguments[4];
				if (type === undefined || HELPER.isEmptyStr(type)) type = 0;
			}
			
			if(me.isCoordObj(nper)) nper = calculates.numberof.call(this, nper, true);
			if(me.isCoordObj(rate)) rate = calculates.numberof.call(this, rate);
			if(me.isCoordObj(pv)) pv = calculates.numberof.call(this, pv, true);
			if(me.isCoordObj(payment)) payment = calculates.numberof.call(this, payment);
			if(me.isCoordObj(type)) type = calculates.numberof.call(this, type);
	
			rate = parseFloat(rate);
			nper = parseFloat(nper);
			payment = parseFloat(payment);
			type = parseFloat(type);
			pv = parseFloat(pv);
			var ir = 0;
			for ( var i = 1; i <= nper; i++) {
				ir = ir + payment * Math.pow((rate + 1), i - 1 + type);
			}
			var fv = -(ir + pv * Math.pow((rate + 1), nper));	
			return Number(Ext.util.Format.number(fv, '0.00'));
		},
		
		// the SYD function returns the depreciation of an asset for a given time
		// period based on the sum-of-years'
		// digits depreciation method.
		// All arguments must in positive number ....
		'syd' : function() {
			var len = arguments.length;
			if(4 != len) throw { code: 'CAL_PARAM_MISS', cal: 'SYD' };

			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var cost = arguments[0], salvage = arguments[1], life = arguments[2], per = arguments[3];		
			if(me.isCoordObj(cost)) cost = calculates.numberof.call(this, cost);
			if(me.isCoordObj(salvage)) salvage = calculates.numberof.call(this, salvage);
			if(me.isCoordObj(life)) life = calculates.numberof.call(this, life);
			if(me.isCoordObj(per)) per = calculates.numberof.call(this, per);
			
			if (per > life || per <= 0 || life <= 0) throw { code: 'NUM_IS_NOT_RIGHT', cal: 'SYD' };
		    var syd = ((cost - salvage) * (life - per + 1) * 2) / (life * (life + 1));
		    return Number(Ext.util.Format.number(syd, '0.00'));
		},
		
		// SLN function returns the depreciation of an asset for a period based on
		// the straight-line depreciation method.
		'sln' : function() {
			var len = arguments.length;
			if(3 != len) throw { code: 'CAL_PARAM_MISS', cal: 'SLN' };
			
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
	
			var cost = arguments[0], salvage = arguments[1], life = arguments[2];
			if(me.isCoordObj(cost)) cost = calculates.numberof.call(this, cost);
			if(me.isCoordObj(salvage)) salvage = calculates.numberof.call(this, salvage);
			if(me.isCoordObj(life)) life = calculates.numberof.call(this, life);
	
			if (life == 0) throw { code: 'SS_ERROR_INFINITY', cal: 'SLN' };
	
			var sln = (cost - salvage) / life;
			return Number(Ext.util.Format.number(sln, '0.00'));
		},
		
		// the DB function returns the depreciation of an asset for a given time
		// period based on the fixed-declining balance method.
		// =DB(10000, 5000, 5, 1, 12)
		'db' : function() {
			var len = arguments.length;
			if(4 > len || 5 < len) throw { code: 'CAL_PARAM_MISS', cal: 'DB' };
			
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
	
			var cost, salvage, life, period, month;
			cost = arguments[0];
			salvage = arguments[1];
			life = arguments[2];
			period = arguments[3];
			if (4 == len) month = 12;
			if (5 == len) month = arguments[4];
	
			if(me.isCoordObj(cost)) cost = calculates.numberof.call(this, cost);
			if(me.isCoordObj(salvage)) salvage = calculates.numberof.call(this, salvage);
			if(me.isCoordObj(life)) life = calculates.numberof.call(this, life);
			if(me.isCoordObj(period)) period = calculates.numberof.call(this, coperiodst);
			if(me.isCoordObj(month)) month = calculates.numberof.call(this, month);
	
			var rate = Math.round((1 - Math.pow((salvage / cost), (1 / life))) * 1000) / 1000;
			var persum = 0, db = 0;
			for ( var i = 1; i <= period; i++) {
				if (i == 1) {
					db = persum = cost * rate * month / 12;
				} else if (i == life) {
					db = ((cost - persum) * rate * (12 - month)) / 12;
				} else {
					db = (cost - persum) * rate;
					persum = persum + db;
				}
			}
	
			return Number(Ext.util.Format.number(db, '0.00'));
		},	

		// the DDB function returns the depreciation of an asset for a given time
	    // period based on the double-declining balance method.
		// DDB(cost,salvage,life,period,factor)
		'ddb' : function() {
			var len = arguments.length;
			if(4 > len || 5 < len) throw { code: 'CAL_PARAM_MISS', cal: 'DDB' };
			
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var cost = calculates.numberof.call(this, arguments[0]);
			var salvage = calculates.numberof.call(this, arguments[1]);
			var life = calculates.numberof.call(this, arguments[2]);
			var period = calculates.numberof.call(this, arguments[3]);
			
			// check some condition 
			if (cost < 0 || salvage < 0 || life < 0 || period < 0 ) {
				throw { code: 'NUM_IS_NOT_RIGHT', cal: 'DDB' };
			}

			var factor = 2;
			if (5 == len) factor = calculates.numberof.call(this,  arguments[4]);

			var persum = 0, db = 0;
			for ( var i = 1; i <= period; i++) {
				db = Math.min((cost - persum) * factor / life, cost - salvage - persum);
				persum = persum + db;
			}
	
			return Number(Ext.util.Format.number(db, '0.00'));
		},
		
		// Returns the depreciation of an asset for any period you specify, including partial periods, using the double-declining balance method or some other method you specify. VDB stands for variable declining balance.
		// VDB(cost, salvage, life, startDate, endDate, [factor], [no_switch])
		'vdb' : function() {
			var len = arguments.length;
			if(5 > len || 7 < len) throw { code: 'CAL_PARAM_MISS', cal: 'VDB' };
			
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var cost = calculates.numberof.call(this, arguments[0]);
			var salvage = calculates.numberof.call(this, arguments[1]);
			var life = calculates.numberof.call(this, arguments[2]);
			var startDate = calculates.numberof.call(this, arguments[3]);
			var endDate = calculates.numberof.call(this, arguments[4]);
			var vdbResult = 0;
			
			// check some condition 
			if (cost < 0 || salvage < 0 || life < 0 || startDate < 0 || endDate < 0 || endDate < startDate) {
				throw { code: 'NUM_IS_NOT_RIGHT', cal: 'VDB' };
			}
			
			if (cost < salvage && startDate === 0 && endDate === 1) {
                return cost - salvage;
            }

			var factor = 2;
			if (5 < len) factor = calculates.numberof.call(this, arguments[5]);
			var no_switch = false;
			if (7 == len) {
				no_switch = arguments[6];
		    	if(me.isCoordObj(no_switch)) no_switch = calculates.valof.call(this, no_switch);	    	
		    	if (HELPER.isBoolean(no_switch)) no_switch = HELPER.getBoolean(no_switch);
		    	else throw { code: 'CAL_NO_VALUE', cal: 'VDB' };
			}

			var startP = Math.floor(startDate), endP = Math.ceil(endDate);
			if (no_switch) {
				for (var i=startP+1; i<=endP; i++) {
					var vdbTerm = HELPER.getGDA(cost, salvage, life, i, factor);
                    if (i === startP + 1)  vdbTerm *= (Math.min(endDate, startP + 1) - startDate);
                    else if (i === endP) vdbTerm *= (endDate + 1 - endP);
                    vdbResult += vdbTerm;
				}
			} else {
				var life1 = life;
                var fPart;
				if (startDate != Math.floor(startDate)) {
					if (factor > 1 && startDate >= life / 2){
                        fPart = startDate - life / 2;
                        startDate = life / 2;
                        endDate -= fPart;
                        life1 += 1;
                    }
				}
				cost -= HELPER.getVDB(cost, salvage, life, life1, startDate, factor);
                vdbResult = HELPER.getVDB(cost, salvage, life, life - startDate, endDate - startDate, factor);
			}
	
			return Number(Ext.util.Format.number(vdbResult, '0.00'));
		},
		
		// Returns the effective annual interest rate, given the nominal annual interest rate and the number of 
		// compounding periods per year.
		// EFFECT(nominal_rate, npery)
		'effect' : function() {
			var len = arguments.length;
			if(2 != len) throw { code: 'CAL_PARAM_MISS', cal: 'EFFECT' };
			
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };

			var rate = calculates.numberof.call(this, arguments[0], true);
			var nper = calculates.numberof.call(this, arguments[1]);
			
			if (rate <= 0 || nper < 1)  throw { code: 'NUM_IS_NOT_RIGHT', cal: 'EFFECT' };
			
			return Math.pow((1.0 + rate / nper), nper) - 1.0;
		},
		
		'dollarfr' : function() {
			var len = arguments.length;
			if(2 != len) throw { code: 'CAL_PARAM_MISS', cal: 'dollarfr' };
			
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
	
			var decimal_dollar = arguments[0], fraction = arguments[1];
			if(me.isCoordObj(decimal_dollar)) decimal_dollar = calculates.numberof.call(this, decimal_dollar);
			if(me.isCoordObj(fraction)) fraction = calculates.numberof.call(this, fraction);
	
			fraction = Math.floor(fraction);
			if (fraction < 0) throw { code: 'NUM_IS_NOT_RIGHT', cal: 'dollarfr' };
			else if (fraction == 0) throw { code: 'SS_ERROR_INFINITY', cal: 'dollarfr' };
			
			return HELPER.convert2DollarFraction(decimal_dollar, fraction);
		},
		
		'dollarde' : function() {
			var len = arguments.length;
			if(2 != len) throw { code: 'CAL_PARAM_MISS', cal: 'dollarde' };
			
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
	
			var fraction_dollar = arguments[0], fraction = arguments[1];
			if(me.isCoordObj(fraction_dollar)) fraction_dollar = calculates.numberof.call(this, fraction_dollar);
			if(me.isCoordObj(fraction)) fraction = calculates.numberof.call(this, fraction);
	
			fraction = Math.floor(fraction);
			if (fraction < 0) throw { code: 'NUM_IS_NOT_RIGHT', cal: 'dollarde' };
			else if (fraction < 1) throw { code: 'SS_ERROR_INFINITY', cal: 'dollarde' };
			
			return HELPER.convert2DollarInt(fraction_dollar, fraction);
		},
		
		'couppcd' : function() {
			return this.me.coupCommonFn(arguments, 'couppcd', this);		
		},
		
		'coupncd' : function() {
			return this.me.coupCommonFn(arguments, 'coupncd', this);		
		},
		
		'coupnum' : function() {
			return this.me.coupCommonFn(arguments, 'coupnum', this);		
		},
		
		'coupdays' : function() {
			return this.me.coupCommonFn(arguments, 'coupdays', this);		
		},
		
		'coupdaysnc' : function() {
			return this.me.coupCommonFn(arguments, 'coupdaysnc', this);		
		},
		
		/*========================================================================================
		 * The following formulas are related to Lookup and Reference
		 *========================================================================================*/
		
		/*
		 * Returns the number of columns in a reference
		 */
		'columns' : function(){
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp, isheet = this.sheet, irow = this.row, icol = this.col;
			var len = arguments.length; 	
			if(0 == len) throw {code: 'CAL_PARAM_MISS',cal: 'columns'};
				
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
								
			if(me.isCoordObj(arguments[0])){
				var args = me.transferAll2Absolute(arguments, isheet, irow, icol);
				var arg = args[0];							
				var span = arg.span;
				if(span){
					return span[4]-span[2]+1;
				}					
			} else {
				// check whether it is boolean
				if (HELPER.isBoolean(arguments[0])) throw { code: 'CAL_NO_VALUE', cal: 'columns' };
				if (Ext.isNumber(Number(arguments[0]))) return 1;
			}

			throw {code: 'CAL_NO_VALUE',cal: 'columns'};
		},
		
		/*
		 * Returns the number of rows in a reference
		 */
		'rows' : function(){
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp, isheet = this.sheet, irow = this.row, icol = this.col;
			var len = arguments.length; 
			if(0 == len) throw {code: 'CAL_PARAM_MISS',cal: 'ROWS'};
				
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			// check whether it is array ...
			if (len > 1) {
				// check to see whether it is array - if yes return length - like this: =rows({1,2;3,4})
				var result = 0;
				for ( var k = 0; k < len; k++) {
					if (Ext.isArray(arguments[k])) result = result + 1;
					else throw {code: 'CAL_NO_VALUE',cal: 'ROWS'};
				}
				return result;
			}
			
			if(me.isCoordObj(arguments[0])){
				var args = me.transferAll2Absolute(arguments, isheet, irow, icol);
				var arg = args[0];							
				var span = arg.span;
				if(span){
					return span[3]-span[1]+1;
				}					
			} else {
				// check whether it is boolean
				if (HELPER.isBoolean(arguments[0])) throw { code: 'CAL_NO_VALUE', cal: 'rows' };
				if (Ext.isNumber(Number(arguments[0]))) return 1;
			}
			throw {code: 'CAL_NO_VALUE',cal: 'ROWS'};
		},
		
		/*
		 * Returns the number of areas in a reference
		 */
		'areas' : function(){
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp, isheet = this.sheet, irow = this.row, icol = this.col;
			var len = arguments.length; 
			if(1 > len) throw { code: 'CAL_PARAM_MISS', cal: 'areas' };
			
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result};
			var count = 0;
			
			var counting = function(args){
				for(var i = 0, size = args.length; i < size; i++){
					var arg = args[i];
					if(me.isCoordObj(arg)) count++;							
					else if(Ext.isArray(arg)) counting(arg);
				}
			};			
			counting(arguments);
			
			return count;
		},
		
		
		/*
		 * Looks up values in a vector or array.
		 * If the LOOKUP function can't find the lookup_value, the function matches the largest value in lookup_vector that is less than or equal to lookup_value.
		 * work now: =LOOKUP("C", {"a","b","c","d";1,2,3,4})
		 */
		'lookup' : function(){	
			
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp, isheet = this.sheet, irow = this.row, icol = this.col;
			var len = arguments.length;
			if(len < 2 && len > 3) throw { code: 'CAL_PARAM_MISS', cal: 'lookup' };
			
			// this is for paramter 1 - lookup_value
		    var lookup_value = arguments[0];
		    if(me.isCoordObj(lookup_value)) lookup_value = calculates.valof.call(this, lookup_value);
		    if (Ext.isString(lookup_value)) lookup_value = lookup_value.toLowerCase();
		    
		    // this is for paramter 2 - rangeArray
			var rangeArray = arguments[1];
			if (Ext.isObject(rangeArray)) {
				rangeArray = calculates.rangeObjsOf.call(this, [rangeArray]);
			} 
			if (rangeArray == null || rangeArray.length == 0)  throw { code: 'CAL_NO_VALUE', cal: 'lookup' };
			
			var resultArray = rangeArray;
			if (len == 3) {
				if (Ext.isObject(arguments[2])) {
					resultArray = calculates.rangeObjsOf.call(this, [arguments[2]]);
				} else resultArray = arguments[2];
				if (resultArray == null || resultArray.length == 0)  throw { code: 'CAL_NO_VALUE', cal: 'lookup' };
			}
			
			// check 2 array size are same or not ...
			if (rangeArray.length != resultArray.length) throw { code: 'CAL_NO_VALUE', cal: 'lookup' };
	
			for (var k=rangeArray.length; k>0; k--) {
			    var tempVal = rangeArray[k-1]; 
			    if (tempVal != null && tempVal != undefined) {
			    	if (HELPER.isNumber(tempVal)) tempVal = Number(tempVal);
			    	else tempVal = tempVal.toLowerCase();
			    } else continue;
			    
			    if (HELPER.isNumber(lookup_value)) {
			    	if (tempVal <= lookup_value) return resultArray[k-1]; 
			    } else if (Ext.isString(lookup_value)) {
			    	if (tempVal.localeCompare(lookup_value) <= 0) return resultArray[k-1];
			    }			    
			}
			
			throw { code: 'VALUE_NOT_AVAILABLE', cal: 'lookup' };
		},
		
		/*
		 * choose a item from a list
		 */
		'choose' : function(){			
			var me = this.me, calculates = me.calculates;
			var len = arguments.length; 
			if(2 > len) throw { code: 'CAL_PARAM_MISS', cal: 'choose' };
			
			var indexPos = calculates.numberof.call(this, arguments[0]);
			
			if (0 < indexPos && indexPos < len) {
				// convert to integer if it is not
				indexPos = Math.floor(indexPos);
				var result = arguments[indexPos];			
				if(me.isCoordObj(result)) result = calculates.valof.call(this, result);
				return result;
			} else
				throw { code: 'CAL_NO_VALUE', cal: 'choose' };
		},
		
		/*
		 * return the column index
		 */
		'column' : function(){
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp, isheet = this.sheet, irow = this.row, icol = this.col;
			var len = arguments.length; 
			
			if (len == 0) return icol;
			if (1 < len) throw {code: 'CAL_PARAM_MISS',cal: 'COLUMN'};
			
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
					
			if(me.isCoordObj(arguments[0])){
				var args = me.transferAll2Absolute(arguments, isheet, irow, icol);
				var arg = args[0];							
				if (arg && arg.span) {
					var span = arg.span;
					return span[2];
				} else throw {code: 'CAL_NO_VALUE',cal: 'column'};				
			}else{
				return arg;
			}
			
			throw {code: 'VALUE_NOT_AVAILABLE',cal: 'COLUMN'};
		},
		
		/*
		 * return the row index
		 */
		'row' : function(){
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp, isheet = this.sheet, irow = this.row, icol = this.col;
			var len = arguments.length;
			
			if (len == 0) return irow;
			if (1 < len) throw {code: 'CAL_PARAM_MISS',cal: 'ROW'};
			
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };

			if(me.isCoordObj(arguments[0])){
				var args = me.transferAll2Absolute(arguments, isheet, irow, icol);
                if(this.isArrayFormula){
                    var arr = [];
                    for(var i = 0, count = args.length; i < count; i++){
                        var it = args[i];
                        var span = it.span;
                        for(var j = span[1]; j <= span[3]; j++){
                            arr.push(j);
                        }
                    }
                    return arr;
                }
				var arg = args[0];							
				//if(me.checkRangeMatch(args, 1, false, false)){
				if (arg && arg.span) {
					var span = arg.span;
					return span[1];
				} else throw { code: 'CAL_NO_VALUE', cal: 'row' };				
			} else {
				// check whether it is boolean
				if (HELPER.isBoolean(arguments[0])) throw { code: 'CAL_NO_VALUE', cal: 'row' };
				if (Ext.isNumber(Number(arguments[0]))) return 1;
			}		
		},
		
		/**
		 * search for a specified item in a range of cells.
		 * 
		 *    MATCH(lookup_value, lookup_array, [match_type])
		 *    
		 *  match_type: 
		 *  
		 *  1 or omited: match finds the largest value that is <= lookup_value.
		 *               lookup_array must be in ascending order ... 1-9
		 *  0: find fist value =, not need order for array
		 *  -1: smallest value >= lookup_value. lookup_array must be in dscending order ... 9 - 1
		 */
		'match' : function(){
			var len = arguments.length;
			if(len < 2 && len > 3) throw { code: 'CAL_PARAM_MISS', cal: 'match' };
			
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var lookup_value = arguments[0];			
			if(me.isCoordObj(lookup_value)) lookup_value = calculates.valof.call(this, lookup_value);
			
			var match_type = 1; // default
		    if (len === 3) match_type = calculates.numberof.call(this, arguments[2]);
		    if (match_type != 0 && match_type != 1 && match_type != -1) throw { code: 'CAL_NO_VALUE', cal: 'match' };
		    
		    var lookarray = calculates.rangeObjsOf.call(this, [arguments[1]]);	
		    // ok, we need sort this based from small to large ... Except
		    // if type = 0, The MATCH function will find the first value that is equal to value. The array can be sorted in any order.
		    //if (match_type == 1) lookarray = HELPER.sortNumberArray(lookarray, "asc");
		    //else if (match_type == 1) lookarray = HELPER.sortNumberArray(lookarray, "desc");
		   
		    var result = 0;
			for ( var i = 0; i < lookarray.length; i++) {
				if (match_type == '0') {
					// if it is string .... wildcard character can be used ... ? * etc ...
					if (HELPER.isNumber(lookup_value)) {
						if (lookarray[i].toString() == lookup_value) {
							result = i + 1;
						    break;
						}
					} else if (1 == SCOM.kmpCompare(lookarray[i].toString(), lookup_value.toString())) {
						result = i + 1;
						break;
					}
					
				} else if (match_type == '1') {
					// if array is not sorted, that is fine. We just assume it is sorted 
					// and find the large number ...
					if (lookarray[i]) {
					    if (lookarray[i].toString() <= lookup_value) result = i + 1;
					    else break;
					} 
				} else if (match_type == '-1') {
					// assume this should be in desc sort order
					if (lookarray[i]) {
						if (lookarray[i].toString() >= lookup_value) result = i + 1;
						else break;
					} 
				}
			}
			
			if (result == 0) throw { code: 'VALUE_NOT_AVAILABLE', cal: 'match' };
			
			return result;
		},
		
		/**
		 * Search for value in the left-most column of tabe_array and returns the value in the same row based on the col_index.
		 * vlookup(lookup_value, tabe_array, col_index, [not_exact_match]) - vertical lookup
		 * 
		 * 1) if lookup_value smaller than the smallest val - return #N/A
		 * 2) table_array: 2 or more columns data.
		 * 3) col_index. <1 return #value#
		 *               >total columns - #REF!
		 * 4) Option, TRUE (default) - match. False - exact.
		 */
		'vlookup' : function() {
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp, isheet = this.sheet, irow = this.row, icol = this.col;
			var len = arguments.length;  
			
			if (len < 3 || len > 4) throw {code: 'CAL_PARAM_MISS',cal: 'vlookup'};
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw {code: 'CAL_INCORRECT_COORD',span: result};
			
			// this is for paramter 1 - lookup_value
		    var lookup_value = arguments[0];
		    if(me.isCoordObj(lookup_value)) lookup_value = calculates.valof.call(this, lookup_value);
		    if (Ext.isString(lookup_value)) lookup_value = lookup_value.toLowerCase();

		    // this is for paramter 2 - tableArray
			var posOffset = arguments[1], tableArray = null;			
			if (Ext.isObject(posOffset)) {
				var key = posOffset.span.join("-");
				if (key.charAt(0) == "-") key = isheet + key;
				tableArray = HELPER.getValueFromCache(key);
				if (!tableArray || tableArray.length == 0) {
					tableArray = calculates.rangeVal2Dimension.call(this, [posOffset]);
					HELPER.addValueToCache(key, tableArray);
				}
			} 
			if (tableArray == null || tableArray.length == 0)  throw { code: 'CAL_NO_VALUE', cal: 'vlookup' };
			
			// this is for paramter 3 - col_index
		    var colIndex = calculates.numberof.call(this, arguments[2]);
		    if (colIndex < 1) throw { code: 'CAL_NO_VALUE', cal: 'vlookup' };
		    else if (colIndex > tableArray[0].length) throw { code: 'CAL_INCORRECT_COORD', span: result };
		    
		    var rangeLookup = true; // ---- default 
		    if (len === 4) {
		    	rangeLookup = arguments[3];
		    	if(me.isCoordObj(rangeLookup)) rangeLookup = calculates.valof.call(this, rangeLookup);
		    	
		    	if (HELPER.isNumber(rangeLookup)) {
		    		if (rangeLookup == 0) rangeLookup = false;
		    	} else if (HELPER.isBoolean(rangeLookup)) rangeLookup = HELPER.getBoolean(rangeLookup);
			    else throw { code: 'CAL_NO_VALUE', cal: 'vlookup' };
		    }
		    
		    // ok, we need loop through the 2 dimension array and get result ...
		    var result = null;
			if (rangeLookup) { // match
				// ok, we need get the max value now ...
				var matchXIndex = -1;
				var selectedValue = null;
				for (var k=0; k<tableArray.length; k++) {
				    var tempVal = tableArray[k][0]; // first value for each Y values
				    if (tempVal != null && tempVal != undefined) {
				    	if (HELPER.isNumber(tempVal)) tempVal = Number(tempVal);
				    	else tempVal = tempVal.toLowerCase();
				    } else continue;
				    
				    // upper case and lower case are equal ...
				    if (tempVal === lookup_value) {
				    	var result = tableArray[k][colIndex-1];
						if (typeof result == 'undefined' || result == null) result = 0;
						return result;
				    }
				    
				    // ok, now we need see whether this is number and whether it is the biggest of value 
				    if (HELPER.isNumber(lookup_value)) {
				    	if (tempVal < lookup_value) { // ok we need record this value ... can be ...
				    		if (selectedValue == null || selectedValue < tempVal) { // first time or big ...
				    			selectedValue = tempVal;
				    			matchXIndex = k;
				    		} 
				    	}
				    } else if (Ext.isString(lookup_value) && Ext.isString(tempVal)) { // this is for String compare .... 
				    	if (tempVal.localeCompare(lookup_value) < 0) { // compare string A and string B
				    		if (selectedValue == null || selectedValue.localeCompare(tempVal) < 0) { // first time or big ...
				    			selectedValue = tempVal;
				    			matchYIndex = k;
				    		} 
				    	}
				    }
				}
				
				// special case if result is undefined ...
				if (matchXIndex > -1) {
					var result = tableArray[matchXIndex][colIndex-1];
					if (typeof result == 'undefined' || result == null) result = 0;
					return result;
				}
				else throw { code: 'VALUE_NOT_AVAILABLE', cal: 'vlookup' };
				
			} else { // exact 
				for (var k=0; k<tableArray.length; k++) {
				    var tempVal = tableArray[k][0]; // first value for each Y values
				    if (tempVal != null && tempVal != undefined) {
				    	if (HELPER.isNumber(tempVal)) tempVal = Number(tempVal);
				    	else tempVal = tempVal.toLowerCase();
				    } else continue;
				    
				    if (tempVal === lookup_value) {
				    	var result = tableArray[k][colIndex-1];
						if (typeof result == 'undefined' || result == null) result = 0;
						return result;	
				    }
				}
			}
			
			if (result == null) throw { code: 'VALUE_NOT_AVAILABLE', cal: 'vlookup' };
		},
		
		/**
		 * Search for value in the top row of tabe_array and returns the value in the same column based on the col_index.
		 * hlookup(lookup_value, tabe_array, row_index, [not_exact_match]) - horizen lookup
		 * 
		 * 1) if lookup_value smaller than the smallest val - return #N/A
		 * 2) table_array: 2 or more columns data.
		 * 3) row_index. <1 return #value#
		 *               >total columns - #REF!
		 * 4) Option, TRUE (default) - match. False - exact.
		 * 
		 * TODO:
		 * 
		 *     =HLOOKUP(3, {1,2,3;"a","b","c";"d","e","f"}, 2, TRUE)
		 */
		'hlookup' : function() {
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp, isheet = this.sheet, irow = this.row, icol = this.col;
			var len = arguments.length; 
			
			if (len < 3 || len > 4) throw {code: 'CAL_PARAM_MISS', cal: 'hlookup'};
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw {code: 'CAL_INCORRECT_COORD', span: result};
			
			// this is for paramter 1 - lookup_value
		    var lookup_value = arguments[0];
		    if(me.isCoordObj(lookup_value)) lookup_value = calculates.valof.call(this, lookup_value);
		    if (Ext.isString(lookup_value)) lookup_value = lookup_value.toLowerCase();
		    
		    // this is for paramter 2 - tableArray
			var posOffset = arguments[1], tableArray = null;
			if (Ext.isObject(posOffset)) {
				var key = posOffset.span.join("-");
				if (key.charAt(0) == "-") key = isheet + key;
				tableArray = HELPER.getValueFromCache(key);
				if (!tableArray || tableArray.length == 0) {
					tableArray = calculates.rangeVal2Dimension.call(this, [posOffset]);
					HELPER.addValueToCache(key, tableArray);
				}
			} 
			if (tableArray == null || tableArray.length == 0)  throw { code: 'CAL_NO_VALUE', cal: 'hlookup' };
			
			// this is for paramter 3 - col_index
		    var rowIndex = calculates.numberof.call(this, arguments[2]);
		    if (rowIndex < 1) throw { code: 'CAL_NO_VALUE', cal: 'hlookup' };
		    else if (rowIndex > tableArray.length) throw { code: 'CAL_INCORRECT_COORD', span: result };
		    
		    var rangeLookup = true; // ---- default 
		    if (len === 4) {
		    	rangeLookup = arguments[3];
		    	if(me.isCoordObj(rangeLookup)) rangeLookup = calculates.valof.call(this, rangeLookup);
		    	
		    	if (HELPER.isNumber(rangeLookup)) {
		    		if (rangeLookup == 0) rangeLookup = false;
		    	} else if (HELPER.isBoolean(rangeLookup)) rangeLookup = HELPER.getBoolean(rangeLookup);
			    else throw { code: 'CAL_NO_VALUE', cal: 'hlookup' };
		    }
		    
		    // ok, we need loop through the 2 dimension array and get result ...
		    var result = null;
			if (rangeLookup) { // match
				// ok, we need get the max value now ...
				var matchYIndex = -1;
				var selectedValue = null;
				for (var k=0; k<tableArray[0].length; k++) {
				    var tempVal = tableArray[0][k]; // first row value
				    if (tempVal != null && tempVal != undefined) {
				    	if (HELPER.isNumber(tempVal)) tempVal = Number(tempVal);
				    	else tempVal = tempVal.toLowerCase();
				    } else continue;
				    
				    // upper case and lower case are equal ...
				    if (tempVal === lookup_value) {
				    	var result = tableArray[rowIndex-1][k];
						if (typeof result == 'undefined' || result == null) result = 0;
						return result;
				    }
				    
				    // ok, now we need see whether this is number and whether it is the biggest of value 
				    if (HELPER.isNumber(lookup_value)) {
				    	if (tempVal < lookup_value) { // ok we need record this value ... can be ...
				    		if (selectedValue == null || selectedValue < tempVal) { // first time or big ...
				    			selectedValue = tempVal;
				    			matchYIndex = k;
				    		} 
				    	}
				    } else if (Ext.isString(lookup_value) && Ext.isString(tempVal) ) { // this is for String compare .... 
				    	if (tempVal.localeCompare(lookup_value) < 0) { // compare string A and string B
				    		if (selectedValue == null || selectedValue.localeCompare(tempVal) < 0) { // first time or big ...
				    			selectedValue = tempVal;
				    			matchYIndex = k;
				    		} 
				    	}
				    }
				}
				
				if (matchYIndex > -1) {
					var result = tableArray[rowIndex-1][matchYIndex];
					if (typeof result == 'undefined' || result == null) result = 0;
					return result;
				} 
				else throw { code: 'VALUE_NOT_AVAILABLE', cal: 'hlookup' };
				
			} else { // exact 
				for (var k=0; k<tableArray[0].length; k++) {
				    var tempVal = tableArray[0][k]; // first row value ...
				    if (tempVal != null && tempVal != undefined) {
				    	if (HELPER.isNumber(tempVal)) tempVal = Number(tempVal);
				    	else tempVal = tempVal.toLowerCase();
				    } else continue;
				    
				    if (tempVal === lookup_value) {
				    	var result = tableArray[rowIndex-1][k];
						if (typeof result == 'undefined' || result == null) result = 0;
						return result;	
				    } 
				}
			}
			
			if (result == null) throw { code: 'VALUE_NOT_AVAILABLE', cal: 'hlookup' };
		},
		
		/**
		 * This function returns either the value or the reference to a value from a table or range.
		 * 
		 * INDEX(array, row_num, column_num)
		 * 
		 * UPDATE @ 2013 12 13 - ignore INDEX(reference, row_num, column_num. area_num)
		 * 
		 *  Row_num     is the number of the row in reference from which to return a reference.
	     *  Column_num     is the number of the column in reference from which to return a reference.
	     *  Area_num     selects a range in reference from which to return the intersection of row_num and column_num. The first area selected or entered is numbered 1, the second is 2, and so on. If area_num is omitted, INDEX uses area 1.
	     * 
	     * There can be case like this: =index({1,2;3,4},0,2) -> we will change this as =index([1,2],[3,4],0,2) 
	     * and this case, len will be change dynamic ... we need be careful for this case ...
	     * 
	     */
		'index' : function() {
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp, isheet = this.sheet, irow = this.row, icol = this.col;
			var len = arguments.length; 
			
			if (0 > len) throw {code: 'CAL_PARAM_MISS',cal: 'index'};
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw {code: 'CAL_INCORRECT_COORD',span: result};
			
			// loop argument and check whether it is array, if yes ...
			var listAreas = [];
			var isMulArray = false;
			for (var i=0; i<len; i++) {
				if (Ext.isArray(arguments[i])) {
					listAreas.push(arguments[i]);
					isMulArray = true;
				}
			}
			if (!isMulArray) listAreas.push(arguments[0]);
			
			// calculate extra length ...
			var areaSize = listAreas.length;		
			var rowIndex = 1, colIndex = 1;
			
			if (1 == len - areaSize) rowIndex = calculates.numberof.call(this, arguments[len-1]);
			else if (2 == len - areaSize) {
				rowIndex = calculates.numberof.call(this, arguments[len-2]);
				colIndex = calculates.numberof.call(this, arguments[len-1]);
			}
			
			if (!Ext.isNumber(rowIndex) || 0 > rowIndex) throw {code: 'CAL_NO_VALUE', cal: 'index'};
			if (0 == rowIndex) rowIndex = 1;
			if (!Ext.isNumber(colIndex) || 0 > colIndex) throw {code: 'CAL_NO_VALUE', cal: 'index'};
			if (0 == colIndex) colIndex = 1;
			
			// ok now we need check whether it is object or Array ...
			var twoDimensionArray = [];
		    if (isMulArray) {
		    	twoDimensionArray = listAreas;
		    } else {				
			    twoDimensionArray = calculates.rangeVal2Dimension.call(this, [arguments[0]]);
		    }
			if (twoDimensionArray.length < rowIndex || twoDimensionArray[0].length < colIndex) throw {code: 'CAL_NO_VALUE', cal: 'index'};
			
			return twoDimensionArray[rowIndex-1][colIndex-1];
		},
		
		/*
		 * Returns a reference indicated by a text value
		 * TODO
		 * this is a bug here. =indirect("A1") -> now if I change A1 value, this result is not refresh ...
		 */
		'indirect' : function(){
			var me = this.me, calculates = me.calculates, isheet = this.sheet, irow = this.row, icol = this.col;
			var len = arguments.length; 		
			if (1 != len && 2 != len) throw {code: 'CAL_PARAM_MISS',cal: 'indirect'};
			
			// get parameters ...
			var coordStr = arguments[0];
			if (Ext.isObject(coordStr)) throw {code:'CAL_INCORRECT_COORD', cal: 'indirect'};
			
			// convert string A2 -> into cood ...
			var coord = EnterpriseSheet.sheet.calculate.Coordinate.prototype.string2Coord(coordStr, isheet, SCONST.ABSOLUTE_COORD);
            /*
             * here need add refs to this cell, so when the related cell is changed, this formula will be calculated
             * it's not very good to do this inside this formula, will cause some meanless processing
             */
            var store = this.store, coordArr = me.toCoordArr(coord);

            store.setCell(isheet, irow, icol, {
                refs: coordArr
            }, undefined, true);

            
			//var val = calculates.valof.call(this, coord[0]);
			
			return coord;
		},
		
		/*
		 * Returns a reference offset from a given reference
		 */
		'offset' : function(){
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp, isheet = this.sheet, irow = this.row, icol = this.col;
			var len = arguments.length; 
			if(3 > len || len > 5) throw {code: 'CAL_PARAM_MISS',cal: 'offset'};
				
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			/*
			 * transfer all coord span to absolute coord
			 */		
			var args = me.transferAll2Absolute(arguments, isheet, irow, icol);
			try{
				var rowOffset = args[1], colOffset = args[2], rowSpan = args[3], colSpan = args[4];
				if(me.isCoordObj(rowOffset)){
					var span = rowOffset.span;
					rowOffset = me.getCellData(span[0], span[1], span[2], this);
				}
				rowOffset = Number(rowOffset);
				if(!Ext.isNumber(rowOffset)){
					throw {
						code: 'CAL_NO_VALUE',
						cal: 'offset'
					}
				}
				if(me.isCoordObj(colOffset)){
					var span = colOffset.span;
					colOffset = me.getCellData(span[0], span[1], span[2], this);
				}
				colOffset = Number(colOffset);
				if(!Ext.isNumber(colOffset)){
					throw {
						code: 'CAL_NO_VALUE',
						cal: 'offset'
					}
				}
				if(me.isCoordObj(rowSpan)){
					var span = rowSpan.span;
					rowSpan = me.getCellData(span[0], span[1], span[2], this);
				}					
				if(me.isCoordObj(colSpan)){
					var span = colSpan.span;
					colSpan = me.getCellData(span[0], span[1], span[2], this);
				}
				var originSpan = args[0].span;
				originSpan[1] += rowOffset;
				originSpan[3] += rowOffset;
				originSpan[2] += colOffset;
				originSpan[4] += colOffset;
				if(Ext.isDefined(rowSpan)){
					rowSpan = Number(rowSpan);
					if(Ext.isNumber(rowSpan)){
						originSpan[3] = originSpan[1]+rowSpan-1;
					}else{
						throw {
							code: 'CAL_NO_VALUE',
							cal: 'offset'
						}
					}
				}
				if(Ext.isDefined(colSpan)){
					colSpan = Number(colSpan);
					if(Ext.isNumber(colSpan)){
						originSpan[4] = originSpan[2]+colSpan-1;
					}else{
						throw {
							code: 'CAL_NO_VALUE',
							cal: 'offset'
						};
					}
				}
				return args[0];
			}catch(e){
				throw {
					code: 'CAL_NO_VALUE',
					cal: 'offset'
				}
			}
		},
		
		/**
		 * HYPERLINK(link_location,friendly_name)
		 */
		'hyperlink' : function() {
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp, isheet = this.sheet, irow = this.row, icol = this.col;
			var len = arguments.length; 	
			if(1 !== len && 2 != len) throw {code: 'CAL_PARAM_MISS',cal: 'hyperlink'};
			
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw {code: 'CAL_INCORRECT_COORD',span: result};  
			
			var linkLocation = arguments[0];
			if(me.isCoordObj(linkLocation)) linkLocation = calculates.valof.call(this, linkLocation);
			
			var friendlyName = linkLocation;
			if (len == 2) {
				friendlyName = arguments[1];
			    if(me.isCoordObj(friendlyName)) friendlyName = calculates.valof.call(this, friendlyName);
			}
			
			// check link ...
            if(EnterpriseSheet.sheet.calculate.Coordinate.prototype.isCoordSpan(linkLocation)){
                if('#' === linkLocation.charAt(0)){
                    linkLocation = linkLocation.slice(1);
                }
            }else if(!SCONST['urlProReg'].test(linkLocation)){
				linkLocation = 'http://'+linkLocation;
			}
			
			var cell = store.getCell(isheet, irow, icol);
			var md = {
                clink: linkLocation,
                cfm: 'link'
			};
			store.setCell(isheet, irow, icol, md, null, true);
				
			// create link now ...
			return friendlyName;
		},
		
	    /*========================================================================================
		 * The following formulas are related to database
		 *========================================================================================*/
		
		/*
		 * Averages the values in a field (column) of records in a list or database that match conditions you specify.
		 * 
		 *     DAVERAGE( database, field, criteria )  
		 *     Field     indicates which column is used in the function. Enter the column label enclosed between double quotation marks, such as "Age" or "Yield," or a number (without quotation marks) that represents the position of the column within the list: 1 for the first column, 2 for the second column, and so on.
		 *     Criteria     is the range of cells that contains the conditions you specify. You can use any range for the criteria argument, as long as it includes at least one column label and at least one cell below the column label in which you specify a condition for the column.
		 */
		'daverage' : function(){
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp, isheet = this.sheet, irow = this.row, icol = this.col;
			var len = arguments.length; 	
			if(3 !== len) throw {code: 'CAL_PARAM_MISS',cal: 'daverage'};
				
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw {code: 'CAL_INCORRECT_COORD',span: result};  
			
			var dbRange = arguments[0];
			if (Ext.isObject(dbRange)) {
				dbRange = calculates.rangeVal2Dimension.call(this, [dbRange]);
			} 
			if (dbRange == null || dbRange.length <= 1)  throw { code: 'CAL_NO_VALUE', cal: 'daverage' };			
		    
		    // ok, this is for field ... this is for the label or column ...
		    var field = arguments[1]; 
		    // TODO -- need check "1" and 1 different ...
		    if(me.isCoordObj(field)) field = calculates.valof.call(this, field);
			
		    // get a list of criteria ...
		    var criteraRange = arguments[2];
			if (Ext.isObject(criteraRange)) {
				criteraRange = calculates.rangeVal2Dimension.call(this, [criteraRange]); 
			} 
			if (criteraRange == null || criteraRange.length <= 1) throw { code: 'CAL_NO_VALUE', cal: 'daverage' };
				
			// ok, now we need calculate ...
		},
		
		
	    /*========================================================================================
		 * The following formulas are related to Engineering 
		 *========================================================================================*/	
		
		'delta' : function() {		
			var len = arguments.length;
			if(0 == len || len > 2) throw { code: 'CAL_PARAM_MISS', cal: 'delta' };
			
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var number1 = calculates.numberof.call(this, arguments[0]);
			if (isNaN(number1) || number1 === undefined || number1 === "" ) throw { code: 'CAL_NO_VALUE', cal: 'delta' };
	
			var number2 = 0;
			if (len == 2) {
				number2 = arguments[1];
				if(me.isCoordObj(number2)) number2 = calculates.numberof.call(this, number2);
				if (isNaN(number2) ||number2 === undefined || number2 === "" ) throw { code: 'CAL_NO_VALUE', cal: 'delta' };
			}
	
			var result = 0;
			if (number1 == number2) result = 1;
			
			return result;
		},
		
		/**
		 * Returns the error function integrated between lower_limit and upper_limit.
		 * If upper_limit omitted, ERF integrates between zero and lower_limit.
		 * 
		 * ERF(lower_limit,[upper_limit])
		 */
		'erf' : function() {		
			var len = arguments.length;
			if(0 == len || len > 2) throw { code: 'CAL_PARAM_MISS', cal: 'ERF' };
			
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var lower_limit = calculates.numberof.call(this, arguments[0]);
			if (lower_limit === undefined || lower_limit === "" ) throw { code: 'CAL_NO_VALUE', cal: 'ERF' };
			var result1 = HELPER.calculateErf(lower_limit);
	
			var upper_limit = 0;
			if (len == 2) {
				upper_limit = calculates.numberof.call(this, arguments[1]);
				if (upper_limit === undefined || upper_limit === "" )throw { code: 'CAL_NO_VALUE', cal: 'ERF' };
				var result2 = HELPER.calculateErf(upper_limit);				
				return result2 - result1;
			} else {
				return result1;
			}
		},	
		
		// Result: 1 - erf(x)
		'erfc' : function() {		
			var len = arguments.length;
			if(0 == len || len > 2) throw { code: 'CAL_PARAM_MISS', cal: 'ERFC' };
			
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var lower_limit = calculates.numberof.call(this, arguments[0]);
			if (lower_limit === undefined || lower_limit === "" ) throw { code: 'CAL_NO_VALUE', cal: 'ERFC' };
			var result1 = HELPER.calculateErf(lower_limit);
	
			var upper_limit = 0;
			if (len == 2) {
				upper_limit = calculates.numberof.call(this, arguments[1]);
				if (upper_limit === undefined || upper_limit === "" )throw { code: 'CAL_NO_VALUE', cal: 'ERFC' };
				var result2 = HELPER.calculateErf(upper_limit);			
				return 1 - result2 + result1;
			} else {
				return 1 - result1;
			}
		},	
		
		// Returns 1 if number >= step; returns 0 (zero) otherwise.
		'gestep' : function() {
			var len = arguments.length;
			if(0 == len || len > 2) throw { code: 'CAL_PARAM_MISS', cal: 'gestep' };
			
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var number = calculates.numberof.call(this, arguments[0]);
			var step = 0;
			if (len === 2) step = calculates.numberof.call(this, arguments[1]);
			
			return (number >= step) ? 1 : 0;
		},
		
		/**
		 * Returns a bitwise 'AND' of two numbers.
		 * BITAND( number1, number2)
		 */
		'bitand' : function() {				
			var len = arguments.length;
			if (2 != len) throw { code: 'CAL_PARAM_MISS', cal: 'bitand' };
			
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var number1 = calculates.numberof.call(this, arguments[0]);
			if (number1 === undefined || number1 === "" || number1 < 0) throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'bitand' };
			var number2 = calculates.numberof.call(this, arguments[1]);
			if (number2 === undefined || number2 === "" || number2 < 0) throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'bitand' };
			
			if (HELPER.isInt(number1) && HELPER.isInt(number2)) return number1 & number2;
			else throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'bitand' };
		},
		
		/**
		 * Returns a bitwise 'OR' of two numbers.
		 * BITOR( number1, number2)
		 */
		'bitor' : function() {		
			var len = arguments.length;
			if (2 != len) throw { code: 'CAL_PARAM_MISS', cal: 'bitor' };
			
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var number1 = calculates.numberof.call(this, arguments[0]);
			if (number1 === undefined || number1 === "" || number1 < 0) throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'bitor' };
			var number2 = calculates.numberof.call(this, arguments[1]);
			if (number2 === undefined || number2 === "" || number2 < 0) throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'bitor' };
			
			if (HELPER.isInt(number1) && HELPER.isInt(number2)) return number1 | number2;
			
			throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'bitand' };
		},
		
		/**
		 * Returns a bitwise 'XOR' of two numbers.
		 * BITXOR( number1, number2)
		 */
		'bitxor' : function() {		
			var len = arguments.length;
			if (2 != len) throw { code: 'CAL_PARAM_MISS', cal: 'bitxor' };
			
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var number1 = calculates.numberof.call(this, arguments[0]);
			if (number1 === undefined || number1 === "" || number1 < 0) throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'bitxor' };
			var number2 = calculates.numberof.call(this, arguments[1]);
			if (number2 === undefined || number2 === "" || number2 < 0) throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'bitxor' };
	
			if (HELPER.isInt(number1) && HELPER.isInt(number2)) {
				if (number1 > 281474976710655 || number2 > 281474976710655) throw { code: 'NUM_IS_NOT_RIGHT', cal: 'bitxor' };
				return number1 ^ number2;
			}
			
			throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'bitxor' };
		},
		
		/**
		 * Returns a number shifted right by the specified number of bits.
		 * BITRSHIFT(number, shift_amount)
		 */
		'bitrshift' : function() {		
			var len = arguments.length;
			if (2 != len) throw { code: 'CAL_PARAM_MISS', cal: 'bitrshift' };
			
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var number1 = calculates.numberof.call(this, arguments[0]);
			if (number1 === undefined || number1 === "" || number1 < 0) throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'bitrshift' };
			var number2 = calculates.numberof.call(this, arguments[1]);
			if (number2 === undefined || number2 === "" || number2 < 0) throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'bitrshift' };
			
			if (HELPER.isInt(number1) && HELPER.isInt(number2)) return number1 >> number2;
			throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'bitrshift' };
		},
		
		/**
		 * Returns a number shifted left by the specified number of bits.
		 * BITLSHIFT(number, shift_amount)
		 */
		'bitlshift' : function() {		
			var len = arguments.length;
			if (2 != len) throw { code: 'CAL_PARAM_MISS', cal: 'bitlshift' };
			
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var number1 = calculates.numberof.call(this, arguments[0]);
			if (number1 === undefined || number1 === "" || number1 < 0) throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'bitlshift' };
			var number2 = calculates.numberof.call(this, arguments[1]);
			if (number2 === undefined || number2 === "" || number2 < 0) throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'bitlshift' };
			
			if (HELPER.isInt(number1) && HELPER.isInt(number2)) return number1 << number2;
			throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'bitlshift' };
		},
		
		/**
		 * Converts a binary number to decimal.
		 * BIN2DEC(number)
		 */
		'bin2dec' : function() {
			var len = arguments.length;
			if(len != 1) throw { code: 'CAL_PARAM_MISS', cal: 'bin2dec' };
			
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var number = calculates.numberof.call(this, arguments[0]);
			if (number === undefined || number === "" ) throw { code: 'CAL_NO_VALUE', cal: 'bin2dec' };
			
			// Return error if number is not binary or contains more than 10 characters (10 digits)
	        if (!/^[01]{1,10}$/.test(number)) throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'bin2dec' };
	        
	        // Convert binary number to decimal
		    var result = parseInt(number, 2);
		  
		    // Handle negative numbers
		    var stringified = number.toString();
		    if (stringified.length === 10 && stringified.substring(0, 1) === '1') {
		         return parseInt(stringified.substring(1), 2) - 512;
		    } else {
		        return result;
		    }
		},
		
	    /**
		 * Converts a binary number to hexadecimal.
		 * BIN2HEX(number, [places])
		 */
		'bin2hex' : function() {			
			var len = arguments.length;
			if(2 != len && 1 != len) throw { code: 'CAL_PARAM_MISS', cal: 'bin2hex' };
			
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var number = calculates.numberof.call(this, arguments[0]);
			if (number === undefined || number === "" ) throw { code: 'CAL_NO_VALUE', cal: 'bin2hex' };
			
			// Return error if number is not binary or contains more than 10 characters (10 digits)
	        if (!/^[01]{1,10}$/.test(number)) throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'bin2hex' };
	        
	        // Ignore places and return a 10-character hexadecimal number if number is negative
		    var stringified = number.toString();
		    if (stringified.length === 10 && stringified.substring(0, 1) === '1') {
		        return (1099511627264 + parseInt(stringified.substring(1), 2)).toString(16).toUpperCase();
		    }
	        
	        var result = parseInt(number, 2).toString(16);
	        var places = result.length;
			if (len === 2) places = calculates.numberof.call(this, arguments[1]);
		  
		    // Return hexadecimal number using the minimum number of characters necessary if places is undefined
			if (typeof places === 'undefined') {
			    return result.toUpperCase();
			} else {
			    // Return error if places is nonnumeric
			    if (isNaN(places))  throw { code: 'CAL_NO_VALUE', cal: 'bin2hex' };
			    
			    // Return error if places is negative
			    if (places < 0) throw { code: 'NUM_IS_NOT_RIGHT', cal: 'bin2hex' };
			    
			    // Truncate places in case it is not an integer
			    places = Math.floor(places);
			 
			    // Pad return value with leading 0s (zeros) if necessary (using Underscore.string)
			    if (places >= result.length) {
			    	result = HELPER.repeat('0', places - result.length) + result;
			    	return result.toUpperCase();
			    } else 
			    	throw { code: 'NUM_IS_NOT_RIGHT', cal: 'bin2hex' };
			}
		},
		
	    /**
		 * Converts a binary number to octal.
		 * BIN2OCT(number, [places])
		 */
		'bin2oct' : function() {
			
			var len = arguments.length;
			if(2 != len && 1 != len) throw { code: 'CAL_PARAM_MISS', cal: 'bin2oct' };
			
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var number = calculates.numberof.call(this, arguments[0]);
			if (number === undefined || number === "" ) throw { code: 'CAL_NO_VALUE', cal: 'bin2oct' };	
			// Return error if number is not binary or contains more than 10 characters (10 digits)
	        if (!/^[01]{1,10}$/.test(number)) throw { code: 'NUM_IS_NOT_RIGHT', cal: 'bin2oct' };
	        
	        // Ignore places and return a 10-character octal number if number is negative
			var stringified = number.toString();
			if (stringified.length === 10 && stringified.substring(0, 1) === '1') {
			    return (1073741312 + parseInt(stringified.substring(1), 2)).toString(8);
			}
	        
	        // Convert binary number to octal
			var result = parseInt(number, 2).toString(8);
			var places = result.length;
			if (len === 2) places = calculates.numberof.call(this, arguments[1]);
			 
			// Return octal number using the minimum number of characters necessary if places is undefined
			if (typeof places === 'undefined') {
			    return result;
			} else {
			    // Return error if places is nonnumeric
			    if (isNaN(places)) throw { code: 'CAL_NO_VALUE', cal: 'bin2oct' };
			    
			    // Return error if places is negative
			    if (places < 0) throw { code: 'NUM_IS_NOT_RIGHT', cal: 'bin2oct' };
			    
			    // Truncate places in case it is not an integer
			    places = Math.floor(places);
			 
			    // Pad return value with leading 0s (zeros) if necessary (using Underscore.string)
			    if (places >= result.length) {
			    	return HELPER.repeat('0', places - result.length) + result ;
			    } 
			    throw { code: 'NUM_IS_NOT_RIGHT', cal: 'bin2oct' };
			}
		},
		
		/**
		 * Converts a text representation of a number in a given base into a decimal number.
		 */
		'hex2dec' : function() {
			var len = arguments.length;
			if(1 != len) throw { code: 'CAL_PARAM_MISS', cal: 'hex2dec' };
			
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var val = arguments[0];
			if(me.isCoordObj(val)) val = calculates.valof.call(this, val);
			if (!/^[0-9A-Fa-f]{1,10}$/.test(val)) throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'hex2dec' };
 
			// Convert hexadecimal number to decimal
			var decimal = parseInt(val, 16);
			 
			// Return decimal number
			return (decimal >= 549755813888) ? decimal - 1099511627776 : decimal;
		},
		
		'hex2bin' : function() {
			var len = arguments.length;
			if(1 != len && 2 != len) throw { code: 'CAL_PARAM_MISS', cal: 'hex2bin' };
			
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var val = arguments[0];
			if(me.isCoordObj(val)) val = calculates.valof.call(this, val);
			if (!/^[0-9A-Fa-f]{1,10}$/.test(val)) throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'hex2bin' };
			
			var negative = (val.length === 10 && val.substring(0, 1).toLowerCase() === 'f') ? true : false;
			var decimal = (negative) ? parseInt(val, 16) - 1099511627776 : parseInt(val, 16);
			
			if (decimal < -512 || decimal > 511) throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'hex2bin' };
            if (negative) return '1' + HELPER.repeat('0', 9 - (512 + decimal).toString(2).length) + (512 + decimal).toString(2);
            var result = decimal.toString(2);
 
            // this is only one item ...
			if (1 == len) return result;
			
			// this is need get second item ...
			var places = calculates.numberof.call(this, arguments[1]);
			if (places < 0) throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'hex2bin' };
			places = Math.floor(places);
			
			if (places >= result.length) 
			    return HELPER.repeat('0', places - result.length) + result;
			else
                throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'hex2bin' };
		},
		
		'hex2oct' : function() {
			var len = arguments.length;
			if(1 != len && 2 != len) throw { code: 'CAL_PARAM_MISS', cal: 'hex2oct' };
			
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var val = arguments[0];
			if(me.isCoordObj(val)) val = calculates.valof.call(this, val);
			if (!/^[0-9A-Fa-f]{1,10}$/.test(val)) throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'hex2oct' };
			
			var decimal = parseInt(val, 16);		
			if (decimal > 536870911 && decimal < 1098974756864) throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'hex2oct' };		
			if (decimal >= 1098974756864) return (decimal - 1098437885952).toString(8);
			var result = decimal.toString(8);
 
            // this is only one item ...
			if (1 == len) return result;
			
			// this is need get second item ...
			var places = calculates.numberof.call(this, arguments[1]);
			if (places < 0) throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'hex2oct' };
			places = Math.floor(places);
			
			if (places >= result.length) 
			    return HELPER.repeat('0', places - result.length) + result;
			else
                throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'hex2oct' };
		},
		
		'dec2bin' : function() {
			var len = arguments.length;
			if(1 != len && 2 != len) throw { code: 'CAL_PARAM_MISS', cal: 'dec2bin' };
			
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var number = arguments[0];
			if(me.isCoordObj(number)) number = calculates.numberof.call(this, number);
			if (!/^-?[0-9]{1,3}$/.test(number) || number < -512 || number > 511)
				throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'dec2bin' };
			
			// Ignore places and return a 10-character binary number if number is negative
			if (number < 0) {
			    return '1' + HELPER.repeat('0', 9 - (512 + number).toString(2).length) + (512 + number).toString(2);
			}
			 
			// Convert decimal number to binary
			var result = parseInt(number, 10).toString(2);
			
			// this is only one item ...
			if (1 == len) return result;
			
			// this is need get second item ...
			var places = calculates.numberof.call(this, arguments[1]);
			if (places < 0) throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'dec2bin' };
			places = Math.floor(places);
			
			if (places >= result.length) 
			    return HELPER.repeat('0', places - result.length) + result;
			else
                throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'dec2bin' };
		},
		
		'dec2oct' : function() {
			var len = arguments.length;
			if(1 != len && 2 != len) throw { code: 'CAL_PARAM_MISS', cal: 'dec2oct' };
			
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var number = arguments[0];
			if(me.isCoordObj(number)) number = calculates.numberof.call(this, number);
			if (!/^-?[0-9]{1,9}$/.test(number) || number < -536870912 || number > 536870911)
				throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'dec2oct' };
			
			// Ignore places and return a 10-character octal number if number is negative
			if (number < 0) {
			   return (1073741824 + number).toString(8);
			}
			 
			// Convert decimal number to binary
			var result = parseInt(number, 10).toString(8);
			
			// this is only one item ...
			if (1 == len) return result;
			
			// this is need get second item ...
			var places = calculates.numberof.call(this, arguments[1]);
			if (places < 0) throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'dec2oct' };
			places = Math.floor(places);
			
			if (places >= result.length) 
			    return HELPER.repeat('0', places - result.length) + result;
			else
                throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'dec2oct' };
		},
		
		'dec2hex' : function() {
			var len = arguments.length;
			if(1 != len && 2 != len) throw { code: 'CAL_PARAM_MISS', cal: 'dec2hex' };
			
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var number = arguments[0];
			if(me.isCoordObj(number)) number = calculates.numberof.call(this, number);
			if (!/^-?[0-9]{1,15}$/.test(number) || number < -549755813888 || number > 549755813887)
				throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'dec2hex' };
			
			if (number < 0) {
			   number = (0xFFFFFFFFFF + number + 1).toString(16);
			   return number.toString(16).toUpperCase();
			}
			 
			// Convert decimal number to hex
			var result = number.toString(16).toUpperCase();
			
			// this is only one item ...
			if (1 == len) return result;
			
			// this is need get second item ...
			var places = calculates.numberof.call(this, arguments[1]);
			if (places < 0) throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'dec2hex' };
			places = Math.floor(places);
			
			if (places >= result.length) 
			    return HELPER.repeat('0', places - result.length) + result;
			else
                throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'dec2hex' };
		},
		
		'oct2bin' : function() {
			var len = arguments.length;
			if(1 != len && 2 != len) throw { code: 'CAL_PARAM_MISS', cal: 'oct2bin' };
			
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var number = arguments[0];
			if(me.isCoordObj(number)) number = calculates.numberof.call(this, number);
			if (!/^[0-7]{1,10}$/.test(number)) throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'oct2bin' };
				
			var negative = (number.length === 10 && number.substring(0, 1) === '7') ? true : false;
			var decimal = (negative) ? parseInt(number, 8) - 1073741824 : parseInt(number, 8);
			if (decimal < -512 || decimal > 511) throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'oct2bin' };			
			if (negative) return '1' + HELPER.repeat('0', 9 - (512 + decimal).toString(2).length) + (512 + decimal).toString(2);
			var result = decimal.toString(2);
			
			if (1 == len) return result;
			var places = calculates.numberof.call(this, arguments[1]);
			if (places < 0) throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'oct2bin' };
			places = Math.floor(places);
			
			if (places >= result.length) return HELPER.repeat('0', places - result.length) + result;
			else throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'oct2bin' };			
		},
		
		// Converts an octal number to decimal.
		'oct2dec' : function() {
			var len = arguments.length;
			if(1 != len) throw { code: 'CAL_PARAM_MISS', cal: 'oct2dec' };
			
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var number = arguments[0];
			if(me.isCoordObj(number)) number = calculates.numberof.call(this, number);
			if (!/^[0-7]{1,10}$/.test(number)) throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'oct2dec' };
				
			var decimal = parseInt(number, 8);
			return (decimal >= 536870912) ? decimal - 1073741824 : decimal;
		},
		
		'oct2hex' : function() {
			var len = arguments.length;
			if(1 != len && 2 != len) throw { code: 'CAL_PARAM_MISS', cal: 'oct2hex' };
			
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var number = arguments[0];
			if(me.isCoordObj(number)) number = calculates.numberof.call(this, number);
			if (!/^[0-7]{1,10}$/.test(number)) throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'oct2hex' };
			
			var decimal = parseInt(number, 8);
			if (decimal >= 536870912) return 'FF' + (decimal + 3221225472).toString(16).toUpperCase();
			var result = decimal.toString(16).toUpperCase();		
			
			if (1 == len) return result;
			var places = calculates.numberof.call(this, arguments[1]);
			if (places < 0) throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'oct2hex' };
			places = Math.floor(places);
			
			if (places >= result.length) return HELPER.repeat('0', places - result.length) + result;
			else throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'oct2hex' };			
		},
		
		/**
	     * This is the function to convert number CONVERT(number, from_unit, to_unit)
	     */
	    'convert' : function() {    	
	    	var len = arguments.length;
			if(3 != len) throw { code: 'CAL_PARAM_MISS', cal: 'convert' };
			
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			// get those 3 parameter - number, from_unit, to_unit
			var origNumber = calculates.numberof.call(this, arguments[0], true);
			var fromUnit = arguments[1], toUnit = arguments[2]; 	
		    if(me.isCoordObj(fromUnit)) fromUnit = calculates.valof.call(this, fromUnit);
		    if(me.isCoordObj(toUnit)) toUnit = calculates.valof.call(this, toUnit);

			// add condition 
			if (fromUnit === null || toUnit === null) throw { code: 'CAL_NO_VALUE', cal: 'convert' };
			
			// check whether fromUnit and toUnit are same group
			var fromUnitSet = null, toUnitSet = null;
			var fromToUnitData = HELPER.fromToUnitData;
	        for(var i=0; i<fromToUnitData.length; i++){
	            var keyValue = (fromToUnitData[i])[0];
	            if (keyValue == fromUnit) fromUnitSet = fromToUnitData[i];
	            if (keyValue == toUnit) toUnitSet = fromToUnitData[i];
	        }
	        
	        // now check condition 
	        if (fromUnitSet === null || toUnitSet === null) throw { code: 'VALUE_NOT_AVAILABLE', cal: 'convert' };
	        
	        // this is not in same group - through N/A
	        if (fromUnitSet[1] != toUnitSet[1]) throw { code: 'VALUE_NOT_AVAILABLE', cal: 'convert' };
	        
	        // if it is temperature - need recalculate .... based on some new calculation ...
	        
	        // ok, now I know we are in same group ... do convert now 
	        var result = origNumber * fromUnitSet[2] / toUnitSet[2];   
	
			if (fromUnitSet[1] == "temperature") {
				if (fromUnitSet[0] == 'C' || fromUnitSet[0] == 'cel') {
					if (toUnit[0] == 'F' || toUnit[0] == 'fah') {
						result = origNumber * 9 / 5 + 32;
					} else {
						result = origNumber + 273.15;
					}
				} else if (fromUnitSet[0] == 'F' || fromUnitSet[0] == 'fah') {
					result = (origNumber - 32) * 5 / 9;
					if (toUnit[0] == 'K' || toUnit[0] == 'kel') {
						result = +273.15;
					}
				} else {
					result = origNumber - 273.15;
					if (toUnit[0] == 'F' || toUnit[0] == 'fah') {
						result = result * 9 / 5 + 32;
					}
				}
			}
			
			// check the special case ...
			// check the case ... 1.6105100000000000001 at this case we need chop
			// the extra 0
			// first get decimal length
			var digitalLen = HELPER.getDigitalLen(result);
			if (digitalLen > 14) { // now I know this is a special case and we need
									// deal with - round to something chop it ...
				result = HELPER.roundUpNonZero(result);
			}
	        
	        return result;
	    },
	    
	    'imdiv' : function() {
             var len = arguments.length;
			 if(2 != len) throw { code: 'CAL_PARAM_MISS', cal: 'imdiv' };
			
			 var me = this.me, calculates = me.calculates;
			 var store = this.store, timestamp = this.timestamp;
			 var result = me.checkCoordValid(arguments);
			 if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			 
			 var inumber1 = arguments[0];
	         if(me.isCoordObj(inumber1)) inumber1 = calculates.valof.call(this, inumber1);
	         
	         var inumber2 = arguments[1];
	         if(me.isCoordObj(inumber2)) inumber2 = calculates.valof.call(this, inumber2);
			 
	         return HELPER.IMDIV(inumber1.toString(), inumber2.toString());  
		 },
		 
		 'imsum' : function() {
			 return this.me.imMathCommonFunction2(arguments, 'IMSUM', this);
		 },
		 
		 'improduct' : function() {
             return this.me.imMathCommonFunction2(arguments, 'IMPRODUCT', this);
		 },
		 
		 'imsub' : function() {
             return this.me.imMathCommonFunction2(arguments, 'IMSUB', this);
		 },
	    
	    'imabs' : function() {
			return this.me.imMathCommonFunction(arguments, 'IMABS', this);
		 },
	        
	    'imlog2' : function() {	    	
			return this.me.imMathCommonFunction(arguments, 'IMLOG2', this);
	     },
	     
	     'imln' : function() {	    	
			return this.me.imMathCommonFunction(arguments, 'IMLN', this);
	     },
	     
	     'imexp' : function() {	    	
			return this.me.imMathCommonFunction(arguments, 'IMEXP', this);
	     },
	    
	    'imlog10' : function() {	    	
	    	return this.me.imMathCommonFunction(arguments, 'IMLOG10', this);
	     },
		 
		 'imsin' : function() {
			 return this.me.imMathCommonFunction(arguments, 'IMSIN', this);	
		 },
		 
		 'imcos' : function() {
             return this.me.imMathCommonFunction(arguments, 'IMCOS', this);	
		 },
		 
		 'imcsc' : function() {
             return this.me.imMathCommonFunction(arguments, 'IMCSC', this);	
		 },
		 
		 'imcot' : function() {
             return this.me.imMathCommonFunction(arguments, 'IMCOT', this);	
		 },
		 
		 'imcosh' : function() {
             return this.me.imMathCommonFunction(arguments, 'IMCOSH', this);	
		 },
		 
		 'imcsch' : function() {
             return this.me.imMathCommonFunction(arguments, 'IMCSCH', this);	
		 },
		 
		 'imsinh' : function() {
             return this.me.imMathCommonFunction(arguments, 'IMSINH', this);	
		 },
		 
		 'imsec' : function() {
             return this.me.imMathCommonFunction(arguments, 'IMSEC', this);	
		 },
		 
		 'imsech' : function() {
             return this.me.imMathCommonFunction(arguments, 'IMSECH', this);	
		 },
		 
		 'imargument' : function() {
			 return this.me.imMathCommonFunction(arguments, 'IMARGUMENT', this);
		 },
		 
		 'imaginary' : function() {
			 return this.me.imMathCommonFunction(arguments, 'IMAGINARY', this);
		 },
		 
		 'imconjugate' : function() {
			 return this.me.imMathCommonFunction(arguments, 'IMCONJUGATE', this);
		 },
		 
		 'imreal' : function() {
			 return this.me.imMathCommonFunction(arguments, 'IMREAL', this);
		 },
		 
		 'imsqrt' : function() {
			 return this.me.imMathCommonFunction(arguments, 'IMSQRT', this);
		 },
		 
		 'imtan' : function() {
			 return this.me.imMathCommonFunction(arguments, 'IMTAN', this);
		 },
		 
		 'impower' : function() {
             var len = arguments.length;
			 if(2 != len) throw { code: 'CAL_PARAM_MISS', cal: 'impower' };
			
			 var me = this.me, calculates = me.calculates;
			 var store = this.store, timestamp = this.timestamp;
			 var result = me.checkCoordValid(arguments);
			 if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			 
			 var inumber = arguments[0];
	         if(me.isCoordObj(inumber)) inumber = calculates.valof.call(this, inumber);
	         inumber = inumber.toString(); 
	         
	         var expo = calculates.numberof.call(this, arguments[1]);
	         var x = HELPER.IMREAL(inumber);
			 var y = HELPER.IMAGINARY(inumber);
	         
			  var unit = inumber.substring(inumber.length - 1);
			  unit = (unit === 'i' || unit === 'j') ? unit : 'i';
			  
			  // Return error if either coefficient is not a number
			  if (x === '#NUM!' || y === '#NUM!') throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'impower' };
			 
			  // Calculate power of modulus
			  var abs = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
			  var p = Math.pow(abs, expo);
			  var t = HELPER.IMARGUMENT(inumber);
			 
			  // Return exponential of complex number
			  return HELPER.COMPLEX(p * Math.cos(expo * t), p * Math.sin(expo * t), unit);
		 },
		 
		 'imsub' : function() {
             var len = arguments.length;
			 if(2 != len) throw { code: 'CAL_PARAM_MISS', cal: 'imsub' };
			
			 var me = this.me, calculates = me.calculates;
			 var store = this.store, timestamp = this.timestamp;
			 var result = me.checkCoordValid(arguments);
			 if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			 
			 var inumber = arguments[0];
	         if(me.isCoordObj(inumber)) inumber = calculates.valof.call(this, inumber);
	         inumber = inumber.toString(); 
	         
	         var inumber2 = arguments[1];
	         if(me.isCoordObj(inumber2)) inumber2 = calculates.valof.call(this, inumber2);
	         inumber2 = inumber2.toString(); 
	         
	         var a = HELPER.IMREAL(inumber);
             var b = HELPER.IMAGINARY(inumber);
             var c = HELPER.IMREAL(inumber2);
             var d = HELPER.IMAGINARY(inumber2);
	         
			  var unit1 = inumber.substring(inumber.length - 1);
			  var unit2 = inumber2.substring(inumber2.length - 1);
			  var unit = 'i';
			  if (unit1 === 'j') unit = 'j';
			  else if (unit2 === 'j') unit = 'j';
			  
			  // Return error if either coefficient is not a number
			  if (a === '#NUM!' || b === '#NUM!' || c === '#NUM!' || d === '#NUM!') throw { code: 'CAL_PARAM_NEED_BE_NUM', cal: 'imsub' };
			 
			  return HELPER.COMPLEX(a - c, b - d, unit);
		 },
		 
		 //=============================================== for bessel function ============================
	    /**
	     * Returns the modified Bessel function, which is equivalent to the Bessel function evaluated for purely imaginary arguments.
	     * See this: http://www.mhtl.uwaterloo.ca/old/courses/me3532/js/bessel.html
	     */
	    'besseli' : function() {
	        var len = arguments.length;
			if(2 != len) throw { code: 'CAL_PARAM_MISS', cal: 'besseli' };
			var me = this.me, calculates = me.calculates;
			var x = calculates.numberof.call(this, arguments[0]);
			var n = calculates.numberof.call(this, arguments[1]);
			if (n < 0) throw { code: 'CAL_NO_VALUE', cal: 'besseli' };
			
			return FORMULA_HELPER.besseli(x,n);
	    },
	    
	    'besselj' : function(args) {
	    	var len = arguments.length;
			if(2 != len) throw { code: 'CAL_PARAM_MISS', cal: 'besselj' };
			var me = this.me, calculates = me.calculates;
			var x = calculates.numberof.call(this, arguments[0]);
			var n = calculates.numberof.call(this, arguments[1]);			
			if (n < 0) throw { code: 'CAL_NO_VALUE', cal: 'besselj' };
			
			return FORMULA_HELPER.besselj(x,n);
	    },
	    
	    'besselk' : function(args) {
	    	var len = arguments.length;
			if(2 != len) throw { code: 'CAL_PARAM_MISS', cal: 'besselk' };
			var me = this.me, calculates = me.calculates;
			var x = calculates.numberof.call(this, arguments[0]);
			var n = calculates.numberof.call(this, arguments[1]);			
			if (n < 0) throw { code: 'CAL_NO_VALUE', cal: 'besselk' };
			
			return FORMULA_HELPER.besselk(x,n);
	    },
	    
	    'bessely' : function(args) {
	    	var len = arguments.length;
			if(2 != len) throw { code: 'CAL_PARAM_MISS', cal: 'bessely' };
			var me = this.me, calculates = me.calculates;
			var x = calculates.numberof.call(this, arguments[0]);
			var n = calculates.numberof.call(this, arguments[1]);			
			if (n < 0) throw { code: 'CAL_NO_VALUE', cal: 'bessely' };
			
			return FORMULA_HELPER.bessely(x,n);
	    },
	    
	    /*========================================================================================
		 * Those are formula for old version Excel 2007 and earlier ... 
		 *========================================================================================*/
	    
	    'rank' : function() {
            return this.me.rankCommonFunction(arguments, 'rank', this);
	    },
	    
	    'rank_avg' : function() {
            return this.me.rankCommonFunction(arguments, 'rank.avg', this);
	    },
	    
	    'rank_eq' : function() {
            return this.me.rankCommonFunction(arguments, 'rank.eq', this);
	    },
	    
	    /**
	     * Estimates standard deviation based on a sample. The standard deviation is a measure of how widely 
	     * values are dispersed from the average value (the mean).
	     */
	    'stdev' : function() {
			 return this.me.stdevCommonFunction(arguments, 'stdev', this);
		},
		
		'stdevp' : function() { 
            return this.me.stdevCommonFunction(arguments, 'stdev.p', this);
	    },
		 
		'var_orig' : function() { 
            return this.me.stdevCommonFunction(arguments, 'var', this);
	    },
	    
	    'varp' : function() { 
            return this.me.stdevCommonFunction(arguments, 'var.p', this);
	    },

	    /**
	     * Returns the normal distribution for the specified mean and standard deviation. This function has a very wide 
	     * range of applications in statistics, including hypothesis testing.
	     * NORMDIST(x,mean,standard_dev,cumulative)
	     */
	    'normdist' : function() {
	    	var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var len = arguments.length; 
			if(4 != len) throw {code: 'CAL_PARAM_MISS', cal: 'normdist'};
			
			var result = me.checkCoordValid(coord);
			if(true !== result) throw {code: 'CAL_INCORRECT_COORD',span: result};
			
			// x value
			var x = arguments[0];
			if(me.isCoordObj(x)) x = calculates.valof.call(this, x);
			
			// mean and standard_dev
			var mean = arguments[1];
			if(me.isCoordObj(mean)) mean = calculates.numberof.call(this, mean);
			
			// mean and standard_dev
			var standard_dev = arguments[2];
			if(me.isCoordObj(standard_dev)) standard_dev = calculates.numberof.call(this, standard_dev);
			if (standard_dev <= 0) throw {code: 'NUM_IS_NOT_RIGHT', cal: 'normdist'};
					
			var cumulative = arguments[3];
			if(me.isCoordObj(cumulative)) cumulative = calculates.valof.call(this, cumulative);
			if (HELPER.isBoolean(cumulative)) cumulative = HELPER.getBoolean(cumulative);
			else throw {code: 'CAL_NO_VALUE', cal: 'normdist'};
			
			// more stuff in here ....
			if (cumulative) {
				
			} else {
				
			}
	    },
	    
	    /**
	     * Returns the standard normal cumulative distribution function. The distribution has a mean 
	     * of 0 (zero) and a standard deviation of one. Use this function in place of a table of 
	     * standard normal curve areas.
	     */
	    // Copyright (c) 2012 Sutoiku, Inc. (MIT License)
        // Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
        // The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	    'normsdist' : function() {
	    	var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var len = arguments.length; 
			if(1 != len) throw {code: 'CAL_PARAM_MISS', cal: 'normsdist'};
			
			// mean and z
			var z = arguments[0];
			if(me.isCoordObj(z)) z = calculates.numberof.call(this, z);
			
			var maxZval = 6.0, y, x, w;
            if (z === 0.0) x = 0.0;
            else {
                y = 0.5 * Math.abs(z);
                if (y >= (maxZval * 0.5)) x = 1.0;
                else if (y < 1.0) {
                    w = y * y;
                    x = ((((((((0.000124818987 * w - 0.001075204047) * w + 0.005198775019) * w - 0.019198292004) * w + 0.059054035642) * w - 0.151968751364) * w + 0.319152932694) * w - 0.531923007300) * w + 0.797884560593) * y * 2.0;
                } else {
                    y -= 2.0;
                    x = (((((((((((((-0.000045255659 * y + 0.000152529290) * y - 0.000019538132) * y - 0.000676904986) * y + 0.001390604284) * y - 0.000794620820) * y - 0.002034254874) * y + 0.006549791214) * y - 0.010557625006) * y + 0.011630447319) * y - 0.009279453341) * y + 0.005353579108) * y - 0.002141268741) * y + 0.000535310849) * y + 0.999936657524;
                }
            }
            
            return z > 0.0 ? ((x + 1.0) * 0.5) : ((1.0 - x) * 0.5);
	    },
	    
	    /*========================================================================================
		 * EnterpriseSheet formula 
		 *========================================================================================*/
	    /**
	     * this formula will return the checkbox value for the select cell, if cell is checked. 
	     * return true. Otherwise, return false. 
	     */
	    'es_checked' : function() {	    	
	    	var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var len = arguments.length; 
			if(1 != len) throw {code: 'CAL_PARAM_MISS', cal: 'es_checked'};
			
			var val = arguments[0];
		    if(me.isCoordObj(val)) {
		    	val = calculates.cellof.call(this, val, 'getCellData');
		    	if (val && val.it && val.it == "checkbox") {
		    		if (val.itchk == true) return true;
		    		else return false;
		    	} 
		    } 
		    throw {code: 'VALUE_NOT_AVAILABLE', cal: 'es_checked'};  	
	    },
	    
	    
	    /*========================================================================================
		 * Private: The following formulas are inner use - do not call outside ...
		 *========================================================================================*/

	    /**
         * array formula
         */
        'transpose' : function(){
            var me = this.me, calculates = me.calculates;
            var store = this.store, timestamp = this.timestamp, isheet = this.sheet, irow = this.row, icol = this.col;
            var len = arguments.length;
                       
            if (1 !== len) throw {code: 'CAL_PARAM_MISS',cal: 'TRANSPOSE'};
                       
            var result = me.checkCoordValid(arguments);
            if(true !== result){
                throw { code: 'CAL_INCORRECT_COORD', span: result };
            }
            var arr = [];
            me.each(this.sheet, this.row, this.col, arguments, function(obj, itemType, index, insideIndex, item){
                var data;
                if('span' == itemType){
                    var sheet = obj[0], row = obj[1], col = obj[2];
                    if(Ext.isNumber(sheet)){
                        var cell = me.getCellData(sheet, row, col, this);

                        data = cell.data;
                        var index = col-item[2];
                        while(arr.length <= index){
                            arr.push([]);
                        }
                        var it = arr[index];
                        it.push(data);
                    }
                }else{
                    throw { code: 'CAL_INCORRECT_COORD'};
                    return;
                }// if pass only 1 argument means it's a direct value
                               
            }, this);
            return arr;
        },
	    
		
		/*========================================================================================
		 * Private: The following formulas are inner use - do not call outside ...
		 *========================================================================================*/
		overwriteplus : function() {
			var me = this.me, calculates = me.calculates;		
			var val1 = arguments[0], val2 = arguments[1];
            
		    if(me.isCoordObj(val1)) val1 = calculates.valof.call(this, val1);
		    if(me.isCoordObj(val2)) val2 = calculates.valof.call(this, val2);
		    
		    // return immediately if it is number ... to improve performance ...
		    if (Ext.isNumber(Number(val1)) && Ext.isNumber(Number(val2))) {
		    	var num = Number(val1) + Number(val2);
		    	var digitalLen = HELPER.getDigitalLen(num);
		        if (digitalLen > 13) num = HELPER.roundUpNonZero(num);
		    	return num;
		    }

		    // check whether it is date or not ...
		    if (HELPER.isSSDefaultDate(val1)) {
		    	if (Ext.isNumber(Number(val2))) return HELPER.calculateDate(val1, val2, "+");
		    	else if (HELPER.isSSDefaultDate(val2)) return HELPER.calculate2Date(val1, val2, "+");
		    }
		    
		    if (Ext.isNumber(Number(val1))) {
		    	if (HELPER.isSSDefaultDate(val2))  return HELPER.calculateDate(val2, val1, "+");	    	
		    	// ok, check to see whether it is String + number, if yes, through #value!	
		    	if (Ext.isString(val2)) throw { code: 'CAL_NO_VALUE'};
		    }
		    
		    // check another case ...
		    if (Ext.isNumber(Number(val2)) && Ext.isString(val1) )  throw {code: 'CAL_NO_VALUE'};
 
		    return val1 + val2;
		},
		
		overwriteminus : function() {
			var me = this.me, calculates = me.calculates;
			var val1 = arguments[0], val2 = arguments[1];
            
		    if(me.isCoordObj(val1)) val1 = calculates.valof.call(this, val1);
		    if(me.isCoordObj(val2)) val2 = calculates.valof.call(this, val2);
		    
		    if (Ext.isNumber(Number(val1)) && Ext.isNumber(Number(val2))) {
		    	var num = Number(val1) - Number(val2);
		    	var digitalLen = HELPER.getDigitalLen(num);
		        if (digitalLen > 13) num = HELPER.roundUpNonZero(num);
		    	return num;
		    }
		    
		    // check whether it is date or not ...
		    if (HELPER.isSSDefaultDate(val1)) {
		    	if (Ext.isNumber(Number(val2))) return HELPER.calculateDate(val1, val2, "-");
		    	else if (HELPER.isSSDefaultDate(val2)) return HELPER.calculate2Date(val1, val2, "-");
		    }
		    
		    if (Ext.isNumber(Number(val1))) {
		    	if (HELPER.isSSDefaultDate(val2))  return HELPER.calculateDateByNum2(val1, val2, "-");
		        // ok, check to see whether it is String + number, if yes, through #value!	
		    	if (Ext.isString(val2)) throw { code: 'CAL_NO_VALUE'};
		    }
		    
		    // check another case ...
		    if (Ext.isNumber(Number(val2)) && Ext.isString(val1)) throw { code: 'CAL_NO_VALUE'};
		    
		    return val1 - val2;
		},
		
		// this method will overwrite & function ...
		overwriteAnd : function() {
			var me = this.me, calculates = me.calculates;
			var store = this.store, timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) throw { code: 'CAL_INCORRECT_COORD', span: result };
			
			var val1 = arguments[0], val2 = arguments[1];
            
		    if(me.isCoordObj(val1)) val1 = calculates.valof.call(this, val1);
		    if(me.isCoordObj(val2)) val2 = calculates.valof.call(this, val2);
		    
		    return val1 + val2;
		},
		
		// this method will overwrite multiple 
		// Can be array * array ... be careful for this method ...
		overwritemultiple : function() {
			var me = this.me, calculates = me.calculates, sheetId = this.sheet;
			
			var val1 = arguments[0], val2 = arguments[1], isArrayVal1 = false, isArrayVal2 = false;
            
			if(me.isCoordObj(val1)) {
				var key = val1.span.join("-");
				if (key.charAt(0) == "-") key = sheetId + key;
				var temp = HELPER.getValueFromCache(key);
				if (!temp || temp.length == 0) {
					val1 = calculates.rangeVal2Dimension.call(this, [val1]);
					HELPER.addValueToCache(key, val1); 
				} else {
					val1 = temp;
					temp = [];
				}
				isArrayVal1 = true;
			}
		    if(me.isCoordObj(val2)) {
		    	var key = val2.span.join("-");
		    	if (key.charAt(0) == "-") key = sheetId + key;
				var temp = HELPER.getValueFromCache(key);
				if (!temp || temp.length == 0) {
					val2 = calculates.rangeVal2Dimension.call(this, [val2]);
					HELPER.addValueToCache(key, val2);
				} else {
					val2 = temp;
					temp = [];
				}
				isArrayVal2 = true;
		    }
		    
		    if (Ext.isNumber(Number(val1)) && Ext.isNumber(Number(val2))) {
		    	return Number(val1) * Number(val2);
		    }
		    
		    // if it is date and number ...
		    if (Ext.isNumber(Number(val2))) {
		    	var temp = val1;
		    	if (isArrayVal1) temp = val1[0][0];
		    	if (HELPER.isSSDefaultDate(temp)) return HELPER.calculateDate(temp, val2, "*");
		    }
		    if (Ext.isNumber(Number(val1)) )  {
		    	var temp = val2;
		    	if (isArrayVal2) temp = val2[0][0];
		    	if (HELPER.isSSDefaultDate(temp)) return HELPER.calculateDate(temp, val1, "*");
		    }
			
			// check another case ........ this is for array part ...
			
			// if both are array, just return the array result ...
			if (Ext.isArray(val1) && Ext.isArray(val2)) {
				if (val1.length == 0 || val2.length == 0 || val1.length != val2.length) 
					throw {code: 'CAL_NO_VALUE', cal: 'multiple'};					
                if(Ext.isArray(val1[0]) && Ext.isArray(val2[0])){
			    return HELPER.combine2ArrsAs1Arr(val1, val2, "multiple");
                }else if(!Ext.isArray(val1[0]) && !Ext.isArray(val2[0])){
                    return HELPER.cal2ArrsAs1Arr(val1, val2, "multiple");
                }
			}

		    throw {code: 'CAL_NO_VALUE', cal: 'multiple'};
		},
		
		// this method will overwrite divide 
		overwritedivide : function() {
			var me = this.me, calculates = me.calculates;
			
			var val1 = arguments[0], val2 = arguments[1];
            
			if(me.isCoordObj(val1)) val1 = calculates.valof.call(this, val1);
		    if(me.isCoordObj(val2)) val2 = calculates.valof.call(this, val2);
		    
		    if (Ext.isNumber(Number(val1)) && Ext.isNumber(Number(val2))) {
		    	return Number(val1) / Number(val2);
		    }

		    throw {code: 'CAL_NO_VALUE', cal: 'multiple'};
		},
		
		/**
		 * this is function to process condition overwrite. For example:
		 *  
		 *    if("ok">2, "ok", "not")
		 *    if(date>1000, "1000", "not")
		 *  
		 *  Return Result:
		 *    true or false
		 */
		overwriteCompareCond : function() {
			var me = this.me, calculates = me.calculates, sheetId = this.sheet;
			var val1 = arguments[0], symbol = arguments[1], val2 = arguments[2];
            
			var val1IsString = false, val2IsString = false;
			
			// ===================================================================
			if (symbol == "=") symbol = "==";
			else if (symbol == "<>") symbol = "!=";
			
			// ===================================================================			
			if(me.isCoordObj(val2)) val2 = calculates.valof.call(this, val2);		
			
			// need check whether it is empty string ...
			if (val2 == "") {
				val2 = 0;
				val2IsNum = true;
			} else if (HELPER.isEmptyStr(val2)) val2IsString = true;
			else {			
				var val2IsNum = Ext.isNumber(Number(val2));
				if (val2IsNum) val2 = Number(val2);		
				else if (Ext.isString(val2)) {
					var checkDate = SFORMAT.checkingDate(val2);
					if (checkDate) {
						val2 = HELPER.convertDateToNum(checkDate);
					} else {
					    //val2 = val2.toLowerCase();
					    val2IsString = true;
					}
				}
			}
			
			// ====================================================================
			if(me.isCoordObj(val1)) val1 = calculates.valof.call(this, val1);			
			
			// check whether it is string ... And empty or space string ...
			if (val1 == "") {
				val1 = 0;
				val1IsNum = true;
			} else if (HELPER.isEmptyStr(val1)) val1IsString = true;
			else {			
				var val1IsNum = Ext.isNumber(Number(val1));
				if (val1IsNum) val1 = Number(val1);		
				else if (Ext.isString(val1)) {
					var checkDate = SFORMAT.checkingDate(val1);
					if (checkDate) {
						val1 = HELPER.convertDateToNum(checkDate);
					} else {
					    //val1 = val1.toLowerCase();
					    val1IsString = true;
					}
				}
			}
			
			// if both are string ...
			if (val1IsString && val2IsString) {
				// need use localeCompare  
				return HELPER.compare2String(val1, symbol, val2);
			} else if (val1IsString && val2IsNum) {
				val1 = 9999999999999; // case: "text">0 true; "text">1000 true
			} else if (val2IsString && val1IsNum) {
				val2 = 9999999999999; // case: "text">0 true; "text">1000 true
			}

			// return compare result ...
			return eval(val1+symbol+val2);
		},
		
		/**
		 * this is function to process condition overwrite. For example:
		 * 
		 *  A1:D5>=2 => overwritecondition(A1:D5, ">=", 2);
		 *  
		 *  Return Result:
		 *    2 dimension array ...
		 */
		overwriteArrCompareCond : function() {
			var me = this.me, calculates = me.calculates, sheetId = this.sheet;
			var val1 = arguments[0], symbol = arguments[1], val2 = arguments[2]; 
			
			// this is 2 dimension array ...
			var val1Arr = null;
			if (Ext.isArray(val1)) val1Arr = val1;
			else if (Ext.isArray(val1.span)) {
				var key = val1.span.join("-");
				if (key.charAt(0) == "-") key = sheetId + key;
				var val1Arr = HELPER.getValueFromCache(key);
				if (!val1Arr || val1Arr.length == 0) {
					val1Arr = calculates.rangeVal2Dimension.call(this, [val1]);
					HELPER.addValueToCache(key, val1Arr);
				}
			}
			
			if(me.isCoordObj(val2)) val2 = calculates.valof.call(this, val2);
			
			// if val2 is String ...
			if (Ext.isString(val2)) val2 = '"' + val2.toLowerCase() + '"';
			if (symbol == "=") symbol = "==";
			else if (symbol == "<>") symbol = "!=";
			
			var val2IsNum = false, val2IsBoolean = false;
			if (HELPER.isBoolean(val2)) val2IsBoolean = true;
			else val2IsNum = Ext.isNumber(Number(val2));
			
			// check condition 
			if (val1Arr) {
				// if condition match, then we just put this as 1. Otherwise, the result will be EMPTY (not zero)
				// condition match			
				for (var i=0; i<val1Arr.length; i++) {
					for (var j=0; j<val1Arr[0].length; j++) {				
						var temp = val1Arr[i][j], result = undefined;						
						try {
							if (typeof temp != 'undefined') {
								// check boolean condition ...
								var tempIsBoolean = HELPER.isBoolean(temp);
								if (tempIsBoolean && val2IsBoolean) {
								    if ( HELPER.getBoolean(temp) == HELPER.getBoolean(val2) ) val1Arr[i][j] = 1;
								    else val1Arr[i][j] = undefined;
								    continue;
								} else if (tempIsBoolean || val2IsBoolean) {
									val1Arr[i][j] = undefined;
								    continue;
								}
								
								if (val2IsNum) {
									// if it is empty "" -> not need eval
									if (temp == "") {
										val1Arr[i][j] = undefined;
									    continue;
									}
									
									if(Ext.isNumber(Number(temp))) {
								    	temp = Number(temp);
								    } else if(Ext.isString(temp)) {								    
								    	temp = 9999999999999; // case: "text">0 true; "text">1000 true
								    }
								} else if (!Ext.isNumber(Number(temp)) && Ext.isString(temp)) { 
									temp = '"' + temp.toLowerCase() + '"';	
								}
								
								if ( eval(temp+symbol+val2) ) result = 1; 
							} else if (val2IsNum) { // if it is undefined ... convert to 0.
								temp = 0;
								if ( eval(temp+symbol+val2) ) result = 1; 
							}
						} catch (err) {
								// console.log(err);
					    }
						val1Arr[i][j] = result;
					} // second loop
				} // first loop
			}
			
			return val1Arr;
		}
		
		
		
	}	
}, function(){
    //alert(HELPER.replaceBraces("{1,2;4,5}"))
	Ext.apply(EnterpriseSheet.sheet.calculate.Calculate.prototype, {
		
        escapeErrorFuncs: {'iferror':true, 'iserror':true, 'if': true, 'isna':true, 'ifna':true, 'iserr':true},
              
        contentRelatedProperty: ['data', 'display', 'cal', 'arg', 'value', 'timestamp', 'refs', 'afrow', 'afcol', 'aerow', 'aecol', 'clink', 'cfm', 'itms'],
              
        calculateRelatedProperty: ['cal', 'arg', 'value', 'refs', 'timestamp', 'afrow', 'afcol', 'aerow', 'aecol', 'clink', 'cfm'],
		/*
		 * check whether the passed str is a calculate or not
		 */
		isCalculate : function(str){
			var reg = new RegExp();
		    reg.compile(/^=.+/gi);
		    return reg.test(str);
		},
		
		couldbeCalculate : function(str){
			var reg = new RegExp();
		    reg.compile(/^=/gi);
		    return str && reg.test(str);
		},
		
		/*
		 * check whether the span string, such as 'A4', in the embrace of a function or not	 
		 */
		isInFun : function(str, pos){
			var match = 0, i;
			for(i = pos-1; i >=0; i--){
				if(')' == str[i]){
					match--;
				}
				if('(' == str[i]){
					match++;
				}
				if(1 == match){
					break;
				}
			}
			var flag = true;
			if(0 == match){
				flag = false;
			}else if(1 == match){
				if(')' == str[pos]){
					return true;
				}
				if(0 >= i){
					flag = false;
				}else{
					if(/[a-zA-Z0-9_]/.test(str[i-1])){		
						/*
						 * means this range is in a function
						 * but we still need check whether it's in a operation
						 * check forward first
						 */
						for(var j = pos, len = str.length; j < len; j++){
							var ch = str[j];
							if(',' == ch || ')' == ch || '"' == ch || "'" == ch){							
								break;
							}
							if(/[*+-\/\>\<\=\%]/.test(ch)){
								flag = false;
								break;
							}
						}					
						if(flag){
							/*
							 * check backward if need
							 */
							for(var j = pos-1; j >= 0; j--){
								var ch = str[j];
								if(',' == ch || '(' == ch || '"' == ch || "'" == ch){							
									break;
								}
								if(/[*+-\/\<\>\=\%]/.test(ch)){
									flag = false;
									break;
								}
							}
						}
					}else{
						flag = false;
					}
				}
			}
			return flag;
		},
		
		/*
		 * check whether the span string, such as 'A4', in the embrace of a string or not	 
		 this function got problem, not working rightly
		isInStr : function(str, pos){
			var pcs = str.slice(0, pos), count = 0;
			pcs.replace(/"/gi, function(w){
				count++;
			});
			if(1 === count%2){
				return true;
			}
			count = 0;
			pcs.replace(/'/gi, function(w){
				count++;
			});
			if(1 === count%2){
				return true;
			}
			count = 0;
			pcs.replace(/&quot;/gi, function(w){
				count++;
			});
			if(1 === count%2){
				return true;
			}
			count = 0;
			pcs.replace(/&#39;/gi, function(w){
				count++;
			});
			if(1 === count%2){
				return true;
			}
			return false;			
		},
         */
        /*
         * transfer the input calculate to the callable form,
         * for example, to transfer "=SUM(D1:D3)" to "sum({row:-1,col:0},{row:-3,col:0},true)"
         */
        transferCalculate : function(o, store, sheetId, row, col, forceAbsoluteCoord){
            if(this.isCalculate(o.data)){
                o.cal = true;
                var me = this;

                // this is for recalculate - special for + handle case: =12+"23" => =12+23
                // TODO, seems this method need some improve in performance
                var calStr = HELPER.reCheckDoubleQuote(o.data);
                calStr = HELPER.replaceBraces(calStr);

                // convert special formula nam - such as: =STDEV.S(A2:A11) -> =STDEV_S(A2:A11)
                // STDEV.S (dot) will not work ...
                calStr = HELPER.convertSpecialFormulaName(calStr);
            
                // THIS is used to handle case: {} -> []. Such as: =sum({1,2}) -> =sum([1,2])
                // And Extra comma ...                               
                calStr = HELPER.reCheckBracesAndExtraComma(calStr);
                
                // check to see whether it does include & - for case: =text("date", fm) & " per hour"
                // not this: SUMIF(G299:G304, ">" & H299) .... this will be another method to convert ...
                var lowCalStr = calStr.toLowerCase();
                if (lowCalStr.indexOf("&") != -1){
                    calStr = HELPER.convertAndSymbol(calStr, true);
                }

                // Convert condtion for the sumproduct formula ...
                //   =SUMPRODUCT((B2:B11*C2:C11)*(D2:D11>3)) 
                //   Condition need to be changed to: D2:D11>3 -> overwritecondition(D2:D11, ">", 3);
                // TO reduce calculate, we just check condition if it is sumproduct. 
                // Need add more for future for other case if appear ...
                if (lowCalStr.indexOf("sumproduct(") != -1) {
                	// overwritecondition ....
                	calStr = HELPER.convertFormulaCondition(calStr, "sumproduct");
                }
                
                /**
                 // ok, this is the place to check math operation
                 // This method will cover more functions -
                 // For example:
                 //    =123 + "test"
                 //    =today()+2
                 //    =1+today()
                 //    ='123' + "123"
                 //    =123 + "123"
                 //    =2*8+today()+2
                 // ok, we need take care of one case =123 + "test" - lots of case
                 //    = '123'+123; ='123'+"test"; ='a1' etc
                 * Do not just add * and /. There will be some problem in the order ...
                 *
                 **/
                if (calStr.indexOf("+") != -1 || calStr.indexOf("-") != -1 ){
                	// check whether it is science formatt, if yes, add ()
	                if (/[0-9.]+e[\+\-][0-9]+/i.test(calStr)) {
	                	calStr = HELPER.addBracket2ScienceData(calStr);
	                }
                    calStr = HELPER.convertPlusMinus(calStr, true);
                }
                
                /**
                 * this is for * and /
                 * Need be really careful. this should be done after + -
                 */
                if (calStr.indexOf("*") != -1 || calStr.indexOf("/") != -1 ){
                    calStr = HELPER.convertMulDiv(calStr, true);
                }
                
                /**
                 * for =2*2^3 cases etc lots of them ...see comments in convertPower function
                 * & shold be before ^ ... order is important ...
                 *      & then + - then * / then ^ 
                 */
                if (calStr.indexOf("^") != -1) calStr = HELPER.convertPower(calStr);
                
                /**
                 * Will convert any condition in the string into function compare  
                 */
                if (HELPER.isExpressFn(calStr.substring(1))) {
                	calStr = HELPER.convertCondition(calStr, "overwriteCompareCond");
                }
                
                /**
                 * sepcial process for IFERROR, iserror, isna etc which return error information ...
                 */
                calStr = this.escapeErrorResult(calStr);
                
                this.spanReg.lastIndex = 0;
                /*
                 * save the reference coord
                 */
                var refCoord = [], visited = {};
                var arg = calStr.replace(this.spanReg, function(w){
                    var pos = arguments[arguments.length-2];
                    var str = arguments[arguments.length-1];                 
                    
                    var ret = me.assembleCoordByRegResult(arguments);
                    if(!ret){
                    	return w;
                    }
                                       
                    var arr = ret.span, next = ret.next, ctype = ret.type;
                    /*
                     * normlize the coord to 5-tpl
                     */
                    arr = EnterpriseSheet.sheet.calculate.Coordinate.prototype.normalizeCoord(arr);
                                       
                    if('' !== arr[0] && 'string' == SCOM.typeOf(arr[0])){
                        /*
                         * if sheet part is a stirng and not '', means it should be as 'Sheet1', we need transfer the name to id
                        */
                        var foundSheetId = store.getSheetIdByName(arr[0]);
                        if(Ext.isNumber(foundSheetId)){
                            arr[0] = foundSheetId;
                            if(!visited[w]){
                                refCoord.push([].concat(arr));
                            }
                        }
                        
                    }else if(!visited[w]){
                        var refSpan = [sheetId, arr[1], arr[2], arr[3], arr[4]];
                        refCoord.push(refSpan);
                    }
                    visited[w] = true;
                                         
                    if(!forceAbsoluteCoord){
                        /*
                         * change the absoluate coord to relative coord
                         */
                        arr = me.absolute2Relative(arr, row, col, ctype);
                    }else{
                        ctype = SCONST.ABSOLUTE_COORD;
                    }
                                       
                                       
                    var coord = Ext.encode({
                        span:arr,
                        type: ctype
                    });
                    /*
                     * if it's not in function, then we add valueOf for it automatically
                     */
                    
                    if(!me.isInFun(str, pos)){
                        coord = 'valof('+coord+')';
                    }
                    return coord+next;
                });             
                
                /*
                 * delete the "="
                 */
                arg = arg.slice(1);
                /*
                 * check and process some special case
                 */
                o.arg = this.specialCaseForCalculateStr(arg);
                if(0 < refCoord.length){
                    o.refs = [].concat(refCoord);
                }else{
                	/*
                	 * need set it to null not undefined
                	 */
                    o.refs = null;
                }
              
                /*
                 * process sheet name in the coord, if with blank, then include them with ""
                 */
                this.addQuoteForSheetName(o, store);
              
            }else{
                delete(o.cal);
            }
            return o;
        },
              
        /**
         * process the named functions
         */
        prepareNamedFuncs : function(namedFuncs, refStr, curSheetId, store){
            refStr = refStr || '';
            var arr = [], visited = {};
            var calPro = this;
            var fn = function(vn){
                if(namedFuncs.hasOwnProperty(vn)){
                    if('visiting' === visited[vn]){
                        /*
                         * means there is a loop reference
                         */
                        return false;
                    }else if(true !== visited[vn]){
                        visited[vn] = 'visiting';
                        var it = namedFuncs[vn], json = it.json;
                        var jsonArr = [{cal: json}];
                        try{
                            var jsonObj = Ext.decode(json);
                            if(!Ext.isArray(jsonObj)){
                                jsonArr = [jsonObj];
                            }else{
                                jsonArr = jsonObj;
                            }
                        }catch(e){}
                        for(var i = 0, len = jsonArr.length; i < len; i++){
                            var jsonObj = jsonArr[i], cal = jsonObj.cal, scope = jsonObj.scope, flag = true;
                            cal.replace(/("[^\"]+")|('[^\']+')|([a-z0-9._]+)/gi, function(w){
                                var str = arguments[3];
                                if(namedFuncs.hasOwnProperty(str) && !visited[str]){
                                    if(false === fn(str)){
                                        flag = false;
                                    }
                                }
                            });
                            if(flag){
                                arr.push({
                                    name: vn,
                                    cal: cal,
                                    scope: scope
                                });
                                visited[vn] = true;
                            }
                        }
                    }
                }
            }
            for(var p in namedFuncs){
                if(namedFuncs.hasOwnProperty(p)){
                    delete(namedFuncs[p].refs);
                    fn(p);
                }
            }
              
            var items = [], vars = [];
            for(var k = 0, size = arr.length; k < size; k++){
                var p = arr[k], name = p.name, it = namedFuncs[name], cal = '=beval('+p.cal+')';
                var o = calPro.transferCalculate({data: cal}, store, curSheetId, undefined, undefined, true);
                it.arg = o.arg;
                if(o.refs){
	                if(it.refs){
	                    it.refs = it.refs.concat(o.refs);
	                }else{
	                    it.refs = o.refs;
	                }
                }
                var packs = name.split('.');
                var len = packs.length;
                if(1 < len){
                    var invalid;
                    for(var i = 0; i < len; i++){
                        if(!/^[a-z_]+[a-z0-9_]*/.test(packs[i])){
                            invalid = true;
                            break;
                        }
                    }
                    if(invalid){
                        continue;
                    }
                    for(var i = 0; i < len; i++){
                        if(0 === i){
                            items.push('var '+packs[i]+'='+packs[i]+'||{};');
                        }else if(i === len-1){
                            var vname = packs.slice(0, i+1).join('.');
                            vars.push({
                                name: vname,
                                arg: o.arg,
                                scope: p.scope
                            });
                        }else{
                            var vname = packs.slice(0, i+1).join('.');
                            items.push(vname+'='+vname+'||{};');
                        }
                    }
                }else{
                    items.push('var '+name+';');
                    vars.push({
                        name: name,
                        arg: o.arg,
                        scope: p.scope
                    });
                }
            }
            var namedFunStr = items.join(''), envStr = calPro.fakeEnv();
            for(var i = 0, len = vars.length; i < len; i++){
                var it = vars[i], scope = it.scope, name = it.name, arg = it.arg;
                try{
                    var str = envStr+refStr+namedFunStr+arg;
                    /*
                     * check whether the str is valid to calculate
                    */
                    (function(){
                        eval(str);
                    })();
                    if(Ext.isDefined(scope)){
                        items.push('if(_curSheetId==='+it.scope+'){try{'+name+'=function(){return '+arg+';}}catch(e){};}');
                    }else{
                        items.push('try{'+name+'='+name+'||function(){return '+arg+';}}catch(e){};');
                    }
                }catch(e){
                    if(Ext.isDefined(scope)){
                        items.push("if(_curSheetId==="+it.scope+"){try{"+name+"='"+name+"||"+Ext.String.escape(arg)+"';}catch(e){};}");
                    }else{
                        items.push("try{"+name+"='"+name+"||"+Ext.String.escape(arg)+"';}catch(e){};");
                    }
                }
            }
            return items;
        },
              
        prepareRefNamedFunc : function(configs, curSheetId, store){
            var arr = [], namedFuncs = {};
            var calPro = this;
            for(var p in configs){
                if(configs.hasOwnProperty(p)){
                    var it = configs[p], json, scope;
                    /*
                     * ctype == 'ref' is for reserved for the old file data, for new data there will only be named_func
                     */
                    if('ref' == it.ctype){
                        try{
                            json = Ext.decode(it.json);
                            if(Ext.isArray(json) && json[0].cal){
                                json = json[0];
                            }
                        }catch(e){
                            json = it.json;
                        }
                        if(Ext.isObject(json)){
                            scope = json.scope;
                            json = json.cal;
                        }
                        var name = it.name;
                        var packs = name.split('.');
                        var len = packs.length;
                        var jsonStr = Ext.encode(json);
                        if(1 < len){
                            var invalid;
                            for(var i = 0; i < len; i++){
                                if(!/^[a-z_]+[a-z0-9_]*/.test(packs[i])){
                                    invalid = true;
                                    break;
                                }
                            }
                            if(invalid){
                                break;
                            }
                            for(var i = 0; i < len; i++){
                                if(0 === i){
                                    arr.push('var '+packs[i]+'='+packs[i]+'||{};');
                                }else if(i === len-1){
                                    var vname = packs.slice(0, i+1).join('.');
                                    arr.push('try{'+vname+'='+jsonStr+';}catch(e){};');
                                }else{
                                    var vname = packs.slice(0, i+1).join('.');
                                    arr.push(vname+'='+vname+'||{};');
                                }
                            }
                        }else{
                            arr.push('var '+it.name+'; try{'+it.name+'='+jsonStr+';}catch(e){};');
                        }
              
                        var coord = [];
                        for(var i = 0, len = json.length; i < len; i++){
                            var span = json[i].span;
                            if(Ext.isArray(span) && !Ext.isNumber(span[0])){
                                span[0] = curSheetId;
                            }
                            coord.push(span);
                        }
                        if(0 < coord.length){
                            it.refs = coord;
                        }else{
                            delete(it.refs);
                        }
                    }else if('named_func' == it.ctype){
                        namedFuncs[it.name] = it;
                    }
                }
            }
            /*
             * process the named functions
             */
            arr = arr.concat(calPro.prepareNamedFuncs(namedFuncs, arr.join(''), curSheetId, store));
 
            return arr;
        }
	});
});
Ext.define('EnterpriseSheet.sheet.calculate.Condition', {
	
	/* Begin Definitions */
	
	extend : 'EnterpriseSheet.sheet.calculate.Calculate',		
	
	statics : {
		/*
		 * the condition property usually has one more 'c' at start than the origin property
		 */
		styles : ['cbgc', 'bar', 'icon', 'showIconOnly', 'ccolor', 'cfw', 'cltcorner', 'hint', 'mini'],
        styleMap : {'cbgc': 'bgc', 'ccolor': 'color', 'cfw': 'fw', 'cltcorner': 'ltcorner'},
		stylesWithoutMini : ['cbgc', 'bar', 'icon', 'showIconOnly', 'ccolor', 'cfw', 'cltcorner', 'hint']
	},
	
	/* End Definitions */
	
	kitOffset : [5, -1],
	
	ignoreDate : true,
	
	constructor : function(config){
		Ext.apply(this, config);
		
		this.resetCache();	
		
		this.initListMenu();
		
		this.callParent();	
	},	
	
	/*
	 * init the calculate 
	 */
	init : function(sheet){
		this.callParent(arguments);
		
		sheet.on({
			scope: this,
			//'focuschange': this.onFocusChange,
			'changing': this.hideListKit,
            'changereadonly': this.onChangeReadOnly
		});
	},
	
	/*
	 * show condition reference
	 */
	showConditionReference : function(cell, sheetId, row, col){
		var store = this.sheet.getStore();
		var cdt = this.sheet.getConditionOfCell(sheetId, row, col);
		if(0 < cdt.length){					
			var coord = [];
			for(var k = 0, count = cdt.length; k < count; k++){
				var it = cdt[k];				
				if(it){
					var rng = it.rng, opt = it.opt, name = it.name;
					
					if('minichart' == name){
						rng = [Ext.isObject(opt.base) ? opt.base : {
							span: opt.base,
							type: SCONST['ABSOLUTE_COORD']
						}];
					}
					if('colorgrad' !== name && 'colorbar' !== name && 'vd' !== name){
						for(var i = 0, len = rng.length; i < len; i++){
							var it = rng[i];
							var span = it.span, type = it.type;
							if(SCONST.RELATIVE_COORD == type){
								span[1] += row;
								span[2] += col;
								span[3] += row;
								span[4] += col;
							}
							coord.push({
								span: span,
								cls: 'ss-rm-condition'
							});
						}
					}					
				}				
			}			
			//console.log(Ext.encode(coord))
			var rm = this.sheet.getReferenceModel();
			
			rm.setReference(coord, false, false, 'ss-cal-ref');			
			rm.show();
			return true;
		}
		return false;
	},
		
	/*
	 * return true if the cell is a mini chart cell
	 */
	withMiniChart : function(sheetId, row, col){
		var store = this.sheet.getStore();
		var cdt = this.sheet.getConditionOfCell(sheetId, row, col);
		if(0 < cdt.length){            
            for(var k = 0, count = cdt.length; k < count; k++){
                var it = cdt[k];                
                if('minichart' == it.name){
                    return true;
                }
            }
		}
		
		return false;
	},
	
	getMiniChartRangeByCell : function(sheetId, row, col){
		var store = this.sheet.getStore(), cdt = store.getConditionOfCell(sheetId, row, col); 
		if(0 < cdt.length){			
			for(var i = 0, len = cdt.length; i < len; i++){
				var cond = cdt[i];                
				if(cond && 'minichart' == cond.name){
					return cond.opt.base;
				}
			}
		}
	},
           
    getMiniChartRelatedCoord : function(cdt){
        return [cdt.opt.base.span];
    },
           
    
	
	/**
	 * check whether the condition type is an auto extend type
	 * @param {string} name: the name of the condtion
	 * @return {boolean}: true means it's auto extend type
	 */
	isAutoExtendType : function(name){
		return 'colorbar' == name || 'colorgrad' == name;
	},
	
	/**
	 * process the condition cell, apply the condition
	 * @param {object} o: the cell data object, if o.cal is not null/undefined, then will calculate the value
	 * @param {object} scope: the scope of the calculate function
	 * Notice: in scope, we need pass: 
	 * "store":which use for get cell data to calculate;
	 * "sheet":the sheet index of the calculate cell we process;
	 * "row":the row index of the calculate cell;
	 * "col":the column index of the calculate cell;
	 * @param {boolean} skipUpdateValue: true to not update value in calculate		 
	 */
	processCondition : function(o, scope, skipUpdateValue){
		
		var store = scope.store, sheetId = scope.sheet, row = scope.row, col = scope.col, timestamp = scope.timestamp;		
        var conditions = this.sheet.getCdtFloatingOfCell(sheetId, row, col, true);
        
		
		this.results = {}, ret = {}, old = Ext.apply({}, o);

		for(var i = conditions.length-1; i >= 0; i--){
			var condition = conditions[i];
            var cdtObj = condition.jsonObj;
			var name = cdtObj.name;
			var fn = this[name];			
			if(fn){
				Ext.apply(ret, fn.call(this, o, cdtObj.rng, cdtObj.opt, scope, condition));
			}
		}				
		//if(!skipUpdateValue){
			/*
			 * loop the style in this.styles, and compare with the old to check the changes
			 */
			var styles = EnterpriseSheet.sheet.calculate.Condition.styles;
			for(var i = 0, len = styles.length; i < len; i++){
				var p = styles[i];
				var flag = !SCOM.nullOrUndefined(ret[p]);
				if((flag || !SCOM.nullOrUndefined(old[p])) && (ret[p] !== old[p])){
					/*
					 * if changed then update the store
					 */
					if(flag){
						var modified = {};
						modified[p] = ret[p];
						
						/*
						 * set the last param to true so we can skip the pulling to backend
						 */
						store.setCell(sheetId, row, col, modified, null, true, undefined, true);
					}else{
						var deleted = [];
						deleted.push(p);
						
						/*
						 * set the last param to true so we can skip the pulling to backend
						 */
						store.setCell(sheetId, row, col, null, deleted, true, undefined, true);
					}
					/*
					 * add a flag to show the condtion is changed
					 */
					ret.cdtChanged = true;
				}
			}
            store.setCell(sheetId, row, col, {'cdtVal': true}, null, true, undefined, true);
		//}	
			
		/*
		 * apply the changes
		 */
		Ext.apply(o, ret);
		
		return o;
	},		
	
	/*
	 * find the repeat values in some ranges
	 * @param {string} timestamp: the timestamp string, to check the valid of calculate value and condition cache item
	 * @param {object} store: the store ref
	 * @param {int} sheet: the sheet id of the cell we calculating
	 * @param {int} row: the row index of the cell we calculating
	 * @param {int} col: the column index of the cell we calculating
	 * @param {array} range: the array of the range of the condition
	 * @return {object}: return the repeat values
	 */
	findRepeatInCondition : function(timestamp, store, sheet, row, col, range){
		var lookup = {}, repeat = {};		
		var fn = function(s, r, c){
			var cell = this.getCellData(s, r, c, {
				store: store,
				timestamp: timestamp,
				isCdt: true
			});
			
			if(cell.data){
				if(lookup[cell.data]){
					repeat[cell.data] = true;
				}else{
					lookup[cell.data] = true;
				}		
			}
		};
		
		this.walkRange(store, sheet, row, col, range, fn);		
		var arr = [];
		for(var p in repeat){
			arr.push(p);
		}
		return arr;
	},
	
	/*
	 * get the repeat value in the range of condition
	 * it will check the cache first, if not found then recalculate it and save in cache
	 * @param {array} range: the range array
	 * @param {object} scope: the scope object
	 * @return {object}: return the object contains all repeat value
	 */
	getRepeat : function(range, scope){		
		var store = scope.store, timestamp = scope.timestamp, sheet = scope.sheet, row = scope.row, col = scope.col;						
		/*
		 * get the min max value, first check the cache, 
		 * if not find in cache, then need re-calculate, and set the value to cache for future use 
		 */
		range = this.transfer2Absolute(sheet, row, col, range);
		
		var str = Ext.encode(range);
		var data = this.getFromCache(str, timestamp), repeat;
		if(!data || false == SCOM.typeOf(data.repeat)){			
			repeat = this.findRepeatInCondition(timestamp, store, sheet, row, col, range);
			this.keep2Cache(str, timestamp, {
				repeat:repeat
			});
		}else{
			repeat = data.repeat;
		}
		
		return repeat;
	},		
		
	/*
	 * find the average values in some ranges
	 * @param {int} pos: the position value, if it's 10, means the top 10 or top 10%; if it's -10, means the bottom 10 or bottom 10%
	 * @param {boolean} isPercent: true means pos is a percent
	 * @param {string} timestamp: the timestamp string, to check the valid of calculate value and condition cache item
	 * @param {object} store: the store ref
	 * @param {int} sheet: the sheet id of the cell we calculating
	 * @param {int} row: the row index of the cell we calculating
	 * @param {int} col: the column index of the cell we calculating
	 * @param {array} range: the array of the range of the condition
	 * @return {object}: return the average value
	 */
	findPositionValueInCondition : function(position, isPercent, timestamp, store, sheet, row, col, range){				
		var arr = [];		
		var fn = function(s, r, c){
			var cell = this.getCellData(s, r, c, {
				store: store,
				timestamp: timestamp,
				isCdt: true
			});
			
			if(SCOM.canbeNumber(cell.data)){
				arr.push(Number(cell.data));
			}
		};		
		this.walkRange(store, sheet, row, col, range, fn);
		
		var len = arr.length;
		if(0 < len){	
			if(isPercent){
				var posFlag = 0 < position;
				position = Math[(posFlag ? 'floor' : 'ceil')](position*len/100);				
				/*
				 * if it is 0, then no need calculate any more
				 */
				if(0 == position){
					position = posFlag ? 1 : -1;
				};				
			}
			arr.sort(function(a, b){
				return a-b;
			});			
			if(0 < position){
				var index = len-position;
				if(0 > index){
					index = 0;
				}
				return arr[index];
			}else{
				position = -position-1;
				if(position >= len){
					position = len-1;
				}
				return arr[position];
			}
		}
	},
	
	/*
	 * get the position value in the range of condition
	 * it will check the cache first, if not found then recalculate it and save in cache
	 * @param {int} pos: the position value, if it's 10, means the top 10 or top 10%; if it's -10, means the bottom 10 or bottom 10%
	 * @param {boolean} isPercent: true means pos is a percent
	 * @param {array} range: the range array
	 * @param {object} scope: the scope object
	 * @return {number}: return the average value of the range
	 */
	getPositionValue : function(position, isPercent, range, scope){			
		var store = scope.store, timestamp = scope.timestamp, sheet = scope.sheet, row = scope.row, col = scope.col;	
		
		/*
		 * get the min max value, first check the cache, 
		 * if not find in cache, then need re-calculate, and set the value to cache for future use 
		 */
		range = this.transfer2Absolute(sheet, row, col, range);
		
		var str = Ext.encode(range);
		var data = this.getFromCache(str, timestamp), value;
		
		/*
		 * construct the name to get
		 */
		var name = isPercent ? position+'%' : position;
		if(!data || false == SCOM.typeOf(data[name])){			
			value = this.findPositionValueInCondition(position, isPercent, timestamp, store, sheet, row, col, range);
			var obj = {};
			obj[name] = value;
			this.keep2Cache(str, timestamp, obj);
		}else{
			value = data[name];
		}
		
		return value;
	},
			
		
	
	/******************************************************
	 * below are the specifical condition methods
	 ******************************************************/
	
	/*
	 * show color gradual change based on the percent of current cell in the condition range
	 */
	colorgrad : function(cell, range, option, scope){	
		if(this.results['cbgc'] || !SCOM.canbeNumber(cell.data)){
			return;
		}				
		/*
		 * get the min/max value in the range of current condition
		 */
        var obj = {};
           
        if(Ext.isDefined(option.min)){
            condition.cache = condition.cache || {};
            if(Ext.isDefined(condition.cache.min)){
                if(Ext.isNumber(condition.cache.min)){
                    obj.min = condition.cache.min;
                }
            }else if(Ext.isDefined(option.minArg)){
                var o = this.evalCal(option.minArg, scope);
                if(Ext.isNumber(o.data)){
                    obj.min = o.data;
                    condition.cache.min = o.data;
                }
            }
        }
        if(Ext.isDefined(option.max)){
            condition.cache = condition.cache || {};
            if(Ext.isDefined(condition.cache.max)){
                if(Ext.isNumber(condition.cache.max)){
                    obj.max = condition.cache.max;
                }
            }else if(Ext.isDefined(option.maxArg)){
                var o = this.evalCal(option.maxArg, scope);
                if(Ext.isNumber(o.data)){
                    obj.max = o.data;
                    condition.cache.max = o.data;
                }
            }
        }
        if(!Ext.isDefined(obj.min) || !Ext.isDefined(obj.max)){
            var o = this.getMinMax(range, scope, {
                isCdt: true
            });
            if(o.min > 0 && o.max > 0){
                o.min--;
            }
            Ext.apply(obj, o);
        }
		
		if(obj){
			var min = obj.min, max = obj.max;
			var v = cell.data, oldcbgc = cell.cbgc;
			if(max == min){
				v = 1;
			}else{
				v = (v-min)/(max-min);
			}
			/*
			 * calculate the color
			 */
			var start = option['start'], stop = option['stop'], end = option['end'], r, g, b;
            if(!end){
                end = stop
                stop = null;
            }
			if(stop){
				if(0.5 > v){
					v = v/0.5;
					r = Math.round((stop[0]-start[0])*v+start[0]);
					g = Math.round((stop[1]-start[1])*v+start[1]);
					b = Math.round((stop[2]-start[2])*v+start[2]);
				}else{
					v = (v-0.5)/0.5;
					r = Math.round((end[0]-stop[0])*v+stop[0]);
					g = Math.round((end[1]-stop[1])*v+stop[1]);
					b = Math.round((end[2]-stop[2])*v+stop[2]);
				}
			}else{
				r = Math.round((end[0]-start[0])*v+start[0]);
				g = Math.round((end[1]-start[1])*v+start[1]);
				b = Math.round((end[2]-start[2])*v+start[2]);
			}
			var bgc = 'rgb('+r+','+g+','+b+')';
			obj = {
				cbgc:bgc
			};															
			this.results['cbgc'] = bgc;
			return obj;
		}		
	},
	
	
	/*
	 * show a color bar for the current cell, the width of the bar depends on the percent of current cell in the condition range
	 */
	colorbar : function(cell, range, option, scope, condition){
		if(this.results['bar'] || !SCOM.canbeNumber(cell.data)){
			return;
		}
        scope.me = this;
		/*
		 * get the min/max value in the range of current condition
		 */	
        var obj = {};
           
        if(Ext.isDefined(option.min)){
            condition.cache = condition.cache || {};
            if(Ext.isDefined(condition.cache.min)){
                if(Ext.isNumber(condition.cache.min)){
                    obj.min = condition.cache.min;
                }
            }else if(Ext.isDefined(option.minArg)){
                var o = this.evalCal(option.minArg, scope);
                if(Ext.isNumber(o.data)){
                    obj.min = o.data;
                    condition.cache.min = o.data;
                }
            }
        }
        if(Ext.isDefined(option.max)){
            condition.cache = condition.cache || {};
            if(Ext.isDefined(condition.cache.max)){
                if(Ext.isNumber(condition.cache.max)){
                    obj.max = condition.cache.max;
                }
            }else if(Ext.isDefined(option.maxArg)){
                var o = this.evalCal(option.maxArg, scope);
                if(Ext.isNumber(o.data)){
                    obj.max = o.data;
                    condition.cache.max = o.data;
                }
            }
        }
        if(!Ext.isDefined(obj.min) || !Ext.isDefined(obj.max)){
            var o = this.getMinMax(range, scope, {
                isCdt: true
            });
            if(o.min > 0 && o.max > 0){
                /*
                 * do this so the min one will still show a little bit bar
                 */
                o.min = o.min*0.9;
            }
            Ext.apply(obj, o);
        }
		if(obj){
			var min = obj.min, max = obj.max;
			var v = cell.data, oldbar = cell.bar, l, c;
            if(0 < min){
                v -= min;
                max -= min;
                min = 0;
            }
            if(v < min){
                v = min;
            }
            if(v > max){
                v = max;
            }
			if(max === min){
				if(0 > max){
					v = '100%';
					c = option['neg'];
					l = '0%';
				}else{
					v = '100%';
					c = option['pos'];
					l = '0%';
				}				
			}else{
				var span, pos, neg;
				if(max < 0){
					neg = span = -min;
					pos = 0;
				}else if(0 < min){
					pos = span = max;
					neg = 0;
				}else{
					span = max-min;
					pos = max;
					neg = -min;
				}
				if(0 > v){
					c = option['neg'];
					v = Math.round(-v/span*100);
					l = Math.round(neg/span*100)-v;
					l = l+'%';
					v = v+'%';					
				}else{
					c = option['pos'];
					v = Math.round(v/span*100)+'%';
					l = Math.round(neg/span*100)+'%';
					
				}							
			}												
			
			var bar = '<div class="ss-colorbar" style="background:'+c+';width:'+v+';left:'+l+';z-index:'+SCONST['FLOAT_Z_INDEX']+';"></div>';						
			obj = {
				bar:bar
			};												
			this.results['bar'] = bar;
			return obj;
		}		
	},
	
	/*
     * show an icon for the current cell
     */
    iconset : function(cell, range, option, scope){
        if(this.results['icon'] || !SCOM.canbeNumber(cell.data)){
           return;
        }
        /*
         * get the min/max value in the range of current condition
         */
        var obj = this.getMinMax(range, scope, {
            isCdt: true
        });
        if(obj){
            var icon, showIconOnly;
            if(Ext.isDefined(option.set)){
                var min = obj.min, max = obj.max, set = option.set, level = option.level;
                var v = cell.data;
                var step = (max-min)/level, arr = [];
                for(var i = 0; i <= level; i++){
                    arr.push(min+i*step);
                }
                var pos = 0;
                for(var i = arr.length-1; i > 0; i--){
                    var j = i-1;
                    if(arr[i] >= v && v > arr[j]){
                        pos = j;
                        break;
                    }
                }
           
                icon = 'url('+SCONFIG.CONDITION_ICONS_PATH+'/'+set+'/'+pos+'.png)';

            }else if(Ext.isDefined(option['is'])){
                var iconSet = option['is'], icons;
                if(Ext.isObject(iconSet)){
                    var set = iconSet['set'], level = iconSet.level;
                    var arr = [];
                    for(var i = 0, len = iconSet.icons.length; i < len; i++){
                        arr.push({
                            set: set,
                            idx: iconSet.icons[i]
                        });
                    }
                    icons = arr;
                }else{
                    icons = iconSet;
                }
           
                var reverse = option.rv, ths = option.ths;
                showIconOnly = option.only;
                var v = cell.data, min = obj.min, max = obj.max;
                if(reverse){
                    icon = 'url('+SCONFIG.CONDITION_ICONS_PATH+'/'+icons[0].set+'/'+icons[0].idx+'.png)';
                }else{
                    icon = 'url('+SCONFIG.CONDITION_ICONS_PATH+'/'+icons[icons.length-1].set+'/'+icons[icons.length-1].idx+'.png)';
                }
                for(var i = 0, len = ths.length; i < len; i++){
                    var it = ths[i], val = it.v, unit = it.u, compare = it.c || '<=';
                    if(Ext.isArray(val)){
                        var span = val[0].span;
                        val = this.getCellData(span[0], span[1], span[2], scope).data;
                    }
                    val = Number(val);
                    if('percent' == unit){
                        val = val/100*max;
                    }
                    if(Ext.isNumber(val)){
                        if(('<=' === compare && v <= val) || ('<' == compare && v < val)){
                            var pos = reverse ? icons[icons.length-1-i] : icons[i];
                            icon = 'url('+SCONFIG.CONDITION_ICONS_PATH+'/'+pos.set+'/'+pos.idx+'.png)';
                            break;
                        }
                    }
                }
            }
           
            obj = {
                icon: icon,
                showIconOnly: showIconOnly
            };
            this.results['icon'] = icon;
            return obj;
        }
    },
    
	/*
	 * show a mini chart for the current cell, the width of the bar depends on the percent of current cell in the condition range
	 */
	minichart : function(cell, range, option, scope){
		if(this.results['mini']){
			return;
		}
		
		var miniType = option['type'];
		
		if('column' == miniType){
			return this.showMiniColumn(cell, range, option, scope);
        }else if('line' == miniType){
           return this.showMiniLine(cell, range, option, scope);
		}else if('gainloss' == miniType){
			return this.showMiniGainLoss(cell, range, option, scope);
		}
		
	},
	
	/*
	 * for mini gain loss chart
	 */
	showMiniGainLoss : function(cell, range, option, scope){
		var sheet = this.sheet, store = sheet.getStore();		
		var base = option.base;
		if(Ext.isObject(base) && base.span){
			base = base.span;
		}
		var positiveColor = option['pc'], negativeColor = option['nc'];
		if(!SCOM.canbeNumber(base[0])){			
			base[0] = sheet.getSheetId();
		}
		/*
		 * get the min/max value in the range of current condition
		 */	
		var arr = [];
		scope = Ext.apply({
			isCdt: true
		}, scope);
		store.walkRange([base], function(rd){
			var cell = this.getCellData(rd.data.sheet, rd.data.row, rd.data.col, scope);						
			var data = cell.data;
			data = Number(data);
			if(!Ext.isNumber(data)){
				data = 0;
			}
			arr.push(data);
		}, this);
		
		var tmp = [];
		var len = arr.length; 
			sl = 5, 			
			pl = 90/len,
			pw = pl-2, h = 90;			

		var positiveHeight = h/2, negativeHeight = h/2;
		var positiveVPos = 'bottom:'+(negativeHeight+5)+'%', negativeVPos = 'top:'+(5+positiveHeight)+'%';			
		for(var i = 0; i < len; i++){
			var th, vpos, bgc;
			if(0 > arr[i]){
				th = negativeHeight;
				vpos = negativeVPos;
				bgc = negativeColor;
			}else{
				th = 0 == arr[i] ? 0 : positiveHeight;
				vpos = positiveVPos;
				bgc = positiveColor;
			}		
			if(0 != th){
				th += '%;min-height:1px';
			}else{
				th = th+'%';
			}
			tmp.push({
				bgc: bgc,
				h: th,
				w: pw+'%',
				l: (sl+i*pl)+'%',
				vpos: vpos
			});			
		}	
			
		var mini = SLAYOUT.miniColumnTpl.apply(tmp);
		
		var obj = {
			'mini': mini	
		}
		this.results['mini'] = mini;
		return obj;	
	},
	
	/*
	 * for mini column chart
	 */
	showMiniColumn : function(cell, range, option, scope){
		var sheet = this.sheet, store = sheet.getStore();		
		var base = option.base;
		if(Ext.isObject(base) && base.span){
			base = base.span;
		}
		var positiveColor = option['pc'], negativeColor = option['nc'];
		if(!SCOM.canbeNumber(base[0])){			
			base[0] = sheet.getSheetId();
		}
		/*
		 * get the min/max value in the range of current condition
		 */	
		var arr = [], min = false, max = false;
		scope = Ext.apply({
			isCdt: true
		}, scope);
		store.walkRange([base], function(rd){
			var cell = this.getCellData(rd.data.sheet, rd.data.row, rd.data.col, scope);						
			var data = cell.data;
			data = Number(data);
			if(!Ext.isNumber(data)){
				data = 0;
			}
			arr.push(data);
			if(false === min){
				min = data;
			}else if(min > data){
				min = data;
			}
			if(false === max){
				max = data;
			}else if(max < data){
				max = data;
			}
		}, this);
		
		var tmp = [];
		var len = arr.length; 
			sl = 5, 			
			pl = 90/len,
			pw = pl-2, h = 90;			
		if(0 > max){
			var vpos = 'top:5%'; 
			for(var i = 0; i < len; i++){
				var th = h*arr[i]/min;	
				if(0 != th){
					th += '%;min-height:1px';
				}else{
					th = th+'%';
				}
				tmp.push({
					bgc: negativeColor,
					h: th,
					w: pw+'%',
					l: (sl+i*pl)+'%',
					vpos: vpos
				});			
			}
		}else if(0 > min && 0 < max){
			var span = max-min;
			var positiveHeight = h*max/span, negativeHeight = -h*min/span;
			var positiveVPos = 'bottom:'+(negativeHeight+5)+'%', negativeVPos = 'top:'+(5+positiveHeight)+'%';			
			for(var i = 0; i < len; i++){
				var th, vpos, bgc;
				if(0 > arr[i]){
					th = negativeHeight*arr[i]/min;
					vpos = negativeVPos;
					bgc = negativeColor;
				}else{
					th = positiveHeight*arr[i]/max;
					vpos = positiveVPos;
					bgc = positiveColor;
				}		
				if(0 != th){
					th += '%;min-height:1px';
				}else{
					th = th+'%';
				}
				tmp.push({
					bgc: bgc,
					h: th,
					w: pw+'%',
					l: (sl+i*pl)+'%',
					vpos: vpos
				});			
			}
		}else{
			var vpos = 'bottom:5%'; 
			for(var i = 0; i < len; i++){
				var th = h*arr[i]/max;		
				if(0 != th){
					th += '%;min-height:1px';
				}else{
					th = th+'%';
				}
				tmp.push({
					bgc: positiveColor,
					h: th,
					w: pw+'%',
					l: (sl+i*pl)+'%',
					vpos: vpos
				});			
			}
		}		

		var mini = SLAYOUT.miniColumnTpl.apply(tmp);
		
		var obj = {
			'mini': mini	
		}
		
		this.results['mini'] = mini;
		return obj;	
	},
	
    /*
     * for mini column chart
     */
    showMiniLine : function(cell, range, option, scope){
        var sheet = this.sheet, store = sheet.getStore();
        var base = option.base;
        if(Ext.isObject(base) && base.span){
            base = base.span;
        }
        var strokeColor = option['sc'];
        if(!SCOM.canbeNumber(base[0])){
            base[0] = sheet.getSheetId();
        }
        /*
         * get the min/max value in the range of current condition
         */
        var arr = [], min = false, max = false;
        scope = Ext.apply({
            isCdt: true
        }, scope);
        store.walkRange([base], function(rd){
            var cell = this.getCellData(rd.data.sheet, rd.data.row, rd.data.col, scope);
            var data = cell.data;
            data = Number(data);
            if(!Ext.isNumber(data)){
                data = 0;
            }
            arr.push(data);
            if(false === min){
                min = data;
            }else if(min > data){
                min = data;
            }
            if(false === max){
                max = data;
            }else if(max < data){
                max = data;
            }
        }, this);

        var tmp = [];
        var len = arr.length;
           h = max-min;
        for(var i = 0; i < len; i++){
            var th = (arr[i]-min)/h*100
            tmp.push({
                h: th
            });
        }
           
        var nw = 100/(tmp.length-1);
        var d = ['M'];
        for(var i = 0, len = tmp.length; i < len; i++){
            var it = tmp[i];
            d.push(i*nw+','+(100-it.h));
            if(len-1 !== i){
                d.push('L');
            }
        }
        d = d.join('');
        //console.log(d)
        var mini = [
            '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0,0,100,100" preserveAspectRatio="none" class="ss-cell-inside ss-incell-canvas">',
                '<path zIndex="0" d="',d,'" stroke-width="1" stroke="', strokeColor, '" fill="none"></path>',
            '</svg>'
        ].join('');
        var obj = {
           'mini': mini	
        }
           
        this.results['mini'] = mini;
        return obj;
    },
	
	/**
	 * check the validation of the cell
	 */
	vd : function(cell, range, option, scope){		
		if(this.results['cltcorner'] || 0 === scope.row || 0 === scope.col){
			return;
		}
		var obj = {};
		if(!this.checkValidate(cell, option)){
			var html = '<div class="ss-validation-sign" style="z-index:'+SCONST['CORNER_Z_INDEX']+';"></div>';
			this.results['cltcorner'] = html;
			Ext.apply(obj, {
				'cltcorner': html,
				'hint': option.hint || option
			});						
		}
		return obj;
	},
	
	/**
	 * check the validation
	 */
	checkValidate : function(cell, option){
		var dt = option.dt, op = option.op;
		var dts = SCONST.validateDataType, ops = SCONST.validateOption;
		
		// ok, we need check whether this is ignore blank ...
		if (option.ignoreBlank && SCOM.isEmptyValue(cell.data)) return true;
		
		if(dts['number'] == dt){
            var onlyInt = option.io;
			if(ops['between'] === op){
				var min = option.min, max = option.max;
				var data = Number(cell.data);
				if(Ext.isNumber(data) && min <= data && data <= max && (!onlyInt || data === Math.floor(data))){
					return true;
				}
				return false;
			}else if(ops['not_between'] === op){
				var min = option.min, max = option.max;
				var data = Number(cell.data);
				if(Ext.isNumber(data) && (min > data || data > max) && (!onlyInt || data === Math.floor(data))){
					return true;
				}
				return false;
			}else if(ops['less'] === op){
				var num = option.num;
				var data = Number(cell.data);
				if(Ext.isNumber(data) && num > data && (!onlyInt || data === Math.floor(data))){
					return true;
				}
				return false;
			}else if(ops['less_equal'] === op){
				var num = option.num;
				var data = Number(cell.data);
				if(Ext.isNumber(data) && num >= data && (!onlyInt || data === Math.floor(data))){
					return true;
				}
				return false;
			}else if(ops['greater'] === op){
				var num = option.num;
				var data = Number(cell.data);
				if(Ext.isNumber(data) && num < data && (!onlyInt || data === Math.floor(data))){
					return true;
				}
				return false;
			}else if(ops['greater_equal'] === op){
				var num = option.num;
				var data = Number(cell.data);
				if(Ext.isNumber(data) && num <= data && (!onlyInt || data === Math.floor(data))){
					return true;
				}
				return false;
			}else if(ops['equal'] === op){
				var num = option.num;
				var data = Number(cell.data);
				if(Ext.isNumber(data) && num === data && (!onlyInt || data === Math.floor(data))){
					return true;
				}
				return false;
			}else if(ops['not_equal'] === op){
				var num = option.num;
				var data = Number(cell.data);
				if(Ext.isNumber(data) && num !== data && (!onlyInt || data === Math.floor(data))){
					return true;
				}
				return false;
            }else if(ops['any_number'] === op){
                var data = Number(cell.data);
                if(Ext.isNumber(data) && (!onlyInt || data === Math.floor(data))){
                    return true;
                }
                return false;
            }
		}else if(dts['text'] == dt){
			if(ops['contain'] === op){
				var txt = option.txt;
				var str = cell.data;
				if(!SCOM.nullOrUndefined(str)){
					str = str.toString();
					if(-1 !== str.indexOf(txt)){
						return true;
					}
					return false;
				}
			}else if(ops['not_contain'] === op){
				var txt = option.txt;
				var str = cell.data;
				if(!SCOM.nullOrUndefined(str)){
					str = str.toString();
					if(-1 === str.indexOf(txt)){
						return true;
					}
					return false;
				}
			}else if(ops['equal'] === op){
				var txt = option.txt;
				var str = cell.data;
				if(!SCOM.nullOrUndefined(str)){
					str = str.toString();
					if(str === txt){
						return true;
					}
					return false;
				}
			}else if(ops['is_email'] === op){
				var str = cell.data;
				if(!SCOM.nullOrUndefined(str)){
					str = str.toString();
					if(Ext.form.field.VTypes.email(str)){
						return true;
					}
					return false;
				}
			}else if(ops['is_url'] === op){
				var str = cell.data;
				if(!SCOM.nullOrUndefined(str)){
					str = str.toString();
					if(Ext.form.field.VTypes.url(str)){
						return true;
					}
					return false;
				}
			}else if(ops['is_phone'] === op){
				var str = cell.data;
				if(!SCOM.nullOrUndefined(str)){
					str = str.toString();
					//if(/^(([0-9]+)|([\+]?[0-9]+[\s\-]?[0-9]+))$/.test(str)){
                    if(/^[\s]*[0-9]+[0-9\s\-\(\))]*$/.test(str)){
						return true;
					}
					return false;
				}
			}
		}else if(dts['phone'] == dt){ 
			var str = cell.data;
			if(!SCOM.nullOrUndefined(str)){
				str = str.toString();
				//if(/^(([0-9]+)|([\+]?[0-9]+[\s\-]?[0-9]+))$/.test(str)){
                if(/^[\s]*[0-9]+[0-9\s\-\(\))]*$/.test(str)){           
					return true;
				}
				return false;
			}
		}else if(dts['url'] == dt){ 
			var str = cell.data;
			if(!SCOM.nullOrUndefined(str)){
				str = str.toString();
				if(Ext.form.field.VTypes.url(str)){
					return true;
				}
				return false;
			}
		}else if(dts['email'] == dt){ 
			var str = cell.data;
			if(!SCOM.nullOrUndefined(str)){
				str = str.toString();
				if(Ext.form.field.VTypes.email(str)){
					return true;
				}
				return false;
			}
		}else if(dts['date'] == dt){
			var str = cell.data;
			if(!SCOM.nullOrUndefined(str)){
				str = Ext.String.trim(str.toString());
			}
			if(ops['equal'] === op){
				var date = option.date;				
				if(str){					
                    var curDate = SFORMAT.checkingDate(str);
					if('date' === cell.fm && curDate){
						date = SFORMAT.checkingDate(date);
						if(0 === date-curDate){
							return true;
						}
					}
					return false;
				}
			}else if(ops['date_before'] === op){
				var date = option.date;				
				if(str){					
                    var curDate = SFORMAT.checkingDate(str);
					if('date' === cell.fm && curDate){
						date = SFORMAT.checkingDate(date);
						if(0 < date-curDate){
							return true;
						}
					}
					return false;
				}
			}else if(ops['date_on_before'] === op){
				var date = option.date;				
				if(str){					
                    var curDate = SFORMAT.checkingDate(str);
					if('date' === cell.fm && curDate){
						date = SFORMAT.checkingDate(date);
						if(0 <= date-curDate){
							return true;
						}
					}
					return false;
				}
			}else if(ops['date_after'] === op){
				var date = option.date;				
				if(str){					
                    var curDate = SFORMAT.checkingDate(str);
					if('date' === cell.fm && curDate){
						date = SFORMAT.checkingDate(date);
						if(0 > date-curDate){
							return true;
						}
					}
					return false;
				}
			}else if(ops['date_on_after'] === op){
				var date = option.date;				
				if(str){					
                    var curDate = SFORMAT.checkingDate(str);
					if('date' === cell.fm && curDate){
						date = SFORMAT.checkingDate(date);
						if(0 >= date-curDate){
							return true;
						}
					}
					return false;
				}
			}else if(ops['between'] === op){
				var minDate = option.mind, maxDate = option.maxd;				
				if(str){					
                    var curDate = SFORMAT.checkingDate(str);
					if('date' === cell.fm && curDate){
						minDate = SFORMAT.checkingDate(minDate);
						maxDate = SFORMAT.checkingDate(maxDate);
						if(0 <= maxDate-curDate && 0 >= minDate-curDate){
							return true;
						}
					}
					return false;
				}
			}else if(ops['not_between'] === op){
				var minDate = option.mind, maxDate = option.maxd;				
				if(str){					
                    var curDate = SFORMAT.checkingDate(str);
					if('date' === cell.fm && curDate){
						minDate = SFORMAT.checkingDate(minDate);
						maxDate = SFORMAT.checkingDate(maxDate);
						if(0 > maxDate-curDate || 0 < minDate-curDate){
							return true;
						}
					}
					return false;
				}
			}else{				
				if(str){					
					if(SFORMAT.checkingDate(str) || SFORMAT.checkingDateTime(str)){
                        return true;
                    }
					return false;
				}
			}
		}else if(dts['list'] == dt || dts['single_select'] == dt){
			var list = option.list;
			var str = cell.data;
			if(!SCOM.nullOrUndefined(str)){
				str = Ext.String.trim(str.toString());
				if(-1 !== SCOM.indexOfArray(list, str)){
					return true;
				}
				return false;
			}
		}else if(dts['multi_options'] == dt){
			var list = option.list;
			if(!SCOM.isEmptyValue(cell.data)){
				var str = cell.data.toString();
				var itms = str.split(',');
				if(itms){
					for(var i = 0, len = itms.length; i < len; i++){
						var str = Ext.String.trim(itms[i]);
						if(-1 == SCOM.indexOfArray(list, str)){
							return false;
						}
					}
					return true;
				}
			}
		}else if(dts['checkbox'] == dt || dts['radio'] == dt){
			var str = cell.data;
			if(!SCOM.isEmptyValue(str)){
				return false;
			}
		}
		return true;
	},
	
	/*
	 * show a special style for the cell if it fit some special condition, 
	 * such as the value of current cell is the top 10 in the condition range 
	 */
	boolstyle : function(cell, range, option, scope){	
		var style = option.style;
		var rest = {};
		/*
		 * check the style, if all property in style are already set, then return
		 * if not, the rest object will keep these propery not be set
		 */
		for(var p in style){
			if(!this.results[p]){
				rest[p] = true;
			}
		}			
		/*
		 * return if all set
		 */
		if(SCOM.isEmptyObj(rest)){
			return;
		}		
		var obj = {};			
		if(this.testBool(cell, option, scope, range)){
			/*
			 * if fit the condition, then apply the rest style property
			 */
			for(var p in rest){
				this.results[p] = obj[p] = style[p];				
			}
		}		
		return obj;
	},
	
	/*
	 * _private 
	 * test whether the data fit the bool condition
	 * @param {object} cell: the cell data object
	 * @param {object} option: the option of the condition
	 * @param {object} scope: the scope object
	 * @param {array} range: the range array
	 * @return {boolean}: true means the condition is true, or false 
	 */
	testBool : function(cell, option, scope, range){		
		var type = option.type;
		if('function' == SCOM.typeOf(this['test'+type])){
			return this['test'+type].apply(this, arguments);
		}
	},
	
	/*************************************
	 * test for different bool conditions
	 ************************************/
	/*
	 * return true if the cell's value greater than some value, only for number
	 */
	testgreater : function(cell, option, scope){
		var store = scope.store, sheet = scope.sheet;
		var data = cell.data, base = option.base;
		scope = Ext.apply({
			isCdt: true
		}, scope);
		if(SCOM.canbeNumber(base)){
			base = Number(base);
		}else if('array' == SCOM.typeOf(base)){
			/*
			 * if base is a coord, then we get the value by the coord
			 */
			base = this.transferCoord2MinMax(base, sheet).min;
			
			base = this.getCellData(base[0], base[1], base[2], scope);			
			base = base.data;
		}else if('object' == SCOM.typeOf(base)){
			var span = base.span;
			if(SCONST['RELATIVE_COORD'] == base.type){
				span[1] += scope.row;
				span[3] += scope.row;
				span[2] += scope.col;
				span[4] += scope.col;
			}
			/*
			 * if base is a coord, then we get the value by the coord
			 */
			base = this.transferCoord2MinMax(span, sheet).min;
			
			base = this.getCellData(base[0], base[1], base[2], scope);					
			base = base.data;			
		}
		
		var flag = false;
		if(SCOM.canbeNumber(data)){
			data = Number(data);
			base = parseFloat(base) || 0;
			if(data > base){
				flag = true;					
			}
		}
		return flag;
	},
	
	/*
	 * return true if the cell's value less than some value, only for number 
	 */
	testless : function(cell, option, scope){
		var store = scope.store, sheet = scope.sheet;
		var data = cell.data, base = option.base;
		scope = Ext.apply({
			isCdt: true
		}, scope);
		if(SCOM.canbeNumber(base)){
			base = Number(base);
		}else if('array' == SCOM.typeOf(base)){
			/*
			 * if base is a coord, then we get the value by the coord
			 */
			base = this.transferCoord2MinMax(base, sheet).min;
			
			base = this.getCellData(base[0], base[1], base[2], scope);							
			base = base.data;			
		}else if('object' == SCOM.typeOf(base)){
			var span = base.span;
			if(SCONST['RELATIVE_COORD'] == base.type){
				span[1] += scope.row;
				span[3] += scope.row;
				span[2] += scope.col;
				span[4] += scope.col;
			}
			/*
			 * if base is a coord, then we get the value by the coord
			 */
			base = this.transferCoord2MinMax(span, sheet).min;
			
			base = this.getCellData(base[0], base[1], base[2], scope);					
			base = base.data;			
		}
		
		var flag = false;
		if(SCOM.canbeNumber(data)){
			data = Number(data);
			base = parseFloat(base) || 0;
			if(data < base){
				flag = true;					
			}
		}
		return flag;
	},
	
	/*
	 * return true if the cell's value equls some value, only for number 
	 */
	testequal : function(cell, option, scope){
		var store = scope.store, sheet = scope.sheet;
		var data = cell.data, base = option.base;
		scope = Ext.apply({
			isCdt: true
		}, scope);
		if(SCOM.canbeNumber(base)){
			base = Number(base);
		}else if('array' == SCOM.typeOf(base)){
			/*
			 * if base is a coord, then we get the value by the coord
			 */
			base = this.transferCoord2MinMax(base, sheet).min;
			
			base = this.getCellData(base[0], base[1], base[2], scope);					
			base = base.data;			
		}else if('object' == SCOM.typeOf(base)){
			var span = base.span;
			if(SCONST['RELATIVE_COORD'] == base.type){
				span[1] += scope.row;
				span[3] += scope.row;
				span[2] += scope.col;
				span[4] += scope.col;
			}
			/*
			 * if base is a coord, then we get the value by the coord
			 */
			base = this.transferCoord2MinMax(span, sheet).min;
			
			base = this.getCellData(base[0], base[1], base[2], scope);					
			base = base.data;			
		}
		
		var flag = false;
		if(SCOM.canbeNumber(data)){
			data = Number(data);
			base = parseFloat(base) || 0;
			if(data == base){
				flag = true;
			}
		}
		return flag;
	},
	
	/*
	 * return true if the cell's value include some value 
	 */
	testinclude : function(cell, option, scope){
		var store = scope.store, sheet = scope.sheet;
		var data = cell.data || '', base = option.base;
		
		var flag = false;
		base = base || '';
		base = base.toString();
        
		data = data.toString();
		if(-1 != data.indexOf(base)){
			flag = true;
		}
		return flag;
	},
	
	/*
	 * return true if the cell's value is repeated or not
	 */
	testrepeat : function(cell, option, scope, range){
		var store = scope.store, sheet = scope.sheet;
		var data = cell.data, base = option.base;
				
		var flag = false;
		var repeat = this.getRepeat(range, scope);
		if(SCONST.REPEAT_VALUE == base){
			for(var i = 0, len = repeat.length; i < len; i++){				
				if(repeat[i] == data){
					flag = true;
					break;
				}
			}
		}else{
			flag = true;
			for(var i = 0, len = repeat.length; i < len; i++){				
				if(repeat[i] == data){
					flag = false;
					break;
				}
			}
		}
		return flag;
	},
	
	/*
	 * return true if the cell's value between some values, only for number
	 */
	testbetween : function(cell, option, scope){		
		var store = scope.store, sheet = scope.sheet;
		var data = cell.data, base = option.base;
		
		var min = base.min, max = base.max;
		scope = Ext.apply({
			isCdt: true
		}, scope);
		var fn = function(o){
			if(SCOM.canbeNumber(o)){
				o = Number(o);
			}else if('array' == SCOM.typeOf(o)){				
				/*
				 * if base is a coord, then we get the value by the coord
				 */
				o = this.transferCoord2MinMax(o, sheet).min;
				o = this.getCellData(o[0], o[1], o[2], store);	
				o = o.data;				
			}else if('object' == SCOM.typeOf(o)){
				var span = o.span;
				if(SCONST['RELATIVE_COORD'] == o.type){
					span[1] += scope.row;
					span[3] += scope.row;
					span[2] += scope.col;
					span[4] += scope.col;
				}
				/*
				 * if base is a coord, then we get the value by the coord
				 */
				o = this.transferCoord2MinMax(span, sheet).min;
				
				o = this.getCellData(o[0], o[1], o[2], scope);					
				o = o.data;			
			}
			return o;
		}
		min = fn.call(this, min), max = fn.call(this, max);		
		var flag = false;
		if(SCOM.canbeNumber(data)){
			data = Number(data);
			min = parseFloat(min) || 0;
			max = parseFloat(max) || 0;
			if(data >= min && data <= max){
				flag = true;
			}
		}
		
		return flag;
	},
	
	/*
	 * return true if the cell's value begin at some date, only for date
	 */
	testdate : function(cell, option, scope){		
		var store = scope.store, sheet = scope.sheet;
		var data = cell.data, base = option.base;		
		var flag = false, date = SFORMAT.checkingDate(data), todate = new Date();
		var today = Ext.Date.format(todate, 'Ymd'), day = Ext.Date.format(date, 'Ymd');
		
		if(date){
			if(SCONST.YESTERDAY == base){
				if(day < today && Ext.Date.format(Ext.Date.add(date, Ext.Date.DAY, 1), 'Ymd') == today){
					flag = true;
				}
			}else if(SCONST.TODAY == base){
				if(day == today){
					flag = true;
				}
			}else if(SCONST.TOMORROW == base){
				if(day > today && Ext.Date.format(Ext.Date.add(date, Ext.Date.DAY, -1), 'Ymd') == today){
					flag = true;
				}
			}else if(SCONST.SEVEN_DAY == base){ // this is for last 7 days
				if(day <= today && Ext.Date.format(Ext.Date.add(date, Ext.Date.DAY, 6), 'Ymd') >= today){
					flag = true;
				}
			}else if(SCONST.LAST_WEEK == base){
				if(day < today){
					var offset = 1 + Number(Ext.Date.format(todate, 'w'));
					var end = Ext.Date.add(todate, Ext.Date.DAY, -offset), start = Ext.Date.add(end, Ext.Date.DAY, -6);					
					if(day <= Ext.Date.format(end, 'Ymd') && day >= Ext.Date.format(start, 'Ymd')){
						flag = true;
					}
				}
			}else if(SCONST.THIS_WEEK == base){
				var offset = Ext.Date.format(todate, 'w');
				var start = Ext.Date.add(todate, Ext.Date.DAY, -offset), end = Ext.Date.add(start, Ext.Date.DAY, 6);					
				if(day <= Ext.Date.format(end, 'Ymd') && day >= Ext.Date.format(start, 'Ymd')){
					flag = true;
				}
			}else if(SCONST.NEXT_WEEK == base){
				if(day > today){
					var offset = 7-Ext.Date.format(todate, 'w');
					var start = Ext.Date.add(todate, Ext.Date.DAY, offset), end = Ext.Date.add(start, Ext.Date.DAY, 6);					
					if(day <= Ext.Date.format(end, 'Ymd') && day >= Ext.Date.format(start, 'Ymd')){
						flag = true;
					}
				}
			}else if(SCONST.LAST_MONTH == base){
				if(day < today){
					var end = Ext.Date.add(todate, Ext.Date.DAY, -Ext.Date.format(todate, 'j')), start = Ext.Date.getFirstDateOfMonth(end);
					if(day <= Ext.Date.format(end, 'Ymd') && day >= Ext.Date.format(start, 'Ymd')){
						flag = true;
					}
				}
			}else if(SCONST.THIS_MONTH == base){
				var start = Ext.Date.getFirstDateOfMonth(todate), end = Ext.Date.getLastDateOfMonth(todate);
				if(day <= Ext.Date.format(end, 'Ymd') && day >= Ext.Date.format(start, 'Ymd')){
					flag = true;
				}
			}else if(SCONST.NEXT_MONTH == base){
				if(day > today){
					var start = Ext.Date.add(todate, Ext.Date.DAY, Ext.Date.getDaysInMonth(todate)-Ext.Date.format(todate, 'j')+1), end = Ext.Date.getLastDateOfMonth(start);
					if(day <= Ext.Date.format(end, 'Ymd') && day >= Ext.Date.format(start, 'Ymd')){
						flag = true;
					}
				}
			}
		}
		
		return flag;
	},
	
	/*
	 * return true if the cell's value above the average, only for number
	 */
	testaverage : function(cell, option, scope, range){
		var store = scope.store, sheet = scope.sheet;
		var data = cell.data, base = option.base;
				
		var flag = false;				
		if(SCOM.canbeNumber(data)){
			data = Number(data);
			var average = this.getAverage(range, scope, {
				isCdt: true
			});
			if(SCONST.BELOW_AVERAGE == base){
				if(data < average){
					flag = true;
				}
			}else{
				if(data > average){
					flag = true;
				}
			}
		}
		
		return flag;
	},
	
	/*
	 * return true if the cell's value is top 10 value
	 */
	testmax : function(cell, option, scope, range){
		var store = scope.store, sheet = scope.sheet;
		var data = cell.data, base = option.base;
				
		var flag = false;				
		if(SCOM.canbeNumber(data) && SCOM.canbeNumber(base)){
			data = Number(data);
			base = Number(base);
			var value = this.getPositionValue(base, false, range, scope);
			if(false != SCOM.typeOf(value) && data >= value){
				flag = true;
			}
		}
		
		return flag;
	},
	
	/*
	 * return true if the cell's value is bottom 10 value
	 */
	testmin : function(cell, option, scope, range){
		var store = scope.store, sheet = scope.sheet;
		var data = cell.data, base = option.base;
				
		var flag = false;				
		if(SCOM.canbeNumber(data) && SCOM.canbeNumber(base)){
			data = Number(data);
			base = -Number(base);
			var value = this.getPositionValue(base, false, range, scope);
			if(false != SCOM.typeOf(value) && data <= value){
				flag = true;
			}
		}
		
		return flag;
	},
	
	/*
	 * return true if the cell's value is top 10%
	 */
	testtop : function(cell, option, scope, range){
		var store = scope.store, sheet = scope.sheet;
		var data = cell.data, base = option.base;
				
		var flag = false;				
		if(SCOM.canbeNumber(data) && SCOM.canbeNumber(base)){
			data = Number(data);
			base = Number(base);
			var value = this.getPositionValue(base, true, range, scope);
			
			if(false != SCOM.typeOf(value) && data >= value){
				flag = true;
			}
		}
		
		return flag;
	},
	
	/*
	 * return true if the cell's value is bottom 10%
	 */
	testbottom : function(cell, option, scope, range){
		var store = scope.store, sheet = scope.sheet;
		var data = cell.data, base = option.base;
				
		var flag = false;				
		if(SCOM.canbeNumber(data) && SCOM.canbeNumber(base)){
			data = Number(data);
			base = -Number(base);
			var value = this.getPositionValue(base, true, range, scope);
			
			if(false != SCOM.typeOf(value) && data <= value){
				flag = true;
			}
		}
		
		return flag;
	},
	
	/*
	 * when remove row, we need change the cdt property
	 */
	beforeRemoveRow : function(sheetId, minrow, maxrow, mincol, maxcol, cdtArr, suspendUpdate){
        var me = this;
		var dspan = maxrow-minrow+1;
		var store = this.sheet.getStore(), needRefreshCdt, oldCdtCache = {}, oldCells, curCells, curCdtCache = {}, rowColCdtCache = {};
		/*
		 * get condition array
		 */
		cdtArr = cdtArr || store.getConditionBySheet(sheetId);
        var checkRngFn = function(rng){
            var changed = false, newRng = [];
            for(var i = 0, count = rng.length; i < count; i++){
                var rngItem = rng[i];
                var span = rngItem.span, type = rngItem.type;
                var top = span[1], bottom = span[3], left = span[2], right = span[4], flag = false;
                if(top || bottom){
                    if(0 === right){
                        rowColCdtCache[it.id] = it;
                    }
                    if((!mincol || mincol <= left) && (!maxcol || (right <= maxcol && 0 !== right))){
                        /*
                         * the removed region cover the condition rng totally
                         */
                        if(minrow <= bottom || 0 === bottom){
                            var topRow = maxrow < top ? top-dspan : (minrow < top ? minrow : top);
                            var bottomRow = 0;
                            if(0 !== bottom){
                                bottomRow = bottom-dspan;
                                if(top < minrow && maxrow > bottom){
                                    bottomRow = minrow-1;
                                }
                            }
                            top = topRow;
                            bottom = bottomRow;
                            flag = true;
                        }else{
                            newRng.push(rngItem);
                        }
                        if(flag){
                            changed = true;
                            if(top <= bottom || (0 === bottom && 0 === span[3])){
                                span[1] = top;
                                span[3] = bottom;
                                newRng.push(rngItem);
                            }
                        }
                    }else if((left <= mincol && (mincol <= right || 0 === right)) || (left <= maxcol && (maxcol <= right || 0 === right))){
                        /*
                         * the removed region cover the condition rng partly
                         */
                        var leftCol = mincol < left ? left : mincol, rightCol = (0 !== right && maxcol > right) ? right : maxcol;
                        if(minrow <= bottom || 0 === bottom){
                            var topRow = maxrow < top ? top-dspan : (minrow < top ? minrow : top);
                            var bottomRow = 0;
                            if(0 !== bottom){
                                bottomRow = bottom-dspan;
                                if(top < minrow && maxrow > bottom){
                                    bottomRow = minrow-1;
                                }
                            }
                            if(left < leftCol){
                                if(0 === left){
                                    left = 1;
                                }
                                newRng.push({
                                    span: [span[0], top, left, bottom, leftCol-1],
                                    type: SCONST['ABSOLUTE_COORD']
                                });
                            }
                            if(bottomRow >= topRow || 0 === bottomRow){
                                newRng.push({
                                    span: [span[0], topRow, leftCol, bottomRow, rightCol],
                                    type: SCONST['ABSOLUTE_COORD']
                                });
                            }
                            if(right > rightCol || 0 === right){
                                newRng.push({
                                    span: [span[0], top, rightCol+1, bottom, right],
                                    type: SCONST['ABSOLUTE_COORD']
                                });
                            }
                            changed = true;
                        }else{
                            newRng.push(rngItem);
                        }
                    }else{
                        newRng.push(rngItem);
                    }
                }else{
                    newRng.push(rngItem);
                }
            }
            /*
             * try to connect the spans
             */
            newRng = me.sheet.connectSpan(newRng);
            return {
                rng: newRng,
                changed: changed
            }
        }
           
		for(var k = 0, len = cdtArr.length; k < len; k++){
			var it = cdtArr[k];
			var myRng = it.rng;
			var cdtName = it.name, changed, newRng, needRemoved;
            if('minichart' === cdtName){
                var obj = checkRngFn(myRng);
                changed = obj.changed;
                newRng = obj.rng;
                it.rng = newRng;
                needRemoved = (0 === newRng.length);
                /*
                 * for the refer rng
                 */
                myRng = [it.opt.base];
                obj = checkRngFn(myRng);
                changed = changed || obj.changed;
                newRng = obj.rng;
                it.opt.base = newRng[0];
                needRemoved = needRemoved || (0 === newRng.length);
            }else{
                var obj = checkRngFn(myRng);
                changed = obj.changed;
                newRng = obj.rng;
                it.rng = newRng;
                needRemoved = (0 === newRng.length);
            }
           
			if(changed){	
				needRefreshCdt = true;
				/*
				 * save the old cdt before change it
				 */
				var cid = it.id+'-'+sheetId;
				var old = store.getFloatingById(it.id, sheetId);
				oldCdtCache[cid] = {
					'name': it.id,
					'sheet': sheetId,
					'ftype': 'cdt',
					'json': old ? old.json : undefined
				};
				var json;
				if(needRemoved){
					if(!suspendUpdate){
						store.setFloatingItem(sheetId, it.id, 'cdt');
					}					                   
				}else{
					json = Ext.encode(it);
					if(!suspendUpdate){
						store.setFloatingItem(sheetId, it.id, 'cdt', json);
					}
				}		
				curCdtCache[cid] = {
					'name': it.id,
					'sheet': sheetId,
					'ftype': 'cdt',
					'json': json	
				}
			}			
		}			
		
        var ret = {
            oldCdt: oldCdtCache,
            curCdt: curCdtCache,
            needRefreshCdt: needRefreshCdt
        };
        if(oldCells){
            if(ret.oldCells){
                Ext.apply(ret.oldCells, oldCells);
            }else{
                ret.oldCells = oldCells;
            }
        }
        if(curCells){
            if(ret.curCells){
                Ext.applyIf(ret.curCells, curCells);
            }else{
                ret.curCells = curCells;
            }
        }
        return ret;
	},
	
	/*
	 * when remove column, we need reset the tpl property
	 */
	beforeRemoveColumn : function(sheetId, mincol, maxcol, minrow, maxrow, cdtArr, suspendUpdate){
        var me = this;
		var dspan = maxcol-mincol+1;
		var store = this.sheet.getStore(), needRefreshCdt, oldCdtCache = {}, curCdtCache = {}, oldCells, curCells, rowColCdtCache = {};
		/*
		 * get condition array
		 */
		cdtArr = cdtArr || store.getConditionBySheet(sheetId);
        var checkRngFn = function(rng){
            var changed = false, newRng = [];
            for(var i = 0, count = rng.length; i < count; i++){
                var rngItem = rng[i];
                var span = rngItem.span, type = rngItem.type;
                var top = span[1], bottom = span[3], left = span[2], right = span[4], flag = false;
                if(0 == bottom){
                    rowColCdtCache[it.id] = it;
                }
                if(left || right){
                    if((!minrow || minrow <= top) && (!maxrow || (bottom <= maxrow && 0 !== bottom))){
                        /*
                         * the removed region cover the condition rng totally
                         */
                        if(mincol <= right || 0 === right){
                            var leftCol = maxcol < left ? left-dspan : (mincol < left ? mincol : left);
                            var rightCol = 0;
                            if(0 !== right){
                                rightCol = right-dspan;
                                if(left < mincol && maxcol > right){
                                    rightCol = mincol-1;
                                }
                            }
                            left = leftCol;
                            right = rightCol;
           
                            flag = true;
                        }
                        if(flag){
                            changed = true;
                            if(left <= right || (0 === right && 0 === span[4])){
                                span[2] = left;
                                span[4] = right;
                                newRng.push(rngItem);
                            }
                        }
                    }else if((top <= minrow && (minrow <= bottom || 0 === bottom)) || (top <= maxrow && (maxrow <= bottom || 0 === bottom))){
                        /*
                         * the removed region cover the condition rng partly
                         */
                        var topRow = minrow < top ? top : minrow, bottomRow = (maxrow > bottom && 0 !== bottom) ? bottom : maxrow;
                        if(mincol <= right || 0 === right){
                            var leftCol = maxcol < left ? left-dspan : (mincol < left ? mincol : left);
                            var rightCol = 0;
                            if(0 !== right){
                                rightCol = right-dspan;
                                if(left < mincol && maxcol > right){
                                    rightCol = mincol-1;
                                }
                            }
           
                            if(top < topRow){
                                if(0 == top){
                                    top = 1;
                                }
                                newRng.push({
                                    span: [span[0], top, left, topRow-1, right],
                                    type: SCONST['ABSOLUTE_COORD']
                                });
                            }
                            if(rightCol >= leftCol || 0 === rightCol){
                                newRng.push({
                                    span: [span[0], topRow, leftCol, bottomRow, rightCol],
                                    type: SCONST['ABSOLUTE_COORD']
                                });
                            }
                            if(bottom > bottomRow || 0 === bottom){
                                newRng.push({
                                    span: [span[0], bottomRow+1, left, bottom, right],
                                    type: SCONST['ABSOLUTE_COORD']
                                });
                            }
                            flag = true;
                            changed = true;
                        }
                    }
                }
                if(!flag){
                    newRng.push(rngItem);
                }
            }
            /*
             * try to connect the spans
             */
            newRng = me.sheet.connectSpan(newRng);
            return {
                rng: newRng,
                changed: changed
            }
        }
		for(var k = 0, len = cdtArr.length; k < len; k++){
			var it = cdtArr[k];
			var myRng = it.rng;
			var cdtName = it.name, changed, newRng, needRemoved;
            if('minichart' === cdtName){
                var obj = checkRngFn(myRng);
                changed = obj.changed;
                newRng = obj.rng;
                it.rng = newRng;
                needRemoved = (0 === newRng.length);
                /*
                 * for the refer rng
                 */
                myRng = [it.opt.base];
                obj = checkRngFn(myRng);
                changed = changed || obj.changed;
                newRng = obj.rng;
                it.opt.base = newRng[0];
                needRemoved = needRemoved || (0 === newRng.length);
            }else{
                var obj = checkRngFn(myRng);
                changed = obj.changed;
                newRng = obj.rng;
                it.rng = newRng;
                needRemoved = (0 === newRng.length);
            }
           
			if(changed){
				needRefreshCdt = true;
				/*
				 * save the old cdt before change it
				 */
				var cid = it.id+'-'+sheetId;
				var old = store.getFloatingById(it.id, sheetId);
				oldCdtCache[cid] = {
					'name': it.id,
					'sheet': sheetId,
					'ftype': 'cdt',
					'json': old ? old.json : undefined
				};
				var json;
				if(needRemoved){
					if(!suspendUpdate){
						store.setFloatingItem(sheetId, it.id, 'cdt');
					}					                   
				}else{
					json = Ext.encode(it);
					if(!suspendUpdate){
						store.setFloatingItem(sheetId, it.id, 'cdt', json);
					}
				}		
				curCdtCache[cid] = {
					'name': it.id,
					'sheet': sheetId,
					'ftype': 'cdt',
					'json': json	
				}
			}			
		}			
		/*
		 * sometimes, when remove cells for row/col condition range, we need avoid the new cells which is not included in the current range get the cdt property from the row/col extend
		 */		
		var ret = {
			oldCdt: oldCdtCache,
			curCdt: curCdtCache,
			needRefreshCdt: needRefreshCdt
		};
        if(oldCells){
            if(ret.oldCells){
                Ext.apply(ret.oldCells, oldCells);
           }else{
                ret.oldCells = oldCells;
           }
        }
        if(curCells){
            if(ret.curCells){
                Ext.applyIf(ret.curCells, curCells);
            }else{
                ret.curCells = curCells;
            }
        }
        return ret;
	},
	
	/*
	 * when remove cell, we need reset the tpl property
	 */
	beforeRemoveCell : function(sheet, minrow, maxrow, mincol, maxcol, moveDir){			
		if('up' == moveDir){
			return this.beforeRemoveRow(sheet, minrow, maxrow, mincol, maxcol);
		}else if('left' == moveDir){
			return this.beforeRemoveColumn(sheet, mincol, maxcol, minrow, maxrow);
		}
	},		
	
	/*
	 * before insert the row
	 */
	beforeInsertRow : function(sheetId, minrow, rowSpan, mincol, colSpan, cdtArr, suspendUpdate){
        var me = this;
		var maxrow = minrow+rowSpan-1, maxcol = mincol+colSpan-1;		
		var store = this.sheet.getStore(), needRefreshCdt, oldCdtCache = {}, curCdtCache = {}, rowColCdtCache = {}, newCdtCellsCache = {};
		/*
		 * get condition array
		 */
		cdtArr = cdtArr || store.getConditionBySheet(sheetId);
        var checkRngFn = function(rng, curCdtName){
            var changed = false, newRng = [];
           
            for(var i = 0, count = rng.length; i < count; i++){
                var rngItem = rng[i];
                var span = rngItem.span, type = rngItem.type;
                var top = span[1], bottom = span[3], left = span[2], right = span[4], flag = false;
           
                if(top || bottom){
                    if(0 === right){
                        rowColCdtCache[id] = it;
                    }
                    if((!mincol || mincol <= left) && (!maxcol || (right <= maxcol && 0 !== right))){
                        /*
                         * the removed region cover the condition rng totally
                         */
                        if(minrow <= bottom || 0 === bottom){
                            var topRow = minrow <= top ? top+rowSpan : top;
                            var bottomRow = 0;
                            if(0 !== bottom){
                                bottomRow = bottom+rowSpan;
                            }
                            top = topRow;
                            bottom = bottomRow;
                            /*
                             * add new inserted cell in newCdtCells array
                             */
                            if(top < minrow){
                                var coord = newCdtCellsCache[id];
                                if(!coord){
                                    newCdtCellsCache[id] = {coord: [], name: curCdtName};
                                    coord = newCdtCellsCache[id].coord;
                                }else{
                                    coord = coord.coord;
                                }
                                coord.push([span[0], minrow, left, maxrow, right]);
                            }
                            flag = true;
                        }else{
                            newRng.push(rngItem);
                        }
                        if(flag){
                            changed = true;
                            span[1] = top;
                            span[3] = bottom;
                            newRng.push(rngItem);
                        }
                    }else if((left <= mincol && (mincol <= right || 0 === right)) || (left <= maxcol && (maxcol <= right || 0 === right))){
                        /*
                         * the removed region cover the condition rng partly
                        */
                        var leftCol = mincol < left ? left : mincol, rightCol = (0 !== right && maxcol > right) ? right : maxcol;
           
                        if(minrow <= bottom || 0 === bottom){
           
                            var topRow = minrow <= top ? top+rowSpan : top;
                            var bottomRow = 0;
                            if(0 !== bottom){
                                bottomRow = bottom+rowSpan;
                            }
                            if(left < leftCol){
                                if(0 === left){
                                    left = 1;
                                }
                                newRng.push({
                                    span: [span[0], top, left, bottom, leftCol-1],
                                    type: SCONST['ABSOLUTE_COORD']
                                });
                            }
                            newRng.push({
                                span: [span[0], topRow, leftCol, bottomRow, rightCol],
                                type: SCONST['ABSOLUTE_COORD']
                            });
                            /*
                             * add new inserted cell in newCdtCells array
                             */
                            if(top < minrow){
                                var coord = newCdtCellsCache[id];
                                if(!coord){
                                    newCdtCellsCache[id] = {coord: [], name: curCdtName};
                                    coord = newCdtCellsCache[id].coord;
                                }else{
                                    coord = coord.coord;
                                }
                                coord.push([span[0], minrow, leftCol, maxrow, rightCol]);
                            }
                            if(right > rightCol || 0 === right){
                                newRng.push({
                                    span: [span[0], top, rightCol+1, bottom, right],
                                    type: SCONST['ABSOLUTE_COORD']
                                });
                            }
                            changed = true;
                        }else{
                            newRng.push(rngItem);
                        }
                    }else{
                        newRng.push(rngItem);
                    }
                }else{
                    newRng.push(rngItem);
                }
            }
            /*
             * try to connect the spans
             */
            newRng = me.sheet.connectSpan(newRng);
            return {
                rng: newRng,
                changed: changed
            }
        }
		for(var k = 0, len = cdtArr.length; k < len; k++){
			var it = cdtArr[k], id = it.id;
            var myRng = it.rng;
            var cdtName = it.name, changed, newRng, needRemoved;
            if('minichart' === cdtName){
                var obj = checkRngFn(myRng, cdtName);
                changed = obj.changed;
                newRng = obj.rng;
                it.rng = newRng;
                needRemoved = (0 === newRng.length);
                /*
                 * for the refer rng
                 */
                myRng = [it.opt.base];
                obj = checkRngFn(myRng, cdtName);
                changed = changed || obj.changed;
                newRng = obj.rng;
                it.opt.base = newRng[0];
                needRemoved = needRemoved || (0 === newRng.length);
            }else{
                var obj = checkRngFn(myRng, cdtName);
                changed = obj.changed;
                newRng = obj.rng;
                it.rng = newRng;
                needRemoved = (0 === newRng.length);
            }
			if(changed){
				needRefreshCdt = true;
				/*
				 * save the old cdt before change it
				 */
				var cid = it.id+'-'+sheetId;
				var old = store.getFloatingById(it.id, sheetId);
				oldCdtCache[cid] = {
					'name': it.id,
					'sheet': sheetId,
					'ftype': 'cdt',
					'json': old ? old.json : undefined
				};
				var json;
				if(needRemoved){
					if(!suspendUpdate){
						store.setFloatingItem(sheetId, it.id, 'cdt');
					}					
				}else{
					json = Ext.encode(it);
					if(!suspendUpdate){
						store.setFloatingItem(sheetId, it.id, 'cdt', json);
					}
				}		
				curCdtCache[cid] = {
					'name': it.id,
					'sheet': sheetId,
					'ftype': 'cdt',
					'json': json	
				}
			}			
		}	
		
		return {
			oldCdt: oldCdtCache,
			curCdt: curCdtCache,
			needRefreshCdt: needRefreshCdt
		};
	},
	
	
	
	/*
	 * before insert the column
	 */
	beforeInsertColumn : function(sheetId, mincol, colSpan, minrow, rowSpan, cdtArr, suspendUpdate){
        var me = this;
		var maxcol = mincol+colSpan-1, maxrow = minrow+rowSpan-1;
		var store = this.sheet.getStore(), needRefreshCdt, oldCdtCache = {}, curCdtCache = {}, rowColCdtCache = {}, newCdtCellsCache = {};
		/*
		 * get condition array
		 */
		cdtArr = cdtArr || store.getConditionBySheet(sheetId);
        var checkRngFn = function(rng, curCdtName){
            var changed = false, newRng = [];
           
            for(var i = 0, count = rng.length; i < count; i++){
                var rngItem = rng[i];
                var span = rngItem.span, type = rngItem.type;
                var top = span[1], bottom = span[3], left = span[2], right = span[4], flag = false;
           
                if(left || right){
                    if(0 === bottom){
                        rowColCdtCache[id] = it;
                    }
                    if((!minrow || minrow <= top) && (!maxrow || (bottom <= maxrow && 0 !== bottom))){
                        /*
                         * the removed region cover the condition rng totally
                         */
                        if(mincol <= right || 0 === right){
                            var leftCol = mincol <= left ? left+colSpan : left;
                            var rightCol = 0;
                            if(0 !== right){
                                rightCol = right+colSpan;
                            }
                            left = leftCol;
                            right = rightCol;
                            /*
                             * add new inserted cell in newCdtCells array
                             */
                            if(left < mincol){
                                var coord = newCdtCellsCache[id];
                                if(!coord){
                                    newCdtCellsCache[id] = {coord: [], name: curCdtName};
                                    coord = newCdtCellsCache[id].coord;
                                }else{
                                    coord = coord.coord;
                                }
                                coord.push([span[0], top, mincol, bottom, maxcol]);
                            }
                            flag = true;
                        }else{
                            newRng.push(rngItem);
                        }
                        if(flag){
                            changed = true;
                            span[2] = left;
                            span[4] = right;
                            newRng.push(rngItem);
                        }
                    }else if((top <= minrow && (minrow <= bottom || 0 === bottom)) || (top <= maxrow && (maxrow <= bottom || 0 === bottom))){
                        /*
                         * the removed region cover the condition rng partly
                         */
                        var topRow = minrow < top ? top : minrow, bottomRow = (0 !== bottom && maxrow > bottom) ? bottom : maxrow;
           
                        if(mincol <= right || 0 === right){
           
                            var leftCol = mincol <= left ? left+colSpan : left;
                            var rightCol = 0;
                            if(0 !== right){
                                rightCol = right+colSpan;
                            }
                            if(top < topRow){
                                if(0 === top){
                                    top = 1;
                                }
                                newRng.push({
                                    span: [span[0], top, left, topRow-1, right],
                                    type: SCONST['ABSOLUTE_COORD']
                                });
                            }
                            newRng.push({
                                span: [span[0], topRow, leftCol, bottomRow, rightCol],
                                type: SCONST['ABSOLUTE_COORD']
                            });
                            /*
                             * add new inserted cell in newCdtCells array
                             */
                            if(left < mincol){
                                var coord = newCdtCellsCache[id];
                                if(!coord){
                                    newCdtCellsCache[id] = {coord: [], name: curCdtName};
                                    coord = newCdtCellsCache[id].coord;
                                }else{
                                    coord = coord.coord;
                                }
                                coord.push([span[0], topRow, mincol, bottomRow, maxcol]);
                            }
                            if(bottom > bottomRow || 0 === bottom){
                                newRng.push({
                                    span: [span[0], bottomRow+1, left, bottom, right],
                                    type: SCONST['ABSOLUTE_COORD']
                                });
                            }
                            changed = true;
                        }else{
                            newRng.push(rngItem);
                        }
                    }else{
                        newRng.push(rngItem);
                    }
                }else{
                    newRng.push(rngItem);
                }
            }
            /*
             * try to connect the spans
             */
            newRng = me.sheet.connectSpan(newRng);
            return {
                rng: newRng,
                changed: changed
            }
        }
		for(var k = 0, len = cdtArr.length; k < len; k++){
			var it = cdtArr[k], id = it.id;
            var myRng = it.rng;
            var cdtName = it.name, changed, newRng, needRemoved;
            if('minichart' === cdtName){
                var obj = checkRngFn(myRng, cdtName);
                changed = obj.changed;
                newRng = obj.rng;
                it.rng = newRng;
                needRemoved = (0 === newRng.length);
                /*
                 * for the refer rng
                 */
                myRng = [it.opt.base];
                obj = checkRngFn(myRng, cdtName);
                changed = changed || obj.changed;
                newRng = obj.rng;
                it.opt.base = newRng[0];
                needRemoved = needRemoved || (0 === newRng.length);
            }else{
                var obj = checkRngFn(myRng, cdtName);
                changed = obj.changed;
                newRng = obj.rng;
                it.rng = newRng;
                needRemoved = (0 === newRng.length);
            }
			if(changed){
				needRefreshCdt = true;
				/*
				 * save the old cdt before change it
				 */
				var cid = it.id+'-'+sheetId;
				var old = store.getFloatingById(it.id, sheetId);
				oldCdtCache[cid] = {
					'name': it.id,
					'sheet': sheetId,
					'ftype': 'cdt',
					'json': old ? old.json : undefined
				};
				var json;
				if(needRemoved){
					if(!suspendUpdate){
						store.setFloatingItem(sheetId, it.id, 'cdt');
					}					           
				}else{
					json = Ext.encode(it);
					if(!suspendUpdate){
						store.setFloatingItem(sheetId, it.id, 'cdt', json);
					}
				}		
				curCdtCache[cid] = {
					'name': it.id,
					'sheet': sheetId,
					'ftype': 'cdt',
					'json': json	
				}
			}			
		}	
		
		return {
			oldCdt: oldCdtCache,
			curCdt: curCdtCache,
			needRefreshCdt: needRefreshCdt
		};
	},

	/*
	 * when remove cell, we need reset the tpl property
	 */
	beforeInsertCell : function(sheetId, row, col, rowSpan, colSpan, moveDir, merged, e, sheet){	
		
		if('down' == moveDir){
			return this.beforeInsertRow(sheetId, row, rowSpan, col, colSpan);
		}else if('right' == moveDir){
			return this.beforeInsertColumn(sheetId, col, colSpan, row, rowSpan);
		}
	},	
	
	/*
	 * reset condition for a new coord
	 */
	resetConditionData : function(cdtObj, store, sheetId, row, col, oldSheetId, oldRow, oldCol){
		//var rowOffset = row-oldRow, colOffset = col-oldCol;
		
		return cdtObj;
	},
	
	/**
	 * get the condition related coord
	 */
	getConditionRelatedCoord : function(cdts, sheetId){
		var store = this.sheet.getStore();
		var coord = [];
		for(var i = 0, len = cdts.length; i < len; i++){
			var cdt = cdts[i];
			cdt = store.getConditionById(cdt.id, sheetId);
			var name = cdt.name;
			if('minichart' == name){
				var opt = cdt.opt;
				coord = coord.concat(opt.base);
			}else{
				var rng = cdt.rng;
				for(var j = 0, count = rng.length; j < count; j++){
					coord.push(rng[j].span);
				}
			}
		}
		return coord;
	},
	
	/**
	 * when focus is changed
	 */
	onFocusChange : function(row, col, sm){		
		var sheet = this.sheet, store = sheet.getStore();
		var sheetId = sheet.getSheetId();
		var flag;
		
		var cdt = sheet.getConditionOfCell(sheetId, row, col, true);
		for(var i = 0, len = cdt.length; i < len; i++){
			var it = cdt[i];			
			if('vd' == it.name){
				var opt = it.opt;
				if(SCONST.validateDataType['list'] === opt.dt){
					var list = opt.list;
					flag = list;
                }else if(SCONST.validateDataType['date'] === opt.dt && !this.ignoreDate){
                    flag = 'date';
                }
			}
		}
        if(flag){
            var cls;
			this.listMenu.removeAll(true);
            if('date' === flag){
                cls = 'ss-date-picker';
                this.listMenu.add({
                    xtype: 'datepicker',
                    handler: this.selectDate, 
                    scope: this
                });
            }else{
                cls = 'icon-list-dot';
                for(var i = 0, len = flag.length; i < len; i++){
                    var it = flag[i];
                    this.listMenu.add({
                        text: it
                    });
                }
            }
			this.listMenu.bindPos = [sheetId, row, col];
			this.showListKit(row, col, cls);
		}else{
			this.hideListKit();
		}
	},
	
	/**
	 * init item list menu
	 */
	initListMenu : function(){
		this.listMenu = this.listMenu || new Ext.menu.Menu({
            plain: true,
			defaults: {
				scope: this,
				handler: this.selectItemFromList
			}
		}); 		
	},
	
	selectDate : function(picker, date){
		var pos = this.listMenu.bindPos;	
		this.skipHideListKitFlag = true;
		this.sheet.setCellData(pos[0], pos[1], pos[2], {
			'data': Ext.Date.format(date, 'Y-m-d'),
			'fm': 'date'
		});
		this.listMenu.hide();
		delete(this.skipHideListKitFlag);
	},
	
	/**
	 * select an item from list
	 */
	selectItemFromList : function(item){
		var menu = item.parentMenu;
		if(menu){
			var pos = menu.bindPos;
			this.skipHideListKitFlag = true;
			this.sheet.setCellData(pos[0], pos[1], pos[2], {
				'data': item.text
			});
			delete(this.skipHideListKitFlag);
		}
	},
	
	/**
	 * show a item list toolkit on the UI
	 */
	showListKit : function(row, col, iconCls){
        iconCls = iconCls || 'icon-list-dot';
		var store = this.sheet.getStore(), sheetId = this.sheet.getSheetId();
		var x = store.getRangeWidth(sheetId, 1, col)+this.kitOffset[0];
		var y = store.getRangeHeight(sheetId, 1, row-1)+this.kitOffset[1];
		if(!this.listKit){						
			this.listKit = new EnterpriseSheet.sheet.floating.Floor({
				sheet:this.sheet,
                localKit: true,                                                                    
				floatingConfig:{
					xtype:'button',
					iconCls: iconCls,						
					x:x,
					y:y,
					ddConfig:false,
					resizeConfig:false,
					destroyMenu: false,
					menu: true,
                    handler: function(btn){
                        this.listMenu.showBy(btn);
                    },
                    scope: this
				}
			});
		}else{
            this.listKit.setIconCls(iconCls);
			this.listKit.setXY([x, y]);
		}	
		/*
		 * ref to cell position in menu
		 */
		this.listMenu.cellPos = [sheetId, row, col];
		this.listKit.show();
	},
	
	/*
	 * hide the clipKit and destory related comp
	 */
	hideListKit : function(){
		if(this.listKit && !this.skipHideListKitFlag){			
			//this.summaryKit.destroy();
			//delete(this.summaryKit);
			this.listKit.hide();
		}
	},
           
    onChangeReadOnly : function(readOnly, sheet){
        if(readOnly){
            this.hideListKit();
        }
    }
}, function(){
    Ext.apply(EnterpriseSheet.sheet.calculate.Condition.prototype, {
        presetCdtObj : function(cdt, store){
            var ret = {};
            var rng = cdt.rng, cdtName = cdt.name;
            var coord = [];
            for(var i = 0, len = rng.length; i < len; i++){
                coord.push(rng[i].span);
            }
            var cells = [].concat(coord), refs = [];
            //cells = this.transferCoord2CellLookup(coord)
            if('boolstyle' === cdtName || 'minichart' === cdtName){
                var base = cdt.opt.base;
                if(Ext.isObject(base) && base.span){
                    coord.push(base.span);
                }
            }else if('colorbar' == cdtName){
                var opt = cdt.opt, min = opt.min, max = opt.max, curSheetId = store.getActivedSheetId();
                var o = this.transferCalculate({data: '='+min}, store, curSheetId, undefined, undefined);
                if(o.cal){
                    opt.minArg = o.arg;
                    if(o.refs){
                        refs = refs.concat(o.refs);
                    }
                }else{
                    delete(opt.minArg);
                }
                o = this.transferCalculate({data: '='+max}, store, curSheetId, undefined, undefined);
                if(o.cal){
                    opt.maxArg = o.arg;
                    if(o.refs){
                        refs = refs.concat(o.refs);
                    }
                }else{
                    delete(opt.maxArg);
                }
            }
            refs = refs.concat(coord);

            return Ext.apply(ret, {
                cells: cells,
                refs: refs
            });
        }, 
        
        generateHint : function(json){
        	var dtype = json.dt, op = json.op;
        	var text = '';    		
    		var dts = SCONST.validateDataType;
    		var options = SCONST.validateOption;
    		for(var p in dts){
    			if(dts[p] === dtype){
    				text = SLANG[p]+' : ';
    				break;
    			}
    		}
    		if(Ext.isDefined(op)){
	    		for(var p in options){
	    			if(options[p] === op){
	    				text += SLANG[p];
	    				break;
	    			}
	    		}
	    		if(dts['number'] === dtype){    
	    			var intOnly = json.io, min = json.min, max = json.max, num = json.num;
    				if(options['between'] === op || options['not_between'] === op){
    					text += ' ['+min+', '+max+']';
                    }else if(options['any_number'] !== op){
    					text += ' '+num;
    				}
    				
                    if(intOnly){
                        text += '; '+SLANG['integer_only'];
                    }
    			}else if(dts['date'] === dtype){
    				var mind = json.mind, maxd = json.maxd;
    				if(options['between'] === op || options['not_between'] === op){    					
    					text += ' ['+mind+', '+maxd+']';
    				}else if(options['is_date'] !== op){
    					text += ' '+json.date;
    				}
    			}else if(dts['text'] === dtype){
    				if(options['is_email'] !== op && options['is_url'] !== op){
    					text += ' "'+json['txt']+'"';
    				}
    			}
    		}else if(dts['list'] === dtype || dts['single_select'] === dtype){
    			text = SLANG['should_be_one_of']+' : {'+json['list'].join(', ')+'}';
    		}else if(dts['multi_options'] === dtype){
    			text = SLANG['should_be_part_of']+' : {'+json['list'].join(', ')+'}';
    		}else if(dts['checkbox'] === dtype){
    			text += SLANG['check_uncheck_only'];
    		}else if(dts['phone'] === dtype){
    			text += SLANG['phone_type_hint'];
    		}else if(dts['url'] === dtype){
    			text += SLANG['url_type_hint'];
    		}else if(dts['email'] === dtype){
    			text += SLANG['email_type_hint'];
    		}
    		
    		return text;
        }
    });
});
Ext.define('EnterpriseSheet.sheet.editor.ContentEditor', {
	
	/* Begin Definitions */
	
	extend: 'Ext.Component',	
	
	requires: [
	    'EnterpriseSheet.common.Common', 
	    'Ext.XTemplate'
	],
			
	/* End Definitions */		
	
	/*
	 * the key navigate throttled time
	 */
	keyDownThrottled : 10,
	
	/*
	 * class for editor
	 */
	cls: 'ss-fixed-editor',			
		
	renderSelectors : {
        innerEl: 'div.ss-editor-inner',
		editorEl: 'div.ss-html',
		cancelEl: 'div.ss-editor-cancel',
		completeEl: 'div.ss-editor-complete',
		dropEl: 'div.ss-editor-coord-drop'
	},		
	
	initComponent : function(){
		
		/*
		 * the render template for content el 
		 */
		this.renderTpl = new Ext.XTemplate(
            '<div class="ss-editor-inner">',
                '<div class="ss-cell ss-html" contentEditable="true" autocomplete="off"></div>',
                '<div class="ss-editor-complete"></div>',
                '<div class="ss-editor-cancel"></div>',
                '<div class="ss-editor-coord-drop"><div class="drop-arrow"></div></div>',
            '</div>',
			{
				compiled: true,
				disableFormats: false
			}
		);
	
		this.initCoordMenu();
		
		this.callParent();
		
		
		this.on({
			scope:this,							
			'quit': this.onQuitEdit
		});
		                
		this.on('keyup', this.onEditKeyUp, this, {buffer:50});				
           
        var me = this;
        /*
        Ext.create('Ext.app.Controller', {
            init : function(){
                this.control({
                    'menuitem': {
                        'click': function(item){
                            me.checkCompleteEdit(item);
                        }
                    },
                    'button': {
                        'click': function(item){
                            me.checkCompleteEdit(item);
                        }
                    }
                });
            }
        }).init();*/        
	},
           
    checkCompleteEdit : function(item, e){
    	if(item.parentMenu !== this.coordMenu){
    		var me = this;
            if(me.isEditing()){
                me.completeEdit();
                me.sheet.refreshFocus();
            }
    	}        
    },
    
	/*
	 * when finished editing, we need change back to select and hide the referenceModel
	 */
	onQuitEdit : function(){	
		var disabled = this.disabled;
		delete(this.available);		
		var sheet = this.sheet;
		var ghost = this.getGhost();
		if(ghost){			
			ghost.hide();
		}
		if(sheet){
			sheet.disableRefer();
			sheet.enableSelect();
			var rm;
			for(var i = 0, len = sheet.regionLookup.length; i < len; i++){
				var region = sheet[sheet.regionLookup[i]];
				if(region.isVisible()){
					rm = region.getReferenceModel();				
					if(rm){					
						rm.setKeepStack(false);
					}
				}
			}	
			if(rm){
				rm.hide();
			}
			
			sheet.fireEvent('quitedit', this, sheet, this.sheetId, this.row, this.col);
            var val = this.getValue();

			/*
			 * switch back to the editing sheet
			 */
			if(!disabled && EnterpriseSheet.sheet.calculate.Calculate.prototype.isCalculate(val) && sheet.getSheetId() != this.sheetId && Ext.isDefined(this.sheetId)){
				sheet.switchSheet(this.sheetId);
			}
			this.setValue('');
           
            // check cell onblur call back event ...
            sheet.onCellEventCallback("onCellBlurFn", this.sheetId, this.row, this.col);

            delete(this.sheetId);
        }
    },
	
	/*
	 * when inputing a calculate in editor, we will show the refered coord in the UI
	 */
	onEditKeyUp : function(e, row, col, region, editor){		
		var sheet = this.sheet;
		/*
		 * check whether it's available
		 */
		if(sheet && this.inputing && this.isAvailable()){
			this.processReferenceForEditing(this.getRawTextValue());
		}			
	},
	
	/*
	 * after start edit, we need check whether it's a calculate formula, if yes, then need show the related span in the calculate
	 * on UI
	 */
	afterStartEdit : function(){
		var sheet = this.sheet;
		if(sheet){
			var rm = sheet.getReferenceModel();		
			var val = this.getRawTextValue();
			if(sheet.calculate && sheet.calculate.couldbeCalculate(val)){		
				
				this.processReferenceForEditing(val);
				/*
				 * set it to true
				 */
				this.navigateFlag = true;
			}else{						
				rm.hide();
				/*
				 * delete it
				 */
				delete(this.navigateFlag);
				/*
				 * set move flag to true
				 */
				this.moveFlag = true;
			}
			this.fireEvent('afterstartedit', this, sheet);
			/*
			 * fire event through sheet
			 */
			sheet.fireEvent('afterstartedit', this, sheet);
           
            if(this.row && this.col){
                // check cell onfocus call back event ...
                sheet.onCellEventCallback("onCellFocusFn", sheet.getSheetId(), this.row, this.col);
            }
		}					
	},
	
	/*
	 * ask sheet to show the reference for calculate
	 */
	processReferenceForEditing : function(value){
		var sheet = this.sheet;
        if(!sheet.calculate.couldbeCalculate(value)){
            return;
        }
		this.syncReferenceFlag = true;
		
		if(sheet.syncReferenceForCalculate(value, undefined, true)){
			for(var i = 0, len = sheet.regionLookup.length; i < len; i++){
				var region = sheet[sheet.regionLookup[i]];
				if(region.isVisible()){
					var rm = region.getReferenceModel();				
					if(rm){					
						rm.pushSelection();
						rm.setKeepStack(true);
						rm.clearEl();
					}
				}
			}							
		}
		var selectedSpan = this.getSelectedCoordSpan();
		if(selectedSpan){
			var coordSpanStr = SCOM.getInnerText(selectedSpan.dom);
			var index = this.indexOfCoordSpanEl(selectedSpan.dom);			
			sheet.activeCoordSpan(coordSpanStr, index);
		}		
		this.syncReferenceFlag = false;
	},

	/*
	 * handler for editor special key, different key will cause different move
	 */
	afterSpecialKey : function(key){
		var region = this.region;					
		var sm = region.getSelectionModel(), pos;	
		var keyObj = Ext.EventObject ? Ext.EventObject : Ext.event.Event;
		if(keyObj.TAB == key || keyObj.RIGHT == key){				
			pos = sm.selectNext('col');
		}else if(keyObj.ENTER == key || keyObj.DOWN == key){			
			pos = sm.selectNext('row');
		}else if(keyObj.LEFT == key){
			pos = sm.selectPrevious('col');
		}else if(keyObj.UP == key){
			pos = sm.selectPrevious('row');
		}
		/*
		 * make sure the cell scroll to the view
		 */
		if(pos){					
			region.scrollCell2View(pos.row, pos.col);
		}		
		/*
		 * focus the region to get input focus
		 */		
		this.blurOff();
	},
	
	/*
	 * create a coord menu
	 */
	initCoordMenu : function(){
		this.relatedCoordItem = new Ext.menu.Item({
			handler: this.changeCoordStr,
			scope: this
		});
		this.relatedCoordWithSheetItem = new Ext.menu.Item({
			handler: this.changeCoordStr,
			scope: this
		});
		this.absoluteCoordItem = new Ext.menu.Item({
			handler: this.changeCoordStr,
			scope: this
		});
		this.absoluteCoordWithSheetItem = new Ext.menu.Item({
			handler: this.changeCoordStr,
			scope: this
		});
		this.absoluteRowCoordItem = new Ext.menu.Item({
			handler: this.changeCoordStr,
			scope: this
		});
		this.absoluteRowCoordWithSheetItem = new Ext.menu.Item({
			handler: this.changeCoordStr,
			scope: this
		});
		this.absoluteColCoordItem = new Ext.menu.Item({
			handler: this.changeCoordStr,
			scope: this
		});
		this.absoluteColCoordWithSheetItem = new Ext.menu.Item({
			handler: this.changeCoordStr,
			scope: this
		});
		this.coordMenu = new Ext.menu.Menu({
			cls:'color-menu',
			plain: true,
			minWidth: 160,
			items: [
			    '<span class="menu-title">'+SLANG['relative']+'</span>',    
			    this.relatedCoordItem,
			    this.relatedCoordWithSheetItem,
			    '-',
			    '<span class="menu-title">'+SLANG['absolute']+'</span>',
			    this.absoluteCoordItem,
			    this.absoluteCoordWithSheetItem,
			    '-',
			    '<span class="menu-title">'+SLANG['row_absolute']+'</span>',
			    this.absoluteRowCoordItem,
			    this.absoluteRowCoordWithSheetItem,
			    '-',
			    '<span class="menu-title">'+SLANG['column_absolute']+'</span>',
			    this.absoluteColCoordItem,
			    this.absoluteColCoordWithSheetItem
			]
		});	
		this.mon(this.coordMenu, {
			scope: this,
			'hide': function(){
				/*
				 * hide the drop
				 */
				this.dropEl.hide();
				this.focus(10);
			}
		});		
	},
	
	/*
	 * init this editor, bind it to a sheet
	 */	
	init : function(sheet){		
		this.sheet = sheet;
        /*
         * need set back reference for sheet
         */
        if(this.self.getName() == 'EnterpriseSheet.sheet.editor.ContentEditor'){
           sheet.contentEditor = this;
        }
		this.mon(sheet, {
        	scope: this,            
            'selectionchange': this.onSelectionChange,            
            'referencechange': this.onReferenceChange,                                
            'referencemouseup': this.onReferenceMouseUp,
            'startmovereference': this.startMoveReference,
            'movingreference': this.onMovingReference,
            'endmovereference': this.endMoveReference,
            'beforestartedit': this.onBeforeStartEditing,
            'switchsheet': this.onSwitchSheet,
            'prepareclickitem': function(){
                if(this.isAvailable()){
                    this.completeEdit();
                }
            }
        });
	},
	
	/*
	 * check when before start editing, if it's fired from other editor, then hide the current one
	 */
	onBeforeStartEditing : function(editor, sheet, sheetId, row, col, region){				
		if(false === sheet.checkDataTypeConfigBeforeEdit(sheetId, row, col, region) || false === sheet.checkCustomizedEvent('beforeEdit', sheetId, row, col, {region: region})){
			this.blurOff();
			this.cancelEdit();
			return false;
		}
		if(editor != this && this.isAvailable()){			
			this.blurOff();
			this.cancelEdit();
		}	
		if(true === this.disabled){
			return false;
		}
	},
	
	/*
	 * return true if the editor is avaiable
	 */
	isAvailable : function(){
		return this.available; 
	},
	
	/*
	 * when start to move the reference
	 */
	startMoveReference : function(draggingCoordSpan, rm){	
		if(!this.isAvailable()){
			return;
		}
		/*
		 * hide drop el
		 */
		this.dropEl.hide();
		
		var sheetId = this.region.getSheetId();		
		var dragSpan = draggingCoordSpan.span;	
		var colorIndex = draggingCoordSpan.colorIndex;
		var dragSpanStr = dragSpan.join('$');		
		var val = this.getValue();
		var me = this;
		/*
		 * only process the calcualte
		 */
		if(EnterpriseSheet.sheet.calculate.Calculate.prototype.couldbeCalculate(val)){
			var index = 0, stopFlag;
			EnterpriseSheet.sheet.calculate.Coordinate.prototype.spanReg.lastIndex = 0;
			var str = val.replace(EnterpriseSheet.sheet.calculate.Coordinate.prototype.spanReg, function(match){
				var pos = arguments[arguments.length-2];
				var str = arguments[arguments.length-1];						
				
				
				if(stopFlag){
					return;
				}
				var ret = EnterpriseSheet.sheet.calculate.Coordinate.prototype.assembleCoordByRegResult(arguments);
				if(ret){
					var span = ret.span;
					span[0] = sheetId;
					if(span.join('$') == dragSpanStr && colorIndex == index){
						var spanEls = Ext.DomQuery.jsSelect('span[class*="ss-cal-coord"]', me.el.dom);
						for(var i = 0, len = spanEls.length; i < len; i++){
							var spanEl = Ext.get(spanEls[i]);
							if(spanEl.hasCls('ss-cal-coord-selected')){
								spanEl.removeCls('ss-cal-coord-selected');
							}						
						}
						Ext.get(spanEls[index]).addCls('ss-cal-coord-selected');
						me.sheet.activeCoordSpan(match, index);
						/*
						 * set flag to true to stop the replace processing
						 */
						stopFlag = true;
					}
					index++;
				}
			});
		}		
	},
	
	/*
	 * when moving the reference
	 */
	onMovingReference : function(draggingCoordSpan, rm){
		if(!this.isAvailable()){
			return;
		}
		var val = this.getValue();
		var store = this.sheet.getStore(), curSheetId = this.sheet.getSheetId();
		/*
		 * only process the calcualte
		 */
		if(EnterpriseSheet.sheet.calculate.Calculate.prototype.couldbeCalculate(val)){
			var curSpan = [].concat(draggingCoordSpan.currentSpan);
			if(Ext.isNumber(curSpan[0])){
				curSpan[0] = store.getSheetNameById(curSpan[0]);
			}
			
			var ghost = this.getGhost();			
			var selectedSpan = this.getSelectedCoordSpan();			
			if(selectedSpan){					
				/*
				 * get old coord span
				 */
				var oldCoordSpan = SCOM.getInnerText(selectedSpan.dom);	
				var oldCoord = EnterpriseSheet.sheet.calculate.Coordinate.prototype.string2Coord(oldCoordSpan);
				var ctype = oldCoord[0].type;
				/*
				 * try to use the same format of the old coord span
				 */
				var str = EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String([{
					span: curSpan,
					type: ctype
				}], undefined, -1 != oldCoordSpan.indexOf('!') || this.sheetId != curSheetId);
				
				var color = selectedSpan.child('.bgc').getStyle('background-color');
                str = '<span class="ss-cal-fletter">'+str[0]+'</span>'+str.slice(1, -1)+'<span class="ss-cal-lletter">'+str[str.length-1]+'</span>';
				str = '<span class="bgc" style="background-color:'+color+';">'+str+'</span>';
				selectedSpan.update(str);				
				this.setValue(this.getGhostValue());				
			}
		}		
	},
	
	/*
	 * end move the reference
	 */
	endMoveReference : function(draggingCoordSpan, rm){
		if(!this.isAvailable()){
			return;
		}
		/*
		var span = this.getSelectedCoordSpan();
		if(span){
			span.removeCls('ss-cal-coord-selected');					
		}*/
		/*
		 * simulate keyup
		 */		
		this.fireEvent('keyup', null, this.row, this.col, this.region, this, true);
		/*
		 * refocus
		 */
		this.focus();
		/*
		 * reset cursor to the last place
		 */
		this.resumeCursorPosition();
		/*
		 * set navigate flag
		 */
		this.navigateFlag = true;
	},
	
	/*
	 * when mouse up on the reference
	 */
	onReferenceMouseUp : function(){
		if(this.isAvailable()){
			
			var span = this.getSelectedCoordSpan();
			if(span){
				span.removeCls('ss-cal-coord-selected');					
			}
			/*
			 * re show the coord span because it could insert the coord in some where
			 */
			this.showCoordSpan(this.getValue());
			/*
			 * simulate keyup
			 */		
			this.fireEvent('keyup', null, this.row, this.col, this.region, this, true);
			this.focus();	
			/*
			 * reset cursor to the last place
			 */
			this.resumeCursorPosition();
			/*
			 * set navigate flag
			 */
			this.navigateFlag = true;
		}		
	},
	
	/*
	 * resume the cursor position
	 */
	resumeCursorPosition : function(){
		var editorEl = this.getEditorEl();
		if(editorEl && !SCOM.nullOrUndefined(this.lastCursorPos)){	
			if(0 !== this.lastCursorPos || this.getValue()){
				SCOM.setCursorPosition(editorEl.dom, this.lastCursorPos);
			}							
		}
	},
	
	/*
	 * extend onRender
	 */
	onRender : function(){
		this.callParent(arguments);		
		
		var el = this.getEl();				
		
		this.addListener2Element();		
	},	
	
	/*
	 * add listeners to element
	 */
	addListener2Element : function(){
		var el = this.getEditorEl();			
		var me = this;			
		if(el){					
			el.swallowEvent(['mousedown']);
			this.mon(el, {
				scope : this,				
				'focus' : this.onEditorFocus,				
				'blur' : function(){
					this.fireEvent('editorblur', this);
                    if(this.inputing){
                        this.inputing = false;
                    }
				},
				'keydown': this.onEditorElKeyDown,
				'keypress': this.onEditorElKeyPress,
				'keyup':this.onEditorElKeyUp,
				'mousedown': this.onEditorElMouseDown,
				'mousemove': this.onEditorElMouseMove				
			});			
			
			/*
			 * add click on this.el
			 */
			this.mon(this.el, {
				scope: this,
				'click': this.onElClick
			});
			/*
			 * click on drop el
			 */
			this.mon(this.dropEl, {
				scope: this,
				'mousedown': this.onEditorElMouseDown
			});
			/*
			 * click on cancel el and complete el
			 */
			this.mon(this.completeEl, {
				scope: this,
                'click': function(){
                     this.completeEdit();
                }
			});
			this.mon(this.cancelEl, {
				scope: this,
				'click': this.cancelEdit
			});
		}
	},
	
	/*
	 * on focuse editor
	 */
	onEditorFocus : function(){
        this.fireEvent('editorfocus', this);
		/*
		 * set a flag, means it's inputing
		 */
		this.inputing = true;				
		
		if(!this.available){
           
			this.available = true;
			var sheet = this.sheet;
			if(sheet){
				var sm = sheet.getSelectionModel();
				var focusCell = sm.getFocusCell();								
				var val = this.getValue();
				
				var flag = this.startEdit(focusCell.row, focusCell.col, sheet.getCurrentRegion(), undefined, true, val);
									
				/*
				 * delete the navigate flag
				 */
				delete(this.navigateFlag);
				delete(this.moveFlag);
				if(false === flag){
					return;
				}
				if(SCOM.nullOrUndefined(this.lastCursorPos)){
					/*
					 * move cursor to end
					 */
					this.lastCursorPos = val.length;
					/*
					 * move cursor to the end of text
					 */
					SCOM.moveCursor2End(this.getEditorEl().dom);
				}else{
					/*
					 * resume the cursor
					 */
					this.resumeCursorPosition();
				}
				
			}
		}					
	},
	
	/*
	 * listeners for editor key
	 */
	onEditorElKeyDown : function(e){
		this.dropEl.hide();
		var editEl = this.getEditorEl();
		
		
		if(this.isAvailable()){
			var val = this.getValue();
			var isCal = EnterpriseSheet.sheet.calculate.Calculate.prototype.couldbeCalculate(val);
			var key = e.getKey();	
			var keyObj = Ext.EventObject ? Ext.EventObject : Ext.event.Event;
			if(keyObj.ESC == key){
				e.stopEvent();
				if(false !== this.sheet.fireEvent('beforeeditorspecialkey', key, this, this.sheet)){							
					this.cancelEdit();
					this.afterSpecialKey(key);					
					this.fireEvent('specialkey', this, this.region, key);					
					this.sheet.fireEvent('loseeditingfocus', this);
				}
				return;
			}else if(keyObj.ENTER == key || keyObj.TAB == key){
                var asArrayFormula = false;
                
                if(true === e.ctrlKey && true === e.shiftKey && keyObj.ENTER === key){
                    asArrayFormula = true;
                }else if(true === e.shiftKey && !isCal){
					return;
				}
				e.stopEvent();
				var flag = false !== this.sheet.fireEvent('beforeeditorspecialkey', key, this, this.sheet, asArrayFormula);
				if(flag){					
					this.completeEdit(asArrayFormula);
					this.afterSpecialKey(key);
					this.fireEvent('specialkey', this, this.region, key, asArrayFormula);
				}			
				return;
			}		
			/*
			 * check the coord change, if changed then update the color span
			 */
			if(isCal){
				if(Ext.isWebKit){
					Ext.Function.defer(this.checkCoordChange, 5, this);
				}else{
					this.checkCoordChange();
				}
			}						
			if(this.processNavigateKey(e, this.row, this.col)){
				/*
				 * for navigate key we stop event and resume cursor position
				 */
				e.stopEvent();
				if(isCal){
					this.resumeCursorPosition();
				}				
			}else{
				return this.fireEvent('keydown', e, this.row, this.col, this.region, this);
			}
		}else{
			return this.fireEvent('keydown', e, this.row, this.col, this.region, this);
		}			
	},
	
	/*
	 * one editor el key press
	 */
	onEditorElKeyPress : function(e){			
		if(this.isAvailable()){
			var val = this.getValue();
			if(EnterpriseSheet.sheet.calculate.Calculate.prototype.couldbeCalculate(val)){
				/*
				 * cache the cursor pos
				 */	
				this.cacheCursorPos();
			}			
			this.fireEvent('keypress', e, this.row, this.col, this.region, this);
		}									
	},
	
	/*
	 * navigate reference
	 * @param {boolean} shift: ture then expand the reference instead of move it
	 * @param {string} dir: the 'row' or 'col' to navigate
	 * @param {boolean} backward: true to move back, or move next
	 */
	navigateReference : function(shift, dir, backward){
		if(!this._navigating){
			this._navigating = true;
			var sheet = this.sheet;
			var rm = sheet.getReferenceModel();			
			var pos;
			if(backward){
				pos = rm.selectPrevious(dir, shift);
			}else{
				pos = rm.selectNext(dir, shift);
			}			
			if(pos && this.region){
				this.region.scrollCell2View(pos.row, pos.col);
			}
			/*
			 * set thrrottled for the navigate listener
			 */
			Ext.Function.defer(function(){
				delete(this._navigating);
			}, this.keyDownThrottled, this);
		}		
	},	
	
	/*
	 * process key down event
	 */
	processNavigateKey : function(e, row, col){		
		/*
		 * if navigate flag is true then we will listen the navigate key
		 */		
		this.isNavigateKey = false;
		var key = e.getKey();
		if(e.DOWN == key){
			if(false === this.sheet.fireEvent('editornavigatedown', this, this.sheet)){
				this.isNavigateKey = true;				
				return true;
			}			
		}else if(e.UP == key){
			if(false === this.sheet.fireEvent('editornavigateup', this, this.sheet)){
				this.isNavigateKey = true;
				return true;
			}			
		}
		
		if(this.navigateFlag){
			var shift = e.shiftKey;
			var dir, backward, navigatedRow, navigatedCol;
			if(e.DOWN == key){				
				dir = 'row';	
				navigatedRow = row+1;
				navigatedCol = col;
			}else if(e.UP == key){				
				dir = 'row';
				backward = true;
				navigatedRow = row-1;
				navigatedCol = col;
			}else if(e.LEFT == key){
				dir = 'col';
				backward = true;
				navigatedRow = row;
				navigatedCol = col-1;
			}else if(e.RIGHT == key){
				dir = 'col';		
				navigatedRow = row;
				navigatedCol = col+1;
			}
			if(dir){
				this.isNavigateKey = true;
				var sheet = this.sheet, sheetId = sheet.getSheetId();
				var rm = sheet.getReferenceModel();
				var shift = e.shiftKey, key = e.getKey();
				var span = this.getSelectedCoordSpan();
				if(span){
					var coordStr = SCOM.getInnerText(span.dom);
					var coord = EnterpriseSheet.sheet.calculate.Coordinate.prototype.string2Coord(coordStr);
					var coordSpan = coord[0].span;					
					if(!Ext.isNumber(coordSpan[0]) || coordSpan[0] == sheetId){														
						this.navigateReference(shift, dir, backward);
					}					
				}else{		
					/*
					 * clear the anchor cell of reference model
					 */
					rm.setAnchorCell();
					rm.selectRange({row: navigatedRow, col: navigatedCol}, {row: navigatedRow, col: navigatedCol});
					var navigateSpan = rm.selection2Span();		
					var spanInfo = this.getCoordSpanInfo(navigateSpan);
					if(spanInfo){
						var spanEl = spanInfo.el, colorIndex = spanInfo.colorIndex;
						spanEl.addCls('ss-cal-coord-selected');						
					}
				}
				return true;
			}					
		}else if(this.moveFlag && (e.LEFT == key || e.RIGHT == key || e.UP == key || e.DOWN == key)){
			e.stopEvent();
			var flag = false !== this.sheet.fireEvent('beforeeditorspecialkey', key, this, this.sheet);			
			if(flag){
				this.getEditorEl().blur();
				this.completeEdit();
				this.afterSpecialKey(key);
				this.fireEvent('specialkey', this, this.region, key);
			}
		}
	},
	
	onEditorElKeyUp : function(e){		
		if(this.isNavigateKey || !this.isAvailable()){			
			return;
		}
		/*
		 * update the el cls by check whether it's a calculate
		 */
		var val = this.getValue(), ghost = this.getGhost();
		var isCal = false;
		if(EnterpriseSheet.sheet.calculate.Calculate.prototype.couldbeCalculate(val) && !this.disableCalEditorStyle){
			this.el.addCls('ss-editor-calculate');		
			if(ghost && !ghost.isVisible()){				
				ghost.show();
			}						
			
			var selectedSpan = this.getSelectedCoordSpan();
			if(selectedSpan){
				selectedSpan.removeCls('ss-cal-coord-selected');
			}
			/*
			 * cache the cursor pos
			 */	
			this.cacheCursorPos();	
			/*
			 * check the coord change, if changed then update the color span
			 */					
			this.checkCoordChange();
			isCal = true;
		}else{
			this.el.removeCls('ss-editor-calculate');		
			if(ghost && ghost.isVisible()){
				ghost.hide();
			}		
			/*
			 * cache the cursor pos
			 */	
			//this.cacheCursorPos();	
		}
				
		this.fireEvent('keyup', e, this.row, this.col, this.region, this, isCal);
		/*
		 * fire an event through sheet
		 */
		if(this.sheet){			
			this.sheet.fireEvent('editorkeyup', e, this.row, this.col, this.region, this, isCal);
		}
	},
	
	/*
	 * if click on drop el, then show the coord menu
	 */
	onElClick : function(e){
		if(!this.isAvailable()){
			return;
		}
		var target = e.getTarget('.ss-editor-coord-drop', null, true);
		if(target){
			var store = this.sheet.getStore();
			/*
			 * get the span this drop show by
			 */
			var span = target.showBySpan;
			var coordStr = SCOM.getInnerText(span.dom);
			var coordProto = EnterpriseSheet.sheet.calculate.Coordinate.prototype;
			var coord = coordProto.string2Coord(coordStr);
			var coordSpan = coord[0].span;
			if(!coordSpan[0]){
				var sheetId = this.sheet.getSheetId();
				coordSpan[0] = store.getSheetNameById(sheetId);		
			}
			coord[0].type = SCONST.RELATIVE_COORD;
			/*
			 * transfer to relative coordinate
			 */
			var relativeCoordStr = coordProto.coord2String(coord, '');
			this.relatedCoordItem.setText(relativeCoordStr);				
			var relativeCoordWithSheetStr = coordProto.coord2String(coord, '', true);
			this.relatedCoordWithSheetItem.setText(relativeCoordWithSheetStr);
			/*
			 * transfer to absolute coordinate
			 */
			coord[0].type = SCONST.ABSOLUTE_COORD;
			var abCoordStr = coordProto.coord2String(coord);
			this.absoluteCoordItem.setText(abCoordStr);
			var abCoordWithSheetStr = coordProto.coord2String(coord, undefined, true);
			this.absoluteCoordWithSheetItem.setText(abCoordWithSheetStr);
			/*
			 * transfer to absolute row coordinate
			 */
			coord[0].type = SCONST.ABSOLUTE_ROW_COORD;
			var abCoordStr = coordProto.coord2String(coord);
			this.absoluteRowCoordItem.setText(abCoordStr);
			var abCoordWithSheetStr = coordProto.coord2String(coord, undefined, true);
			this.absoluteRowCoordWithSheetItem.setText(abCoordWithSheetStr);
			/*
			 * transfer to absolute row coordinate
			 */
			coord[0].type = SCONST.ABSOLUTE_COL_COORD;
			var abCoordStr = coordProto.coord2String(coord);
			this.absoluteColCoordItem.setText(abCoordStr);
			var abCoordWithSheetStr = coordProto.coord2String(coord, undefined, true);
			this.absoluteColCoordWithSheetItem.setText(abCoordWithSheetStr);
			/*
			 * save the span ref
			 */
			this.coordMenu.relatedCoord = {
				span: span,
				coord: coord
			};
			/*
			 * show menu
			 */
			this.coordMenu.showBy(target);
		}
	},
	
	/*
	 * mouse over the editor
	 */
	onEditorElMouseMove : function(e){
		if(!this.isAvailable()){
			return;
		}
		var el = this.el;
		if(el.hasCls('ss-editor-calculate')){
			var ghostEl = this.getGhost();
			var xy = e.getXY();
			var x = xy[0], y = xy[1];

			var spans = Ext.DomQuery.jsSelect('span[class*="ss-cal-coord"]', el.dom);		
			var found;
			var rm = this.sheet.getReferenceModel();
			for(var i = 0, len = spans.length; i < len; i++){
				var span = Ext.get(spans[i]);
                var l = span.getLeft(), r = span.getRight(), t = span.getTop(), b = span.getBottom();
                if(20 < span.getHeight()){
                    var firstLetter = span.down('.ss-cal-fletter'), lastLetter = span.down('.ss-cal-lletter');
                    if(l <= x && x <= lastLetter.getRight() && lastLetter.getTop() <= y && y <= b){
                        found = span;
                        break;
                    }else if(firstLetter.getLeft() <= x && x <= r && t <= y && y <= firstLetter.getBottom()){
                        found = span;
                        break;
                    }
                }else if(l <= x && x <= r && t <= y && y <= b){
					found = span;				
					break;
				}
			}
			if(found){
				var color = found.child('.bgc').getStyle('background-color');
                var firstLetter = found.down('.ss-cal-fletter'), lastLetter = found.down('.ss-cal-lletter');
				this.dropEl.setStyle('background-color', color);
				var dropWidth = this.dropEl.getWidth();
				var spanWidth = found.getWidth();
				/*
				 * set the position
				 */
				if(dropWidth > spanWidth-10){
					/*
					 * adjust drop pos
					 */
					this.dropEl.setLeft(lastLetter.getRight()-ghostEl.getLeft());
				}else{
					this.dropEl.setLeft(lastLetter.getRight()-ghostEl.getLeft()-13);
				}
                this.dropEl.setTop(lastLetter.getTop()-ghostEl.getTop());
				/*
				 * save the current show by span
				 */
				this.dropEl.showBySpan = span;
				this.dropEl.show();
			}else{
				this.dropEl.hide();
			}
		}else{
			this.dropEl.hide();
		}		
	},
		
	/*
	 * mouse down on editor
	 */
	onEditorElMouseDown : function(e){
		if(!this.isAvailable()){
			return;
		}
		/*
		 * delete the navigate flag
		 */
		delete(this.navigateFlag);
		delete(this.moveFlag);
		
		var val = this.getValue();
		if(EnterpriseSheet.sheet.calculate.Calculate.prototype.couldbeCalculate(val)){
			var target = e.getTarget('.ss-editor-coord-drop', null, true);
			if(target){
				return;
			}
			var el = this.el;
			/*
			 * diselect old ones first
			 */
			var sels = Ext.DomQuery.jsSelect('span[class*="ss-cal-coord-selected"]', el.dom);
			var selCoord;
			for(var i = 0, len = sels.length; i < len; i++){
				var sel = Ext.get(sels[i]);				
				sel.removeCls('ss-cal-coord-selected');			
				selCoord = SCOM.getInnerText(sel.dom);
			}
			/*
			 * select the new one if need
			 */
			var xy = e.getXY();
			var x = xy[0], y = xy[1];
			var spans = Ext.DomQuery.jsSelect('span[class*="ss-cal-coord"]', el.dom);		
			var found, foundIndex;
			
			for(var i = 0, len = spans.length; i < len; i++){
				var span = Ext.get(spans[i]);
                var l = span.getLeft(), r = span.getRight(), t = span.getTop(), b = span.getBottom();
                if(20 < span.getHeight()){
                    var firstLetter = span.down('.ss-cal-fletter'), lastLetter = span.down('.ss-cal-lletter');
                    if(l <= x && x <= lastLetter.getRight() && lastLetter.getTop() <= y && y <= b){
                        found = span;
                        foundIndex = i;
                        break;
                    }else if(firstLetter.getLeft() <= x && x <= r && t <= y && y <= firstLetter.getBottom()){
                        found = span;
                        foundIndex = i;
                        break;
                    }
                }else if(l <= x && x <= r && t <= y && y <= b){
                    found = span;
                    foundIndex = i;
                    break;
                }
			}
            if(found){
                found.addCls('ss-cal-coord-selected');
                var coordStr = SCOM.getInnerText(found.dom);
                this.fireEvent('activecoordspan', coordStr, foundIndex, this);
                this.sheet.activeCoordSpan(coordStr, foundIndex);
            }else if(selCoord){
				this.sheet.deactiveCoordSpan();
				this.fireEvent('deactivecoordspan', selCoord, this);
			}	
			/*
			 * cache the cursor pos
			 */		
			Ext.Function.defer(this.cacheCursorPos, 100, this);
		}		
	},		
	
	/*
	 * get the editor element
	 */
	getEditorEl : function(){
		return this.editorEl;
	},
	
	getGhost : function(){
		return this.el.down('.ss-editor-ghost');
	},	
	
	/*
	 * get value and set value
	 */
	getValue : function(){
		var dom = this.editorEl.dom;
		var val = SCOM.getInnerText(dom);		
		val = Ext.util.Format.htmlDecode(val);
		/*
		 * strange issues
		 */
		if('\n' == val){
			val = '';
		}
		
		return val;
	},
	
	getGhostValue : function(){
		var ghost = this.getGhost();
		if(ghost){
			var dom = ghost.dom;
			return SCOM.getInnerText(dom);
		}
	},
	
	getHTMLValue : function(){
		if(this.editorEl){
			return this.editorEl.dom.innerHTML;
		}
	},
	
	getTextValue : function(val){
		if(this.editorEl){
			var dom = this.editorEl.dom;
			if(SCOM.nullOrUndefined(val)){
				val = SCOM.getInnerText(dom);
			}			
			//val = Ext.util.Format.htmlDecode(val);
			/*
			 * strange issues
			 */
			if('\n' == val){
				val = '';
			}
			val = Ext.util.Format.htmlEncode(val);
			val = val.replace(/\n/gi, '<br/>');
			
			return val;
		}
	},
	
	getRawTextValue : function(val){
		if(this.editorEl){
			var dom = this.editorEl.dom;
			if(SCOM.nullOrUndefined(val)){
				val = SCOM.getInnerText(dom);
			}
			if('\n' == val){
				val = '';
			}
			return val;
		}
	},
	
	setValue : function(v, syncGhost){
		if(this.editorEl){
			//this.editorEl.dom.innerHTML = Ext.util.Format.htmlEncode(v);				
			
			this.editorEl.dom.innerHTML = v;
			if(syncGhost){
				/*
				 * if true then check the coord
				 */
				this.checkCoordChange();
			}
		}
	},
     
    
	
	/*
	 * complete edting
	 */
	completeEdit : function(asArrayFormula){
        var sheet = this.sheet;
		if(false !== sheet.fireEvent('beforecompleteedit', this.sheetId, this.row, this.col, this, asArrayFormula)){
			var store = sheet.getStore(), sm = sheet.getSelectionModel();
			if(!this.holdComplete){		
				this.holdComplete = true;
				delete(this.editing);
				
                sheet.fireEvent('preparecompleteedit', this.sheetId, this.row, this.col, this, asArrayFormula);
				var rawValue = this.getRawTextValue(), isCal = EnterpriseSheet.sheet.calculate.Calculate.prototype.couldbeCalculate(rawValue);
				/*
				 * check the '(' and ')' for calculate
				 */
				if(isCal){
					rawValue = this.checkCalculateValid(rawValue);
				}
			
				var data = {data: rawValue};			
				
				var cell = store.getCellData(this.sheetId, this.row, this.col);	
				if((cell.data !== rawValue) || (isCal && asArrayFormula) || (isCal && !asArrayFormula && Ext.isNumber(cell.afrow))){
					/*
					 * only if the value is changed
					 */
					if(!SCOM.nullOrUndefined(rawValue) && '' != rawValue){
						if(SCOM.nullOrUndefined(cell.fm) || '' == cell.fm){							
							var o = SFORMAT.decideFormat(rawValue);
							Ext.apply(data, o);
						}else{
							var o = SFORMAT.syncFormat(rawValue, cell.fm);
							Ext.apply(data, o);
						}
					}
                    if(isCal && asArrayFormula){
                        var afrow = cell.afrow+this.row, afcol = cell.afcol+this.col, aerow = cell.aerow, aecol = cell.aecol;
                        if(Ext.isNumber(afrow)){
                            if(afrow !== this.row || afcol !== this.col){
                                cell = store.getCell(this.sheetId, afrow, afcol);
                                aerow = cell.aerow;
                                aecol = cell.aecol;
                            }
                            aerow += this.row;
                            aecol += this.col;
                            var oldSpan = [this.sheetId, afrow, afcol, aerow, aecol];
                            var pos = sm.getMinMaxPos(), span = [store.getActivedSheetId(), pos.minrow, pos.mincol, pos.maxrow, pos.maxcol];
                            if(EnterpriseSheet.sheet.calculate.Coordinate.prototype.isIncludedSpan(span, oldSpan)){
                                sheet.setArrayFormulaForSpan(span, data);
                            }else{
                                sheet.setArrayFormulaForSpan(oldSpan, data);
                            }
                        }else{
                            sheet.setArrayFormulaForSelection(data);
                        }
                    }else{
                        if(Ext.isNumber(cell.afrow)){
                            /*
                             * means it gonna to change a part of the array formula, need be stop
                             */
                            this.cancelEdit();
                            sheet.fireEvent('try2changepartofarrayformula', this.sheetId, this.row, this.col, this, sheet);
                            return false;
                        }
                        sheet.setCellData(this.sheetId, this.row, this.col, data, ['afrow', 'afcol', 'aerow', 'aecol']);
                    }
					/*
					 * check the format for the formula cell again
					 */
                    /*
					var cellData = sheet.getCellValue(this.sheetId, this.row, this.col);
					var val = cellData.value;
					
					if(!SCOM.nullOrUndefined(val) && '' != val){
						if(SCOM.nullOrUndefined(cell.fm) || '' == cell.fm){
							var o = SFORMAT.decideFormat(val);
							if(o){
								var fm = o.fm, dfm = o.dfm;
								if(fm !== cellData.fm || dfm !== cellData.dfm){
                                    store.setCell(this.sheetId, this.row, this.col, {'fm': fm, 'dfm': dfm});
								}								
							}
						}
					}*/
				}		
				this.dropEl.hide();			
				/*
				 * fire event to quit editing
				 */
				sheet.fireEvent('completeedit', this.sheetId, this.row, this.col, this, asArrayFormula);
				this.fireEvent('quit', this, this.sheetId, this.row, this.col);
				Ext.defer(function(){				
					delete(this.holdComplete);
				}, 10, this);
			}	
		}else{
			delete(this.editing);
		}	
	},
	
	isEditing : function(){
		return this.editing;
	},
	
	/*
	 * cancel editing
	 */
	cancelEdit : function(){
		this.holdComplete = true;
		delete(this.editing);
		
		/*
		 * fire event to quit editing
		 */
		this.fireEvent('quit', this, this.sheetId, this.row, this.col);
        if(this._originVal){
            if(Ext.isNumber(this.cell.afrow)){
                this.setValue('{'+Ext.htmlEncode(this._originVal)+'}');
           }else{
                this.setValue(Ext.htmlEncode(this._originVal));
           }
        }else{
           this.setValue('');
        }
		//this.focus();
		Ext.defer(function(){			
			delete(this.holdComplete);
		}, 10, this);
	},		
	
	/*
	 * override startEdit to plant some more params
	 * @param {int} row: the row index
	 * @param {int} col: the column index
	 * @param {EnterpriseSheet.sheet.regions.Region} region: the Region ref
	 * @param {Ext.EventObject} e: the event object
	 * @param {boolean} noNeedFocus: true to stop focus the editor when it show
	 */
	startEdit : function(row, col, region, e, noNeedFocus, preVal){		
		var store = region.getStore();
		var sheetId = region.getSheetId();
		/*
		 * reset last cursor pos
		 */
		delete(this.lastCursorPos);
		preVal = preVal || '';		
		
		if(0 == row || 0 == col){
			/*
			 * if it's header/lefter/corner, then return, can not be edit
			 */
			return false;
		}
		var cell = store.getCellData(sheetId, row, col);
		
		if(store.isMergedCell(undefined, sheetId, row, col)){
			
			row += cell.minrow;
			col += cell.mincol;
			cell = store.getCellData(sheetId, row, col);
		}		
		/*
		 * fire beforestartedit event
		 */		
		if(false === this.sheet.fireEvent('beforestartedit', this, this.sheet, sheetId, row, col, region)){			
			this.inputing = false;
			this.available = false;					
			return false;
		}
		
		/*
		 * set inputing flag to true
		 */
		this.inputing = true;	
		/*
		 * set editing flag
		 */
		this.editing = true;
		
		this.noNeedFocus = noNeedFocus;
		this.region = region;		
		
		this.sheetId = sheetId;
		this.row = row;
		this.col = col;
		/* 
		 * if this cell is not fully shown, we will scroll the view to show the cell first
		 */
		region.scrollCell2View(row, col);
				
		this.cell = cell;
				
		/*
		 * save the origin value
		 */
		this._originVal = cell.data || '';
        if(Ext.isNumber(cell.afrow)){
            var afrow = cell.afrow+row, afcol = cell.afcol+col;
            var afCell = store.getCell(sheetId, afrow, afcol);
            this._originVal = afCell.data || '';
        }
		var val = true === preVal ? this.getValue() : this._originVal;
		
		var flag = EnterpriseSheet.sheet.calculate.Calculate.prototype.couldbeCalculate(val);

		/*
		 * render and adjust editor position
		 */
		this.adjustEditorPos(flag);
        
		
		var editorEl = this.getEditorEl();						
           
		if(flag && !this.disableCalEditorStyle){
			this.el.addCls('ss-editor-calculate');				
			/*
			 * encode the calculate str
			 */				
			this.showCoordSpan(val);					
		}else{
			this.el.removeCls('ss-editor-calculate');				
		}		
		
		if(true !== preVal){
            var hval = Ext.htmlEncode(val);
            if(Ext.isString(hval)){
                hval = hval.replace(/\n/gi, '<br/>');
            }
			this.setValue(hval);
		}				
		
		if(!noNeedFocus){	
			/*
			 * here need a little bit delay for the focus
			 */
			this.focus(Ext.isIE ? 50 : 10);
			SCOM.moveCursor2End(this.getEditorEl().dom);
		}			
		/*
		 * after start editing
		 */
		this.afterStartEdit();		
	},
	
	/*
	 * an empty interface for subclass use to adjust editor position before starting edit
	 */
	adjustEditorPos : function(flag){
		
	},
	
	/*
	 * generate coord span based on the value
	 */
	generateCoordSpan : function(val, colorOffset){				
		var colors = SCOM.colors;
		var calculate = this.sheet.getCalculate();	
		var index = colorOffset || 0, count = 0;
		EnterpriseSheet.sheet.calculate.Coordinate.prototype.spanReg.lastIndex = 0;
		var str = val.replace(EnterpriseSheet.sheet.calculate.Coordinate.prototype.spanReg, function(match){
			var pos = arguments[arguments.length-2];
			var str = arguments[arguments.length-1];						
			var ret = EnterpriseSheet.sheet.calculate.Coordinate.prototype.assembleCoordByRegResult(arguments);
			if(!ret){
				return match;
			}
			/*
			 * show different color
			 */
			var color = colors[index%colors.length];
			var spanStr;				
			if(/[^0-9a-zA-Z]$/gi.test(match)){
				var len = match.length;
				var pre = match.slice(0, -1), pos = match.slice(len-1, len);
                pre = '<span class="ss-cal-fletter">'+pre[0]+'</span>'+pre.slice(1, -1)+'<span class="ss-cal-lletter">'+pre[pre.length-1]+'</span>';
				spanStr = '<span class="ss-cal-coord">'
					+'<span class="bgc" style="background-color:'+color+';">'+pre+'</span></span>'+pos;
			}else{
                match = '<span class="ss-cal-fletter">'+match[0]+'</span>'+match.slice(1, -1)+'<span class="ss-cal-lletter">'+match[match.length-1]+'</span>';
				spanStr = '<span class="ss-cal-coord">'
					+'<span class="bgc" style="background-color:'+color+';">'+match+'</span></span>';
			}							
			index++;	
			count++;
			return spanStr;
		});
		return {
			html: str,
			coordSpanCount: count 
		};
	},
	
	/*
	 * show the coord span in a different background color
	 */
	showCoordSpan : function(val){						
		var calculate = this.sheet.getCalculate();		
		if(calculate && calculate.couldbeCalculate(val)){	
			
			var selectedSpan = this.getSelectedCoordSpan(), index;			
			if(selectedSpan){
				index = this.indexOfCoordSpanEl(selectedSpan.dom);
			}
			
			val = this.generateCoordSpan(val).html;					
			var ghost = this.getGhost();
			if(ghost){
				ghost.update(val);
				if(!ghost.isVisible()){					
					ghost.show();
				}
			}else{
				val = '<span class="ss-editor-ghost">'+val+'</span>';
				Ext.core.DomHelper.insertFirst(this.innerEl.dom, val);
			}
			if(selectedSpan){
				var spanEl = this.getCoordSpanByIndex(index);
				if(spanEl){
					spanEl = Ext.get(spanEl);
					spanEl.addCls('ss-cal-coord-selected');
				}							
			}			
		}			
	},	
	
	
	/*
	 * focus the editor
	 */
	focus : function(delay) {
		var el = this.getEditorEl();
		if(el && el.isVisible()){			
			el.focus(delay);
		}        
        return this;
    },
    
    blurOff : function(){
    	var el = this.getEditorEl();
    	if(el){
    		el.blur();
    	}
    },        				    
	
	/*
	 * update the text in editor when reference change
	 */
    onSelectionChange : function(startPos, endPos, region, sm){    	
    	if(this.editing){
    		var val = this.getValue();
    		if(!EnterpriseSheet.sheet.calculate.Calculate.prototype.couldbeCalculate(val)){
    			this.completeEdit();
    		}    		
    	}		
	},
	
	/*
	 * update the last cursor pos
	 */
	updateCursorPos : function(target){		
		this.lastCursorPos = this.getTargetPos(target);
	},
	
	getTargetPos : function(target){
        var ghost = this.getGhost();
        
        var index = 0;
        for(var i = 0, len = ghost.dom.childNodes.length; i < len; i++){
            var child = ghost.dom.childNodes[i];
            if(3 == child.nodeType){
                index += child.nodeValue.length;
            }else if(1 == child.nodeType && Ext.get(child).hasCls('ss-cal-coord')){
                index += SCOM.getInnerText(child).length;
            }
            if(child == target){
                return index;
            }
        }
	},
    
	/*
	 * when reference is changed, we need change the calculate
	 */
	onReferenceChange : function(region, rm){				
		var el = this.getEditorEl();
		
		if(true === this.syncReferenceFlag || !this.isAvailable() || !el ||
			!EnterpriseSheet.sheet.calculate.Calculate.prototype.couldbeCalculate(this.getValue())){	
			
			return;
		}						
		var ghost = this.getGhost();		
		/*
		 * get ref and translate it to str
		 */
		var v = rm.getReferenceWithoutStack();	
		var curSheetId = this.sheet.getSheetId();
		if(v && v.length){
			var store = this.sheet.getStore();
			var span = [].concat(v[0]);
			/*
			 * transfer sheet id to sheet name
			 */
			if(Ext.isNumber(span[0])){
				span[0] = store.getSheetNameById(span[0]);
			}else{
				span[0] = store.getSheetNameById(curSheetId);
			}				
														
			var selectedSpan = this.getSelectedCoordSpan();			
			if(selectedSpan){					
				/*
				 * get old coord span
				 */
				var oldCoordSpan = SCOM.getInnerText(selectedSpan.dom);	
				var oldCoord = EnterpriseSheet.sheet.calculate.Coordinate.prototype.string2Coord(oldCoordSpan);
				var ctype = oldCoord[0].type;
				/*
				 * try to use the same format of the old coord span
				 */
				var coordStr = EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String([{
					span: span,
					type: ctype
				}], undefined, -1 != oldCoordSpan.indexOf('!') || this.sheetId != curSheetId);
				
				var color = selectedSpan.child('.bgc').getStyle('background-color');
                var str = coordStr;
                str = '<span class="ss-cal-fletter">'+str[0]+'</span>'+str.slice(1, -1)+'<span class="ss-cal-lletter">'+str[str.length-1]+'</span>';
				str = '<span class="bgc" style="background-color:'+color+';">'+str+'</span>';
				selectedSpan.update(str);				
				this.setValue(this.getGhostValue());	
				/*
				 * update the cursor position after the selected span is changed
				 */				
				this.updateCursorPos(selectedSpan.dom);				
			}else{							
				var str = EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String([{
					span: span,
					type: SCONST.RELATIVE_COORD
				}], '', this.sheetId != curSheetId);
				
				var colors = SCOM.colors;	
				var coordSpans = Ext.DomQuery.jsSelect('span[class*="ss-cal-coord"]', ghost.dom);				
				var color = colors[coordSpans.length%colors.length];
				/*
				 * set the current rm element to actived one
				 */
				this.sheet.activeCoordSpan(span, coordSpans.length);			
				var coordStr = str;
                str = '<span class="ss-cal-fletter">'+str[0]+'</span>'+str.slice(1, -1)+'<span class="ss-cal-lletter">'+str[str.length-1]+'</span>';
				str = '<span class="ss-cal-coord ss-cal-coord-selected">'
					+'<span class="bgc" style="background-color:'+color+';">'+str+'</span></span>';
				/*
				 * merge str to ghost
				 */
				this.merge2Ghost(str, coordStr);
											
				this.setValue(this.getGhostValue());
				
			}
			this.dropEl.hide();
		}			
	},
	
	/*
	 * get selected coord span
	 */
	getSelectedCoordSpan : function(){
		var el = this.el;
		if(el){
			var span = el.down('.ss-cal-coord-selected');			
			return span;
		}			
	},
	
	/*
	 * get coord span by index
	 */
	getCoordSpanByIndex : function(index){
		var el = this.el;
		if(el){
			var spanEls = Ext.DomQuery.jsSelect('span[class*="ss-cal-coord"]', el.dom);
			if(0 <= index && index < spanEls.length){
				return spanEls[index];
			}		
		}
	},
	
	/*
	 * return the index of the passed coord span element
	 */
	indexOfCoordSpanEl : function(spanEl){
		var el = this.el;
		if(el){
			var spanEls = Ext.DomQuery.jsSelect('span[class*="ss-cal-coord"]', el.dom);
			for(var i = 0, len = spanEls.length; i < len; i++){
				var sel = spanEls[i];
				if(spanEl == sel){
					return i;
				}
			}			
		}
	},
	
	/*
	 * get coord span element and index by the span array
	 */
	getCoordSpanInfo : function(span){		
		var el = this.el;
		if(el){
			var spanEls = Ext.DomQuery.jsSelect('span[class*="ss-cal-coord"]', this.el.dom);
			
			for(var i = 0, len = spanEls.length; i < len; i++){
				var spanEl = Ext.get(spanEls[i]);
				var coordStr = SCOM.getInnerText(spanEl.dom);				
				var coord = EnterpriseSheet.sheet.calculate.Coordinate.prototype.string2Coord(coordStr);
				var sp = coord[0].span;				
				if(span[0] == sp[0] && span[1] == sp[1] && span[2] == sp[2] && span[3] == sp[3] && span[4] == sp[4]){
					return {
						el: spanEl,
						colorIndex: i
					};
				}
			}
		}
	},
	
	/*
	 * check whether the coord in the calculate is changed, and then refresh them
	 */
	checkCoordChange : function(){		
		var val = this.getValue();			
		this.showCoordSpan(val);
	},
	
	/*
	 * select a coord span format from the drop menu
	 */
	changeCoordStr : function(item){	
		var menu = item.parentMenu;
		var relatedCoord = menu.relatedCoord;
		var selectedSpan = relatedCoord.span;
		var color = selectedSpan.child('.bgc').getStyle('background-color');
        var str = item.text;
        str = '<span class="ss-cal-fletter">'+str[0]+'</span>'+str.slice(1, -1)+'<span class="ss-cal-lletter">'+str[str.length-1]+'</span>';
		str = '<span class="bgc" style="background-color:'+color+';">'+str+'</span>';
		selectedSpan.update(str);	
		
		this.setValue(this.getGhostValue());	
		/*
		 * reset cursor to the last place
		 */
		this.resumeCursorPosition();
	},
	
	/*
	 * cache the cursor pos
	 */
	cacheCursorPos : function(){
		var pos = SCOM.getSelectedTextPos();	
		if(pos){
			/*
			 * cache the cursor pos
			 */
			this.lastCursorPos = pos.startOffset;
		}		
	},
	
	/*
	 * get the cursor pos
	 */
	getCursorPos : function(){
		return this.lastCursorPos;
	},
	
	setCursorPos : function(pos, refresh){
		this.lastCursorPos = pos;
		if(refresh){
			this.resumeCursorPosition();
		}
	},
	
	/*
	 * merge the span str to ghost
	 */
	merge2Ghost : function(str, coordStr){
		var ghost = this.getGhost();
		var html = ghost.dom.innerHTML;
		if('=' == html){
			/*
			 * if it's empty, then default create sum calculate
			 */
			ghost.update('='+str);
			this.lastCursorPos = this.getGhostValue().length;			
		}else{	
			/*
			 * check whether the cursor is in a function
			 */
			var inFun = false;			
			var val = this.getValue();
			
			if(!SCOM.nullOrUndefined(this.lastCursorPos)){						
				inFun = EnterpriseSheet.sheet.calculate.Calculate.prototype.isInFun(val, this.lastCursorPos)
			}
			
			if(inFun){
				var i = this.lastCursorPos;
				for(var len = val.length; i < len; i++){
					/*
					 * find the right place to insert
					 */
					if(')' == val[i] || ',' == val[i]){
						break;
					}
				}
				var pre = val.slice(0, i), pos = val.slice(i, len);
				var textPre = pre, textPos = pos;
				var withoutComma;
				var offset = 0;
				if(pre){			
					var trimedPre = Ext.String.trim(pre);
					withoutComma = /[\[\}\(\,\+\-\*\/\%\<\>\=]$/i.test(Ext.htmlDecode(trimedPre));
					pre = this.generateCoordSpan(pre);
					offset = pre.coordSpanCount;
					pre = pre.html;					
				}			
				if(pos){
					/*
					 * add the offset for the start color
					 */
					pos = this.generateCoordSpan(pos, offset);
					pos = pos.html;
				}					
				if(withoutComma){
					ghost.update(pre+str+pos);					
					this.lastCursorPos = textPre.length+coordStr.length;					
				}else{
					ghost.update(pre+','+str+pos);
					this.lastCursorPos = textPre.length+coordStr.length+1;					
				}				
			}else{
				var raw = Ext.htmlDecode(val);
				var trimedRaw = Ext.String.trim(raw);
				if(/[\(\,\+\-\*\/\%\>\<\=]$/i.test(trimedRaw)){								
					ghost.update(html+str);
				}else{					
					ghost.update(html+'+'+str);
				}		
				this.lastCursorPos = this.getGhostValue().length;				
			}			
		}
	},
	
	/*
	 * check whether there is missing ) in calculate, if yes, then auto complete it
	 * Check special case if it is inside "
	 */
	checkCalculateValid : function(cal){
		var sum = 0, meetDoubleQuote = false;
		for(var i = 0, len = cal.length; i < len; i++){
			var ch = cal.charAt(i);
			if (ch == "\"")  meetDoubleQuote = !meetDoubleQuote;
			else if(!meetDoubleQuote && '(' == ch) sum++;
			else if(!meetDoubleQuote && ')' == ch) sum--;
		}
		if(0 < sum){
			for(var i = 0; i < sum; i++){
				cal += ')';
			}
		}
		
		// replace case """ -> "\" - there will be more case, but this is just special one ..
		cal = cal.replace(/\"\"\"\"/g, '"\\""');
		
		return cal;
	},
	
	/* 
	 * when sheet is switch we need adjust the relative coord
	 */
	onSwitchSheet : function(oldSheetId, sheetId){
		if(this.isEditing() && this.sheet){		
			var val = this.getValue(), flag;
			if(EnterpriseSheet.sheet.calculate.Calculate.prototype.couldbeCalculate(val)){
				if(sheetId != this.sheetId){
					var store = this.sheet.getStore();
					var relatedSheetName = store.getSheetNameById(this.sheetId);
					var spanEls = Ext.DomQuery.jsSelect('span[class*="ss-cal-coord"]', this.el.dom);
					var relatedSpans = [];
					for(var i = 0, len = spanEls.length; i < len; i++){
						var spanEl = spanEls[i];
						var coordStr = SCOM.getInnerText(spanEl);
						if(-1 == coordStr.indexOf('!')){							
							relatedSpans.push({
								coordStr : coordStr,
								spanEl: spanEl,
								cursorPos: this.getTargetPos(spanEl)
							});							
						}
					}
					/*
					 * here we need adjust the cursor position, because the sheet name is added
					 */
					if(!SCOM.nullOrUndefined(this.lastCursorPos)){	
						var lastCursorPos = this.lastCursorPos;
						
						var offset = relatedSheetName.length+1;
						for(var i = 0, len = relatedSpans.length; i < len; i++){
							var it = relatedSpans[i];
							var cursorPos = it.cursorPos;
							if(Ext.isNumber(cursorPos)){
								cursorPos -= it.coordStr.length;								
								if(cursorPos < lastCursorPos){									
									this.lastCursorPos += offset;
								}
							}
						}
					}
					for(var i = 0, len = relatedSpans.length; i < len; i++){
						var it = relatedSpans[i];
						var coordStr = it.coordStr, spanEl = it.spanEl;
						coordStr = relatedSheetName+'!'+coordStr;							
						Ext.get(spanEl).update(coordStr);
					}
					this.setValue(this.getGhostValue());
					this.checkCoordChange();					
					flag = true;
				}	
				/*
				 * update the reference in current sheet
				 */
				val = this.getRawTextValue();					
				this.processReferenceForEditing(val);
				/*
				 * resume the cursor
				 */
				this.resumeCursorPosition();
				/*
				 * hide drop el
				 */
				this.dropEl.hide();
				return flag;
			}			
		}		
	},
	
	enable : function(){
		this.disabled = false;		
		this.el.unmask();		
	},
	
	disable : function(){
		this.disabled = true;		
		this.el.mask();
	}
});
Ext.define('EnterpriseSheet.sheet.editor.CellEditor', {
	
	/* Begin Definitions */
	
	extend: 'EnterpriseSheet.sheet.editor.ContentEditor',	
			
	/* End Definitions */		
	
	marginOffset : 0,
	
	scrollerOffset: 0,
	
	/*
	 * class for editor
	 */
	cls: 'ss-editor',				

	initComponent : function(){
		
		this.callParent(arguments);
		
		this.on({
			scope: this,
			'afterrender': this._afterRender
		});		
	},
	
	/*
	 * init this editor, bind it to a sheet
	 */	
	init : function(sheet){		
		this.callParent(arguments);
				
		this.mon(sheet, {
        	scope: this,
            'celldblclick': this.onCellDblClick,  
            'cellclick': this.onCellClick,  
            'columnchange': this.onColumnChange,
            'rowchange': this.onRowChange,
            'afterrender': this.afterSheetRender
        });
        
        var sm = sheet.getSelectionModel();
        this.mon(sm, {
            scope: this,
            'focuschange': this.onFocusChange
        });
	},
           
    onFocusChange : function(row, col, sm){
    	if(this.editing){
    		var val = this.getValue();
    		if(!EnterpriseSheet.sheet.calculate.Calculate.prototype.couldbeCalculate(val)){
    			var region = sm.getRegion();
    	        var store = this.sheet.getStore();
    	        this.setValue('');
    	        var el = region.getCellEl(row, col);
    	        if(el){
    	            /*
    	             * process merge cell differently
    	             */
    	            if(store.isMergedCell(this.cell, region.getSheetId(), row, col)){
    	                el = el.down('.ss-incell');
    	            }
    	            this.boundEl = el;
    	           
    	            this.renderEditor();
    	            var pEl = this.el.parent();
    	            if(pEl && el){
    	                this.el.setLeft(el.getLeft()-pEl.getLeft());
    	                this.el.setTop(el.getTop()-pEl.getTop());
    	                this.el.setWidth(1);
    		            this.el.removeCls('ss-editor-calculate');
    		            this.el.setOpacity(0);
    		            var editorEl = this.getEditorEl();
    		            editorEl.blur();
    		            editorEl.focus(10);
    		        }
    	        }
    		}
    	}else{
    		this.setValue('');
    	}        
    },
           
    afterSheetRender : function(){
        this.renderEditor();
    },
        
           
    /**
     * render the editor under the right element, a little tricky to do that
     */
    renderEditor : function(){
        if(!this.rendered){
            var pEl = this.sheet.getEl();
            var contentEditor = this.sheet.contentEditor;
            if(contentEditor){
                var cEl = contentEditor.getEl();
                if(cEl){
                    pEl = SCOM.findParentNodeForBoth(pEl, cEl);
                }
            }
            this.render(pEl);
        }
    },
	
	/*
	 * return true if the editor is avaiable
	 */
	isAvailable : function(){
		return this.el && this.available; 
	},	
			
	_afterRender : function(){
		
		if(this.el){
			this.el.setStyle('z-index', SCONST['TOP_Z_INDEX']);
		}
		this.hideAway();
		
		this.focus();
	},
	
	hideAway : function(){
		if(this.el){
			this.el.setWidth(1);
			this.el.removeCls('ss-editor-calculate');			
            this.el.setOpacity(0);
		}
		this.available = false;
		this.setValue('');
	},
	
	/*
	 * on focuse editor
	 */
	onEditorFocus : function(){
		if(this.isAvailable()){
			/*
			 * set a flag, means it's inputing
			 */
			this.inputing = true;	
			if(SCOM.nullOrUndefined(this.lastCursorPos)){
				var val = this.getValue();
				/*
				 * move cursor to end
				 */
				this.lastCursorPos = val.length;
				/*
				 * move cursor to the end of text
				 */
				SCOM.moveCursor2End(this.getEditorEl().dom);
			}else{
				/*
				 * resume the cursor
				 */
				this.resumeCursorPosition();
			}
		}			
	},	
	
	/*
	 * override superclass
	 */
	onEditorElKeyDown : function(e){		
		if(false === this.callParent(arguments)){
			return;
		}
		
		if(!this.isAvailable()){			
			var key = e.getKey();
			
			// Shift + F11 (122) also not need editable ...
			if(!e.ctrlKey && !e.altKey && key && key != e.ENTER 
					&& key != e.ESC && key != e.TAB && e.SHIFT != key & 122 != key){
				if(!this.disabled){
					Ext.Function.defer(function(){
						var region = this.sheet.getCurrentRegion();
						var sm = region.getSelectionModel();
						var fc = sm.getFocusCell();					
						/*
						 * render editor to edit
						 */
						this.startEdit(fc.row, fc.col, region, e, true, true);
					}, 50, this);
				}				
			}
		}
	},
	
	/*
	 * prepare the editor's style
	 */
	prepareEditorStyle : function(scroller, disSyncStyleFlag){
		
		var scrollDir = scroller.getDir();
		var store = this.sheet.getStore();
		var dp = store.defaultProperty;
		var el = this.getEditorEl(), cell = this.cell, rel = this.region.getEl();
		var sheetId = this.region.getSheetId();
		if(!disSyncStyleFlag){			
			/*
			 * update the styles to make the editor just like the related cell
			 */		
			el.setStyle('background-color', cell.bgc || '');
			if(cell.ff){
				el.setStyle('font-family', cell.ff);
			}
			if(cell.color){
				el.setStyle('color', cell.color);
			}else{
				el.setStyle('color', dp.color || '');
			}
			if(cell.fz){
				el.setStyle('font-size', cell.fz+'pt');			
			}
			if(cell.fw){
				el.setStyle('font-weight', cell.fw);
			}else{
				el.setStyle('font-weight', 'normal');
			}
		}else{
            el.setStyle('font-family', '');
            el.setStyle('font-size', '');
            el.setStyle('font-weight', '');
            el.setStyle('color', '');
			el.setStyle('background-color', '');
		}		
		
		/*
		 * process the max/min width and max/min height issue
		 */
		var sz = this.boundEl.getSize(), w, h, mw, mh;  				
		mw = rel.getRight()-this.boundEl.getLeft()-this.marginOffset;				
		mh = rel.getBottom()-this.boundEl.getTop()-this.marginOffset;
           
        var mergedCellFlag = store.isMergedCell(this.cell, this.sheetId, this.row, this.col);
        if(mergedCellFlag){
            el.setStyle('padding', '0');
        }else{
            el.setStyle('padding', '');           
        }
		if('none' == scrollDir){
			mw += this.scrollerOffset;
			mh += this.scrollerOffset;
		}else if('x' == scrollDir){
			if(!scroller.isVisible()){
				mw += this.scrollerOffset;
			}
			mh += this.scrollerOffset;			
		}else if('y' == scrollDir){
			if(!scroller.isVisible()){
				mh += this.scrollerOffset;
			}
			mw += this.scrollerOffset;
		}
        mw = mw-this.el.getBorderWidth('lr');

		if('normal' != cell.ws){
			/*
			 * this means the editor should grow in width when inputing, and if the editor reach the right margin,
			 * it will grow in height
			 */
			
			/*
			 * handler min/max width
			 */
			w = this.region.guessCellWidth(sheetId, this.row, this.col, cell);
			if(w < mw){
				el.setStyle('min-width', w+'px');
			}else{					
				el.setStyle('min-width', sz.width+'px');
			}
			el.setStyle('max-width', mw+'px');
			
			el.setStyle('width', 'auto');
			if(!disSyncStyleFlag){
				/*
				 * handler min/max height
				 */
				var minh = store.correctRenderHeight(sz.height);
                if(mergedCellFlag){
                    minh += 5;
                }
				el.setStyle('min-height', minh+'px');
				el.setStyle('max-height', mh+'px');
				el.setStyle('height', 'auto');
			}else{
				el.setStyle('height', 'auto');
				el.setStyle('max-width', '');
				el.setStyle('min-height', '');
			}									
		}else{	
			if(!disSyncStyleFlag){
				/*
				 * this means the editor should grow in height when inputing
				 * hanlder min/max height
				 */				
				h = this.region.guessCellHeight(sheetId, this.row, this.col, cell);
                if(mergedCellFlag){
                    h += 5;
                }
				if(h < mh){
					el.setStyle('min-height', h+'px');
				}else{
					el.setStyle('min-height', sz.height+'px');
				}				
				if(h < mh){
					el.setStyle('max-height', mh+'px');
				}else{
					el.setStyle('max-height', h+'px');
				}
				el.setStyle('height', 'auto');					
			}else{
				el.setStyle('height', 'auto');
				el.setStyle('min-height', '');
				el.setStyle('max-width', '');
			}
			/*
			 * fix the width of editor
			 */
			el.setStyle('min-width', '');
			el.setWidth(sz.width);
		}
	},
	
	/*
	 * complete edting
	 */
	completeEdit : function(){
		this.callParent(arguments);
		
		this.hideAway();
	},
	
	/*
	 * cancel editing
	 */
	cancelEdit : function(){
		this.callParent(arguments);
		
		this.hideAway();
	},		
	
	/*
	 * when there is a column change
	 */
	onColumnChange : function(col, modified, deleted, odata, data, store, region){
		if(region == this.region && this.is()){			
			this.syncPosition();
		}
	},
	
	onRowChange : function(row, modified, deleted, odata, data, store, region){
		if(region == this.region && this.isAvailable()){			
			this.syncPosition();
		}
	},	
	
	/*
	 * adjust editor position before starting edit
	 */
	adjustEditorPos : function(flag){
		var store = this.sheet.getStore();
		var row = this.row, col = this.col;
		var region = this.region;
		var el = region.getCellEl(row, col);
		if(el){
			/*
			 * process merge cell differently
			 */
			if(store.isMergedCell(this.cell, this.sheetId, this.row, this.col)){
				el = el.down('.ss-incell');			
			}		
			this.boundEl = el;
			
            this.renderEditor();
            var pEl = this.el.parent();
            var left = el.getLeft()-pEl.getLeft(), top = el.getTop()-pEl.getTop();
           
			if(this.el.hasCls('ss-editor-floating-over')){
				this.el.removeCls('ss-editor-floating-over');
			}
			this.el.setLeft(left);
			this.el.setTop(top);
            this.el.setStyle('width', '');
			/*
			 * prepare the editor before show
			 */
			this.prepareEditorStyle(region.getScroller(), flag);			
			this.el.show();
		}
	},	
    
    onCellDblClick : function(row, col, region, e){
        if(!this.disabled){        	
           /*
            * call start editing
            */    	
            this.startEdit(row, col, region, e);
            
            // check cell double check call back event ...
            this.sheet.onCellEventCallback("onCellDoubleClickFn", region.getSheetId(), row, col);
        }
    },	
    
    // this is for cell click event call back if any ...
    // this just for callback function ...
    onCellClick : function(row, col, region, e){
        if(!this.disabled){
            this.sheet.onCellEventCallback("onCellClickFn", region.getSheetId(), row, col);
        }
    },	
	
	/*
	 * override startEdit to add listener for region scrolling, so we can float the editor when it's out of range
	 */
	startEdit : function(){
		if(this.disabled){
			return false;
		}
		this.crossSheetFlag = false;
		/*
		 * need set available to true
		 */
		this.available = true;
        this.el.setStyle('width', 'auto');
		this.el.setOpacity(1);		
		if(false === this.callParent(arguments)){
			return false;
		}
		
		if(this.editing && this.region){	
			var el = this.getEl();
			this.mun(el, {
				scope: this,
				'mousewheel': this.onMouseWheel
			});
			this.mon(el, {
				scope: this,
				'mousewheel': this.onMouseWheel
			});
			this.mun(this.region, {
				scope: this,
				'moving' : this.onRegionMoving
			});
			this.mon(this.region, {
				scope: this,
				'moving' : this.onRegionMoving
			});
		}		
	},
	
	/*
	 * override onQuitEdit to remove listener for region scrolling
	 */
	onQuitEdit : function(){
		var el = this.getEl();
		if(this.region){
			this.mun(this.region, {
				scope: this,
				'moving' : this.onRegionMoving
			});
			this.mun(el, {
				scope: this,
				'mousewheel': this.onMouseWheel
			});
		}
		this.callParent(arguments);
		delete(this.fixedMode);
		
		if(el.hasCls('ss-editor-floating-over')){
			el.removeCls('ss-editor-floating-over');
		}
		el.setStyle('width', 'auto');
		el.setStyle('height', 'auto');
	},
	
	onMouseWheel : function(e){
		this.region.getScroller().onMouseWheel(e);
	},
	
	/*
	 * when related region is moving
	 */
	onRegionMoving : function(dir, offset, region){
		this.syncPosition();
	},
	
	/*
	 * sync editor position
	 */
	syncPosition : function(){		
		if(this.isAvailable() && this.isEditing()){
			var region = this.region, store = region.getStore(), row = this.row, col = this.col;
			var el = this.getEl(), pEl = el.parent();
			if(!this.crossSheetFlag && region.isInRange(row, col)){
				delete(this.fixedMode);
				var cellEl = region.getCellEl(row, col);
                if(store.isMergedCell(this.cell, this.sheetId, row, col)){
                    cellEl = cellEl.down('.ss-incell');
                }
				var left = cellEl.getLeft()-pEl.getLeft(), top = cellEl.getTop()-pEl.getTop();
				el.setLeft(left);
				el.setTop(top);
				el.setStyle('width', 'auto');
				el.setStyle('height', 'auto');
				if(el.hasCls('ss-editor-floating-over')){
					el.removeCls('ss-editor-floating-over');
				}
				
			}else{
                var contentEditor = this.sheet.contentEditor;
				if(contentEditor){
					var fixed = contentEditor.getEl();
                    if(fixed){
                        this.fixedMode = true;
                        var left = fixed.getLeft()-pEl.getLeft()+1, top = fixed.getTop()-pEl.getTop()+1;
                        el.setLeft(left);
                        el.setTop(top);
                        el.setWidth(fixed.getWidth()-1);
                        el.setHeight(fixed.getHeight()-1);
                        if(!el.hasCls('ss-editor-floating-over')){
                            el.addCls('ss-editor-floating-over');
                        }
                    }
				}
			}
		}		
	},
	
    /* 
	 * when sheet is switch we need adjust the relative coord
	 */
	onSwitchSheet : function(oldSheetId, sheetId){
		if(this.callParent(arguments)){
			this.crossSheetFlag = true;
			this.syncPosition();
		}else{
			this.crossSheetFlag = false;
			this.syncPosition();
		}			
	}
});
Ext.define('EnterpriseSheet.sheet.filter.Filter', {
	
	/* Begin Definitions */	
	
	requires : [
	    'Ext.menu.Menu',
	    'Ext.grid.Panel',	    
	    'Ext.form.field.Text',
	    'Ext.layout.container.Card'
	],
	
	/* End Definitions */
           
    pageCount: 2000,
	
	constructor : function(config){
		Ext.apply(this, config);							
		
		this.callParent();						
	},
	
	init : function(sheet){
		if(this.sheet){
			return;
		}
		this.sheet = sheet;
		
		this.sheet.on({
			scope:this,
			'clickcelltrigger': this.onClickCellTrigger,
			'cellclick':this.onClick
		});
		
		this.initMenu();
	},
	
	/*
	 * init filter menu
	 */
	initMenu : function(){
		if(!this.menu){						
			this.clearFilterItem = new Ext.menu.Item({
				iconCls:'icon-cross',
				text:SLANG['clear_filter'],
				disabled:true,
				handler:function(){
					this.clearFilter();
				},
				scope:this
			});
			
			this.distinctStore = new Ext.data.Store({	
				//buffered: true,
				fields : ['id', 'text', 'qtip', 'checked'],
				proxy: {
		            type: 'memory'
		        }
			});
					
			/*
			 * grid for distinct value list
			 */
			this.grid = this.getDistinctValueGrid();						
			
			/*
			 * ct for filter by condition
			 */
			this.condCt = this.getConditionPanel();
			
			this.filterTypeCt = new Ext.panel.Panel({
				border: false,
				bodyStyle: 'background:transparent;',
				layout: 'card',
				activeItem: 0,
				items: [this.grid, this.condCt],
				buttons:[{
					text: SLANG['remove_filter'],
					handler: function(){
						this.removeFilter();
					},
					scope: this
				}, {
					text:SLANG['ok'],
					handler:function(){
						this.applyFilter();
					},
					scope:this
				}, {
					text:SLANG['cancel'],
					handler: function(){
						this.cancelFilter();
					},
					scope:this
				}]
			});
			
			this.menu = new Ext.menu.Menu(Ext.apply({
				cls: 'ss-filter-menu',
				autoWidth:false,
                plain: true,
				width:300,
				items:[{
					iconCls:'icon-sort-asc',
					text:SLANG['sort_asc'],
					handler:this.sortAsc,
					scope:this
				}, {
					iconCls:'icon-sort-desc',
					text:SLANG['sort_desc'],
					handler:this.sortDesc,
					scope:this
				}, '-', 					
				this.clearFilterItem, '-', /*{
					text: SLANG['filter_condition'],
	                checked: false,
	                checkHandler: this.onFilterTypeCheck,
	                scope: this
				}, '-',*/
				this.filterTypeCt]
			}, this.menuConfig));
			/*
			 * key listeners for search field
			 */
			this.searchField.on('keyup', this.onSearchKeyUp, this, {buffer: 500});
			
			this.grid.on('itemclick', this.onItemClick, this);
			
			this.menu.on('beforehide', function(){
				if(this.holdMenu){
					return false;
				}
			}, this);
			this.menu.on('hide', this.onMenuHide, this);
		}
	},
	
	/*
	 * create grid for distinct value list
	 */
	getDistinctValueGrid : function(){
		this.searchField = new Ext.form.field.Text({
			iconCls: 'no-icon',
			emptyText: SLANG['input2search'],
			flex: 1,
			enableKeyEvents: true
		});
        this.lastPageBtn = Ext.create('Ext.button.Button', {
            text: SLANG['prev_page'],
            handler: function(){
                var startIndex = this.startIndex-this.pageCount;
                if(0 > startIndex){
                    startIndex = 0;
                }
                if(0 === startIndex){
                    this.lastPageBtn.disable();
                }else{
                    this.lastPageBtn.enable();
                }
                this.loadMask.show();
                Ext.Function.defer(function(){                    
                    var isEnd = this.setupWithPage(this.setupInfo.row, this.setupInfo.col, this.setupInfo.filterSpan, this.setupInfo.filterCdt, startIndex, this.pageCount);
                    if(isEnd){
                        this.nextPageBtn.disable();
                    }else{
                        this.nextPageBtn.enable();
                    }
                    this.loadMask.hide();
                }, 100, this);
            },
            scope: this
        });
        this.nextPageBtn = Ext.create('Ext.button.Button', {
            text: SLANG['next_page'],
            handler: function(){
                var startIndex = this.startIndex+this.pageCount;
                this.loadMask.show();
                Ext.Function.defer(function(){                    
                    var isEnd = this.setupWithPage(this.setupInfo.row, this.setupInfo.col, this.setupInfo.filterSpan, this.setupInfo.filterCdt, startIndex, this.pageCount);
                    if(isEnd){
                        this.nextPageBtn.disable();
                    }else{
                        this.nextPageBtn.enable();
                    }
                    this.lastPageBtn.enable();
                    this.loadMask.hide();
                }, 100, this);
            },
            scope: this
        });
        this.displayItem = Ext.create('Ext.Component', {
            flex: 1,
            style: 'text-align:center;'
        });
        
		var grid = new Ext.grid.Panel({				
			//style: 'padding-left:30px;',
			store: this.distinctStore,
			hideHeaders: true,				
			disableSelection: true,
			selModel: {
				pruneRemoved: false
			},				
		    columns: [				        
		        {
		        	header: '('+SLANG['select_all']+')', 
		        	dataIndex: 'text',
		        	menuDisabled: true,			        	
		        	flex: 1,
		        	tdCls: 'ss-filter-distinct-item'
		        }
		    ],
		    viewConfig: {
		    	stripeRows: false,
		    	trackOver: false,
		    	getRowClass: function(rec){
		    		return rec.data.checked ? 'ss-filter-distinct-item-checked' : '';
		    	}
		    },
		    width:230,
			height:230,				
			dockedItems: [{
				xtype: 'container',
				dock: 'top',
				layout: 'hbox',
				items: [this.searchField]
			}, {
				xtype: 'container',
				height: 30,
				dock: 'top',
				style: 'padding:3px;',
				layout: {
					type: 'hbox',
					align: 'stretch'
				},
				defaultType: 'button',
				items: [{						
					text: SLANG['check_all'],					
					handler: this.checkAll,
					scope: this
				}, {
					style: 'margin-left:10px;',
					text: SLANG['uncheck_all'],
					handler: this.uncheckAll,
					scope: this
				}]
			}],
            bbar : [this.lastPageBtn, this.displayItem, this.nextPageBtn]
		});
        this.loadMask = Ext.create('Ext.LoadMask', {
        	target: grid, 
            msg: SLANG['loading']
        });
		return grid;
	},
	
	/*
	 * create condition panel
	 */
	getConditionPanel : function(){
		this.condTypeCombo = new Ext.form.field.ComboBox({
			store: SCOM.filterConditionStore,
			queryMode: 'local',
		    displayField: 'display',
		    valueField: 'ctype',
		    emptyText: SLANG['select_filter_condition'],
		    anchor: '95%'
		});
		var ct = new Ext.container.Container({		
			style: 'padding-left:30px;',
			layout: 'anchor',
			items: [this.condTypeCombo]
		});
		return ct;
	},
	
	onClickCellTrigger : function(sheetId, row, col, region, sheet, target){
		this.onClick(row, col, region, {
			getTarget : function(){
				return Ext.get(target).dom;
			}
		});
	},
	
	/*
	 * when mouse down, we need check wether it's on the filter
	 */
	onClick : function(row, col, region, e){
        if(this.sheet.isReadOnly()){
            return;
        }
		var target = e.getTarget();
		var tgEl = Ext.get(target);
		/*
		 * for chart element, avoid the exception
		 */
		if(Ext.supports.ClassList && !target.classList){
			return;
		}
		if(tgEl.hasCls('ss-filter')){
			var sheet = this.sheet, store = sheet.getStore();
			var sheetId = sheet.getSheetId();
			/*
			 * need call sheet.getCellData, because we need process the filter generated by the table template
			 */
			var cell = sheet.getCellData(sheetId, row, col);			
			/*
			 * setup the filter info and show the menu
			 */
			var span = Ext.decode(cell.filter);			
			/*
			 * a flag to know whether this filter is a table template filter
			 */
			if(cell.tpl){
				var tpl = Ext.decode(cell.tpl);		
				var tplSpan = tpl.span;
				tplSpan[1]++;
				// tplSpan[3]--;
				this.isTplFilter = tplSpan;
			}else{
				this.isTplFilter = false;
			}
			cell.tpl ? Ext.decode(cell.tpl) : false;
			var filterCdt;
			if(cell.filterCdt){
				filterCdt = Ext.decode(cell.filterCdt);
			}			
			this.distinctStore.removeAll();	
			this.menu.showBy(tgEl);
			if(!this.mask){
				this.mask = Ext.getBody().mask();
				this.mask.addCls('top-mask');				
			}else{
				this.mask.show();
			}			
			this.holdMenu = true;
			this.showFilterReference(cell, sheetId, row, col);
            this.loadMask.show();
			Ext.Function.defer(this.setup, 10, this, [row, col, span, filterCdt]);			
		}
	},
	
	/*
	 * check all items
	 */
	checkAll : function(){
		for(var p in this.distinctCache){
			this.distinctCache[p]['checked'] = true;			
		}
		this.distinctStore.each(function(rec){
			rec.data.checked = true;
		}, this);
		this.grid.getView().refresh();
	},
	
	uncheckAll : function(){
		for(var p in this.distinctCache){
			this.distinctCache[p]['checked'] = false;			
		}
		this.distinctStore.each(function(rec){
			rec.data.checked = false;
		}, this);
		this.grid.getView().refresh();
	},
	
	/*
	 * return true only if the span have overlap
	 */
	isOverlapFilter : function(span1, span2){
		
		if(span1[0] === span2[0]){
			if(0 == span1[1] || 0 == span2[1]){
				return true;
			}
			if(0 == span1[3] && 0 == span2[3]){
				return true;
			}
			var tmp1 = [].concat(span1), tmp2 = [].concat(span2);
			if(0 == tmp1[3]){
				if(tmp1[1] < tmp2[3]){
					tmp1[3] = tmp2[3];
				}else{
					tmp1[3] = tmp1[1];
				}
			}
			if(0 == tmp2[3]){
				if(tmp2[1] < tmp1[3]){
					tmp2[3] = tmp1[3];
				}else{
					tmp2[3] = tmp2[1];
				}
			}
			
			if((tmp1[1] >= tmp2[1] && tmp1[1] <= tmp2[3]) || (tmp1[3] >= tmp2[1] && tmp1[3] <= tmp2[3])
				|| (tmp1[1] <= tmp2[1] && tmp1[3] >= tmp2[3])){
				return true;
			}
		}
		return false;
	},
	
	/*
	 * get all related filter in store 
	 */
	getOtherRelatedFilters : function(sheetId, row, col, filterSpan){
		var sheet = this.sheet, store = sheet.getStore();
		
		var otherFilters = [];
		store.each(function(rd){
			var s = rd.data.sheet, r = rd.data.row, c = rd.data.col;
			if(!(sheetId == s && row == r && col == c)){
				var json = rd.data.json;
				if(json && (json.filter || json.tpl)){
					var filter, flag = false;
					if(json.filter){
						flag = true;
						filter = Ext.decode(json.filter);
						if('' === filter[0]){
							filter[0] = s;
						}
						if('' === filter[3]){
							/*
							 * if maxrow is '', means it's for the whole column, we set it to 0 
							 * and the minrow defines where to start
							 */
							filter[3] = 0;
							if('' === filter[1]){
								filter[1] = 0;
							}else{
								filter[1] += r; 
							}
						}else{
							filter[1] += r;
							filter[3] += r;
						}
					}else{
						filter = Ext.decode(json.tpl).span;
						if('' === filter[0]){
							filter[0] = s;
						}
						if(filter[0] == s && filter[1] == r){
							flag = true;
							filter[1]++;
							filter[3]--;
						}
					}		
					if(flag){
						filter[2] = filter[4] = c;
						if(this.isOverlapFilter(filter, filterSpan)){
							var obj = {
								filterSpan: filter
							};
							if(json.filterCdt){
								obj['filterCdt'] = Ext.decode(json.filterCdt);
							}
							otherFilters.push(obj);
						}
					}
				}
			}
		}, this);
		
		return otherFilters;
	},
           
	/*
	 * setup the filter info and status
	 */
    setup : function(row, col, filterSpan, filterCdt){    	
		this.searchField.reset();
		this.filteringFlag = false;		
        this.distinctCache = {};
        delete(this.showHiddenCache);
        var sheet = this.sheet, store = sheet.getStore(), sheetId = sheet.getSheetId();
        /*
		 * transfer the relatived position to absolute position
		 */	
		if('' === filterSpan[0]){
			filterSpan[0] = sheetId;
		}		
		if('' === filterSpan[3]){
			/*
			 * if maxrow is '', means it's for the whole column, we set it to 0 
			 * and the minrow defines where to start
			 */
			filterSpan[3] = 0;
			if('' === filterSpan[1]){
				filterSpan[1] = 0;
			}else{
				filterSpan[1] += row; 
			}
		}else{
			filterSpan[1] += row;
			filterSpan[3] += row;
		}
		filterSpan[2] = filterSpan[4] = col;
		
		store.checkLoadCoord([filterSpan], function(){			
			this.setupInfo = {
		        row: row,
		        col: col,
		        filterSpan: filterSpan,
		        filterCdt: filterCdt
			};
			var startTime = new Date();
	        filterCdt = SCOM.copy(filterCdt);
	        filterSpan = SCOM.copy(filterSpan);
	        var startIndex = 0;
	        
			var sheet = this.sheet, store = sheet.getStore(), sheetId = sheet.getSheetId();
			var distinct = {}, minrow = false, maxrow = false, nonemptys = {};
			
			var startRow = filterSpan[1]+row, endRow = '' !== filterSpan[3] ? filterSpan[3]+row : null;
			
			
			var otherFilters = this.getOtherRelatedFilters(sheetId, row, col, filterSpan);
			this.otherFilters = otherFilters, totalNum = 0;		

			store.walkRange([filterSpan], function(rd){			
				if(row < rd.data.row && 0 !== rd.data.row && 0 !== rd.data.col){
					var sid = rd.data.sheet, r = rd.data.row, c = rd.data.col;
					var visible = store.isVisibleRow(sid, r);				
					if(visible || this.checkFilters(r, this.otherFilters)){
						var data = rd.data.json.data, fm = rd.data.json.fm, cd = rd.data.json;
						if(rd.data.json.cal){
							cd = sheet.getCellValue(sid, r, c, SCOM.genTimeStamp());
							data = cd.data;
						}
						data = 'link' == fm ? data : SFORMAT.transferFormat(cd, fm).data;					
						
						if(false != SCOM.typeOf(data) && '' !== data){
							if(!distinct[data]){
								totalNum++;
								distinct[data] = {							
									'checked':false,
									'rows':{}
								};
							}
							var dt = distinct[data]; 
							if(!dt['checked']){
								dt['checked'] = visible;
							}
							dt['rows'][rd.data.row] = true;
							/*
							 * save the min and max non-empty row
							 */
							if(false === minrow || minrow > rd.data.row){
								minrow = rd.data.row;
							}
							if(false === maxrow || maxrow < rd.data.row){
								maxrow = rd.data.row;
							}
							/*
							 * save the nonemptys
							 */
							nonemptys[rd.data.row] = true;
						}
					}				
				}			
			}, this, true);		
			/*
			 * add empty option if need
			 */
			var emptys = {};
			if(null === endRow){
				endRow = maxrow;
			}
			var erows = {};
			for(var i = startRow; i <= endRow; i++){
				if(!nonemptys[i]){
					var visible = store.isVisibleRow(sheetId, i);
					if(visible || this.checkFilters(i, this.otherFilters)){
						emptys[i] = {
							visible: visible
						};
						erows[i] = true;
					}
				}			
			}
			
			if(!SCOM.isEmptyObj(emptys)){
				var blank = '('+SLANG['blank']+')';
				distinct[blank] = {
					'id': 'blank-text',
					'checked':false,
					'rows':erows
				}
				var dt = distinct[blank]; 
				for(var p in emptys){
					if(!dt['checked']){
						dt['checked'] = emptys[p].visible;
					}else{
						break;
					}
				}			
			}
			if(maxrow < filterSpan[3]){
				maxrow = filterSpan[3];
			}
			/*
			 * save the position and span
			 */
			this.pos = {
				row:row,
				col:col,
				minrow:minrow,
				maxrow:maxrow,
				totalNum: totalNum,
				totalPage: Math.ceil(totalNum/this.pageCount)
			};
			this.filterSpan = filterSpan;
			this.distinctCache = distinct;
			
		    var isEnd = this.setupWithPage(row, col, filterSpan, filterCdt, 0, this.pageCount);
		        
		    this.lastPageBtn.disable();
		    if(isEnd){
		        this.nextPageBtn.disable();
		    }else{
		        this.nextPageBtn.enable();
		    }
		    this.loadMask.hide();
		    this.mask.hide();
		    this.holdMenu = false;
		}, this);        
    },
           
	setupWithPage : function(row, col, filterSpan, filterCdt, startIndex, limit){
		var count = 0, index = 0;
		var disStore = this.distinctStore;
		this.startIndex = startIndex;
		var dataArr = [], distinct = this.distinctCache;
		for(var p in distinct){
			if(distinct.hasOwnProperty(p)){
				var it = distinct[p];
				if(index < startIndex){
					index++;
					continue;
				}else{
					index++;
				}
				if(count > limit){
					break;
				}
				if(!this.filteringFlag || ('blank-text' !== it.id && 0 === p.indexOf(this.filteringFlag))){
					var data = {
						id:it.id,				
						text:p,
						qtip:p,
						checked: it['checked']
					};
					dataArr.push(data);			
					count++;
				}
			}			
		}					
		disStore.pageSize = dataArr.length;
		
		disStore.loadData(dataArr);
		
		var index = Math.floor(startIndex/this.pageCount)+1;
		this.displayItem.update(index+'/'+this.pos.totalPage);
		/*
		 * enable clear filter any way
		 */
		this.clearFilterItem.enable();		
		
		return count <= limit;
	},	
	
	/*
	 * when selection is changed
	 */
	onItemClick : function(grid, rec){
		var p = rec.data.qtip;
		if(this.distinctCache[p]['checked']){
			this.distinctCache[p]['checked'] = false;
			rec.set('checked', false);
		}else{
			this.distinctCache[p]['checked'] = true;
			rec.set('checked', true);
		}		
	},
	
	/*
	 * create filter for the selection
	 */
	createFilterForSelecton : function(){
		var sheet = this.sheet;
		var sm = sheet.getSelectionModel();		
		var span = sm.selection2Span();
		/*
		 * expand the span
		 */
		span = EnterpriseSheet.sheet.range.Range.prototype.expandSpanWithContent(span, sheet);
		//console.log(Ext.encode(span))
		var tpl = sheet.getTableTpl();
		
		var checkTpl = function(){
			if(tpl){
				var flag = tpl.checkSelection([span]);
				if('part' == flag){
					/*			 
					 * can not create filter for table tpl
					 */
					Ext.Msg.show({
						title:SLANG['hint'],
						msg:SLANG['can_not_create_filter'],
						icon:Ext.Msg.INFO,
						buttons:Ext.Msg.OK
					});
					return true;
				}else if('all' == flag){
					tpl.toggleTplFilterForSpan(span);
					return true;
				}
			}
		}
		/*
		 * the row span is more than 1
		 */
		if(0 === span[3] || 0 < span[3]-span[1]){
			if(0 === span[2]){
				/*
				 * whole sheet
				 * can not create filter for whole sheet
				 */
				Ext.Msg.show({
					title:SLANG['hint'],
					msg:SLANG['can_not_create_filter'],
					icon:Ext.Msg.INFO,
					buttons:Ext.Msg.OK
				});
			}else{				
				if(checkTpl()){
					return;
				}
				this.createFilterForSpan(span);		
			}
		}else{			
			if(checkTpl()){
				return;
			}
			/*			 
			 * can not create filter for whole sheet
			 */
			Ext.Msg.show({
				title:SLANG['hint'],
				msg:SLANG['can_not_create_filter'],
				icon:Ext.Msg.INFO,
				buttons:Ext.Msg.OK
			});
		}		
	},
	
	/*
	 * prepare filter
	 * 
	 */
	prepareFilterPreporty : function(row, span){
		var filter = [].concat(span);
		filter[0] = '';
		/*
		 * transfer to relative span
		 */
		if(0 === span[1]){
			/*
			 * if it's for the whole column then we set the minrow and maxrow as ''
			 * start at the first row below the filter cell
			 */
			filter[1] = 1; 
			filter[3] = '';
		}else{
			/*
			 * start at the first row below the filter cell
			 */
			filter[1] = filter[1]-row+1;						
			filter[3] -= row;
		}					
		filter[2] = filter[4] = 0;
		
		var obj =  {
			'trigger':'ss-filter',
			/*
			 * save the filter range into the cell's property
			 */
			'filter':Ext.encode(filter)
		};
		return obj;
	},
	
	/*
	 * create filter for a span
	 */
	createFilterForSpan : function(span, suspendEvent){	
		var sheet = this.sheet, store = sheet.getStore();
		var sheetId = span[0], minrow = span[1], mincol = span[2], maxrow = span[3], maxcol = span[4];
		
		var row = 0 === minrow ? 1 : span[1];
		var tmp = [].concat(span);
		tmp[3] = tmp[1] = row;
				
		if(suspendEvent || false !== sheet.fireEvent('beforecreatefilter', tmp, sheet)){
			if(!suspendEvent){
				sheet.fireEvent('preparecreatefilter', tmp, sheet);
			}
			for(var i = mincol; i <= maxcol; i++){
				var modified = this.prepareFilterPreporty(row, span);					
				store.setCell(sheetId, row, i, modified, null, true);
			}
			/*
			 * refresh the span
			 */
			sheet.refreshRange([[sheetId, minrow, mincol, minrow, maxcol]]);
			if(!suspendEvent){
				sheet.fireEvent('createfilter', tmp, sheet);
			}			
		}
	},
	
	/*
	 * return true if the row fits all filters
	 */
	checkFilters : function(row, filters){
		if(!filters){
			return true;
		}
		var sheet = this.sheet;
		for(var i = 0, len = filters.length; i < len; i++){
			var filter = filters[i];
			var span = filter.filterSpan, cdt = filter.filterCdt;
			if(cdt){
				var col = span[2];
				var ctype = cdt['type'], values = cdt['values'];
				var data = sheet.getCellData(span[0], row, col);
				data = data.data;
				/*
				 * compare as string
				 */
				if(Ext.isNumber(data)){
					data = data.toString();
				}else if(SCOM.nullOrUndefined(data)){
					data = '';
				}
				var index = Ext.Array.indexOf(values, data);
				
				if('match' == ctype && -1 == index){
					return false;
				}else if('match' != ctype && -1 !== index){
					return false;
				}
			}
		}
		return true;
	},           
           
    getShownHiddens : function(){
        var sheet = this.sheet, store = this.sheet.getStore(), sheetId = this.sheet.getSheetId();
        var hflag = false, shown = {}, hidden = {};
        for(var p in this.distinctCache){
            var rows = this.distinctCache[p]['rows'], checked = this.distinctCache[p]['checked'];
            var fn, arr;
            if(checked){
                for(var q in rows){
                    if(!store.isVisibleRow(sheetId, q) && this.checkFilters(q, this.otherFilters)){
                        shown[q] = true;
                    }
                }
            }else{
                hflag = true;
                for(var q in rows){
                    if(store.isVisibleRow(sheetId, q)){
                        hidden[q] = true;
                    }
                }
            }
        }
        var arr = [];
        for(var p in shown){
        	if(shown.hasOwnProperty(p)){
        		arr.push(p);
        	}
        }
        shown = arr;
        
        arr = [];
        for(var p in hidden){
        	if(hidden.hasOwnProperty(p)){
        		arr.push(p);
        	}
        }
        hidden = arr;
        
        return {
            hflag: hflag,
            shown: shown,
            hidden: hidden,
            showPairs: SCOM.transferArr2Pairs(shown),
            hidePairs: SCOM.transferArr2Pairs(hidden)
        }
    },
	
	/*
	 * do the filtering
	 */
	applyFilter : function(suspendEvent, refreshCalCdt, remove){		
		var sheet = this.sheet, store = this.sheet.getStore(), sheetId = this.sheet.getSheetId();                
        var obj = this.getShownHiddens(), shown = obj.shown, hidden = obj.hidden, showPairs = obj.showPairs, hidePairs = obj.hidePairs;

		if(suspendEvent || false !== sheet.fireEvent('beforefiltering', sheetId, shown, hidden, this.pos, sheet)){			
			for(var i = 0, len = showPairs.length; i < len; i++){
				var it = showPairs[i];
                store.showRow(sheetId, it[0], it[1], true);
			}
			for(var i = 0, len = hidePairs.length; i < len; i++){
                var it = hidePairs[i];
                store.hideRow(sheetId, it[0], it[1], true);				
			}						
			/*
			 * update the filtered flag
			 */
			if(0 < obj.hflag){
				this.filteredFlag = true;
			}else{
				delete(this.filteredFlag);			
			}
			/*
			 * update the trigger css
			 */
			var oldData = store.getCell(sheetId, this.pos.row, this.pos.col, true);
			var oldTrigger = oldData.trigger, oldFilterCdt = oldData.filterCdt, oldFilter = oldData.filter;
			this.updateTrigger(remove);
			/*
			 * pass refreshCalCdt for refresh
			 */
			this.sheet.refreshRange(undefined, refreshCalCdt);		
			this.menu.hide();
			if(!suspendEvent){
				/*
				 * if not suspend event
				 */
				sheet.fireEvent('filtering', sheetId, shown, hidden, this.pos, oldTrigger, oldFilter, oldFilterCdt, sheet);
			}	
			return [sheetId, shown, hidden, this.pos, oldTrigger, oldFilterCdt];
		}		
	},
	
	cancelFilter : function(){		
		this.menu.hide();
	},
	
	/*
	 * clear the filter
	 */
	clearFilter : function(suspendEvent, refreshCalCdt, remove){
		/*
		 * set all checked
		 */
		for(var p in this.distinctCache){
			this.distinctCache[p]['checked'] = true;
		}
        if(this.showHiddenCache){
           this.showHiddenCache.hidden = {};
           delete(this.showHiddenCache.hflag);
        }
		this.applyFilter(suspendEvent, refreshCalCdt, remove);
	},
	
	/*
	 * clear the filter and remove the trigger
	 */
	removeFilter : function(){		
		this.clearFilter(false, false, true);
	},
	
	/*
	 * sort the filter span asc
	 */
	sortAsc : function(){		
		this.checkSort('asc');
	},
	
	/*
	 * sort the filter span desc
	 */
	sortDesc : function(){
		this.checkSort('desc');
	},
	
	/*
	 * update the css of the trigger to let user notice the status of the filter right now
	 */
	updateTrigger : function(remove){
		var store = this.sheet.getStore(), sheetId = this.sheet.getSheetId();
		if(true === remove){
           store.setCell(sheetId, this.pos.row, this.pos.col, {'trigger': false}, ['filterCdt', 'filter'], true);
		}else{
			var arr = [];
			if(this.filteredFlag){
				arr.push('filtered');
			}
			if(this.sortFlag){
				arr.push(this.sortFlag);
			}
			arr.unshift('ss');
			arr.push('trigger');
			var str = arr.join('-');		
			
			var filterCdt = this.getFilterCondition();
			
			store.setCell(sheetId, this.pos.row, this.pos.col, {
				'trigger': 'ss-filter '+str,
				'filterCdt': Ext.encode(filterCdt)
			}, null, true);
		}
	},
	
	/*
	 * get filter condtion
	 */
	getFilterCondition: function(){
		var sm = this.grid.getSelectionModel();
		var recs = this.distinctStore.getRange();
		var len = recs.length;
		var sels = [], usels = [];
		for(var p in this.distinctCache){
			var it = this.distinctCache[p], checked = this.distinctCache[p]['checked'];
			var text = p;
			if('blank-text' == it.id){
				text = '';
			}			
			if(!checked){
				usels.push(text);
			}else{
				sels.push(text);
			}
		}		
		var slen = sels.length, ulen = usels.length;
		if(slen < ulen){
			return {
				type: 'match',
				values: sels
			};
		}else{
			return {
				type: 'no-match',
				values: usels
			};
		}
	},
	
	checkSort : function(dir, suspendEvent){
		var sheet = this.sheet, store = this.sheet.getStore();
		var filterSpan = this.filterSpan;
		if((filterSpan[1] === filterSpan[3] && filterSpan[2] === filterSpan[4] && 0 !== filterSpan[1] && 0 !== filterSpan[2])
			|| (0 === filterSpan[1] && 0 === filterSpan[2])){
			/*
			 * can not sort single cell or whole sheet
			 */
			Ext.Msg.show({
				title:SLANG['hint'],
				msg:SLANG['can_not_sort_range'],
				icon:Ext.Msg.INFO,
				buttons:Ext.Msg.OK
			});
		}else{
			if(this.isTplFilter){				
				this.sort(dir, false, suspendEvent);
			}else{
				var withMerged = false, expand;			
				SPOP.showSortColumnOption({
					applyCallback:{
						fn:function(opt){							
							if(0 == opt){
								expand = true;
							}else{
								expand = false;
							}						
							/*
							 * if the sort function will move the whole row, then need check the whole row for valid
							 */
							var tmpSpan = [].concat(filterSpan);
							if(expand){
								tmpSpan[2] = tmpSpan[4] = 0;
							}			
							store.walkRange([tmpSpan], function(rd){				
								var json = rd.data.json;
								if(store.isMergedCell(json, rd.data.sheet, rd.data.row, rd.data.col) || json['tpl']){
									withMerged = true;
									return false;
								}
							}, this, true);
							if(withMerged){
								/*
								 * can not sort with merged cell
								 */
								Ext.Msg.show({
									title:SLANG['hint'],
									msg:SLANG['can_not_sort_merged_or_table_tpl'],
									icon:Ext.Msg.INFO,
									buttons:Ext.Msg.OK
								});
							}else{				
								this.sort(dir, expand, suspendEvent);
							}
						},
						scope:this
					}
				});	
			}			
		}
	},
	
	/*
	 * sort the filter span
	 */
	sort : function(dir, expand, suspendEvent){
		var sortOn = 'col';
		var sheet = this.sheet, store = this.sheet.getStore(), sheetId = this.sheet.getSheetId();
		var filterSpan = this.filterSpan;
		var keys = [filterSpan[2]];
		var sortSpan = filterSpan;
		if(this.isTplFilter){
			sortSpan = this.isTplFilter;
		}		
		/*
		 * save the old trigger
		 */
		var oldTrigger = store.getCell(sheetId, this.pos.row, this.pos.col, true).trigger;
		if(suspendEvent || false !== sheet.fireEvent('beforesortfilter', [].concat(sortSpan), keys, dir, sortOn, expand, false, store)){
			var relatedRows = sheet.getRelatedRowsForAutoHeight([sortSpan], undefined, undefined, true);
			
			var coord;
			if(expand){
				coord = [[sortSpan[0], sortSpan[1], 0, sortSpan[3], 0]];			
			}else{
				coord = [sortSpan];
			}
			/*
			 * get cells need recalculated
			 */
			var reCalCells = sheet.getRecalculateCellsByCoord(coord);
			
			sheet.fireEvent('preparesortfilter', [].concat(sortSpan), keys, dir, sortOn, expand, false, store);
			this.sortFlag = dir;
			/*
			 * update the trigger css
			 */
			this.updateTrigger();		
			
			/*
			 * sort the data but not refresh UI, also suspend the "sortchange" event
			 */
			var diff = store.sortSpan([].concat(sortSpan), SCOM.copy(keys), dir, sortOn, expand, false, true);
			
			store.walkRange(coord, function(rd, walkSpan, store, internalId){
				var sid = rd.data.sheet, row = rd.data.row, col = rd.data.col, json = rd.data.json;
				if(sheet.isCalculateCell(json)){
					/*
					 * reset the calculate string for the new [sheet, row, col]
					 */
					var oldRow, oldCol;
					
					if('row' == sortOn){
						oldCol = diff[rd.data.col];
					}else{
						oldRow = diff[rd.data.row];
					}	
					
					var o = sheet.resetCalculateCellData(json, sid, row, col, undefined, oldRow, oldCol);
					
					store.setCell(sid, row, col, o, null, true);
					
					if(!reCalCells[internalId]){
						reCalCells[internalId] = [sid, row, col];
					}
				}
			}, this, true);
			/*
			 * recalculate the shown/hidden rows
			 */
			var span = [].concat(filterSpan);
			var distinct = {}, minrow = false, maxrow = false, nonemptys = {};
			var row = this.pos.row, col = this.pos.col;		
			store.walkRange([span], function(rd){
				var json = rd.data.json;
				
				if(row < rd.data.row && 0 !== rd.data.row && 0 !== rd.data.col){
					var cd = sheet.getCellValue(rd.data.sheet, rd.data.row, rd.data.col);
					var data = cd.data;			
					if(false != SCOM.typeOf(data) && '' !== data){	
						distinct[data] = distinct[data] || {							
							'checked':this.distinctCache[data].checked,
							'rows':{}
						};
						distinct[data]['rows'][rd.data.row] = true;					
						/*
						 * save the nonemptys
						 */
						nonemptys[rd.data.row] = true;
					}				
				}
			}, this, true);
			/*
			 * add empty option if need
			 */
			var emptys = {};
			for(var i = this.pos.minrow; i <= this.pos.maxrow; i++){
				if(!nonemptys[i]){
					emptys[i] = true;
				}			
			}
			if(!SCOM.isEmptyObj(emptys)){
				var blank = '('+SLANG['blank']+')';
				distinct[blank] = {
					id: 'blank-text',
					'checked':this.distinctCache[blank].checked,
					'rows':emptys
				}				
			}
			this.distinctCache = distinct;
			
			Ext.applyIf(relatedRows, sheet.getRelatedRowsForAutoHeight([sortSpan]));
			/*
			 * check auto height change
			 */
			var changedHeights = sheet.checkAutoHeightForRows(relatedRows);
			
			/*
			 * do the filter again
			 */
			var filterInfo = this.applyFilter(true, reCalCells);
			filterInfo[4] = oldTrigger;
			if(!suspendEvent){
				sheet.fireEvent('sortfilter', [].concat(sortSpan), SCOM.copy(keys), dir, null, expand, false, diff, filterInfo, reCalCells, changedHeights, store);
			}						
		}		
	},
	
	/*
	 * when keyup in search field, will filter the list
	 */
	onSearchKeyUp : function(field, e){
		this.startIndex = 0;
		var count = 0, limit = this.pageCount;
		var val = field.getValue();
		var store = this.distinctStore, sm = this.grid.getSelectionModel();
		if(val){
			var str = val.toString(), distinct = this.distinctCache;
			for(var text in distinct){
				if(distinct.hasOwnProperty(text) && text){
					var it = distinct[text];
					if('blank-text' === it.id){
						it.checked = false;
					}else{
						var index = text.indexOf(str);
						if(0 !== index){
							it.checked = false;
						}else{		
							it.checked = true;
							count++;
						}
					}															
				}
			}
			this.filteringFlag = str;
			this.pos.totalNum = count;			
			this.pos.totalPage = Math.ceil(count/this.pageCount);		
			var isEnd = this.setupWithPage(this.setupInfo.row, this.setupInfo.col, this.setupInfo.filterSpan, this.setupInfo.filterCdt, 0, this.pageCount);
            if(isEnd){
                this.nextPageBtn.disable();
            }else{
                this.nextPageBtn.enable();
            }
		}else{
			this.filteringFlag = false;
			var distinct = this.distinctCache;
			for(var text in distinct){
				if(distinct.hasOwnProperty(text)){					
					var it = distinct[text];
					it.checked = true;																	
				}
			}
			total = SCOM.countObjMember(distinct);
			this.pos.totalNum = total;
			this.pos.totalPage = Math.ceil(total/this.pageCount);
			var isEnd = this.setupWithPage(this.setupInfo.row, this.setupInfo.col, this.setupInfo.filterSpan, this.setupInfo.filterCdt, 0, this.pageCount);
            if(isEnd){
                this.nextPageBtn.disable();
            }else{
                this.nextPageBtn.enable();
            }
		}	
		sm.selectAll();
	},
	
	/*
	 * show filter reference
	 */
	showFilterReference : function(cell, sheetId, row, col){
		if(cell.filter){
			var span = Ext.decode(cell.filter);			
			var coord = [];
			if(!Ext.isNumber(span[0])){
				span[0] = sheetId;
			}
			span[1] += row-1;
			span[2] += col;
			span[3] += row;
			span[4] += col;
			if(!Ext.isNumber(span[3])){
				span[1] = 0;
				span[3] = 0;
			}
			coord.push({
				span: span,
				cls: 'ss-rm-condition'
			});						
			var rm = this.sheet.getReferenceModel();
			
			rm.setReference(coord, false, false, 'ss-cal-ref');			
			rm.show();
			return true;
		}
		return false;
	},
	
	/*
	 * when menu hide we will hide the reference too
	 */
	onMenuHide : function(){
		var rm = this.sheet.getReferenceModel();
		if(rm.hasCls('ss-cal-ref')){				
			rm.hide();
		}
	},
	
	/*
	 * switch filter type
	 */
	onFilterTypeCheck : function(item, checked){
		if(checked){
			this.filterTypeCt.getLayout().setActiveItem(1);			
		}else{
			this.filterTypeCt.getLayout().setActiveItem(0);
		}
	},
	
	/**
	 * clean the all filters in the passed sheet
	 */
	cleanFilterForSheet : function(sheetId){
		var sheet = this.sheet, store = sheet.getStore();
		var rows = {}, oldCells = {}, newCells = {};
		store.each(function(rd, internalId){
			if(rd.data.sheet === sheetId){
				var row = rd.data.row, col = rd.data.col;
				var json = rd.data.json;
				var filter = json.filter;
				if(filter){
					filter = Ext.decode(filter);
					var minrow = filter[1]+row, maxrow = filter[3]+row;
					if(0 === maxrow){
						store.walkRange([[sheetId, minrow, col, maxrow, col]], function(rd){
							if(0 !== rd.data.row){
								rows[rd.data.row] = true;
							}
						});
					}else{
						for(var i = minrow; i <= maxrow; i++){
							rows[i] = true;
						}
					}
					var id = internalId;
					oldCells[id] = SCOM.copy(rd.data);
					store.setCell(sheetId, row, col, null, ['trigger', 'filter', 'filterCdt'], true);
					newCells[id] = SCOM.copy((store.getByMapId(id)).data);
				}
			}
		});
		var hiddens = [];
			    
		for(var p in rows){
			if(rows.hasOwnProperty(p)){
				var row = Number(p);
				if(!store.isVisibleRow(sheetId, row)){					
					hiddens.push(row);
				}
			}
		}
		
		var showPairs = SCOM.transferArr2Pairs(hiddens);
	    for(var i = 0, len = showPairs.length; i < len; i++){
			var it = showPairs[i];
            store.showRow(sheetId, it[0], it[1], true);
		}
		/*
		 * fire event for clean all filters
		 */
		sheet.fireEvent('cleanfilter', sheetId, oldCells, newCells, hiddens, sheet);
		sheet.refreshRange();
	}
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.history.Motion', {
	
	/* Begin Definitions */
		
	
	/* End Definitions */
	constructor : function(config){
		Ext.apply(this, config);
		
		this.callParent();		
	},
	
	undo: function(){
		return this.defaultUndo.apply(this, arguments);
	},
	
	redo: function(){
		return this.defaultRedo.apply(this, arguments);
	},
	
	/*
	 * default undo action
	 * @param {boolean} suspendRefresh: true to not refresh the element
	 * @param {boolean} suspendRefreshSelection: true to not refresh the selection
	 */
	defaultUndo: function(suspendRefresh, suspendRefreshSelection){		
		var sheet = this.sheet, store = sheet.getStore(), sm = sheet.getSelectionModel();
		var coord = this.coord, origins = this.origins, range = this.range,			
			originSheetId = this.originSheetId, originSel = this.originSel,
			originFocus = this.originFocus, ignoreRowCol = this.ignoreRowCol;
		
		store.walkRange(coord, function(rd, walkSpan, store, internalId){
			var id = internalId;
			if(!origins[id]){
				store.setCell(rd.data.sheet, rd.data.row, rd.data.col, null, null, true, 'clear');
			}			
		}, this, undefined, undefined, ignoreRowCol);
		for(var p in origins){
			if(origins.hasOwnProperty(p)){
				var it = origins[p];
				var sheetId = it.sheet, row = it.row, col = it.col, json = it.json;
				store.setCell(sheetId, row, col, json, null, true, 'clear');
			}
		}
			
		if(!suspendRefresh){	
			if(this.cdtCoord){
				sheet.clearCdtValueForCoord(this.cdtCoord);
			}
			if(sheet.getSheetId() != this.originSheetId){
                sheet.go2Sheet(this.originSheetId, function(){
                    sheet.refreshCalCdt(this.refreshCalCdt);
                }, this);
			}else{
				range.refresh(this.refreshCalCdt, undefined, this.cdtCoord);
			}					
		}
		if(!suspendRefreshSelection){
			/*
			 * for selection and focus
			 */
			sm.selectRange(originSel.startPos, originSel.endPos);
			sheet.refreshFocus(originFocus.row, originFocus.col);
		}
		return this.coord;
	},
	
	/*
	 * default redo action
	 * @param {boolean} suspendRefresh: true to not refresh the element
	 * @param {boolean} suspendRefreshSelection: true to not refresh the selection
	 */
	defaultRedo: function(suspendRefresh, suspendRefreshSelection){	
		var sheet = this.sheet, store = sheet.getStore(), sm = sheet.getSelectionModel();
		var coord = this.coord, modifieds = this.modifieds, range = this.range,			
			sheetId = this.sheetId, sel = this.sel,
			focus = this.focus, ignoreRowCol = this.ignoreRowCol;
		
		store.walkRange(coord, function(rd, walkSpan, store, internalId){
			var id = internalId;
			if(!modifieds[id]){
				store.setCell(rd.data.sheet, rd.data.row, rd.data.col, null, null, true, 'clear');
			}			
		}, this, undefined, undefined, ignoreRowCol);
		for(var p in modifieds){
			if(modifieds.hasOwnProperty(p)){
				var it = modifieds[p];
				var sheetid = it.sheet, row = it.row, col = it.col, json = it.json;
				store.setCell(sheetId, row, col, json, null, true, 'clear');
			}
		}
		if(!suspendRefresh){
			if(this.cdtCoord){
				sheet.clearCdtValueForCoord(this.cdtCoord);
			}
			if(sheet.getSheetId() != sheetId){
                sheet.go2Sheet(this.originSheetId, function(){
                    sheet.refreshCalCdt(this.refreshCalCdt);
                }, this);
			}else{
				range.refresh(this.refreshCalCdt, undefined, this.cdtCoord);
			}					
		}
		if(!suspendRefreshSelection){
			/*
			 * for selection and focus
			 */
			sm.selectRange(sel.startPos, sel.endPos);
			sheet.refreshFocus(focus.row, focus.col);
		}
		return this.coord;
	}
});
Ext.define('EnterpriseSheet.sheet.history.History', {
	
	/* Begin Definitions */
	
	extend: 'Ext.util.Observable',	
	
	requires : [
	    'EnterpriseSheet.sheet.history.Motion'
	],
	
	/* End Definitions */
	/*
	 * the max stack length, if the stack grow beyond this value, then will delete 
	 * the oldest motion
	 */
	maxStackLength : 20,
	
	constructor : function(config){
		Ext.apply(this, config);
		
		this.callParent();		
		
		
	},
	
	/*
	 * init the history for sheet
	 */
	init : function(sheet){
		if(this.sheet){
			return;
		}			
		this.sheet = sheet;
		/*
		 * init the stack
		 */
		this.stack = [];
		this.cursor = -1;
		
		var store = sheet.getStore(), editor = sheet.getEditor();
        
           
		this.mon(store, {
			scope: this,
			'afterload': this.afterStoreLoad,
			/*
			 * for remove row/column/cell
			 */
			'prepareremoverow': this.prepareRemoveRow,
			'prepareremovecolumn': this.prepareRemoveColumn,
			'prepareremovecell': this.prepareRemoveCell,
			/*
			 * for insert row/column/cell
			 */
			'prepareinsertrow': this.prepareInsertRow,
			'prepareinsertcolumn': this.prepareInsertColumn,
			'prepareinsertcell': this.prepareInsertCell,			
			/*
			 * for tpl summary change
			 */
			'tplsummarychange' : this.onTplSummaryChange,
			'createfileconfig' : this.onCreateFileConfig,
			'updatefileconfig' : this.onUpdateFileConfig,
			'removefileconfig' : this.onRemoveFileConfig
		});
		
		this.mon(sheet, {
			scope:this,
            'resethistory': this.clearHistory,
            'disablehistory': function(){
                this.disabled = true;
            },
            'enablehistory': function(){
                delete(this.disabled);
            },
            'preparecompleteedit': function(sheetId, row, col, editor, asArrayFormula){
                if(asArrayFormula){
                    var span = sheet.getSelectionModel().selection2Span();
                    this.onArrayFormulaChange(span);
                }
            },
			/*
			 * for data change
			 */
			'datachange' : this.onDataChange,
			'keydown': this.onKeyDown,	
			'prepareautoextendcdt' : function(sheetId, row, col, changedCdt){
				this.prepareautoextendcdt.apply(this, arguments);
				sheet.fireEvent('changing', sheet);
			},
			/*
			 * sort, filtering events
			 */						
			'preparesortspan' : function(){
				this.beforeSortSpan.apply(this, arguments);
				sheet.fireEvent('changing', sheet);
			},
			/*
			 * sort in filter, it could be sort and filter in one step
			 */
			'preparesortfilter' : function(){
				this.beforeSortFilter.apply(this, arguments);
				sheet.fireEvent('changing', sheet);
			},
			'preparecreatefilter':function(span){		
				var range = new EnterpriseSheet.sheet.range.Range({
					sheet: this.sheet,
					coord: [span]
				});
				this.beforeRangeChange(range, 'createfilter', SLANG['create_filter_for']);
				sheet.fireEvent('changing', sheet);
			},
			'filtering':function(sheetId, shown, hidden, triggerPos, oldTrigger, oldFilter, oldFilterCdt){				
				var eventName = 'filtering';
				var display = SLANG['filtering'];
				this.onFiltering(sheetId, shown, hidden, triggerPos, oldTrigger, oldFilter, oldFilterCdt, display);
				sheet.fireEvent('changing', sheet);
			},
			/*
			 * clean the filter 
			 */
			'cleanfilter': this.onCleanFilter,
			/*
			 * before do the autofill
			 */
			'prepareautofill':function(range, fromCoord, ss, originCdts, reCalCells, changedHeights){				
				this.beforeRangeChange(range, 'autofill', SLANG['autofill'], false, reCalCells, originCdts, changedHeights);
				sheet.fireEvent('changing', sheet);
			},
			/*
			 * before do the style brush
			 */
			'preparestylebrush':function(range, fromCoord, sheet, originCdts, reCalCells){
				this.beforeRangeChange(range, 'stylebrush', SLANG['apply_style_brush'], false, reCalCells, originCdts);
				sheet.fireEvent('changing', sheet);
			},
			'preparerangechange':function(range, modified, deleted, changedHeights, cdtCoord){
				this.beforeRangeChange(range, 'rangechange', SLANG['change_property_for'], undefined, undefined, undefined, changedHeights, cdtCoord, true);
				sheet.fireEvent('changing', sheet);
			},			
			'preparecleanrange':function(range, clearType, sheet, originCdts, reCalCells, changedHeights){
				/*
				 * no need margin refresh, but need calculate and condition refresh
				 */
				this.beforeRangeChange(range, 'cleanrange', SLANG['clean_for'], false, reCalCells, originCdts, changedHeights);
				sheet.fireEvent('changing', sheet);
			},
			'preparepaste':function(range, sheet, originCdts, reCalCells, changedHeights){
				
				/*
				 * no need margin refresh, but need calculate and condition refresh
				 */
				this.beforeRangeChange(range, 'paste', SLANG['paste_at'], false, reCalCells, originCdts, changedHeights);
				sheet.fireEvent('changing', sheet);
			},
			'preparerangemove':function(range, sheet, originCdt, reCalCells, changedHeights){								
				/*
				 * no need margin refresh, but need calculate and condition refresh
				 */
				this.beforeRangeChange(range, 'rangemove', SLANG['selection_move2'], false, reCalCells, originCdt, changedHeights);
				sheet.fireEvent('changing', sheet);
			},
			'prepareconditionchange':function(range, ss, originCdt, cdtCoord){
				this.beforeRangeChange(range, 'conditionchange', SLANG['change_condition_for'], false, undefined, originCdt, undefined, cdtCoord);
				sheet.fireEvent('changing', sheet);
			},
			'preparesettpl':function(span){
				var range = new EnterpriseSheet.sheet.range.Range({
					coord: [span],
					sheet: this.sheet
				});
				this.beforeRangeChange(range, 'settpl', SLANG['set_table_tpl'], undefined, true);
				sheet.fireEvent('changing', sheet);
			},
			'prepareborderchange':function(range){
				/*
				 * need margin refresh
				 */
				this.beforeRangeChange(range, 'borderchange', SLANG['change_border_for'], true);
				sheet.fireEvent('changing', sheet);
			},
			/*
			 * for resize
			 */
			'aftercolumnresized': function(){
				this.onColumnResized.apply(this, arguments);
				sheet.fireEvent('changing', sheet);
			},
			
			'rowresized': function(){
				this.onRowResized.apply(this, arguments);
				sheet.fireEvent('changing', sheet);
			},
			
			'rowautoresized': function(){
				this.onRowAutoResized.apply(this, arguments);
				sheet.fireEvent('changing', sheet);
			},
			
			/*
			 * for show/hide
			 */
			'columnhide': function(){
				this.onColumnHide.apply(this, arguments);
				sheet.fireEvent('changing', sheet);
			},
			
			'rowhide': function(){
				this.onRowHide.apply(this, arguments);
				sheet.fireEvent('changing', sheet);
			},
			
			'columnshow': function(){
				this.onColumnShow.apply(this, arguments);
				sheet.fireEvent('changing', sheet);
			},
			
			'rowshow': function(){
				this.onRowShow.apply(this, arguments);
				sheet.fireEvent('changing', sheet);
			},		
			
			/*
			 * for toggle row/col group
			 */
			'togglerowgroup' : function(){
				this.onToggleRowGroup.apply(this, arguments);
				sheet.fireEvent('changing', sheet);
			},
			
			'togglecolgroup' : function(){
				this.onToggleColGroup.apply(this, arguments);
				sheet.fireEvent('changing', sheet);
			},
			
			'togglerowgrouplevel' : function(){
				this.onToggleRowGroupLevel.apply(this, arguments);
				sheet.fireEvent('changing', sheet);
			},
			
			'togglecolgrouplevel' : function(){
				this.onToggleColGroupLevel.apply(this, arguments);
				sheet.fireEvent('changing', sheet);
			},
			
			'changegroup' : function(){
				this.onChangeGroup.apply(this, arguments);
				sheet.fireEvent('changing', sheet);
			},
                 
            'updategroups' : function(){
                this.onUpdateGroups.apply(this, arguments);
                sheet.fireEvent('changing', sheet);
            },
						
			/*
			 * for freeze and split
			 */
			'freezechange': function(){
				this.onFreezeChange.apply(this, arguments);
				sheet.fireEvent('changing', sheet);
			},
			
			'splitchange': function(){
				this.onSplitChange.apply(this, arguments);
				sheet.fireEvent('changing', sheet);
			},
			
			'mergecell': function(){
				this.onMergeCell.apply(this, arguments);
				sheet.fireEvent('changing', sheet);
			},
			
			'unmergecell': function(){
				this.onUnmergeCell.apply(this, arguments);
				sheet.fireEvent('changing', sheet);
			},
			
			'undo':function(suspendRefresh, suspendEvent){				
				this.undo(null, suspendRefresh, suspendEvent);
			},
			
			'redo':function(suspendRefresh, suspendEvent){
				this.redo(null, suspendRefresh, suspendEvent);
			},
			
			/*
			 * for create and delete chart
			 */
			'createchart': function(chartType, chart, rangeStore){
				this.onCreateChart(chartType, chart, rangeStore);
				sheet.fireEvent('changing', sheet);
			},
			
			'deletechart': function(chartType, chart, rangeStore, posize){				
				this.onDeleteChart(chartType, chart, rangeStore, posize);
				sheet.fireEvent('changing', sheet);
			},
			
			/*
			 * for create and delete picture floor 
			 */
			'createpicture': function(url, picFloor){
				this.onCreatePicture(url, picFloor);
				sheet.fireEvent('changing', sheet);
			},
						
			'deletepicture': function(url, picFloor, info){
				this.onDeletePicture(url, picFloor, info);
				sheet.fireEvent('changing', sheet);
			},
            /*
             * for create and delete wedgit floor
             */
            'createwedgit': function(url, picFloor){
                this.onCreateWedgit(url, picFloor);
                sheet.fireEvent('changing', sheet);
            },
                 
            'deletewedgit': function(url, picFloor, info){
                this.onDeleteWedgit(url, picFloor, info);
                sheet.fireEvent('changing', sheet);
            },
			'beforeinsertcopied': this.prepareMergeMotion,
			'insertcopied': function(){
				this.mergeMotion(SLANG['insert_copied']);
			},
            'preparedeleterows': this.prepareMergeMotion,
            'deleterows': function(){
                this.mergeMotion(SLANG['delete_repeat_item']);
            },
            'preparedeletecellrangemovetop': this.prepareMergeMotion,
            'deletecellrangemovetop': function(){
                this.mergeMotion(SLANG['delete_repeat_item']);
            },
            'preparesetheadertitle': this.prepareSetHeaderTitle,
            'preparemoveforinsert': this.prepareMergeMotion,
            'moveforinsert': function(){
                this.mergeMotion(SLANG['cut_move_selection']);
            },
            'createcustomerhistory': this.onCreateCustomerHistory
		});			
	},
	
	/*
	 * detect ctrl+z/ctrl+y
	 */	
	onKeyDown : function(e){		
		var key = e.getKey();		
		if(e.ctrlKey){
			if(89 == key){//press y
                e.preventDefault();
				this.redo();
			}else if(90 == key){//press z
                e.preventDefault();
				this.undo();
			}
		}
	},
	
	/*
	 * create motion when unmerge cells
	 */
	onUnmergeCell : function(span, unmerged, sheet, reCalCells){
		var sheet = this.sheet, sm = sheet.getSelectionModel(), store = sheet.getStore(), sheetId = sheet.getSheetId();
		var sel = sm.getSelection(), focus = sm.getFocusCell(); 		
		
		/*
		 * transfer the focus cell coord to a string
		 */
		var str = EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String([{
			span: span,
			type: SCONST.RELATIVE_COORD
		}], '');
		
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text:SLANG['cancel_merge_cell']+' '+str,	
			conflictAction: 'unmergeCell',
			undo:function(suspendRefresh, suspendRefreshSelection){			
				for(var p in unmerged){
					sheet.doMergeCell(unmerged[p], true, true);
				}				
				if(!suspendRefresh){
					if(sheet.getSheetId() != sheetId){
						sheet.go2Sheet(sheetId);
					}else{
						sheet.refreshRange(null, reCalCells);
					}										
				}
				if(!suspendRefreshSelection){
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			},
			redo:function(suspendRefresh, suspendRefreshSelection){				
				for(var p in unmerged){
					sheet.doUnmergeCell(unmerged[p], true, true);
				}
				if(!suspendRefresh){
					if(sheet.getSheetId() != sheetId){
						sheet.go2Sheet(sheetId);
					}else{
						sheet.refreshRange(null, reCalCells);
					}									
				}
				if(!suspendRefreshSelection){
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);					
				}
			}
		});
		this.add(motion);
	},
	
	/*
	 * create motion when merge cells
	 */
	onMergeCell : function(span, sheet, reCalCells){
		var sheet = this.sheet, sm = sheet.getSelectionModel(), store = sheet.getStore(), sheetId = sheet.getSheetId();
		var sel = sm.getSelection(), focus = sm.getFocusCell(); 		
		
		/*
		 * transfer the focus cell coord to a string
		 */
		var str = EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String([{
			span: span,
			type: SCONST.RELATIVE_COORD
		}], '');
		
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text:SLANG['merge_cell']+' '+str,					
			conflictAction: 'mergeCell',
			undo:function(suspendRefresh, suspendRefreshSelection){						
				sheet.doUnmergeCell(span, true, true);
				if(!suspendRefresh){
					if(sheet.getSheetId() != sheetId){
						sheet.go2Sheet(sheetId, function(){							
							sheet.refreshCalCdt(reCalCells, undefined, undefined, [span]);
						});
					}else{
						sheet.refreshRange([span], reCalCells);
					}									
				}
				if(!suspendRefreshSelection){
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			},
			redo:function(suspendRefresh, suspendRefreshSelection){				
				sheet.doMergeCell(span, true, true);
				if(!suspendRefresh){
					if(sheet.getSheetId() != sheetId){
						sheet.go2Sheet(sheetId, function(){							
							sheet.refreshCalCdt(reCalCells, undefined, undefined, [span]);
						});
					}else{
						sheet.refreshRange([span], reCalCells);
					}										
				}
				if(!suspendRefreshSelection){
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			}
		});
		this.add(motion);
	},
	
	/*
	 * create motion when split change
	 */
	onSplitChange : function(splitPos, oldSplitPos, freezePos, oldFreezePos, rangeInfo, oldRangeInfo, sheet){
		var sheet = this.sheet, sm = sheet.getSelectionModel(), store = sheet.getStore(), sheetId = sheet.getSheetId();
		var sel = sm.getSelection(), focus = sm.getFocusCell(); 		
		
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text:SLANG['split'],					
			undo:function(suspendRefresh, suspendRefreshSelection){		
				var obj = {
					splitPos: oldSplitPos,
					freezePos: oldFreezePos,
					rangeInfo: oldRangeInfo
				};
				sheet.setSheetConfig(obj);
				sheet.updateSheetConfig(true);
				if(!suspendRefresh){						
					if(sheet.getSheetId() != sheetId){
						sheet.go2Sheet(sheetId);
					}else{
						sheet.refreshRange();
					}
				}
				if(!suspendRefreshSelection){
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			},
			redo:function(suspendRefresh, suspendRefreshSelection){				
				var obj = {
					splitPos: splitPos,
					freezePos: freezePos,
					rangeInfo: rangeInfo
				};
				sheet.setSheetConfig(obj);
				sheet.updateSheetConfig(true);
				if(!suspendRefresh){
					if(sheet.getSheetId() != sheetId){
						sheet.go2Sheet(sheetId);
					}else{
						sheet.refreshRange();
					}									
				}
				if(!suspendRefreshSelection){
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			}
		});
		this.add(motion);
	},
	
	/*
	 * create motion when freeze change
	 */
	onFreezeChange : function(freezePos, oldFreezePos, splitPos, oldSplitPos, rangeInfo, oldRangeInfo, sheet){
		var sheet = this.sheet, sm = sheet.getSelectionModel(), store = sheet.getStore(), sheetId = sheet.getSheetId();
		var sel = sm.getSelection(), focus = sm.getFocusCell(); 
		/*
		 * transfer the focus cell coord to a string
		 */
		var text;
		if(freezePos){
			text = SLANG['freeze']+' '+EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String([{
			    span: ['', freezePos.row, freezePos.col, freezePos.row, freezePos.col],
			    type: SCONST.RELATIVE_COORD
			}], '');
		}else{
			text = SLANG['cancel_freeze'];
		}				
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text:text,					
			undo:function(suspendRefresh, suspendRefreshSelection){		
				var obj = {
					freezePos: oldFreezePos,
					splitPos: oldSplitPos,
					rangeInfo: oldRangeInfo
				};
				sheet.setSheetConfig(obj);
				sheet.updateSheetConfig(true);
				if(!suspendRefresh){
					if(sheet.getSheetId() != sheetId){
						sheet.go2Sheet(sheetId);
					}else{
						sheet.refreshRange();
					}										
				}
				if(!suspendRefreshSelection){
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			},
			redo:function(suspendRefresh, suspendRefreshSelection){				
				var obj = {
					freezePos: freezePos,
					splitPos: splitPos,
					rangeInfo: rangeInfo
				};
				sheet.setSheetConfig(obj);
				sheet.updateSheetConfig(true);
				if(!suspendRefresh){
					if(sheet.getSheetId() != sheetId){
						sheet.go2Sheet(sheetId);
					}else{
						sheet.refreshRange();
					}					
				}
				if(!suspendRefreshSelection){
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			}
		});
		this.add(motion);
	},
	
	/*
	 * create motion when row show
	 */
	onRowShow : function(sheetId, minrow, maxrow, hidden){
		var sheet = this.sheet, sm = sheet.getSelectionModel(), store = sheet.getStore();
		var sel = sm.getSelection(), focus = sm.getFocusCell(); 
		/*
		 * transfer the focus cell coord to a string
		 */
		var str = EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String([{
		    span: ['', minrow, 0, maxrow, 0],
		    type: SCONST.RELATIVE_COORD
		}], '');
		var hidePairs = SCOM.transferArr2Pairs(hidden);
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text:SLANG['show']+' '+str,					
			undo:function(suspendRefresh, suspendRefreshSelection){						
				for(var i = 0, len = hidePairs.length; i < len; i++){
					var it = hidePairs[i];
	                store.hideRow(sheetId, it[0], it[1], true);
				}
				if(!suspendRefresh){					
					if(sheet.getSheetId() != sheetId){
						sheet.go2Sheet(sheetId);
					}else{
						sheet.refreshRange();
					}
				}
				if(!suspendRefreshSelection){
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			},
			redo:function(suspendRefresh, suspendRefreshSelection){								
				for(var i = 0, len = hidePairs.length; i < len; i++){
					var it = hidePairs[i];
	                store.showRow(sheetId, it[0], it[1], true);
				}
				if(!suspendRefresh){
					if(sheet.getSheetId() != sheetId){
						sheet.go2Sheet(sheetId);
					}else{
						sheet.refreshRange();
					}					
				}
				if(!suspendRefreshSelection){
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			}
		});
		this.add(motion);	
	},
	
	/*
	 * create motion when column show
	 */
	onColumnShow : function(sheetId, mincol, maxcol, hidden){		
		var sheet = this.sheet, sm = sheet.getSelectionModel(), store = sheet.getStore();
		var sel = sm.getSelection(), focus = sm.getFocusCell(); 
		/*
		 * transfer the focus cell coord to a string
		 */
		var str = EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String([{
		    span: ['', 0, mincol, 0, maxcol],
		    type: SCONST.RELATIVE_COORD
		}], '');
		var hidePairs = SCOM.transferArr2Pairs(hidden);
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text:SLANG['show']+' '+str,			
			undo:function(suspendRefresh, suspendRefreshSelection){					
				for(var i = 0, len = hidePairs.length; i < len; i++){
					var it = hidePairs[i];
	                store.hideColumn(sheetId, it[0], it[1], true);
				}
				if(!suspendRefresh){
					if(sheet.getSheetId() != sheetId){
						sheet.go2Sheet(sheetId);
					}else{
						sheet.refreshRange();
					}					
				}
				if(!suspendRefreshSelection){
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			},
			redo:function(suspendRefresh, suspendRefreshSelection){								
				for(var i = 0, len = hidePairs.length; i < len; i++){
					var it = hidePairs[i];
	                store.showColumn(sheetId, it[0], it[1], true);
				}
				if(!suspendRefresh){
					if(sheet.getSheetId() != sheetId){
						sheet.go2Sheet(sheetId);
					}else{
						sheet.refreshRange();
					}					
				}
				if(!suspendRefreshSelection){
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			}
		});
		this.add(motion);	
	},
	
	/*
	 * create motino when sort span
	 */
	beforeSortSpan : function(span, keys, dir, sortOn, expand, allString){
		var sheet = this.sheet, sm = sheet.getSelectionModel(), store = sheet.getStore();
		var coord = expand ? [[span[0], span[1], 0, span[3], 0]] : [span];
		
		var preCal, posCal, reCalCells, preAutoHeights, posAutoHeights, me = this;
		
		sheet.on('sortspan', function(span, keys, dir, sortOn, expand, allString, diff){	
			
			var mincol = 0, maxcol = 0, minrow = 0, maxrow = 0;
			if(!expand){
				minrow = span[1];
				maxrow = span[3];
				mincol = span[2];
				maxcol = span[4];
			}
			
			var sel = sm.getSelection(), focus = sm.getFocusCell(); 
			var sheetId = sheet.getSheetId();
			/*
			 * transfer the focus cell coord to a string
			 */		
			var str = EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String([{
				span: span,
				type: SCONST.RELATIVE_COORD
			}], '');
			
			var motion = new EnterpriseSheet.sheet.history.Motion({
				text:SLANG['sort']+' '+str,			
				conflictAction: 'sortSpan',
				conflictAnswer: true,
				undo:function(suspendRefresh, suspendRefreshSelection){												
					store.moveRows(sheetId, diff, mincol, maxcol, true);	
					/*
					 * recover calcdt cache
					 */
					me.recoverCell(preCal);
					
					/*
					 * check auto height change
					 */					
					me.recoverAutoHeight(preAutoHeights, suspendRefresh);
					
					if(!suspendRefresh){
						if(sheet.getSheetId() != sheetId){
							sheet.go2Sheet(sheetId, function(){							
								sheet.refreshCalCdt(reCalCells, undefined, undefined, coord);
							});
						}else{
							sheet.refreshRange(null, reCalCells);
						}										
					}
					if(!suspendRefreshSelection){
						sm.selectRange(sel.startPos, sel.endPos);
						sheet.refreshFocus(focus.row, focus.col);
					}
				},
				redo : function(suspendRefresh, suspendRefreshSelection){								
					store.sortSpan(span, keys, dir, sortOn, expand, allString, true);
					/*
					 * recover calcdt cache
					 */
					me.recoverCell(posCal);
					
					/*
					 * check auto height change 
					 */
					me.recoverAutoHeight(posAutoHeights, suspendRefresh);
					
					if(!suspendRefresh){
						if(sheet.getSheetId() != sheetId){
							sheet.go2Sheet(sheetId, function(){							
								sheet.refreshCalCdt(reCalCells, undefined, undefined, coord);
							});
						}else{
							sheet.refreshRange(null, reCalCells);
						}										
					}
					if(!suspendRefreshSelection){
						sm.selectRange(sel.startPos, sel.endPos);
						sheet.refreshFocus(focus.row, focus.col);
					}
				}
			});
			this.add(motion);
		}, this, {single: true});
		sheet.on('spansorted', function(span, keys, dir, sortOn, expand, allString, reCals, oldCals, newCals, changedHeights, store, sheet){
			/*
			 * save post cal and cdt cells
			 */
			preCal = oldCals;
			posCal = newCals;		
			reCalCells = reCals;			
			preAutoHeights = changedHeights.oldHeights;
			posAutoHeights = changedHeights.newHeights;
		}, this, {single: true});
	},	
	
	/**
	 * recover the auto height
	 */
	recoverAutoHeight : function(autoHeights, suspendRefresh){
		var store = this.sheet.getStore();
		for(var p in autoHeights){
			if(autoHeights.hasOwnProperty(p)){
				var it = autoHeights[p];
				store.setRow(it.sheetId, it.row, {'autoHeight': it.ah}, null, true, suspendRefresh, null, true);
			}
		}
	},
	
	beforeSortFilter : function(span, keys, dir, sortOn, expand, allString){
		var sheet = this.sheet, sm = sheet.getSelectionModel(), store = sheet.getStore();
		var coord = expand ? [[span[0], span[1], 0, span[3], 0]] : [span];
		var preCal = this.cacheCalCdt(coord), posCal, me = this;
		sheet.on('sortfilter', function(span, keys, dir, sortOn, expand, allString, diff, filterInfo, reCalCells, changedHeights, store){
			var mincol = 0, maxcol = 0;
			if(!expand){
				mincol = span[2];
				maxcol = span[4];
			}
			/*
			 * save post cal and cdt cells
			 */
			posCal = this.cacheCalCdt(coord);	
			
			var preAutoHeights = changedHeights.oldHeights, posAutoHeights = changedHeights.newHeights;
			
			var sel = sm.getSelection(), focus = sm.getFocusCell(); 
			var sheetId = sheet.getSheetId();		
			
			var shown = filterInfo[1], hidden = filterInfo[2], triggerPos = filterInfo[3], oldTrigger = filterInfo[4];
			var trigger = store.getCell(sheetId, triggerPos.row, triggerPos.col, true).trigger;
			/*
			 * transfer the focus cell coord to a string
			 */		
			var str = EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String([{
			    span: ['', triggerPos.row, triggerPos.col, triggerPos.row, triggerPos.col],
			    type: SCONST.RELATIVE_COORD
			}], '');
			var motion = new EnterpriseSheet.sheet.history.Motion({
				text:SLANG['sort_filter']+' '+str,	
				conflictAction: 'sortFilter',
				conflictAnswer: true,
				undo:function(suspendRefresh, suspendRefreshSelection){		
					
					for(var i = 0, len = shown.length; i < len; i++){
						var row = shown[i];
						store.hideRow(sheetId, row, row, true);
					}						
					for(var i = 0, len = hidden.length; i < len; i++){
						var row = hidden[i];
						store.showRow(sheetId, row, row, true);
					}
					store.setCell(sheetId, triggerPos.row, triggerPos.col, {
						'trigger': oldTrigger
					}, null, true);					
					store.moveRows(sheetId, diff, mincol, maxcol, true);	
					
					/*
					 * recover calcdt cache
					 */
					me.recoverCell(preCal);
					
					/*
					 * check auto height change
					 */
					me.recoverAutoHeight(preAutoHeights, suspendRefresh)										
					
					if(sheet.getSheetId() != sheetId){
						sheet.go2Sheet(sheetId, function(){							
							sheet.refreshCalCdt(reCalCells, undefined, undefined, coord);
						});
					}else{
						sheet.refreshRange(null, reCalCells);
					}
					if(!suspendRefreshSelection){
						sm.selectRange(sel.startPos, sel.endPos);
						sheet.refreshFocus(focus.row, focus.col);
					}
				},
				redo:function(suspendRefresh, suspendRefreshSelection){							
					store.sortSpan(span, keys, dir, sortOn, expand, allString, true);
					for(var i = 0, len = shown.length; i < len; i++){
						var row = shown[i];
						store.showRow(sheetId, row, row, true);
					}
					for(var i = 0, len = hidden.length; i < len; i++){
						var row = hidden[i];
						store.hideRow(sheetId, row, row, true);
					}
					store.setCell(sheetId, triggerPos.row, triggerPos.col, {
						'trigger': trigger
					}, null, true);
					/*
					 * recover calcdt cache
					 */
					me.recoverCell(posCal);
					
					/*
					 * check auto height change
					 */
					me.recoverAutoHeight(posAutoHeights, suspendRefresh)
					
					if(sheet.getSheetId() != sheetId){
						sheet.go2Sheet(sheetId, function(){							
							sheet.refreshCalCdt(reCalCells, undefined, undefined, coord);
						});
					}else{
						sheet.refreshRange(null, reCalCells);
					}
					if(!suspendRefreshSelection){
						sm.selectRange(sel.startPos, sel.endPos);
						sheet.refreshFocus(focus.row, focus.col);
					}
				}
			});
			this.add(motion);
		}, this, {single: true});
	},
	
	/*
	 * create motion when row hide
	 */
	onRowHide : function(sheetId, minrow, maxrow, visibles){
		var sheet = this.sheet, sm = sheet.getSelectionModel(), store = sheet.getStore();
		var sel = sm.getSelection(), focus = sm.getFocusCell(); 
		/*
		 * transfer the focus cell coord to a string
		 */
		var str = EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String([{
		    span: ['', minrow, 0, maxrow, 0],
		    type: SCONST.RELATIVE_COORD
		}], '');
		var showPairs = SCOM.transferArr2Pairs(visibles);
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text:SLANG['hide']+' '+str,			
			undo:function(suspendRefresh, suspendRefreshSelection){					
				for(var i = 0, len = showPairs.length; i < len; i++){
					var it = showPairs[i];
	                store.showRow(sheetId, it[0], it[1], true);
				}
				if(!suspendRefresh){
					if(sheet.getSheetId() != sheetId){
						sheet.go2Sheet(sheetId);
					}else{
						sheet.refreshRange();
					}									
				}
				if(!suspendRefreshSelection){
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			},
			redo:function(suspendRefresh, suspendRefreshSelection){							
				for(var i = 0, len = showPairs.length; i < len; i++){
					var it = showPairs[i];
	                store.hideRow(sheetId, it[0], it[1], true);
				}
				if(!suspendRefresh){
					if(sheet.getSheetId() != sheetId){
						sheet.go2Sheet(sheetId);
					}else{
						sheet.refreshRange();
					}					
				}
				if(!suspendRefreshSelection){
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			}
		});
		this.add(motion);	
	},
	
	/*
	 * create motion when row hide
	 */
	onFiltering : function(sheetId, shown, hidden, triggerPos, oldTrigger, oldFilter, oldFilterCdt, display){
		var sheet = this.sheet, sm = sheet.getSelectionModel(), store = sheet.getStore();
		var sel = sm.getSelection(), focus = sm.getFocusCell(); 
		var curData = store.getCell(sheetId, triggerPos.row, triggerPos.col);
		var trigger = curData.trigger, filter = curData.filter, filterCdt = curData.filterCdt;
		
		shown = shown || [];
		hidden = hidden || [];
		var showPairs = SCOM.transferArr2Pairs(shown), hidePairs = SCOM.transferArr2Pairs(hidden);
	    
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text:display,			
			undo:function(suspendRefresh, suspendRefreshSelection){
				for(var i = 0, len = showPairs.length; i < len; i++){
					var it = showPairs[i];
		            store.hideRow(sheetId, it[0], it[1], true);
				}
				for(var i = 0, len = hidePairs.length; i < len; i++){
					var it = hidePairs[i];
		            store.showRow(sheetId, it[0], it[1], true);
				}				
				var modify = {
					'trigger': oldTrigger	
				}, deleted = null;
				
				if(oldFilter){
					modify['filter'] = oldFilter;
				}else{
					deleted = deleted || [];
					deleted.push('filter');
				}
				if(oldFilterCdt){
					modify['filterCdt'] = oldFilterCdt;
				}else{
					deleted = deleted || [];
					deleted.push('filterCdt');
				}
				
				store.setCell(sheetId, triggerPos.row, triggerPos.col, modify, deleted, true);
				if(!suspendRefresh){
					if(sheet.getSheetId() != sheetId){
						sheet.go2Sheet(sheetId);
					}else{
						sheet.refreshRange();
					}					
				}
				if(!suspendRefreshSelection){
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			},
			redo:function(suspendRefresh, suspendRefreshSelection){				
				for(var i = 0, len = showPairs.length; i < len; i++){
					var it = showPairs[i];
		            store.showRow(sheetId, it[0], it[1], true);
				}
				for(var i = 0, len = hidePairs.length; i < len; i++){
					var it = hidePairs[i];
		            store.hideRow(sheetId, it[0], it[1], true);
				}
				var modify = {
					'trigger': trigger	
				}, deleted = null;
				
				if(filter){
					modify['filter'] = filter;
				}else{
					deleted = deleted || [];
					deleted.push('filter');
				}
				
				if(filterCdt){
					modify['filterCdt'] = filterCdt;
				}else{
					deleted = deleted || [];
					deleted.push('filterCdt');
				}
				
				store.setCell(sheetId, triggerPos.row, triggerPos.col, modify, deleted, true);
				if(!suspendRefresh){
					if(sheet.getSheetId() != sheetId){
						sheet.go2Sheet(sheetId);
					}else{
						sheet.refreshRange();
					}					
				}
				if(!suspendRefreshSelection){
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			}
		});
		this.add(motion);	
	},
	
	/*
	 * create motion when column hide
	 */
	onColumnHide : function(sheetId, mincol, maxcol, visibles){
		var sheet = this.sheet, sm = sheet.getSelectionModel(), store = sheet.getStore();
		var sel = sm.getSelection(), focus = sm.getFocusCell(); 
		/*
		 * transfer the focus cell coord to a string
		 */
		var str = EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String([{
		    span: ['', 0, mincol, 0, maxcol],
		    type: SCONST.RELATIVE_COORD
		}], '');
		var showPairs = SCOM.transferArr2Pairs(visibles);
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text:SLANG['hide']+' '+str,			
			undo:function(suspendRefresh, suspendRefreshSelection){		
				for(var i = 0, len = showPairs.length; i < len; i++){
					var it = showPairs[i];
	                store.showColumn(sheetId, it[0], it[1], true);
				}				
				
				if(!suspendRefresh){
					if(sheet.getSheetId() != sheetId){
						sheet.go2Sheet(sheetId);
					}else{
						sheet.refreshRange();
					}						
				}
				if(!suspendRefreshSelection){
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			},
			redo:function(suspendRefresh, suspendRefreshSelection){								
				for(var i = 0, len = showPairs.length; i < len; i++){
					var it = showPairs[i];
	                store.hideColumn(sheetId, it[0], it[1], true);
				}	
				if(!suspendRefresh){
					if(sheet.getSheetId() != sheetId){
						sheet.go2Sheet(sheetId);
					}else{
						sheet.refreshRange();
					}					
				}
				if(!suspendRefreshSelection){
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			}
		});
		this.add(motion);	
	},
	
	/*
	 * clean the filters in the current sheet
	 */
	onCleanFilter : function(sheetId, preCells, posCells, hiddens){
		var me = this;
		var sheet = this.sheet, sm = sheet.getSelectionModel(), store = sheet.getStore();
		var sel = sm.getSelection(), focus = sm.getFocusCell(); 
		
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text:SLANG['cancel_filtering'],			
			undo:function(suspendRefresh, suspendRefreshSelection){		
				me.recoverCell(preCells);
				
				for(var i = 0, len = hiddens.length; i < len; i++){
					store.hideRow(sheetId, hiddens[i], hiddens[i], true);
				}
				
				if(!suspendRefresh){
					if(sheet.getSheetId() != sheetId){
						sheet.go2Sheet(sheetId);
					}else{
						sheet.refreshRange();
					}						
				}
				if(!suspendRefreshSelection){
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			},
			redo:function(suspendRefresh, suspendRefreshSelection){		
				me.recoverCell(posCells);
				
				for(var i = 0, len = hiddens.length; i < len; i++){
					store.showRow(sheetId, hiddens[i], hiddens[i], true);
				}
				if(!suspendRefresh){
					if(sheet.getSheetId() != sheetId){
						sheet.go2Sheet(sheetId);
					}else{
						sheet.refreshRange();
					}					
				}
				if(!suspendRefreshSelection){
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			}
		});
		this.add(motion);	
	},
	
	/*
	 * when toggle a row group
	 */
	onToggleRowGroup : function(name, expand, sheetId, rows, oldRowGroups, rowGroups, sheet){
		var sm = sheet.getSelectionModel(), store = sheet.getStore();
		var sel = sm.getSelection(), focus = sm.getFocusCell(); 
		/*
		 * transfer the focus cell coord to a string
		 */
		
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text: (expand ? SLANG['expand_row_group'] : SLANG['collapse_row_group']),			
			undo:function(suspendRefresh, suspendRefreshSelection){		
				if(expand){
					for(var i = 0, len = rows.length; i < len; i++){
						store.hideRow(sheetId, rows[i], rows[i], true);
					}
				}else{
					for(var i = 0, len = rows.length; i < len; i++){
						store.showRow(sheetId, rows[i], rows[i], true);
					}
				}				
				store.updateRowGroups(sheetId, oldRowGroups);
				sheet.updateGroupState('row', name, expand);
				
				if(!suspendRefresh){
					if(sheet.getSheetId() != sheetId){
						sheet.go2Sheet(sheetId);
					}else{
						sheet.refreshRange();
					}						
				}
				if(!suspendRefreshSelection){
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			},
			redo:function(suspendRefresh, suspendRefreshSelection){				
				if(expand){
					for(var i = 0, len = rows.length; i < len; i++){
						store.showRow(sheetId, rows[i], rows[i], true);
					}
				}else{
					for(var i = 0, len = rows.length; i < len; i++){
						store.hideRow(sheetId, rows[i], rows[i], true);
					}
				}				
				store.updateRowGroups(sheetId, rowGroups);
				sheet.updateGroupState('row', name, !expand);
				
				if(!suspendRefresh){
					if(sheet.getSheetId() != sheetId){
						sheet.go2Sheet(sheetId);
					}else{
						sheet.refreshRange();
					}						
				}
				if(!suspendRefreshSelection){
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			}
		});
		this.add(motion);
	},
	
	/*
	 * when toggle a column group
	 */
	onToggleColGroup : function(name, expand, sheetId, columns, oldColGroups, colGroups, sheet){
		var sm = sheet.getSelectionModel(), store = sheet.getStore();
		var sel = sm.getSelection(), focus = sm.getFocusCell(); 
		/*
		 * transfer the focus cell coord to a string
		 */
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text: (expand ? SLANG['expand_column_group'] : SLANG['collapse_column_group']),			
			undo:function(suspendRefresh, suspendRefreshSelection){		
				if(expand){
					for(var i = 0, len = columns.length; i < len; i++){
						store.hideColumn(sheetId, columns[i], columns[i], true);
					}
				}else{
					for(var i = 0, len = columns.length; i < len; i++){
						store.showColumn(sheetId, columns[i], columns[i], true);
					}
				}				
				store.updateColumnGroups(sheetId, oldColGroups);
				sheet.updateGroupState('col', name, expand);
				
				if(!suspendRefresh){
					if(sheet.getSheetId() != sheetId){
						sheet.go2Sheet(sheetId);
					}else{
						sheet.refreshRange();
					}					
				}
				if(!suspendRefreshSelection){
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			},
			redo:function(suspendRefresh, suspendRefreshSelection){				
				if(expand){
					for(var i = 0, len = columns.length; i < len; i++){
						store.showColumn(sheetId, columns[i], columns[i], true);
					}
				}else{
					for(var i = 0, len = columns.length; i < len; i++){
						store.hideColumn(sheetId, columns[i], columns[i], true);
					}
				}				
				store.updateColumnGroups(sheetId, colGroups);
				sheet.updateGroupState('col', name, !expand);
				
				if(!suspendRefresh){
					if(sheet.getSheetId() != sheetId){
						sheet.go2Sheet(sheetId);
					}else{
						sheet.refreshRange();
					}						
				}
				if(!suspendRefreshSelection){
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			}
		});
		this.add(motion);
	},
	
	/*
	 * when toggle a row group
	 */
	onToggleRowGroupLevel : function(expand, sheetId, showns, hiddens, oldRowGroups, rowGroups, oldRowLevels, rowLevels, sheet){
		var sm = sheet.getSelectionModel(), store = sheet.getStore();
		var sel = sm.getSelection(), focus = sm.getFocusCell(); 
		/*
		 * transfer the focus cell coord to a string
		 */
		
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text: (expand ? SLANG['expand_row_group'] : SLANG['collapse_row_group']),			
			undo:function(suspendRefresh, suspendRefreshSelection){		
				for(var row in hiddens){
					store.showRow(sheetId, row, row, true);
				}
				for(var row in showns){
					store.hideRow(sheetId, row, row, true);
				}				
				store.updateRowGroups(sheetId, oldRowGroups);
				if(sheetId == sheet.getSheetId()){
					sheet.setGroupLevel('row', oldRowLevels);
				}					
				
				if(!suspendRefresh){
					if(sheet.getSheetId() != sheetId){
						sheet.go2Sheet(sheetId);
					}else{
						sheet.refreshRange();
					}						
				}
				if(!suspendRefreshSelection){
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			},
			redo:function(suspendRefresh, suspendRefreshSelection){				
				for(var row in showns){
					store.showRow(sheetId, row, row, true);
				}
				for(var row in hiddens){
					store.hideRow(sheetId, row, row, true);
				}				
				store.updateRowGroups(sheetId, rowGroups);
				if(sheetId == sheet.getSheetId()){
					sheet.setGroupLevel('row', rowLevels);
				}				
				
				if(!suspendRefresh){
					if(sheet.getSheetId() != sheetId){
						sheet.go2Sheet(sheetId);
					}else{
						sheet.refreshRange();
					}						
				}
				if(!suspendRefreshSelection){
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			}
		});
		this.add(motion);
	},
	
	/*
	 * when toggle a column group
	 */
	onToggleColGroupLevel : function(expand, sheetId, showns, hiddens, oldColGroups, colGroups, oldColLevels, colLevels, sheet){
		var sm = sheet.getSelectionModel(), store = sheet.getStore();
		var sel = sm.getSelection(), focus = sm.getFocusCell(); 
		/*
		 * transfer the focus cell coord to a string
		 */
		
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text: (expand ? SLANG['expand_column_group'] : SLANG['collapse_column_group']),			
			undo:function(suspendRefresh, suspendRefreshSelection){		
				for(var col in hiddens){
					store.showColumn(sheetId, col, col, true);
				}
				for(var col in showns){
					store.hideColumn(sheetId, col, col, true);
				}							
				store.updateColumnGroups(sheetId, oldColGroups);
				if(sheetId == sheet.getSheetId()){
					sheet.setGroupLevel('col', oldColLevels);
				}				
				
				if(!suspendRefresh){
					if(sheet.getSheetId() != sheetId){
						sheet.go2Sheet(sheetId);
					}else{
						sheet.refreshRange();
					}					
				}
				if(!suspendRefreshSelection){
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			},
			redo:function(suspendRefresh, suspendRefreshSelection){				
				for(var col in showns){
					store.showColumn(sheetId, col, col, true);
				}
				for(var col in hiddens){
					store.hideColumn(sheetId, col, col, true);
				}				
				store.updateColumnGroups(sheetId, colGroups);
				if(sheetId == sheet.getSheetId()){
					sheet.setGroupLevel('col', colLevels);
				}				
				
				if(!suspendRefresh){
					if(sheet.getSheetId() != sheetId){
						sheet.go2Sheet(sheetId);
					}else{
						sheet.refreshRange();
					}						
				}
				if(!suspendRefreshSelection){
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			}
		});
		this.add(motion);
	},
	
	/*
	 * create motion for add group
	 */
	onChangeGroup : function(dir, sheetId, oldGroups, groups, sheet){
		var sm = sheet.getSelectionModel(), store = sheet.getStore();
		var sel = sm.getSelection(), focus = sm.getFocusCell(); 
		/*
		 * transfer the focus cell coord to a string
		 */
		
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text: SLANG['change_group'],			
			undo:function(suspendRefresh, suspendRefreshSelection){		
				var needLayout;
				if('row' == dir){
					var oldMaxLevel = sheet.rowGroupMaxLevel;
					sheet.setRowGroups(oldGroups);
					needLayout = oldMaxLevel != sheet.rowGroupMaxLevel;					
					store.updateRowGroups(sheetId, oldGroups);
				}else{
					var oldMaxLevel = sheet.colGroupMaxLevel;
					sheet.setColumnGroups(oldGroups);
					needLayout = oldMaxLevel != sheet.colGroupMaxLevel;					
					store.updateColumnGroups(sheetId, oldGroups);
				}		
				if(needLayout){
					if(Ext.isFunction(sheet.doLayout)){
						sheet.doLayout();
					}else if(Ext.isFunction(sheet.updateLayout)){
						sheet.updateLayout();
					}					
				}
				
				if(!suspendRefresh){
					if(sheet.getSheetId() != sheetId){
						sheet.go2Sheet(sheetId);
					}else{
						sheet.refreshRange();
					}						
				}
				if(!suspendRefreshSelection){
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			},
			redo:function(suspendRefresh, suspendRefreshSelection){		
				var needLayout;
				if('row' == dir){
					var oldMaxLevel = sheet.rowGroupMaxLevel;
					sheet.setRowGroups(groups);
					needLayout = oldMaxLevel != sheet.rowGroupMaxLevel;					
					store.updateRowGroups(sheetId, groups);
				}else{
					var oldMaxLevel = sheet.colGroupMaxLevel;
					sheet.setColumnGroups(groups);
					needLayout = oldMaxLevel != sheet.colGroupMaxLevel;					
					store.updateColumnGroups(sheetId, groups);
				}		
				if(needLayout){
					if(Ext.isFunction(sheet.doLayout)){
						sheet.doLayout();
					}else if(Ext.isFunction(sheet.updateLayout)){
						sheet.updateLayout();
					}					
				}
				
				if(!suspendRefresh){
					if(sheet.getSheetId() != sheetId){
						sheet.go2Sheet(sheetId);
					}else{
						sheet.refreshRange();
					}						
				}
				if(!suspendRefreshSelection){
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			}
		});
		this.add(motion);
	},
           
    /*
     * create motion for update groups
     */
    onUpdateGroups : function(sheetId, oldRowGroups, oldColGroups, rowGroups, colGroups, sheet){
        var sm = sheet.getSelectionModel(), store = sheet.getStore();
        var sel = sm.getSelection(), focus = sm.getFocusCell();
        /*
         * transfer the focus cell coord to a string
         */
           
        var motion = new EnterpriseSheet.sheet.history.Motion({
            text: SLANG['update_groups'],
            undo:function(suspendRefresh, suspendRefreshSelection){
                var needLayout;
                var oldRowMaxLevel = sheet.rowGroupMaxLevel;
                sheet.setRowGroups(oldRowGroups);
                needLayout = oldRowMaxLevel != sheet.rowGroupMaxLevel;
                store.updateRowGroups(sheetId, oldRowGroups);

                var oldColMaxLevel = sheet.colGroupMaxLevel;
                sheet.setColumnGroups(oldColGroups);
                needLayout = needLayout || oldMaxLevel != sheet.colGroupMaxLevel;
                store.updateColumnGroups(sheetId, oldColGroups);

                if(needLayout){
					if(Ext.isFunction(sheet.doLayout)){
						sheet.doLayout();
					}else if(Ext.isFunction(sheet.updateLayout)){
						sheet.updateLayout();
					}					
				}
                                                              
                if(!suspendRefresh){
                    if(sheet.getSheetId() != sheetId){
                        sheet.go2Sheet(sheetId);
                    }else{
                        sheet.refreshRange();
                    }
                }
                if(!suspendRefreshSelection){
                    sm.selectRange(sel.startPos, sel.endPos);
                    sheet.refreshFocus(focus.row, focus.col);
                }
            },
            redo:function(suspendRefresh, suspendRefreshSelection){
                var needLayout;

                var oldRowMaxLevel = sheet.rowGroupMaxLevel;
                sheet.setRowGroups(rowGroups);
                needLayout = oldRowMaxLevel != sheet.rowGroupMaxLevel;
                store.updateRowGroups(sheetId, rowGroups);

                var oldColMaxLevel = sheet.colGroupMaxLevel;
                sheet.setColumnGroups(colGroups);
                needLayout = needLayout || oldColMaxLevel != sheet.colGroupMaxLevel;
                store.updateColumnGroups(sheetId, colGroups);

                if(needLayout){
					if(Ext.isFunction(sheet.doLayout)){
						sheet.doLayout();
					}else if(Ext.isFunction(sheet.updateLayout)){
						sheet.updateLayout();
					}					
				}
                                                            
                if(!suspendRefresh){
                    if(sheet.getSheetId() != sheetId){
                        sheet.go2Sheet(sheetId);
                    }else{
                        sheet.refreshRange();
                    }
                }
                if(!suspendRefreshSelection){
                    sm.selectRange(sel.startPos, sel.endPos);
                    sheet.refreshFocus(focus.row, focus.col);
                }
            }
        });
        this.add(motion);
    },
	
	/*
	 * create motion when row resized
	 */
	onRowResized : function(row, old, cur){		
		var sheet = this.sheet, sm = sheet.getSelectionModel(), store = sheet.getStore();		
		/*
		 * save the current sheet Id
		 */
		var originSel = sm.getSelection(), originFocus = sm.getFocusCell(), originSheetId = sheet.getSheetId();
		var minrow = row;
		for(var p in old){
			if(p < minrow){
				minrow = p;
			}
		}
		/*
		 * transfer the focus cell coord to a string
		 */
		var str = EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String([{
		    span: ['', minrow, 0, row, 0],
		    type: SCONST.RELATIVE_COORD
		}], '');
		
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text:SLANG['change_row_height_for']+' '+str,			
			undo:function(suspendRefresh, suspendRefreshSelection){				
				for(var p in old){
					var i = Number(p);
					var v = old[p];					
					if(true === v){						
						store.showRow(originSheetId, i, i, true);
					}else if(false === v){						
						store.hideRow(originSheetId, i, i, true);
					}else if(null === v){
						if(0 == i){
							store.setWhole(originSheetId, null, ['height'], true);
						}else{
							store.setRow(originSheetId, i, null, ['height'], true, true);
						}
					}else{
						var modified = {}, deleted = [];
						if(!SCOM.canbeNumber(v['height'])){
							deleted.push('height');
						}else{
							modified['height'] = v['height'];
						}
						if(!SCOM.canbeNumber(v['autoHeight'])){
							deleted.push('autoHeight');
						}else{
							modified['autoHeight'] = v['autoHeight'];
						}
						if(!SCOM.canbeNumber(v['hoff'])){
							deleted.push('hoff');
						}else{
							modified['hoff'] = v['hoff'];
						}
						store.setCell(originSheetId, i, 0, modified, deleted, true);
					}
				}
				if(!suspendRefresh){
					if(sheet.getSheetId() != originSheetId){
						sheet.go2Sheet(originSheetId);
					}else{
						sheet.refreshRange();
					}										
				}
				if(!suspendRefreshSelection){
					sm.selectRange(originSel.startPos, originSel.endPos);
					sheet.refreshFocus(originFocus.row, originFocus.col);
				}
			},
			redo:function(suspendRefresh, suspendRefreshSelection){				
				for(var p in cur){
					var i = Number(p);
					var v = cur[p];					
					if(Ext.isNumber(v)){						
						store.setRowHeight(originSheetId, i, v, true, true);
					}else if(true === v){						
						store.showRow(originSheetId, i, i, true);
					}else if(false === v){						
						store.hideRow(originSheetId, i, i, true);
					}else if(null === v){
						if(0 == i){
							store.setWhole(originSheetId, null, ['height'], true);
						}else{
							store.setRow(originSheetId, i, null, ['height'], true, true);
						}
					}
				}
				if(!suspendRefresh){
					if(sheet.getSheetId() != originSheetId){
						sheet.go2Sheet(originSheetId);
					}else{
						sheet.refreshRange();
					}					
				}
				if(!suspendRefreshSelection){
					sm.selectRange(originSel.startPos, originSel.endPos);
					sheet.refreshFocus(originFocus.row, originFocus.col);
				}
			}
		});
		this.add(motion);
	},
	
	/*
	 * create motion when row auto resized
	 */
	onRowAutoResized : function(row, old, cur){		
		var sheet = this.sheet, sm = sheet.getSelectionModel(), store = sheet.getStore();		
		/*
		 * save the current sheet Id
		 */
		var originSel = sm.getSelection(), originFocus = sm.getFocusCell(), originSheetId = sheet.getSheetId();
		/*
		 * transfer the focus cell coord to a string
		 */
		var str = EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String([{
		    span: ['', row, 0, row, 0],
		    type: SCONST.RELATIVE_COORD
		}], '');
		
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text:SLANG['change_row_height_for']+' '+str,			
			undo:function(suspendRefresh, suspendRefreshSelection){		
				var modified = {}, deleted = [];
				if(!SCOM.canbeNumber(old['height'])){
					deleted.push('height');
				}else{
					modified['height'] = old['height'];
				}
				if(!SCOM.canbeNumber(old['autoHeight'])){
					deleted.push('autoHeight');
				}else{
					modified['autoHeight'] = old['autoHeight'];
				}
				if(!SCOM.canbeNumber(old['hoff'])){
					deleted.push('hoff');
				}else{
					modified['hoff'] = old['hoff'];
				}
				store.setCell(originSheetId, row, 0, modified, deleted, true);
				
				if(!suspendRefresh){
					if(sheet.getSheetId() != originSheetId){
						sheet.go2Sheet(originSheetId);
					}else{
						sheet.refreshRange();
					}										
				}
				if(!suspendRefreshSelection){
					sm.selectRange(originSel.startPos, originSel.endPos);
					sheet.refreshFocus(originFocus.row, originFocus.col);
				}
			},
			redo:function(suspendRefresh, suspendRefreshSelection){				
				var modified = {}, deleted = [];
				if(!SCOM.canbeNumber(cur['height'])){
					deleted.push('height');
				}else{
					modified['height'] = cur['height'];
				}
				if(!SCOM.canbeNumber(cur['autoHeight'])){
					deleted.push('autoHeight');
				}else{
					modified['autoHeight'] = cur['autoHeight'];
				}
				if(!SCOM.canbeNumber(cur['hoff'])){
					deleted.push('hoff');
				}else{
					modified['hoff'] = cur['hoff'];
				}
				store.setCell(originSheetId, row, 0, modified, deleted, true);
				if(!suspendRefresh){
					if(sheet.getSheetId() != originSheetId){
						sheet.go2Sheet(originSheetId);
					}else{
						sheet.refreshRange();
					}					
				}
				if(!suspendRefreshSelection){
					sm.selectRange(originSel.startPos, originSel.endPos);
					sheet.refreshFocus(originFocus.row, originFocus.col);
				}
			}
		});
		this.add(motion);
	},
	
	/*
	 * create motion when column resized
	 */
	onColumnResized : function(col, old, cur, changedHeights){		
		var me = this;
		var sheet = this.sheet, sm = sheet.getSelectionModel(), store = sheet.getStore();		
		/*
		 * save the current sheet Id
		 */
		var originSel = sm.getSelection(), originFocus = sm.getFocusCell(), originSheetId = sheet.getSheetId();
		var preAutoHeights = changedHeights.oldHeights, posAutoHeights = changedHeights.newHeights;
		var mincol = col;
		for(var p in old){
			if(p < mincol){
				mincol = p;
			}
		}
		/*
		 * transfer the focus cell coord to a string
		 */
		var str = EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String([{
		    span: ['', 0, mincol, 0, col],
		    type: SCONST.RELATIVE_COORD
		}], '');
		
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text:SLANG['change_column_width_for']+' '+str,			
			undo:function(suspendRefresh, suspendRefreshSelection){				
				for(var p in old){
					var i = Number(p);
					var v = old[p];					
					if(Ext.isNumber(v)){						
						store.setColumnWidth(originSheetId, i, v, true, true);
					}else if(true === v){						
						store.showColumn(originSheetId, i, i, true);
					}else if(false === v){						
						store.hideColumn(originSheetId, i, i, true);
					}else if(null === v){
						if(0 == i){
							store.setWhole(originSheetId, null, ['width'], true);
						}else{
							store.setColumn(originSheetId, i, null, ['width'], true, true);
						}						
					}
				}
				
				me.recoverAutoHeight(preAutoHeights, suspendRefresh);
				
				if(!suspendRefresh){
					if(sheet.getSheetId() != originSheetId){
						sheet.go2Sheet(originSheetId);
					}else{
						sheet.refreshRange();
					}					
				}
				if(!suspendRefreshSelection){
					sm.selectRange(originSel.startPos, originSel.endPos);
					sheet.refreshFocus(originFocus.row, originFocus.col);
				}
			},
			redo:function(suspendRefresh, suspendRefreshSelection){				
				for(var p in cur){
					var i = Number(p);
					var v = cur[p];					
					if(Ext.isNumber(v)){						
						store.setColumnWidth(originSheetId, i, v, true, true);
					}else if(true === v){						
						store.showColumn(originSheetId, i, i, true);
					}else if(false === v){						
						store.hideColumn(originSheetId, i, i, true);
					}else if(null === v){
						if(0 == i){
							store.setWhole(originSheetId, null, ['width'], true);
						}else{
							store.setColumn(originSheetId, i, null, ['width'], true, true);
						}
					}
				}

				me.recoverAutoHeight(posAutoHeights, suspendRefresh);
				
				if(!suspendRefresh){
					sheet.checkAutoHeightForCoord(null, [[originSheetId, 0, mincol, 0, col]], true);
					if(sheet.getSheetId() != originSheetId){
						sheet.go2Sheet(originSheetId);
					}else{
						sheet.refreshRange();
					}					
				}
				if(!suspendRefreshSelection){
					sm.selectRange(originSel.startPos, originSel.endPos);
					sheet.refreshFocus(originFocus.row, originFocus.col);
				}
			}
		});
		this.add(motion);
	},
	
	/*
	 * creat motion when sheet is sorted
	 */	
	beforeAllChange : function(eventName, display){
		var sheet = this.sheet, sm = sheet.getSelectionModel(), store = sheet.getStore();		
		/*
		 * save the original selection and focus for undo
		 */
		var originSel = sm.getSelection(), originFocus = sm.getFocusCell(), originSheetId = sheet.getSheetId();			
		
		var origin = store.backupData();		
		/*
		 * unplug the last one
		 */
		if(this[eventName+'Ref']){
			sheet.un(eventName, this[eventName+'Ref'], this);
			delete(this[eventName+'Ref']);
		}		
		var fn = function(range){						
			var modified = store.backupData();
			var motion = new EnterpriseSheet.sheet.history.Motion({				
				text:display,
				undo:function(suspendRefresh, suspendRefreshSelection){
					store.recoverData(origin);
					if(!suspendRefresh){
						if(sheet.getSheetId() != originSheetId){
							sheet.go2Sheet(originSheetId);
						}else{
							sheet.refreshRange();
						}				
					}
					if(!suspendRefreshSelection){
						sm.selectRange(originSel.startPos, originSel.endPos);
						sheet.refreshFocus(originFocus.row, originFocus.col);
					}
				},	
				redo:function(suspendRefresh, suspendRefreshSelection){
					store.recoverData(modified);
					if(!suspendRefresh){
						if(sheet.getSheetId() != originSheetId){
							sheet.go2Sheet(originSheetId);
						}else{
							sheet.refreshRange();
						}					
					}
					if(!suspendRefreshSelection){
						sm.selectRange(originSel.startPos, originSel.endPos);
						sheet.refreshFocus(originFocus.row, originFocus.col);
					}
				}
			});
			this.add(motion);
		};
		sheet.on(eventName, fn, this, {
			/*
			 * very important to set it for execute only one single time 
			 */
			single:true
		});
		/*
		 * save the ref of fn
		 */
		this[eventName+'Ref'] = fn;	
	},
	
           
    prepareSetHeaderTitle : function(span){
        var me = this;
        var sheet = this.sheet, sm = sheet.getSelectionModel(), store = sheet.getStore();
        var origins = {};
        var tspan = [span[0], 0, span[2], 0, span[4]];
        
        store.walkRange([span], function(rd, walkSpan, store, internalId){
            var id = store.getIdBasedData({sheet:rd.data.sheet, row: 0, col: rd.data.col});
            origins[id] = store.getCell(rd.data.sheet, 0, rd.data.col).data;
        }, this);

        sheet.on('setheadertitle', function(span, titles){
            var motion = new EnterpriseSheet.sheet.history.Motion({
                text:SLANG['set_header_title'],
                undo:function(suspendRefresh, suspendRefreshSelection){
                    store.walkRange([span], function(rec, walkSpan, store, internalId){
                        var id = store.getIdBasedData({sheet: rec.data.sheet, row: 0, col: rec.data.col});
                        store.setCell(rec.data.sheet, 0, rec.data.col, {
                            data : origins[id]
                        }, undefined, true);
                    }, this);
                    sheet.refreshRange([tspan]);
                },
                redo:function(suspendRefresh, suspendRefreshSelection){
                    store.walkRange([span], function(rec, walkSpan, store, internalId){
                        var id = internalId;
                        store.setCell(rec.data.sheet, 0, rec.data.col, {
                            data : titles[id]
                        }, undefined, true);
                    }, this);
                    sheet.refreshRange([tspan]);
                }
            });
            this.add(motion);
        }, this, {single: true});
    },
	
	/**
	 * before range change, create the motion for history
	 * @param {object} range: the range instance ref
	 * @param {string} eventName: the event fire next, usually it's a pair of this event, such as beforepaste and paste 
	 * @param {string} text: the text for the action
	 * @param {boolean} withMargin: true to refresh the margin of the range
	 * @param {boolean} refreshCalCdt: true to also refresh the calculate and condition cells
	 * @param {object} originCdts: the origin condition before changed by this action
	 * @param {object} changedHeights: an object of changed heights
	 * @param {object} cdtCoord: a coord of condition cells need to be refresh
	 */
	beforeRangeChange : function(range, eventName, text, withMargin, refreshCalCdt, originCdts, changedHeights, cdtCoord, ignoreRowCol){
		var me = this;
		var sheet = this.sheet, sm = sheet.getSelectionModel(), store = sheet.getStore();		
		/*
		 * save the original selection and focus for undo
		 */
		var originSel = sm.getSelection(), originFocus = sm.getFocusCell(), originSheetId = sheet.getSheetId();
		/*
		 * for original cell object in the range
		 */
		var origins = {}, coord = range.getCoord();
		
		if(withMargin){
			coord = range.extend2Margin(coord);
		}
		
		store.walkRange(coord, function(rd, walkSpan, store, internalId){
			var id = internalId;
			origins[id] = SCOM.copy(rd.data);
		}, this, undefined, undefined, ignoreRowCol);
		
		var oldRange = range;
		var fn = function(range){
			/*
			 * if originCdts is not null then means this action changed cdt
			 * we need save the changed cdts for undo/redo using
			 */
			var changedCdts;
			if(originCdts){
				
				for(var p in originCdts){
					if(originCdts.hasOwnProperty(p)){
						changedCdts = changedCdts || {};
						var it = originCdts[p];
						// add condition - there have exception in some case @ 2013 03 18
						if (it) changedCdts[p] = store.getFloatingById(p, it.sheet);
					}
				}
			}
			
			if(!(range instanceof EnterpriseSheet.sheet.range.Range)){
				range = oldRange;
			}
			/*
			 * save the changed selection and focus for redo
			 */
			var sel = sm.getSelection(), focus = sm.getFocusCell(), sheetId = sheet.getSheetId();
			var modifieds = {};
			store.walkRange(coord, function(rd, walkSpan, store, internalId){
				var id = internalId;
				modifieds[id] = SCOM.copy(rd.data);
			}, this, undefined, undefined, ignoreRowCol);
			/*
			 * transfer the focus cell coord to a string
			 */
			var str = EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String([{
				span: sm.selection2Span(),
				type: SCONST.RELATIVE_COORD
			}], '');
			
			var motionCfg = {
				refreshCalCdt:refreshCalCdt,
				cdtCoord: cdtCoord,
				text:text+' '+str,
				sheet:sheet,
				coord:coord,
				range:range,
				sel:sel,
				focus:focus,
				sheetId:sheetId,
				modifieds:modifieds,
				origins:origins,
				originSheetId:originSheetId,
				originSel:originSel,
				originFocus:originFocus,
                ignoreRowCol: ignoreRowCol
			};
			if('rangechange' == eventName || 'paste' == eventName || 'autofill' == eventName || 'rangemove' == eventName || 'cleanrange' == eventName || 'conditionchange' == eventName || 'stylebrush' == eventName){
				var modifiedProperty, deletedProperty;
				if('rangechange' == eventName){
					modifiedProperty = arguments[1];
					deletedProperty = arguments[2];
				}
				/*
				 * need process rangechange specially, because we need check the autoHeight problem for related rows
				 */
				Ext.apply(motionCfg, {
					undo: function(suspendRefresh, suspendRefreshSelection){						
						/*
						 * recover the cdt
						 */
						if(originCdts){
							for(var p in originCdts){
								if(originCdts.hasOwnProperty(p)){
									var it = originCdts[p];									
									store.setFloatingItem(it.sheet, p, 'cdt', it.json);
								}
							}
						}
						this.defaultUndo.apply(this, arguments);
						if(changedHeights){
							var preAutoHeights = changedHeights.oldHeights;
							me.recoverAutoHeight(preAutoHeights, suspendRefresh);
						}
					},
					redo: function(suspendRefresh, suspendRefreshSelection){						
						/*
						 * change the cdts again
						 */
						if(originCdts){
							for(var p in originCdts){
								if(changedCdts.hasOwnProperty(p)){
									var it = changedCdts[p];
									if(it){
										store.setFloatingItem(it.sheet, p, 'cdt', it.json);
									}else{
										var it = originCdts[p];
										store.setFloatingItem(it.sheet, p, 'cdt');
									}									
								}else{
									var it = originCdts[p];
									store.setFloatingItem(it.sheet, p, 'cdt');
								}
							}
						}
						this.defaultRedo.apply(this, arguments);
						if(changedHeights){
							var posAutoHeights = changedHeights.newHeights;
							me.recoverAutoHeight(posAutoHeights, suspendRefresh);
						}
					}
				});
			}
			var motion = new EnterpriseSheet.sheet.history.Motion(motionCfg);			
			this.add(motion);
		};
		
		sheet.on(eventName, fn, this, {
			/*
			 * very important to set it for execute only one single time 
			 */
			single:true
		});		
	},
	
	/*
	 * before auto extend the condition when input something
	 */
	prepareautoextendcdt : function(sheetId, row, col, changedCdts, sheet, reCalCells){
		var me = this;
		var store = sheet.getStore();
		var origin = store.getCell(sheetId, row, col, true);
		var originCdts;
		if(changedCdts){
			originCdts = {};
			for(var p in changedCdts){
				if(changedCdts.hasOwnProperty(p)){
					var it = changedCdts[p];
					originCdts[p] = store.getFloatingById(p, sheetId);
				}
			}
		}
		var fn = function(sheetId, row, col, modified, deleted){
			me.onAutoExtendCdt(null, sheetId, row, col, modified, deleted, origin, originCdts, changedCdts, reCalCells);
		}
		sheet.on('autoextendcdt', fn, this, {
			/*
			 * very important to set it for execute only one single time 
			 */
			single:true
		});		
	},
	
	/*
	 * when the auto extend condition is done
	 */
	onAutoExtendCdt : function(timestamp, sheetId, row, col, modified, deleted, origin, originCdts, changedCdts, reCalCells){
		var me = this;
		var sheet = this.sheet, sm = sheet.getSelectionModel(), store = sheet.getStore();
		
		/*
		 * save the original selection and focus for undo
		 */
		var originSel = sm.getSelection(), originFocus = sm.getFocusCell();
		
		/*
		 * save the changed selection and focus for redo
		 */
		var sel = sm.getSelection(), focus = sm.getFocusCell();
		/*
		 * transfer the focus cell coord to a string
		 */
		var str = EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String([{
		    span: EnterpriseSheet.sheet.calculate.Coordinate.prototype.normalizeCoord([focus.row, focus.col]),
		    type: SCONST.RELATIVE_COORD
		}], '');
		var inputStr = SCOM.removeHTMLTag(modified['data']);
		inputStr = Ext.String.ellipsis(inputStr, 10);
		
		var coord = [[sheetId, row, col, row, col]];
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text:SLANG['input']+' "'+inputStr+'" '+SLANG['at']+' '+str,
			/*
			 * means this motion need cause to refresh the calculate and conditon cells 
			 */
			refreshCalCdt:true,
			undo: function(suspendRefresh, suspendRefreshSelection){
				if(originCdts){
					for(var p in originCdts){
						if(originCdts.hasOwnProperty(p)){
							var it = originCdts[p];
							store.setFloatingItem(sheetId, p, 'cdt', it.json);
						}
					}
				}
				/*
				 * suspend the listener temp
				 */
				me.mun(sheet, 'datachange', me.onDataChange, me);
				var m = {}, d = [];
				for(var p in modified){						
					if(origin && false != SCOM.typeOf(origin[p])){
						m[p] = origin[p];
					}else{
						d.push(p);
					}
				}
				if(origin && deleted){
					for(var i = 0, len = deleted.length; i < len; i++){
						var p = deleted[i];
						if(false != SCOM.typeOf(origin[p])){
							m[p] = origin[p];
						}						
					}
				}
				sheet.setCell(sheetId, row, col, m, d, true);		
				if(!suspendRefresh){
					if(sheet.getSheetId() != sheetId){
						sheet.go2Sheet(sheetId, function(){							
							sheet.refreshCalCdt(reCalCells, undefined, undefined, coord);
						});
					}else{
						sheet.refreshRange(coord, reCalCells);
					}					
				}
				if(!suspendRefreshSelection){
					/*
					 * for selection and focus
					 */
					sm.selectRange(originSel.startPos, originSel.endPos);
					sheet.refreshFocus(originFocus.row, originFocus.col);
				}
				/*
				 * reset the listener temp
				 */
				me.mon(sheet, 'datachange', me.onDataChange, me);
			},
			redo: function(suspendRefresh, suspendRefreshSelection){	
				if(changedCdts){
					for(var p in changedCdts){
						if(changedCdts.hasOwnProperty(p)){
							var it = changedCdts[p];
							store.setFloatingItem(sheetId, p, 'cdt', Ext.encode(it));
						}
					}
				}
				/*
				 * suspend the listener temp
				 */
				me.mun(sheet, 'datachange', me.onDataChange, me);
				sheet.setCell(sheetId, row, col, modified, deleted, true);
				if(!suspendRefresh){
					if(sheet.getSheetId() != sheetId){
						sheet.go2Sheet(sheetId, function(){							
							sheet.refreshCalCdt(reCalCells, undefined, undefined, coord);
						});
					}else{
						sheet.refreshRange(coord, reCalCells);
					}				
				}
				if(!suspendRefreshSelection){
					/*
					 * for selection and focus
					 */
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
				/*
				 * reset the listener temp
				 */
				me.mon(sheet, 'datachange', me.onDataChange, me);
			}			
		});			
		this.add(motion);	
		sheet.fireEvent('changing', sheet);		
	},
    
    /**
     * when array formula is changed
     */
    onArrayFormulaChange : function(span){
        var coordPro = EnterpriseSheet.sheet.calculate.Coordinate.prototype;
        var me = this, sheet = me.sheet, store = sheet.getStore();
        /*
         * suspend the listener temp
         */
        me.mun(sheet, 'datachange', me.onDataChange, me);
        var oldCells = {}, curCells = {};
		var reCalCells = coordPro.transferCoord2CellLookup([span]);
        Ext.apply(reCalCells, sheet.findDirectRecalculateCellsForCells(reCalCells));
        store.walkRange([span], function(rec, walkSpan, store, internalId){
            oldCells[internalId] = Ext.apply({}, rec.data.json);
        }, me);
        sheet.on('completeedit', function(sheetId, row, col, editor, asArrayFormula){
            store.walkRange([span], function(rec, walkSpan, store, internalId){
                curCells[internalId] = Ext.apply({}, rec.data.json);
            }, me);
            var motion = new EnterpriseSheet.sheet.history.Motion({
                text:SLANG['input_array_formula'],
                undo: function(suspendRefresh, suspendRefreshSelection){
                    /*
                     * suspend the listener temp
                     */
                    me.mun(sheet, 'datachange', me.onDataChange, me);
                    store.walkRange([span], function(rec, walkSpan, store, internalId){
                        store.setCell(rec.data.sheet, rec.data.row, rec.data.col, oldCells[internalId], undefined, true, 'clear');
                    }, me);
                    sheet.refreshCalCdt(reCalCells);
                    me.mon(sheet, 'datachange', me.onDataChange, me);
                },
                redo: function(suspendRefresh, suspendRefreshSelection){
                    /*
                     * suspend the listener temp
                     */
                    me.mun(sheet, 'datachange', me.onDataChange, me);
                    store.walkRange([span], function(rec, walkSpan, store, internalId){
                        store.setCell(rec.data.sheet, rec.data.row, rec.data.col, curCells[internalId], undefined, true, 'clear');
                    }, me);
                    sheet.refreshCalCdt(reCalCells);
                    me.mon(sheet, 'datachange', me.onDataChange, me);
                }
            });
            this.add(motion);
            me.mon(sheet, 'datachange', me.onDataChange, me);
            sheet.fireEvent('changing', sheet);
        }, this, {single: true});
    },
	
	/*
	 * change the cell data
	 */
	onDataChange : function(timestamp, sheetId, row, col, modified, deleted, origin, rd, store, suspendRefresh, reCalCells){
		origin = Ext.apply({}, origin);
		
		var me = this;
		var sheet = this.sheet, sm = sheet.getSelectionModel(), store = sheet.getStore();
		
		/*
		 * save the original selection and focus for undo
		 */
		var originSel = sm.getSelection(), originFocus = sm.getFocusCell();
		
		/*
		 * save the changed selection and focus for redo
		 */
		var sel = sm.getSelection(), focus = sm.getFocusCell();
		/*
		 * transfer the focus cell coord to a string
		 */
		var str = EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String([{
		    span: EnterpriseSheet.sheet.calculate.Coordinate.prototype.normalizeCoord([focus.row, focus.col]),
		    type: SCONST.RELATIVE_COORD
		}], '');
		
		var text;
		if (modified){
			if(modified['data']){
				var inputStr = SCOM.removeHTMLTag(modified['data']);
				inputStr = Ext.String.ellipsis(inputStr, 10);
				text = SLANG['input']+' "'+inputStr+'" '+SLANG['at']+' '+str;
			}else{
				text = SLANG['change_checked']+' '+SLANG['at']+' '+str;
			}			
		}
				
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text: text,
			/*
			 * means this motion need cause to refresh the calculate and conditon cells 
			 */
			refreshCalCdt: reCalCells,
			undo: function(suspendRefresh, suspendRefreshSelection){
				/*
				 * suspend the listener temp
				 */
				me.mun(sheet, 'datachange', me.onDataChange, me);
				var m = {}, d = ['value'];
				for(var p in modified){						
					if(origin && false != SCOM.typeOf(origin[p])){
						m[p] = origin[p];
					}else{
						d.push(p);
					}
				}
				if(origin && deleted){
					for(var i = 0, len = deleted.length; i < len; i++){
						var p = deleted[i];
						if(false != SCOM.typeOf(origin[p])){
							m[p] = origin[p];
						}						
					}
				}
				sheet.setCell(sheetId, row, col, m, d, suspendRefresh);		
				if(!suspendRefresh){
					if(sheet.getSheetId() != sheetId){
						sheet.go2Sheet(sheetId);
					}					
				}
				if(!suspendRefreshSelection){
					/*
					 * for selection and focus
					 */
					sm.selectRange(originSel.startPos, originSel.endPos);
					sheet.refreshFocus(originFocus.row, originFocus.col);
				}
				/*
				 * reset the listener temp
				 */
				me.mon(sheet, 'datachange', me.onDataChange, me);
			},
			redo: function(suspendRefresh, suspendRefreshSelection){	
				/*
				 * suspend the listener temp
				 */
				me.mun(sheet, 'datachange', me.onDataChange, me);
                deleted = deleted || [];
                deleted.push('value');
				sheet.setCell(sheetId, row, col, modified, deleted, suspendRefresh);
				if(!suspendRefresh){
					if(sheet.getSheetId() != sheetId){
						sheet.go2Sheet(sheetId);
					}					
				}
				if(!suspendRefreshSelection){
					/*
					 * for selection and focus
					 */
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
				/*
				 * reset the listener temp
				 */
				me.mon(sheet, 'datachange', me.onDataChange, me);
			}			
		});			
		this.add(motion);	
		sheet.fireEvent('changing', sheet);		
	},
	
	/*
	 * change the cell data
	 */
	onTplSummaryChange : function(timestamp, sheetId, row, col, modified, deleted, origin, rd, store, flag, reCalCells){
		var me = this;
		var sheet = this.sheet, sm = sheet.getSelectionModel(), store = sheet.getStore();
		
		/*
		 * save the original selection and focus for undo
		 */
		var originSel = sm.getSelection(), originFocus = sm.getFocusCell();
		
		/*
		 * save the changed selection and focus for redo
		 */
		var sel = sm.getSelection(), focus = sm.getFocusCell();
		/*
		 * transfer the focus cell coord to a string
		 */
		var str = EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String([{
		    span: EnterpriseSheet.sheet.calculate.Coordinate.prototype.normalizeCoord([focus.row, focus.col]),
		    type: SCONST.RELATIVE_COORD
		}], '');
		var coord = [[sheet, row, col, row, col]];
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text:SLANG['change_tpl_summary']+' '+SLANG['at']+' '+str,
			/*
			 * means this motion need cause to refresh the calculate and conditon cells 
			 */
			refreshCalCdt:reCalCells,
			undo: function(suspendRefresh, suspendRefreshSelection){
				/*
				 * suspend the listener temp
				 */
				me.mun(sheet, 'datachange', me.onDataChange, me);
				var m = {}, d = [];
				for(var p in modified){						
					if(origin && false != SCOM.typeOf(origin[p])){
						m[p] = origin[p];
					}else{
						d.push(p);
					}
				}
				if(origin && deleted){
					for(var i = 0, len = deleted.length; i < len; i++){
						var p = deleted[i];
						if(false != SCOM.typeOf(origin[p])){
							m[p] = origin[p];
						}						
					}
				}
				sheet.setCell(sheetId, row, col, m, d, suspendRefresh);
				if(!suspendRefresh){
					if(sheet.getSheetId() != sheetId){
						sheet.go2Sheet(sheetId, function(){
							sheet.refreshCalCdt(reCalCells, undefined, undefined, coord);
						});
					}else{
						sheet.refreshCalCdt(reCalCells, undefined, undefined, coord);
					}					
				}				
				if(!suspendRefreshSelection){					
					/*
					 * for selection and focus
					 */
					sm.selectRange(originSel.startPos, originSel.endPos);
					sheet.refreshFocus(originFocus.row, originFocus.col);
				}
				/*
				 * reset the listener temp
				 */
				me.mon(sheet, 'datachange', me.onDataChange, me);
			},
			redo: function(suspendRefresh, suspendRefreshSelection){	
				/*
				 * suspend the listener temp
				 */
				me.mun(sheet, 'datachange', me.onDataChange, me);
				sheet.setCell(sheetId, row, col, modified, deleted, suspendRefresh);				
				if(!suspendRefresh){
					if(sheet.getSheetId() != sheetId){
						sheet.go2Sheet(sheetId, function(){
							sheet.refreshCalCdt(reCalCells, undefined, undefined, coord);
						});
					}else{
						sheet.refreshCalCdt(reCalCells, undefined, undefined, coord);
					}					
				}
				if(!suspendRefreshSelection){					
					/*
					 * for selection and focus
					 */
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
				/*
				 * reset the listener temp
				 */
				me.mon(sheet, 'datachange', me.onDataChange, me);
			}			
		});			
		this.add(motion);	
		sheet.fireEvent('changing', sheet);		
	},	
	
	/*
	 * cache the cal and cdt 
	 */
	cacheCalCdt : function(coord){
		var calCdtCache = {};
		var sheet = this.sheet, store = sheet.getStore();
		store.walkRange(coord, function(rd, walkSpan, store, internalId){
			var row = rd.data.row, col = rd.data.col, json = rd.data.json;
			
			if(json.cal || sheet.isConditionCell(json, rd.data.sheet, row, col)){
				calCdtCache[internalId] = SCOM.copy(rd.data);
			}
		}, this);
		return calCdtCache;
	},
	
	/*
	 * recover the calculate cells
	 */
	recoverCal : function(calCache){
		var sheet = this.sheet, store = sheet.getStore();
		for(var p in calCache){
			if(calCache.hasOwnProperty(p)){
				var it = calCache[p];
				var sheetId = it.sheet, row = it.row, col = it.col;
                if(Ext.isDefined(row)){
                    store.setCell(sheetId, row, col, SCOM.copy(it.json), null, true);
                }
			}
		}
	},
	
	/*
	 * recover cells
	 */
	recoverCell : function(cellCache){
		var sheet = this.sheet, store = sheet.getStore();
		for(var p in cellCache){
			if(cellCache.hasOwnProperty(p)){
				var it = cellCache[p];
				var sheetId = it.sheet, row = it.row, col = it.col;
				store.setCell(sheetId, row, col, it.json, null, true, 'clear');
			}
		}
	},
	
	/*
	 * recover the condition floating items
	 */
	recoverCdt : function(cdtCache){
		var sheet = this.sheet, store = sheet.getStore();
		for(var p in cdtCache){
			if(cdtCache.hasOwnProperty(p)){
				var it = cdtCache[p];
				store.setFloatingItem(it.sheet, it.name, it.ftype, it.json);
			}
		}
	},
	
	/*
	 * change the freeze pos if the passed is different with the current one 
	 */
	recoverFreeze : function(freezePos, rangeInfo){
		var sheet = this.sheet;
		var curFreezePos = sheet.freezePos;
		if(!curFreezePos && !freezePos){
			return;
		}
		if(curFreezePos && freezePos && curFreezePos.row == freezePos.row && curFreezePos.col == freezePos.col){
			return;
		}
		var obj = {
			freezePos: freezePos,
			rangeInfo: rangeInfo
		};
		sheet.setSheetConfig(obj);
	},
	
	recoverMerged : function(merged){
		var sheet = this.sheet, store = sheet.getStore(), sheetId = sheet.getSheetId();
		for(var p in merged){
			if(merged.hasOwnProperty(p)){
				var item = merged[p];
				var mergedMinRow = item.minrow, mergedMinCol = item.mincol, mergedMaxRow = item.maxrow, mergedMaxCol = item.maxcol;
				for(var i = mergedMinRow; i <= mergedMaxRow; i++){
					for(var j = mergedMinCol; j <= mergedMaxCol; j++){
						if(mergedMinRow == mergedMaxRow && mergedMinCol == mergedMaxCol){
							store.setCell(sheetId, i, j, null, ['minrow', 'mincol', 'maxrow', 'maxcol', 'abminrow', 'abmincol', 'abmaxrow', 'abmaxcol'], true);
						}else{
							store.setCell(sheetId, i, j, {
								minrow: mergedMinRow-i,
								mincol: mergedMinCol-j,
								maxrow: mergedMaxRow-i,
								maxcol: mergedMaxCol-j
							}, null, true);
						}									
					}
				}							
			}
		}
	},
	
	/*
	 * for row/col/cell insert/remove
	 */
	prepareRemoveRow : function(){
		var sheet = this.sheet, store = sheet.getStore();
		var preRowGroups, posRowGroups, posMerged, me = this;
		if(sheet.rowGroups){
			preRowGroups = SCOM.copy(sheet.rowGroups);
		}
		var preFreezePos, posFreezePos, preRange, posRange;
		if(sheet.freezePos){
			preFreezePos = SCOM.copy(sheet.freezePos);
			preRange = sheet.getRangeInfo();
		}
		sheet.rangeStoreRef = {};
		sheet.on('holdremoverow', function(sheetId, minrow, maxrow, deleted, merged, e, sheet, preCal, posCal, preCdt, posCdt, preCells, posCells, preReCalCells, posReCalCells, deletedNameRef){
			/*
			 * save it for undo/redo
			 */
			var rangeStoreRef = sheet.rangeStoreRef;
			var sheet = this.sheet, sm = sheet.getSelectionModel(), store = sheet.getStore();
			var sel = sm.getSelection(), focus = sm.getFocusCell(); 			
			/*
			 * transfer the focus cell coord to a string
			 */
			var str = EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String([{
			    span: ['', minrow, 0, maxrow, 0],
			    type: SCONST.RELATIVE_COORD
			}], '');
			
			var motion = new EnterpriseSheet.sheet.history.Motion({
				text:SLANG['remove']+' '+SLANG['row']+' '+str,		
				refreshCalCdt: true,
				conflictAction: 'removeRow',
				undo:function(suspendRefresh, suspendRefreshSelection){			
					/*
					 * recover cells
					 */
					me.recoverCell(preCells);
					var rowSpan = maxrow-minrow+1;
					store.insertRow(sheetId, minrow, rowSpan, true);
					/*
					 * for row group
					 */
					sheet.layoutRowGroups(preRowGroups);
					/*
					 * recover the deleted data
					 */
                    for(var i = 0, dlen = deleted.length; i < dlen; i++){
                        var d = deleted[i].data;
                        store.setCell(d.sheet, d.row, d.col, d.json, null, true);
                    }

					/*
					 * process merged cells
					 */
					me.recoverMerged(merged);
					
					/*
					 * recover calcdt cache
					 */
					me.recoverCal(preCal);
					
					/*
					 * recover condition floting item
					 */
					me.recoverCdt(preCdt);
					
					/*
					 * recover freeze pos if need
					 */
					me.recoverFreeze(preFreezePos, preRange);
					
					store.checkNameRefForInsertRow(sheetId, minrow, rowSpan);
					
					/*
					 * add the deleted ref
					 */
					if(deletedNameRef){
						for(var p in deletedNameRef){
							if(deletedNameRef.hasOwnProperty(p)){
								store.setFileConfig('ref', p, deletedNameRef[p].json);
							}
						}
					}
					/*
					 * for range store 
					 */
					for(var p in rangeStoreRef){
						if(rangeStoreRef.hasOwnProperty(p)){
							var it = rangeStoreRef[p];
							it.rangeStore.resetRangeConfig(it.oldConfig);
						}
					}
					if(!suspendRefresh){
						/*
						 * need refresh the cal and cdt
						 */
						if(sheet.getSheetId() != sheetId){
							sheet.go2Sheet(sheetId, function(){
								sheet.refreshCalCdt(preReCalCells);
							}, this);
						}else{
							sheet.refreshRange(null, preReCalCells);
						}										
					}
					if(!suspendRefreshSelection){
						sm.selectRange(sel.startPos, sel.endPos);
						sheet.refreshFocus(focus.row, focus.col);
					}
					sheet.fireEvent('undoremoverow', sheetId, minrow, maxrow, deleted, merged, this);
				},
				redo:function(suspendRefresh, suspendRefreshSelection){				
					store.removeRow(sheetId, minrow, maxrow, true);
					/*
					 * for row group
					 */
					sheet.layoutRowGroups(posRowGroups);
					/*
					 * process merged cells
					 */
					me.recoverMerged(posMerged);					
					/*
					 * recover calcdt cache
					 */
					me.recoverCal(posCal);
					/*
					 * recover condition floting item
					 */
					me.recoverCdt(posCdt);
					/*
					 * recover cells
					 */
					me.recoverCell(posCells);
					/*
					 * recover freeze pos if need
					 */
					me.recoverFreeze(posFreezePos, posRange);
					
					store.checkNameRefForDeleteRow(sheetId, minrow, maxrow);
					
					/*
					 * for range store 
					 */
					for(var p in rangeStoreRef){
						if(rangeStoreRef.hasOwnProperty(p)){
							var it = rangeStoreRef[p];
							it.rangeStore.resetRangeConfig(it.newConfig);
						}
					}
					
					if(!suspendRefresh){
						if(sheet.getSheetId() != sheetId){
							sheet.go2Sheet(sheetId, function(){
								sheet.refreshCalCdt(posReCalCells);
							}, this);
						}else{
							sheet.refreshRange(null, posReCalCells);
						}										
					}
					if(!suspendRefreshSelection){
						sm.selectRange(sel.startPos, sel.endPos);
						sheet.refreshFocus(focus.row, focus.col);
					}
					sheet.fireEvent('redoremoverow', sheetId, minrow, maxrow, posMerged, this);
				}
			});
			this.add(motion);
		}, this, {single: true});
		/*
		 * cache calCdt after row is removed
		 */
		store.on('rowremoved', function(sheetId, minrow, maxrow){				
			if(sheet.rowGroups){
				posRowGroups = SCOM.copy(sheet.rowGroups);
			}
			if(sheet.freezePos){
				posFreezePos = SCOM.copy(sheet.freezePos);
				posRange = sheet.getRangeInfo();
			}
			
		}, this, {single: true});
           
        store.on('rowremoved', function(sheet, minrow, maxrow, deleted, changedMerged, store){
            posMerged = changedMerged;
        }, this, {single: true});
		
		sheet.fireEvent('changing', sheet);
	},
	
	prepareRemoveColumn : function(){
		var sheet = this.sheet, store = sheet.getStore();
		var preColGroups, posColGroups, posMerged, me = this;
		if(sheet.colGroups){
			preColGroups = SCOM.copy(sheet.colGroups);
		}
		var preFreezePos, posFreezePos, preRange, posRange, preAutoHeights, posAutoHeights;
		if(sheet.freezePos){
			preFreezePos = SCOM.copy(sheet.freezePos);
			preRange = sheet.getRangeInfo();
		}
		sheet.rangeStoreRef = {};
		sheet.on('holdremovecolumn', function(sheetId, mincol, maxcol, deleted, merged, e, sheet, preCal, posCal, preCdt, posCdt, preCells, posCells, preReCalCells, posReCalCells, deletedNameRef){
			var rangeStoreRef = sheet.rangeStoreRef;
			
			var sheet = this.sheet, sm = sheet.getSelectionModel(), store = sheet.getStore();			
			var sel = sm.getSelection(), focus = sm.getFocusCell(); 			
			/*
			 * transfer the focus cell coord to a string
			 */
			var str = EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String([{
			    span: ['', 0, mincol, 0, maxcol],
			    type: SCONST.RELATIVE_COORD
			}], '');
			
			var motion = new EnterpriseSheet.sheet.history.Motion({
				text:SLANG['remove']+' '+SLANG['column']+' '+str,	
				refreshCalCdt: true,
				conflictAction: 'removeColumn',
				undo:function(suspendRefresh, suspendRefreshSelection){			
					/*
					 * recover cells
					 */
					me.recoverCell(preCells);
					var colSpan = maxcol-mincol+1;
					store.insertColumn(sheetId, mincol, colSpan, true);		
					/*
					 * for column group
					 */
					sheet.layoutColumnGroups(preColGroups);
					/*
					 * recover the deleted data
					 */
                    for(var i = 0, dlen = deleted.length; i < dlen; i++){
						var d = deleted[i].data;
						store.setCell(d.sheet, d.row, d.col, d.json, null, true);
					}
					/*
					 * process merged cells
					 */
					me.recoverMerged(merged);					
					/*
					 * recover calcdt cache
					 */
					me.recoverCal(preCal);
					/*
					 * recover condition item
					 */
					me.recoverCdt(preCdt);
					
					/*
					 * recover freeze pos if need
					 */
					me.recoverFreeze(preFreezePos, preRange);
					
					/*
					 * check the autheight
					 */
					me.recoverAutoHeight(preAutoHeights, suspendRefresh);
					
					/*
					 * check name ref
					 */
					store.checkNameRefForInsertColumn(sheetId, mincol, colSpan);
					/*
					 * add the deleted ref
					 */
					if(deletedNameRef){
						for(var p in deletedNameRef){
							if(deletedNameRef.hasOwnProperty(p)){
								store.setFileConfig('ref', p, deletedNameRef[p].json);
							}
						}
					}
					
					/*
					 * for range store 
					 */
					for(var p in rangeStoreRef){
						if(rangeStoreRef.hasOwnProperty(p)){
							var it = rangeStoreRef[p];
							it.rangeStore.resetRangeConfig(it.oldConfig);
						}
					}
					if(!suspendRefresh){								
						/*
						 * need refresh the cal and cdt
						 */
						if(sheet.getSheetId() != sheetId){
							sheet.go2Sheet(sheetId, function(){
								sheet.refreshCalCdt(preReCalCells);
							}, this);
						}else{
							sheet.refreshRange(null, preReCalCells);
						}									
					}
					if(!suspendRefreshSelection){
						sm.selectRange(sel.startPos, sel.endPos);
						sheet.refreshFocus(focus.row, focus.col);
					}
				},
				redo:function(suspendRefresh, suspendRefreshSelection){		
					store.removeColumn(sheetId, mincol, maxcol, true);
					/*
					 * for column group
					 */
					sheet.layoutColumnGroups(posColGroups);
					/*
					 * process merged cells
					 */
					me.recoverMerged(posMerged);
					/*
					 * recover calcdt cache
					 */
					me.recoverCal(posCal);
					/*
					 * recover condition item
					 */
					me.recoverCdt(posCdt);
					/*
					 * recover cells
					 */
					me.recoverCell(posCells);
					/*
					 * recover freeze pos if need
					 */
					me.recoverFreeze(posFreezePos, posRange);
					/*
					 * check the autheight
					 */
					me.recoverAutoHeight(posAutoHeights, suspendRefresh);
					
					/*
					 * check name ref
					 */
					store.checkNameRefForDeleteColumn(sheetId, mincol, maxcol);
					
					/*
					 * for range store 
					 */
					for(var p in rangeStoreRef){
						if(rangeStoreRef.hasOwnProperty(p)){
							var it = rangeStoreRef[p];
							it.rangeStore.resetRangeConfig(it.newConfig);
						}
					}
					if(!suspendRefresh){
						/*
						 * need refresh the cal and cdt
						 */
						if(sheet.getSheetId() != sheetId){
							sheet.go2Sheet(sheetId, function(){
								sheet.refreshCalCdt(posReCalCells);
							}, this);
						}else{
							sheet.refreshRange(null, posReCalCells);
						}									
					}
					if(!suspendRefreshSelection){
						sm.selectRange(sel.startPos, sel.endPos);
						sheet.refreshFocus(focus.row, focus.col);
					}
				}
			});
			this.add(motion);
		}, this, {single: true});
		/*
		 * cache calCdt after column is removed
		 */
		sheet.on('columnremoved', function(sheetId, mincol, maxcol, changedHeights){			
			if(sheet.colGroups){
				posColGroups = SCOM.copy(sheet.colGroups);
			}
			if(sheet.freezePos){
				posFreezePos = SCOM.copy(sheet.freezePos);
				posRange = sheet.getRangeInfo();
			}
            preAutoHeights = changedHeights.oldHeights;
			posAutoHeights = changedHeights.newHeights;
		}, this, {single: true});
           
        store.on('columnremoved', function(sheet, mincol, maxcol, deleted, changedMerged, store){
            posMerged = changedMerged;
        }, this, {single: true});
		
		sheet.fireEvent('changing', sheet);
	},		
	
	/*
	 * the cell is removed in the store, but not render yet
	 */
	prepareRemoveCell : function(){
		var sheet = this.sheet, store = sheet.getStore();
		var me = this;
		var preAutoHeights, posAutoHeights;
		
		sheet.rangeStoreRef = {};
		sheet.on('holdremovecell', function(sheetId, minrow, maxrow, mincol, maxcol, moveDir, deleted, merged, e, sheet, preCal, posCal, preCdt, posCdt, preCells, posCells, preReCalCells, posReCalCells, deletedNameRef){
			var rangeStoreRef = sheet.rangeStoreRef;
			var sheet = this.sheet, sm = sheet.getSelectionModel(), store = sheet.getStore();
			var sel = sm.getSelection(), focus = sm.getFocusCell(); 
			/*
			 * transfer the focus cell coord to a string
			 */
			var str = EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String([{
			    span: ['', minrow, mincol, maxrow, maxcol],
			    type: SCONST.RELATIVE_COORD
			}], '');
			
			
			var motion = new EnterpriseSheet.sheet.history.Motion({
				text:SLANG['remove']+' '+SLANG['cell']+' '+str,	
				refreshCalCdt: true,
				conflictAction: 'removeCell',
				undo:function(suspendRefresh, suspendRefreshSelection){	
					/*
					 * recover cells
					 */
					me.recoverCell(preCells);
					var rowSpan = maxrow-minrow+1, colSpan = maxcol-mincol+1;
					var insertDir = 'up' == moveDir ? 'down' : 'right';
					store.insertCell(sheetId, minrow, mincol, rowSpan, colSpan, insertDir, true);			
					/*
					 * recover the deleted data
					 */
                    for(var i = 0, dlen = deleted.length; i < dlen; i++){
						var d = deleted[i].data;
						store.setCell(d.sheet, d.row, d.col, d.json, null, true);
					};
					/*
					 * recover calculate cell cache
					 */
					me.recoverCal(preCal);
					/*
					 * recover condition floating item
					 */
					me.recoverCdt(preCdt);
					
					/*
					 * check the autheight
					 */
					me.recoverAutoHeight(preAutoHeights, suspendRefresh);
					
					/*
					 * check name ref
					 */
					store.checkNameRefForInsertCell(sheetId, minrow, mincol, rowSpan, colSpan, insertDir);
					/*
					 * add the deleted ref
					 */
					if(deletedNameRef){
						for(var p in deletedNameRef){
							if(deletedNameRef.hasOwnProperty(p)){
								store.setFileConfig('ref', p, deletedNameRef[p].json);
							}
						}
					}
					/*
					 * for range store 
					 */
					for(var p in rangeStoreRef){
						if(rangeStoreRef.hasOwnProperty(p)){
							var it = rangeStoreRef[p];
							it.rangeStore.resetRangeConfig(it.oldConfig);
						}
					}
					if(!suspendRefresh){
						/*
						 * need refresh the cal and cdt
						 */
						if(sheet.getSheetId() != sheetId){
							sheet.go2Sheet(sheetId, function(){
								sheet.refreshCalCdt(preReCalCells);
							}, this);
						}else{
							sheet.refreshRange(null, preReCalCells);
						}										
					}
					if(!suspendRefreshSelection){
						sm.selectRange(sel.startPos, sel.endPos);
						sheet.refreshFocus(focus.row, focus.col);
					}
				},
				redo:function(suspendRefresh, suspendRefreshSelection){	
					store.removeCell(sheetId, minrow, maxrow, mincol, maxcol, moveDir, true, true);
					/*
					 * recover calculate cell cache
					 */
					me.recoverCal(posCal);
					/*
					 * recover condition floating item
					 */
					me.recoverCdt(posCdt);
					/*
					 * recover cells
					 */
					me.recoverCell(posCells);
					/*
					 * check the autheight
					 */					
					me.recoverAutoHeight(posAutoHeights, suspendRefresh);
					
					/*
					 * check name ref
					 */
					store.checkNameRefForDeleteCell(sheetId, minrow, maxrow, mincol, maxcol, moveDir);
					/*
					 * for range store 
					 */
					for(var p in rangeStoreRef){
						if(rangeStoreRef.hasOwnProperty(p)){
							var it = rangeStoreRef[p];
							it.rangeStore.resetRangeConfig(it.newConfig);
						}
					}
					if(!suspendRefresh){
						/*
						 * need refresh the cal and cdt
						 */
						if(sheet.getSheetId() != sheetId){
							sheet.go2Sheet(sheetId, function(){
								sheet.refreshCalCdt(posReCalCells);
							}, this);
						}else{
							sheet.refreshRange(null, posReCalCells);
						}											
					}
					if(!suspendRefreshSelection){
						sm.selectRange(sel.startPos, sel.endPos);
						sheet.refreshFocus(focus.row, focus.col);
					}
				}
			});
			this.add(motion);
		}, this, {single: true});		
		
		/*
		 * cache calCdt after column is removed
		 */
		sheet.on('cellremoved', function(sheetId, minrow, mincol, maxrow, maxcol, moveDir, changedHeights){			
			preAutoHeights = changedHeights.oldHeights;
			posAutoHeights = changedHeights.newHeights;
		}, this, {single: true});
		
		sheet.fireEvent('changing', sheet);
	},	
	
	/*
	 * the row is inserted in the store, but not render yet
	 */
	prepareInsertRow : function(){
		var sheet = this.sheet, store = sheet.getStore();
		var preRowGroups, posRowGroups, posMerged, me = this;
		if(sheet.rowGroups){
			preRowGroups = SCOM.copy(sheet.rowGroups);
		}
		var preFreezePos, posFreezePos, preRange, posRange;
		if(sheet.freezePos){
			preFreezePos = SCOM.copy(sheet.freezePos);
			preRange = sheet.getRangeInfo();
		}
		sheet.rangeStoreRef = {};
		sheet.on('holdinsertrow', function(sheetId, row, rowSpan, merged, e, sheet, preCal, posCal, preCdt, posCdt, preCells, posCells, preReCalCells, posReCalCells, insertCellCache){
			var rangeStoreRef = sheet.rangeStoreRef;
			var maxrow = row+rowSpan-1;
			var sheet = this.sheet, sm = sheet.getSelectionModel(), store = sheet.getStore();
			var sel = sm.getSelection(), focus = sm.getFocusCell(); 
			/*
			 * transfer the focus cell coord to a string
			 */		
			
			var motion = new EnterpriseSheet.sheet.history.Motion({
				text:SLANG['insert_row_at']+' '+row,	
				refreshCalCdt: true,
				conflictAction: 'insertRow',
				undo:function(suspendRefresh, suspendRefreshSelection){			
					/*
					 * recover cells
					 */
					me.recoverCell(preCells);
					
					store.removeRow(sheetId, row, maxrow, true);	
					/*
					 * for row group
					 */
					sheet.layoutRowGroups(preRowGroups);
					/*
					 * process merged cells
					 */
					me.recoverMerged(merged);
					/*
					 * recover calculate cell cache
					 */
					me.recoverCal(preCal);
					/*
					 * recover condition floating item
					 */
					me.recoverCdt(preCdt);
					
					/*
					 * recover freeze pos if need
					 */
					me.recoverFreeze(preFreezePos, preRange);
					
					/*
					 * check the name ref
					 */
					store.checkNameRefForDeleteRow(sheetId, row, maxrow);
					/*
					 * for range store 
					 */
					for(var p in rangeStoreRef){
						if(rangeStoreRef.hasOwnProperty(p)){
							var it = rangeStoreRef[p];
							it.rangeStore.resetRangeConfig(it.oldConfig);
						}
					}
					if(!suspendRefresh){
						/*
						 * need refresh the cal and cdt
						 */
						if(sheet.getSheetId() != sheetId){
							sheet.go2Sheet(sheetId, function(){
								sheet.refreshCalCdt(preReCalCells);
							}, this);
						}else{
							sheet.refreshRange(null, preReCalCells);
						}										
					}
					if(!suspendRefreshSelection){
						sm.selectRange(sel.startPos, sel.endPos);
						sheet.refreshFocus(focus.row, focus.col);
					}
					sheet.fireEvent('undoinsertrow', sheetId, row, rowSpan, this);
				},
				redo:function(suspendRefresh, suspendRefreshSelection){				
					store.insertRow(sheetId, row, rowSpan, true, insertCellCache);
					/*
					 * for row group
					 */
					sheet.layoutRowGroups(posRowGroups);
					/*
					 * process merged cells
					 */
					me.recoverMerged(posMerged);
					/*
					 * recover calculate cell cache
					 */
					me.recoverCal(posCal);
					/*
					 * recover condition floating item
					 */
					me.recoverCdt(posCdt);
					/*
					 * recover cells
					 */
					me.recoverCell(posCells);
					/*
					 * recover freeze pos if need
					 */
					me.recoverFreeze(posFreezePos, posRange);
					
					/*
					 * check the name ref
					 */
					store.checkNameRefForInsertRow(sheetId, row, rowSpan);
					/*
					 * for range store 
					 */
					for(var p in rangeStoreRef){
						if(rangeStoreRef.hasOwnProperty(p)){
							var it = rangeStoreRef[p];
							it.rangeStore.resetRangeConfig(it.newConfig);
						}
					}
					if(!suspendRefresh){
						/*
						 * need refresh the cal and cdt
						 */
						if(sheet.getSheetId() != sheetId){
							sheet.go2Sheet(sheetId, function(){
								sheet.refreshCalCdt(posReCalCells);
							}, this);
						}else{
							sheet.refreshRange(null, posReCalCells);
						}										
					}
					if(!suspendRefreshSelection){
						sm.selectRange(sel.startPos, sel.endPos);
						sheet.refreshFocus(focus.row, focus.col);
					}
					sheet.fireEvent('redoinsertrow', sheetId, row, rowSpan, this);
				}
			});
			this.add(motion);
		}, this, {single: true});
		/*
		 * cache calCdt after column is removed
		 */
		store.on('rowinserted', function(sheetId, row, rowSpan){			
			if(sheet.rowGroups){
				posRowGroups = SCOM.copy(sheet.rowGroups);
			}
			if(sheet.freezePos){
				posFreezePos = SCOM.copy(sheet.freezePos);
				posRange = sheet.getRangeInfo();
			}
			posMerged = store.checkMergedCellChange(sheetId, {
				min:row,
				max:row
			}, null, true);
		}, this, {single: true});
		
		sheet.fireEvent('changing', sheet);
	},	
	
	/*
	 * the column is inserted in the store, but not render yet
	 */
	prepareInsertColumn : function(){
		var sheet = this.sheet, store = sheet.getStore();
		var preColGroups, posColGroups, posMerged, me = this;
		if(sheet.colGroups){
			preColGroups = SCOM.copy(sheet.colGroups);
		}
		var preFreezePos, posFreezePos, preRange, posRange;
		if(sheet.freezePos){
			preFreezePos = SCOM.copy(sheet.freezePos);
			preRange = sheet.getRangeInfo();
		}
		sheet.rangeStoreRef = {};
		sheet.on('holdinsertcolumn', function(sheetId, col, colSpan, merged, e, sheet, preCal, posCal, preCdt, posCdt, preCells, posCells, preReCalCells, posReCalCells, insertCellCache){
			var rangeStoreRef = sheet.rangeStoreRef;
			var maxcol = col+colSpan-1;
			var sheet = this.sheet, sm = sheet.getSelectionModel(), store = sheet.getStore();
			var sel = sm.getSelection(), focus = sm.getFocusCell(); 
			/*
			 * transfer the focus cell coord to a string
			 */
			var str = EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String([{
			    span: ['', 0, col, 0, col],
			    type: SCONST.RELATIVE_COORD
			}], '');
			
			var motion = new EnterpriseSheet.sheet.history.Motion({
				text:SLANG['insert_column_at']+' '+str,			
				refreshCalCdt: true,
				conflictAction: 'insertColumn',
				undo:function(suspendRefresh, suspendRefreshSelection){	
					/*
					 * recover cells
					 */
					me.recoverCell(preCells);
					store.removeColumn(sheetId, col, maxcol, true);	
					/*
					 * for column group
					 */
					sheet.layoutColumnGroups(preColGroups);
					/*
					 * process merged cells
					 */
					me.recoverMerged(merged);
					/*
					 * recover cal cache
					 */
					me.recoverCal(preCal);
					/*
					 * recover condition floating item
					 */
					me.recoverCdt(preCdt);
					
					/*
					 * recover freeze pos if need
					 */
					me.recoverFreeze(preFreezePos, preRange);
					
					/* 
					 * check name ref
					 */
					store.checkNameRefForDeleteColumn(sheetId, col, maxcol);
					/*
					 * for range store 
					 */
					for(var p in rangeStoreRef){
						if(rangeStoreRef.hasOwnProperty(p)){
							var it = rangeStoreRef[p];
							it.rangeStore.resetRangeConfig(it.oldConfig);
						}
					}
					if(!suspendRefresh){
						/*
						 * need refresh the cal and cdt
						 */
						if(sheet.getSheetId() != sheetId){
							sheet.go2Sheet(sheetId, function(){
								sheet.refreshCalCdt(preReCalCells);
							}, this);
						}else{
							sheet.refreshRange(null, preReCalCells);
						}											
					}
					if(!suspendRefreshSelection){
						sm.selectRange(sel.startPos, sel.endPos);
						sheet.refreshFocus(focus.row, focus.col);
					}
				},
				redo:function(suspendRefresh, suspendRefreshSelection){				
					store.insertColumn(sheetId, col, colSpan, true, insertCellCache);
					/*
					 * for column group
					 */
					sheet.layoutColumnGroups(posColGroups);
					/*
					 * process merged cells
					 */
					me.recoverMerged(posMerged);
					/*
					 * recover cal cache
					 */
					me.recoverCal(posCal);
					/*
					 * recover condition floating item
					 */
					me.recoverCdt(posCdt);
					/*
					 * recover cells
					 */
					me.recoverCell(posCells);
					/*
					 * recover freeze pos if need
					 */
					me.recoverFreeze(posFreezePos, posRange);
					
					/* 
					 * check name ref
					 */
					store.checkNameRefForInsertColumn(sheetId, col, colSpan);
					/*
					 * for range store 
					 */
					for(var p in rangeStoreRef){
						if(rangeStoreRef.hasOwnProperty(p)){
							var it = rangeStoreRef[p];
							it.rangeStore.resetRangeConfig(it.newConfig);
						}
					}
					if(!suspendRefresh){
						/*
						 * need refresh the cal and cdt
						 */
						if(sheet.getSheetId() != sheetId){
							sheet.go2Sheet(sheetId, function(){
								sheet.refreshCalCdt(posReCalCells);
							}, this);
						}else{
							sheet.refreshRange(null, posReCalCells);
						}										
					}
					if(!suspendRefreshSelection){
						sm.selectRange(sel.startPos, sel.endPos);
						sheet.refreshFocus(focus.row, focus.col);
					}
				}
			});
			this.add(motion);
		}, this, {single: true});
		/*
		 * cache calCdt after column is removed
		 */
		store.on('columninserted', function(sheetId, col, colSpan){			
			if(sheet.colGroups){
				posColGroups = SCOM.copy(sheet.colGroups);
			}
			if(sheet.freezePos){
				posFreezePos = SCOM.copy(sheet.freezePos);
				posRange = sheet.getRangeInfo();
			}
			posMerged = store.checkMergedCellChange(sheetId, null, {
				min:col,
				max:col
			}, true);
		}, this, {single: true});
		
		sheet.fireEvent('changing', sheet);
	},	
	
	/*
	 * the cell is inserted in the store, but not render yet
	 */
	prepareInsertCell : function(){
		var sheet = this.sheet, store = sheet.getStore();
		var me = this;
		var preAutoHeights, posAutoHeights;
		sheet.rangeStoreRef = {};
		sheet.on('holdinsertcell', function(sheetId, row, col, rowSpan, colSpan, moveDir, merged, evt, sheet, preCal, posCal, preCdt, posCdt, preCells, posCells, preReCalCells, posReCalCells, insertCellCache){
			var rangeStoreRef = sheet.rangeStoreRef;
			var maxrow = row+rowSpan-1, maxcol = col+colSpan-1;
			var sheet = this.sheet, sm = sheet.getSelectionModel(), store = sheet.getStore();
			var sel = sm.getSelection(), focus = sm.getFocusCell(); 
			/*
			 * transfer the focus cell coord to a string
			 */
			var str = EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String([{
			    span: ['', row, col, row, col],
			    type: SCONST.RELATIVE_COORD
			}], '');
			
			var motion = new EnterpriseSheet.sheet.history.Motion({
				text:SLANG['insert_cell_at']+' '+str,	
				refreshCalCdt: true,
				conflictAction: 'insertCell',
				undo:function(suspendRefresh, suspendRefreshSelection){							
					/*
					 * recover cells
					 */
					me.recoverCell(preCells);
					var deleteDir = 'right' == moveDir ? 'left' : 'up';
					store.removeCell(sheetId, row, maxrow, col, maxcol, deleteDir, true);		
					/*
					 * recover cal cache
					 */
					me.recoverCal(preCal);
					/*
					 * recover condition floating item
					 */
					me.recoverCdt(preCdt);
					
					/*
					 * check the autheight
					 */
					me.recoverAutoHeight(preAutoHeights, suspendRefresh);
					
					/* 
					 * check name ref
					 */
					store.checkNameRefForDeleteCell(sheetId, row, maxrow, col, maxcol, deleteDir);
					/*
					 * for range store 
					 */
					for(var p in rangeStoreRef){
						if(rangeStoreRef.hasOwnProperty(p)){
							var it = rangeStoreRef[p];
							it.rangeStore.resetRangeConfig(it.oldConfig);
						}
					}
					if(!suspendRefresh){
						/*
						 * need refresh the cal and cdt
						 */
						if(sheet.getSheetId() != sheetId){
							sheet.go2Sheet(sheetId, function(){
								sheet.refreshCalCdt(preReCalCells);
							}, this);
						}else{
							sheet.refreshRange(null, preReCalCells);
						}										
					}
					if(!suspendRefreshSelection){
						sm.selectRange(sel.startPos, sel.endPos);
						sheet.refreshFocus(focus.row, focus.col);
					}
				},
				redo:function(suspendRefresh, suspendRefreshSelection){							
					store.insertCell(sheetId, row, col, rowSpan, colSpan, moveDir, true, insertCellCache);
					/*
					 * recover cal cache
					 */
					me.recoverCal(posCal);
					/*
					 * recover condition floating item
					 */
					me.recoverCdt(posCdt);
					/*
					 * recover cells
					 */
					me.recoverCell(posCells);
					
					/*
					 * check the autheight
					 */
					me.recoverAutoHeight(posAutoHeights, suspendRefresh);					
					/* 
					 * check name ref
					 */
					store.checkNameRefForInsertCell(sheetId, row, col, rowSpan, colSpan, moveDir);
					/*
					 * for range store 
					 */
					for(var p in rangeStoreRef){
						if(rangeStoreRef.hasOwnProperty(p)){
							var it = rangeStoreRef[p];
							it.rangeStore.resetRangeConfig(it.newConfig);
						}
					}
					if(!suspendRefresh){
						/*
						 * need refresh the cal and cdt
						 */
						if(sheet.getSheetId() != sheetId){
							sheet.go2Sheet(sheetId, function(){
								sheet.refreshCalCdt(posReCalCells);
							}, this);
						}else{
							sheet.refreshRange(null, posReCalCells);
						}											
					}
					if(!suspendRefreshSelection){
						sm.selectRange(sel.startPos, sel.endPos);
						sheet.refreshFocus(focus.row, focus.col);
					}
				}
			});
			this.add(motion);
		}, this, {single: true});		
		
		/*
		 * cache calCdt after column is removed
		 */
		sheet.on('cellinserted', function(sheetId, minrow, mincol, rowSpan, colSpan, moveDir, changedHeights){			
			preAutoHeights = changedHeights.oldHeights;
			posAutoHeights = changedHeights.newHeights;
		}, this, {single: true});
		
		sheet.fireEvent('changing', sheet);
	},	
		
	/*
	 * add a motion to history
	 */
	add : function(motion){
        if(this.disabled){
            return;
        }
		this.forward();		
		this.stack.splice(this.cursor);
		this.stack.push(motion);
		if(this.maxStackLength < this.stack.length){
			this.stack.splice(0, this.stack.length-this.maxStackLength);
		}
		this.setCursor(this.stack.length-1);			
		this.fireEvent('add', motion, this);
	},
	
	/*
	 * undo a or more motions
	 * @param {int} index: the index of motion in the history to undo
	 * @param {boolean} suspendRefresh: true to not refresh UI
	 * @param {boolean} suspendEvent: true to not fire changing event
	 */
	undo : function(index, suspendRefresh, suspendEvent){		
		var rm = this.sheet.getReferenceModel();
		rm.hide();
		if(index){				
			var refreshCalCdt = false, motion, needRecheckRows = {};
			for(var i = 0; i < index; i++){
				/*
				 * hold the refresh element and selection
				 */
				motion = this.stack[this.cursor];
				if(true !== refreshCalCdt){
					if(true === motion.refreshCalCdt){
						refreshCalCdt = true;
					}else if(Ext.isObject(motion.refreshCalCdt)){
						refreshCalCdt = refreshCalCdt || {};
						Ext.applyIf(refreshCalCdt, motion.refreshCalCdt);
					}
				}				
				var res = motion.undo(true, true);
				this.backward();
			}			
			/*
			 * for last one, specially only hold refresh for element
			 */
			motion = this.stack[this.cursor];
			if(true === motion.refreshCalCdt){
				refreshCalCdt = true;
			}else if(Ext.isObject(motion.refreshCalCdt)){
				refreshCalCdt = refreshCalCdt || {};
				Ext.applyIf(refreshCalCdt, motion.refreshCalCdt);
			}
			var res = motion.undo(true);
			
			this.backward();
			if(!suspendRefresh){
				/*
				 * generate a timestamp if need refresh calculate and condition cell
				 */			
				this.sheet.refreshRange(null,  refreshCalCdt);				
			}
			/*
			 * fire changing event of sheet
			 */
			if(!suspendEvent){
				this.sheet.fireEvent('changing', this.sheet);
			}			
		}else if(0 <= this.cursor){			
			this.stack[this.cursor].undo(suspendRefresh);
			this.backward();
			/*
			 * fire changing event of sheet
			 */
			if(!suspendEvent){
				this.sheet.fireEvent('changing', this.sheet);
			}			
		}
	},
	
	/*
	 * redo a or more motions
	 * @param {int} index: the index of motion in the history to redo
	 * @param {boolean} suspendRefresh: true to not refresh UI
	 * @param {boolean} suspendEvent: true to not fire changing event
	 */
	redo : function(index, suspendRefresh, suspendEvent){		
		var rm = this.sheet.getReferenceModel();
		rm.hide();
		if(index){			
			var refreshCalCdt = false, motion, needRecheckRows = {}
			for(var i = 0; i < index; i++){
				this.forward();
				/*
				 * hold the refresh element and selection
				 */
				motion = this.stack[this.cursor];
				if(true !== refreshCalCdt){
					if(true === motion.refreshCalCdt){
						refreshCalCdt = true;
					}else if(Ext.isObject(motion.refreshCalCdt)){
						refreshCalCdt = refreshCalCdt || {};
						Ext.applyIf(refreshCalCdt, motion.refreshCalCdt);
					}
				}
				var res = motion.redo(true, true);
			}
			this.forward();
			/*
			 * for last one, specially only hold refresh for element
			 */
			motion = this.stack[this.cursor];
			if(true === motion.refreshCalCdt){
				refreshCalCdt = true;
			}else if(Ext.isObject(motion.refreshCalCdt)){
				refreshCalCdt = refreshCalCdt || {};
				Ext.applyIf(refreshCalCdt, motion.refreshCalCdt);
			}
			var res = motion.redo(true);
			
			
			if(!suspendRefresh){
				/*
				 * generate a timestamp if need refresh calculate and condition cell
				 */			
				this.sheet.refreshRange(null,  refreshCalCdt);				
			}
			/*
			 * fire changing event of sheet
			 */
			if(!suspendEvent){
				this.sheet.fireEvent('changing', this.sheet);
			}
		}else if(this.stack.length-1 > this.cursor){
			this.forward();
			this.stack[this.cursor].redo(suspendRefresh);
			/*
			 * fire changing event of sheet
			 */
			if(!suspendEvent){
				this.sheet.fireEvent('changing', this.sheet);
			}			
		}
	},
	
	getStack : function(){
		return this.stack;
	},
	
	getMotion : function(index){
		return this.stack[index];
	},
	
	getCount : function(){
		return this.stack.length;
	},
	
	setCursor : function(cursor){
		var old = this.cursor;
		this.cursor = cursor;
		this.fireEvent('movecursor', this.cursor, old, this.stack.length, this);
	},
	
	moveCursor : function(offset){
		var old = this.cursor;
		this.cursor += offset;
		this.fireEvent('movecursor', this.cursor, old, this.stack.length, this);
	},
	
	forward : function(){
		this.moveCursor(1);		
	},
	
	backward : function(){
		this.moveCursor(-1);		
	},
	
	/*
	 * create motion for create chart event
	 */
	onCreateChart : function(chartType, chart, rangeStore){
		var sheet = this.sheet, sm = sheet.getSelectionModel(), store = sheet.getStore();
		var sheetId = sheet.getSheetId();
		var sel = sm.getSelection(), focus = sm.getFocusCell();
		var info, chartId = chart.getId(), chartName = chart.getName();
		/*
		 * create motion
		 */
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text:SLANG['create_chart'],			
			undo:function(suspendRefresh, suspendRefreshSelection){
				var chartFloor = sheet.getFloorById(chartId);						
				/*
				 * cache the position and size
				 */
				info = chartFloor.getPositionSize();						
				chartFloor.destroy(false, true);
				if(!suspendRefresh){
					if(sheet.getSheetId() != sheetId){
						sheet.go2Sheet(sheetId);
					}else{
						sheet.refreshRange();
					}									
				}
				if(!suspendRefreshSelection){
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			},
			redo:function(suspendRefresh, suspendRefreshSelection){		
				info.floorId = chartName;				
				sheet.createChart(chartType, rangeStore, info, true);
				
				if(!suspendRefresh){
					if(sheet.getSheetId() != sheetId){
						sheet.go2Sheet(sheetId);
					}else{
						sheet.refreshRange();
					}										
				}
				if(!suspendRefreshSelection){
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			}
		});
		this.add(motion);
	},
	
	/*
	 * create motion for delete chart event
	 */
	onDeleteChart : function(chartType, chart, rangeStore, info){
		
		var sheet = this.sheet, sm = sheet.getSelectionModel(), store = sheet.getStore();
		var sheetId = sheet.getSheetId();
		var sel = sm.getSelection(), focus = sm.getFocusCell();
		var chartId = chart.getId(), chartName = chart.getName();
		info = info || {};				
		/*
		 * create motion
		 */
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text:SLANG['delete_chart'],			
			undo:function(suspendRefresh, suspendRefreshSelection){
				info.floorId = chartName;
				
				sheet.createChart(chartType, rangeStore, info, true);				
				
				if(!suspendRefresh){
					if(sheet.getSheetId() != sheetId){
						sheet.go2Sheet(sheetId);
					}else{
						sheet.refreshRange();
					}										
				}
				if(!suspendRefreshSelection){
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			},
			redo:function(suspendRefresh, suspendRefreshSelection){		
				var chartFloor = sheet.getFloorById(chartId);
				
				/*
				 * cache the position and size
				 */
				info = chartFloor.getPositionSize();				
				chartFloor.destroy(false, true);
				
				if(!suspendRefresh){
					if(sheet.getSheetId() != sheetId){
						sheet.go2Sheet(sheetId);
					}else{
						sheet.refreshRange();
					}					
				}
				if(!suspendRefreshSelection){
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			}
		});
		this.add(motion);
	},
	
	/*
	 * create motion for insert picture
	 */
	onCreatePicture : function(url, floor){
		var sheet = this.sheet, sm = sheet.getSelectionModel(), store = sheet.getStore();
		var sheetId = sheet.getSheetId();
		var sel = sm.getSelection(), focus = sm.getFocusCell();
		var info, floorId = floor.getId(), floorName = floor.getName();
		/*
		 * create motion
		 */
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text:SLANG['create_picture'],			
			undo:function(suspendRefresh, suspendRefreshSelection){
				var floor = sheet.getFloorById(floorId);				
				/*
				 * cache the position and size
				 */
				info = floor.getPositionSize();						
				floor.destroy(false, true);
				if(!suspendRefresh){
					if(sheet.getSheetId() != sheetId){
						sheet.go2Sheet(sheetId);
					}else{
						sheet.refreshRange();
					}					
				}
				if(!suspendRefreshSelection){
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			},
			redo:function(suspendRefresh, suspendRefreshSelection){		
				info.floorId = floorName;
				sheet.createPicture(url, info, true);
				
				if(!suspendRefresh){
					if(sheet.getSheetId() != sheetId){
						sheet.go2Sheet(sheetId);
					}else{
						sheet.refreshRange();
					}					
				}
				if(!suspendRefreshSelection){
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			}
		});
		this.add(motion);
	},
	
	/*
	 * create motion for delete picture event
	 */
	onDeletePicture : function(url, floor, info){
		
		var sheet = this.sheet, sm = sheet.getSelectionModel(), store = sheet.getStore();
		var sheetId = sheet.getSheetId();
		var sel = sm.getSelection(), focus = sm.getFocusCell();
		var floorId = floor.getId(), floorName = floor.getName();
		info = info || {};		
		/*
		 * create motion
		 */
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text:SLANG['delete_picture'],			
			undo:function(suspendRefresh, suspendRefreshSelection){
				info.floorId = floorName;
				sheet.createPicture(url, info, true);				
				
				if(!suspendRefresh){
					if(sheet.getSheetId() != sheetId){
						sheet.go2Sheet(sheetId);
					}else{
						sheet.refreshRange();
					}					
				}
				if(!suspendRefreshSelection){
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			},
			redo:function(suspendRefresh, suspendRefreshSelection){		
				var floor = sheet.getFloorById(floorId);
				/*
				 * cache the position and size
				 */
				info = floor.getPositionSize();				
				floor.destroy(false, true);
				
				if(!suspendRefresh){
					if(sheet.getSheetId() != sheetId){
						sheet.go2Sheet(sheetId);
					}else{
						sheet.refreshRange();
					}					
				}
				if(!suspendRefreshSelection){
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			}
		});
		this.add(motion);
	},
           
    /*
     * create motion for insert wedgit
     */
    onCreateWedgit : function(url, floor){
        var sheet = this.sheet, sm = sheet.getSelectionModel(), store = sheet.getStore();
        var sheetId = sheet.getSheetId();
        var sel = sm.getSelection(), focus = sm.getFocusCell();
        var info, floorId = floor.getId(), floorName = floor.getName();
        /*
         * create motion
         */
        var motion = new EnterpriseSheet.sheet.history.Motion({
            text:SLANG['create_wedgit'],
            undo:function(suspendRefresh, suspendRefreshSelection){
                var floor = sheet.getFloorById(floorId);
                /*
                 * cache the position and size
                 */
                info = floor.getPositionSize();
                floor.destroy(false, true);
                if(!suspendRefresh){
                    if(sheet.getSheetId() != sheetId){
                        sheet.go2Sheet(sheetId);
                    }else{
                        sheet.refreshRange();
                    }
                }
                if(!suspendRefreshSelection){
                    sm.selectRange(sel.startPos, sel.endPos);
                    sheet.refreshFocus(focus.row, focus.col);
                }
            },
            redo:function(suspendRefresh, suspendRefreshSelection){
                info.floorId = floorName;
                sheet.createWedgit(url, info, true);
                            
                if(!suspendRefresh){
                    if(sheet.getSheetId() != sheetId){
                        sheet.go2Sheet(sheetId);
                    }else{
                        sheet.refreshRange();
                    }
                }
                if(!suspendRefreshSelection){
                    sm.selectRange(sel.startPos, sel.endPos);
                    sheet.refreshFocus(focus.row, focus.col);
                }
            }
        });
        this.add(motion);
    },
           
    /*
     * create motion for delete wedgit event
     */
    onDeleteWedgit : function(url, floor, info){
           
        var sheet = this.sheet, sm = sheet.getSelectionModel(), store = sheet.getStore();
        var sheetId = sheet.getSheetId();
        var sel = sm.getSelection(), focus = sm.getFocusCell();
        var floorId = floor.getId(), floorName = floor.getName();
        info = info || {};
        /*
         * create motion
         */
        var motion = new EnterpriseSheet.sheet.history.Motion({
            text:SLANG['delete_wedgit'],
            undo:function(suspendRefresh, suspendRefreshSelection){
                info.floorId = floorName;
                sheet.createWedgit(url, info, true);
                                                       
                if(!suspendRefresh){
                    if(sheet.getSheetId() != sheetId){
                        sheet.go2Sheet(sheetId);
                    }else{
                        sheet.refreshRange();
                    }
                }
                if(!suspendRefreshSelection){
                    sm.selectRange(sel.startPos, sel.endPos);
                    sheet.refreshFocus(focus.row, focus.col);
                }
            },
            redo:function(suspendRefresh, suspendRefreshSelection){
                var floor = sheet.getFloorById(floorId);
                /*
                 * cache the position and size
                 */
                info = floor.getPositionSize();
                floor.destroy(false, true);
                                                       
                if(!suspendRefresh){
                    if(sheet.getSheetId() != sheetId){
                        sheet.go2Sheet(sheetId);
                    }else{
                        sheet.refreshRange();
                    }
                }
                if(!suspendRefreshSelection){
                    sm.selectRange(sel.startPos, sel.endPos);
                    sheet.refreshFocus(focus.row, focus.col);
                }
            }
        });
        this.add(motion);
    },
	
	/*
	 * after store load
	 */
	afterStoreLoad : function(){
        this.clearHistory();
	},
           
    clearHistory : function(){
        /*
         * init the stack
         */
        this.stack = [];
        this.cursor = -1;
        /*
         * fire event to history list and history button
         */
        this.fireEvent('clearhistory', this);
    },
	
	/**
	 * mark the motion position for merge next
	 */
	prepareMergeMotion : function(){
		this.markPosition = this.cursor+1;
	},
	
	/**
	 * merge the motions
	 */
	mergeMotion : function(motionText, clearValueSpan){
		if(Ext.isNumber(this.markPosition)){
			if(1 < this.stack.length-this.markPosition){
				var arr = this.stack.splice(this.markPosition);
				var len = arr.length;
				this.cursor -= len;
				var sheet = this.sheet;
				/*
				 * create motion
				 */
				var motion = new EnterpriseSheet.sheet.history.Motion({
					text: motionText,			
					undo:function(suspendRefresh, suspendRefreshSelection){
                        if(clearValueSpan){
                            sheet.clearValueForCoord([clearValueSpan]);
                        }
						var refreshCalCdt = false, motion, needRecheckRows = {};
						for(var i = len-1; 0 < i; i--){
							var motion = arr[i];
							if(true !== refreshCalCdt){
								if(true === motion.refreshCalCdt){
									refreshCalCdt = true;
								}else if(Ext.isObject(motion.refreshCalCdt)){
									refreshCalCdt = refreshCalCdt || {};
									Ext.applyIf(refreshCalCdt, motion.refreshCalCdt);
								}
							}
							motion.undo(true, true);
						}
						motion = arr[0];
						if(true === motion.refreshCalCdt){
							refreshCalCdt = true;
						}else if(Ext.isObject(motion.refreshCalCdt)){
							refreshCalCdt = refreshCalCdt || {};
							Ext.applyIf(refreshCalCdt, motion.refreshCalCdt);
						}
						var res = motion.undo(true);
						
						if(!suspendRefresh){
							/*
							 * generate a timestamp if need refresh calculate and condition cell
							 */			
							sheet.refreshRange(null, refreshCalCdt);				
						}
					},
					redo:function(suspendRefresh, suspendRefreshSelection){
                        if(clearValueSpan){
                            sheet.clearValueForCoord([clearValueSpan]);
                        }
						var refreshCalCdt = false, motion, needRecheckRows = {};
						for(var i = 0; i < len-1; i++){
							var motion = arr[i];
							if(true !== refreshCalCdt){
								if(true === motion.refreshCalCdt){
									refreshCalCdt = true;
								}else if(Ext.isObject(motion.refreshCalCdt)){
									refreshCalCdt = refreshCalCdt || {};
									Ext.applyIf(refreshCalCdt, motion.refreshCalCdt);
								}
							}
							motion.redo(true, true);
						}
						motion = arr[len-1];
						if(true === motion.refreshCalCdt){
							refreshCalCdt = true;
						}else if(Ext.isObject(motion.refreshCalCdt)){
							refreshCalCdt = refreshCalCdt || {};
							Ext.applyIf(refreshCalCdt, motion.refreshCalCdt);
						}
						var res = motion.redo(true);
						
						if(!suspendRefresh){
							/*
							 * generate a timestamp if need refresh calculate and condition cell
							 */			
							sheet.refreshRange(null, refreshCalCdt);				
						}
					}
				});
				this.add(motion);
			}
			/*
			 * delete the mark
			 */
			delete(this.markPosition);
		}
	},
	
	onCreateMotionForSetCell : function(cells){
		var me = this, sheet = this.sheet, store = sheet.getStore();
		var text = SLANG['change_cells'];
		var newCells = {};
		for(var p in cells){
			if(cells.hasOwnProperty(p)){
				var it = cells[p];
				newCells[p] = {
					pos: it.pos,
					cell: store.getCell(it.pos[0], it.pos[1], it.pos[2], true, p)
				};
			}
		}
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text: text,	
			undo: function(suspendRefresh, suspendRefreshSelection){
				me.disabled = true;
				var activedSheetId = store.getActivedSheetId(), refreshFlag = false, allCoord = [];
				for(var p in cells){
					if(cells.hasOwnProperty(p)){
						var it = cells[p], cell = it.cell, pos = it.pos;
						var sheetId = pos[0], row = pos[1], col = pos[2];
						var oldCoord = store.presetTplForCells([[sheetId, row, col, row, col]], true, true);
		    			store.setCell(sheetId, row, col, cell, undefined, false, 'clear');
		    			var coord = store.presetTplForCells([[sheetId, row, col, row, col]], undefined, true);
		    			if(activedSheetId === sheetId){
		    				if(0 === row || 0 === col){
		    					refreshFlag = true;
		    				}else if(!refreshFlag){
		    					allCoord = allCoord.concat(oldCoord.concat(coord).concat([sheetId, row, col, row, col]));
		    				}    				
		    			}
					}
				}
				if(refreshFlag){
					sheet.refreshRange();
				}else{
					sheet.refreshRange(allCoord);
				}
				me.disabled = false;
			},
			redo: function(suspendRefresh, suspendRefreshSelection){
				me.disabled = true;
				var activedSheetId = store.getActivedSheetId(), refreshFlag = false, allCoord = [];
				for(var p in newCells){
					if(newCells.hasOwnProperty(p)){
						var it = newCells[p], cell = it.cell, pos = it.pos;
						var sheetId = pos[0], row = pos[1], col = pos[2];
						var oldCoord = store.presetTplForCells([[sheetId, row, col, row, col]], true, true);
		    			store.setCell(sheetId, row, col, cell, undefined, false, 'clear');
		    			var coord = store.presetTplForCells([[sheetId, row, col, row, col]], undefined, true);
		    			if(activedSheetId === sheetId){
		    				if(0 === row || 0 === col){
		    					refreshFlag = true;
		    				}else if(!refreshFlag){
		    					allCoord = allCoord.concat(oldCoord.concat(coord).concat([sheetId, row, col, row, col]));
		    				}    				
		    			}
					}
				}
				if(refreshFlag){
					sheet.refreshRange();
				}else{
					sheet.refreshRange(allCoord);
				}
				me.disabled = false;
			}			
		});			
		this.add(motion);	
		sheet.fireEvent('changing', sheet);	
	},
	
	disable: function(){
		this.disabled = true;
	},
	
	enable : function(){
		delete(this.disabled);
	},
	
	onCreateCustomerHistory : function(callback, scope){
		if(callback){
			callback.call(scope, this);
		}		
	},
	
	onCreateFileConfig : function(config, store){
		if(this.disabled){
			return;
		}
		var me = this, sheet = this.sheet, store = sheet.getStore();
		var text = SLANG['create_defined_func'];
		
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text: text,	
			undo: function(suspendRefresh, suspendRefreshSelection){
				me.disabled = true;
				if('named_func' === config.ctype){
    				store.setFileConfig(config.ctype, config.name);
    			}
				me.disabled = false;
			},
			redo: function(suspendRefresh, suspendRefreshSelection){
				me.disabled = true;
				if('named_func' === config.ctype){
    				store.setFileConfig(config.ctype, config.name, config.json);
    			}
				me.disabled = false;
			}			
		});			
		this.add(motion);	
		sheet.fireEvent('changing', sheet);
	},
	
	onUpdateFileConfig : function(config, store, oldJson){
		if(this.disabled){
			return;
		}
		var me = this, sheet = this.sheet, store = sheet.getStore();
		var text = SLANG['update_defined_func'];
		
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text: text,	
			undo: function(suspendRefresh, suspendRefreshSelection){
				me.disabled = true;
				if('named_func' === config.ctype){
    				store.setFileConfig(config.ctype, config.name, oldJson);
    			}
				me.disabled = false;
			},
			redo: function(suspendRefresh, suspendRefreshSelection){
				me.disabled = true;
				if('named_func' === config.ctype){
    				store.setFileConfig(config.ctype, config.name, config.json);
    			}
				me.disabled = false;
			}			
		});			
		this.add(motion);	
		sheet.fireEvent('changing', sheet);
	},
	
	onRemoveFileConfig : function(config, store){
		if(this.disabled){
			return;
		}
		var me = this, sheet = this.sheet, store = sheet.getStore();
		var text = SLANG['remove_defined_func'];
		
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text: text,	
			undo: function(suspendRefresh, suspendRefreshSelection){
				me.disabled = true;
				if('named_func' === config.ctype){
    				store.setFileConfig(config.ctype, config.name, config.json);
    			}
				me.disabled = false;
			},
			redo: function(suspendRefresh, suspendRefreshSelection){
				me.disabled = true;
				if('named_func' === config.ctype){
    				store.setFileConfig(config.ctype, config.name);
    			}
				me.disabled = false;
			}			
		});			
		this.add(motion);	
		sheet.fireEvent('changing', sheet);	
	}
});
Ext.define('EnterpriseSheet.sheet.history.HistoryList', {
	
	/* Begin Definitions */
	
	extend: 'Ext.menu.Menu',		
	
	/* End Definitions */
	
	minWidth:200,

    defaultDisplay: '&nbsp;',    
    
	initComponent : function(){
		this.displayItem = new Ext.toolbar.TextItem({
			text : this.defaultDisplay 
		});
		
		this.items = [{}];
		
        this.bbar = {
            xtype: 'toolbar',
            cls: 'ss-sheetlist-bar',
            border: false,
            items: [this.displayItem]
        };
		
		this.callParent();
				
		this.on({
			scope:this,
			'beforeshow':this._beforeShow
		});				
	},
	
	_beforeShow : function(){
		var history = this.history;
		this.removeAll();
		if('undo' == this.mode){					
			for(var i = 0; i <= history.cursor; i++){
				var motion = history.getMotion(i);
				this.insert(0, {
					text:motion.text,
					motion:motion,
					handler:this.doMotion,
					scope:this
				});
			}
		}else{
			for(var i = history.cursor+1, len = history.getCount(); i < len; i++){
				var motion = history.getMotion(i);
				this.add({
					text:motion.text,
					motion:motion,
					handler:this.doMotion,
					scope:this
				});
			}
		}		
	},	
	
	doMotion : function(item){
		var index = this.items.indexOf(item);
		if('undo' == this.mode){
			this.history.undo(index);
		}else{
			this.history.redo(index);
		}		
	},		    
    
    /*
     * update the display when active change
     */
    updateDisplay : function(){
    	var text = SLANG['cancel'];
    	if(0 < this.activeCount){
    		text = SLANG['cancel']+' '+this.activeCount+' '+SLANG['steps'];
    	}
    	this.displayItem.update(text);
    },
    
    /*
     * deactive all items in the menu
     */
    deactiveAllItems:function(){
        for(var i = 0, len = this.items.getCount(); i < len; i++){
            var it = this.items.get(i);
            if(it.deactivate){
            	it.deactivate();
            }
        }
        this.activeCount = 0;
        this.updateDisplay();
    },
    
    /*
     * extend onMouseLeave function
     */
    onMouseLeave : function(e){
    	/*
    	 * deactive all items
    	 */
    	this.deactiveAllItems();
    	this.callParent(arguments);        
    },
    
    onMouseOver : function(e){
    	this.callParent(arguments);
    	
    	var me = this,
    		item = me.getItemFromEvent(e);
    	
    	var index = this.items.indexOf(item);
    	/*
    	 * update the display
    	 */
    	this.activeCount = index+1;
    	this.updateDisplay();
        for(var i = 0; i < index; i++){
        	var it = this.items.get(i);
        	if (it.activate) {
        		it.activate();
        	}
        }
        for(var i = index+1, len = this.items.getCount(); i < len; i++){
        	var it = this.items.get(i);
        	if(it.deactivate){
        		it.deactivate();
        	}
        }
    }        
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.history.HistoryButton', {
	
	/* Begin Definitions */
	
	extend: 'Ext.button.Split',		
	
	requires : [
	    'EnterpriseSheet.sheet.history.HistoryList'
	],
	
	/* End Definitions */
	
	disabled : true,
	
	/*
	 * get rid of the default disabledClass
	 */
	disabledCls : '',
	
	initComponent : function(){
		
		this.mode = this.mode || 'undo';
		
		this.menu = new EnterpriseSheet.sheet.history.HistoryList({
			mode:this.mode,
			history:this.history
		});
		
		if(this.disabled){
			this.iconCls = 'icon-'+this.mode+'-disable';
		}else{
			this.iconCls = 'icon-'+this.mode+'-enable';
		}		
		
		this.callParent();
		
		this.mon(this.history, {
			scope:this,
			'movecursor':this.onMoveCursor,
			'clearhistory': this.onClearHistory
		});
	},
	
	/*
	 * set the handler
	 */
	handler : function(){
		if('undo' == this.mode){
			this.history.undo();
		}else{
			this.history.redo();
		}
	},
	
	disable : function(){
		this.callParent(arguments);
		this.setIconCls('icon-'+this.mode+'-disable');
	},
	
	enable : function(){
		this.callParent(arguments);		
		this.setIconCls('icon-'+this.mode+'-enable');
	},
	
	onMoveCursor : function(cursor, old, len){
		if('undo' == this.mode){
			if(0 <= cursor){
				this.enable();
			}else{
				this.disable();
			}
		}else{
			if(len-1 > cursor){
				this.enable();
			}else{
				this.disable();
			}
		}
	},
	
	onClearHistory : function(){
		this.disable();
	}
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.layout.Table', {

    /* Begin Definitions */

    alias: ['layout.sheettable'],
    extend: 'Ext.layout.container.Table',
    
    /* End Definitions */
    
    /*
     * override getLayoutItems here, we need also layout the hidden ones
     */
    getLayoutItems: function() {
    	var owner = this.owner,
        items = owner && owner.items;

    	return (items && items.items) || [];
    }
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.layout.LayoutTemplates', {
	
	requires : [	
	    'EnterpriseSheet.Config',
		'EnterpriseSheet.common.Common', 
		'Ext.XTemplate'
	],
	
	singleton : true,
	
	opacity : .85,
	
	constructor : function(){
		
		Ext.util.Format._istrue = function(v){
			return undefined !== v && null !== v && '' !== v;
		}
		var isVerticalAlign = function(va){
			return 'middle' == va || 'bottom' == va;
		}
		
		Ext.util.Format._isVerticalAlign = isVerticalAlign;
		var cell = [
			'<div cid="{ri}${ci}" ri={ri} ci={ci} class="ss-cfloat ',
			/*
			 * wrap flag is for the double border,
			 * for make double border/3px solid border work, we need add a wrap for the cell
			 */
			'<tpl if="true===values.wrap">',
				'ss-cwrap " style="width:{width};height:{height};',
				'{[values.bgc?"background-color:"+values.bgc+";":""]}',
				'{[values.icon?"background-image:"+values.icon+";":""]}',
				'padding-right:{wpr}px;padding-bottom:{wpb}px;" >',
				'<div class="',
			'</tpl>',
				'ss-cell {css} {[values.dsd?"ss-cell-disabled":""]}" ',
				'style="width:{width};height:{height};{[values.body?"":"line-height:"+values.height+";"]}{[values.incell?"overflow:hidden;":"', (SCONFIG.hideOverflowInCell?'overflow:hidden;':''), '"]}',				
				'<tpl if="true===values.body">',
					/*
					 * if body is true, then means this cell not in lefter and header.
					 * we add this condition cause the lefter and header cell don't need
					 * below styles
					 */					
					'{[fm._istrue(values.pl)?"padding-left:"+values.pl+"px;":""]}{[fm._istrue(values.pr)?"padding-right:"+values.pr+"px;":""]}',
					'{[fm._istrue(values.pt)?"padding-top:"+values.pt+"px;":""]}{[fm._istrue(values.pb)?"padding-bottom:"+values.pb+"px;":""]}',
					'{[values.ws?"white-space:"+values.ws+";":""]}{[values.ww?"word-wrap:"+values.ww+";":""]}',
					'{[values.bgc?"background-color:"+values.bgc+";":""]}{[values.icon?"background-image:"+values.icon+";":""]}{[values.ta?"text-align:"+values.ta+";":""]}',
					//'{[values.dsd?"opacity:', this.opacity, ';":""]}',
					
					'{[values.ti?"text-indent:"+values.ti+";":""]}{[values.color?"color:"+values.color+";":""]}',
					'{[values.ff?"font-family:"+values.ff+";":""]}{[fm._istrue(values.fz)?"font-size:"+values.fz+"pt;":""]}',
					'{[fm._istrue(values.fw)?"font-weight:"+values.fw+";":""]}{[values.fs?"font-style:"+values.fs+";":""]}',
					'{[values.u||values.o||values.s?"text-decoration:"+(values.u||"")+" "+(values.o||"")+" "+(values.s||"")+";":""]}',		
					'{[fm._istrue(values.zd)?"z-index:"+values.zd+";":""]}',
					/*
					 * border styles
					 */
					'{[fm._istrue(values.blw)?"border-left-width:"+values.blw+"px;":""]}{[values.bls?"border-left-style:"+values.bls+";":""]}{[values.blc?"border-left-color:"+values.blc+";":""]}',
					'{[fm._istrue(values.btw)?"border-top-width:"+values.btw+"px;":""]}{[values.bts?"border-top-style:"+values.bts+";":""]}{[values.btc?"border-top-color:"+values.btc+";":""]}',
					'{[fm._istrue(values.brw)?"border-right-width:"+values.brw+"px;":""]}{[values.brs?"border-right-style:"+values.brs+";":""]}{[values.brc?"border-right-color:"+values.brc+";":""]}',
					'{[fm._istrue(values.bbw)?"border-bottom-width:"+values.bbw+"px;":""]}{[values.bbs?"border-bottom-style:"+values.bbs+";":""]}{[values.bbc?"border-bottom-color:"+values.bbc+";":""]}',				
				'</tpl>',
				'">',						
							
				'<tpl if="true===values.incell">',
					/*
					 * this condition is add for handle combined cell, it's not a very neat way but works					 	 
					 */
					'<div class="ss-incell" ',
						'style="{[values.ws?"white-space:"+values.ws+";":""]}{[values.ws?"word-wrap:"+values.ww+";":""]}width:{w}px;height:{h}px;margin-left:{l}px;margin-top:{t}px;">',
				'</tpl>',
					'<tpl if="true==this.isVerticalAlign(values.va)">',	
						/*
						 * notice if it's combined cell then the w and h is for the real size of the combined cell
						 */
						'<div class="ss-vcell" style="vertical-align:{va};{[true===values.incell?("width:"+values.w+"px;height:"+values.h+"px"):("width:"+values.width+";height:"+values.height)]};">',
					'</tpl>',		
							'{preItem}',
							'{data}',
							/*
							 * for colorful bar of condition function
							 */
							'{bar}',
							/*
							 * for mini chart
							 */
							'{mini}',
							/*
							 * for incell image
							 */
							'{icp}',
							/*
							 * for right trigger, will use for embadded combobox, datefield and filter etc.
							 */
							'{posTrigger}',
							
							'{ltcorner}',
							'{lbcorner}',
							'{rtcorner}',
							'{rbcorner}',
						'{[fm._isVerticalAlign(values.va)?"</div>":""]}',												
					'{[values.incell?"</div>":""]}',				
				/*
				 * the end of the wrap
				 */
				'{[values.wrap?"</div>":""]}',
			'</div>'
		]
		var cellTpl = new Ext.XTemplate(cell.join(''), {
			isVerticalAlign:isVerticalAlign
		}).compile();
		
		var row = ['<tpl for=".">'].concat(cell, ['</tpl>']);	
		var rowTpl = new Ext.XTemplate(row.join(''), {
			isVerticalAlign:isVerticalAlign
		}).compile();
		
		var region = [
			'<tpl for=".">',
				'<div class="ss-row" style="height:{height};padding-bottom:1px;">',
					'<tpl for="cells">'].concat(
					cell,			
					['</tpl>',
				'</div>',
			'</tpl>'
		]);	
		
		var regionTpl = new Ext.XTemplate(region.join(''), {
			isVerticalAlign:isVerticalAlign
		}).compile();	
		
		
		/*
		 * a function to get the data from a cell element
		 */
		var getCellInnerText = function(cell){
			var cellEl = Ext.get(cell);
			var text;
			if(cellEl){			
				var vcell = cellEl.down('.ss-vcell');
				if(vcell){
					text = vcell.dom.innerHTML;
					text = SCOM.removeHTMLTag(text);
				}else{
					var incell = cellEl.down('.ss-incell');
					if(incell){
						text = incell.dom.innerHTML;
						text = SCOM.removeHTMLTag(text);
					}else{
						text = cellEl.dom.innerHTML;
						text = SCOM.removeHTMLTag(text);
					}
				}			
			}
			text = text || '';
			return text;
		};
		
		/*
		 * for row/column group tpl
		 */
		var groupTpl = new Ext.XTemplate([
		    '<div name="{name}" start="{start}" end="{end}" class="ss-{dir}-group {cls}" ',
		    	'style="border-color:{color};{[values.top?"top:"+values.top+"px;":""]}{[values.left?"left:"+values.left+"px;":""]}">',
		    	'<tpl if="true===values.max||true===values.min">',
		    		'<div class="{[true===values.max?"ss-group-tail":"ss-group-head"]}" style="background-color:{color};border-color:{color};"></div>',
		    	'</tpl>',
		    '</div>'
		].join('')).compile();	
		
		var miniColumnTpl = new Ext.XTemplate([
		    '<tpl for=".">',
		    	'<div class="ss-mini-col ss-cell-inside" style="background-color:{bgc};{vpos};left:{l};width:{w};height:{h};"></div>',
		    '</tpl>'
		].join('')).compile();
		
		
		var guessHeightTable = ['<table cellpadding=0 border=0 cellspacing=0><tbody><tr><tpl for="."><td>'].concat(cell, ['</td></tpl></tr></tbody></table>']);	
		var guessHeightTpl = new Ext.XTemplate(guessHeightTable.join(''), {
			isVerticalAlign:isVerticalAlign
		}).compile();
		
		this.callParent(arguments);
		
		var tpls = {
			'region' : regionTpl,
			'row' : rowTpl,
			'cell' : cellTpl,
			'group' : groupTpl,
			'miniColumnTpl': miniColumnTpl,
			'getCellInnerText' : getCellInnerText,
			'guessHeightTpl' : guessHeightTpl
		};
		
		Ext.apply(this, tpls);
	}
}, function(){
	SLAYOUT = EnterpriseSheet.sheet.layout.LayoutTemplates;
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.tpl.TableTemplate', {
	
	/* Begin Definitions */	
	
	requires : ['Ext.menu.Menu'],
	
	/* End Definitions */
	
	separateChar : '$',
	
	MAX_CACHE_SIZE : 500,
	
	kitOffset : [5, -20],
	
	constructor : function(){
		this.initSummaryMenu();
		/*
		 * create a cache to hold the table style
		 */
		this.resetCache();
		
		this.callParent();		
	},
	
	init : function(sheet){
		if(this.sheet){
			return;
		}
		this.sheet = sheet;	
		var store = sheet.getStore();		
		store.on({
			scope: this,					
			'beforehiderow' : this.resetCache,
			'beforehidecolumn' : this.resetCache,
			'beforeshowrow' : this.resetCache,
			'beforeshowcolumn' : this.resetCache,
						
			/*
			 * need check the valid before remove
			 */
			//'beforeremoverow' : this.beforeRemoveRow,
			//'beforeremovecolumn' : this.beforeRemoveColumn,
			'beforeremovecell' : this.beforeRemoveCell,						
			'beforeinsertcell' : this.beforeInsertCell,
			
			/*
			 * for remove/insert
			 */
			'beforeholdremoverow' : this.holdRemoveRow,
			'beforeholdremovecolumn' : this.holdRemoveColumn,
			'beforeholdinsertrow' : this.holdInsertRow,
			'beforeholdinsertcolumn' : this.holdInsertColumn
		});
		
		sheet.on({
			scope: this,
			'cellmousedown' : this.onCellMouseDown,
			'incellmousedown' : this.onIncellMouseDown,			
			'cellmouseup' : this.onCellMouseUp,
			'changing': this.hideSummaryKit
		});
		
	},
           
    isTableHeader : function(cell, sheetId, row, col){
        var tpl = cell.tpl;
        if(tpl){
            tpl = Ext.decode(tpl);
            var span = tpl.span;
            return sheetId === span[0] && (row === span[1] || (1 === row && 0 === span[1]));
        }
    },
	
	/*
	 * mouse down on a cell element
	 */
	onCellMouseDown : function(row, col, region, e){
		var store = this.sheet.getStore(), sheetId = this.sheet.getSheetId();
		var cell = store.getCell(sheetId, row, col), flag = false;
		if(cell.tpl){
			var tpl = Ext.decode(cell.tpl), withoutFoot = !tpl.withFoot;
			var tplData = this.getTplById(tpl.id);
			if(tplData){
				Ext.apply(tpl, tplData);
			}
            var fs = withoutFoot ? false : tpl['footStyle'];

			if(col !== tpl.span[2] && row === tpl.span[3] && fs){
				flag = true;
				this.showSummaryKit(row, col);
			}
		}			
		if(!flag){
			this.hideSummaryKit();
		}
	},
	
	/*
	 * mouse down on an element inside the cell
	 */
	onIncellMouseDown : function(rc, target, region, e){
		var store = this.sheet.getStore(), sheetId = this.sheet.getSheetId(), sm = this.sheet.getSelectionModel();
		var tgEl = Ext.get(target);			
		if(tgEl.hasCls('ss-tpl-rz')){
			this.rzFlag = true;
			var cell = store.getCell(sheetId, rc[0], rc[1]);
			var tpl = Ext.decode(cell.tpl);
			var span = tpl.span;
			var top = span[1], left = span[2];
			sm.addCls('ss-autofill');
			var mode = {
				type: 'bottom-right',
				minrow: top+1,
				mincol: left,
				maxrow: rc[0],
				maxcol: rc[1]
			};
			this.tplSpan = [sheetId, top, left, rc[0], rc[1]];
			sm.setMode(mode);			
			sm.selectRange({row:top, col:left}, {row:rc[0], col:rc[1]});
			return false;
		}		
	},
	
	onCellMouseUp : function(){
		if(this.rzFlag){
			var sm = this.sheet.getSelectionModel();
			sm.removeCls('ss-autofill');
			sm.setMode();
			var span = sm.selection2Span();			
			delete(this.rzFlag);
			/*
			 * update the tpl property
			 */
			this.updateTplForSpan(span);
		}		
	},
	
	/*
	 * update the tpl 
	 */
	updateTplForSpan : function(span){
		var tplSpan = this.tplSpan;
		var sheetId = tplSpan[0], minrow = tplSpan[1], mincol = tplSpan[2], maxrow = tplSpan[3], maxcol = tplSpan[4];
		var sheet = this.sheet, store = sheet.getStore();
		var cell = store.getCell(sheetId, minrow, mincol);		
		var tpl = Ext.decode(cell.tpl);

		if(span[3] > tplSpan[3] || span[4] > tplSpan[4]){
			if(false === sheet.fireEvent('beforesettpl', span, tpl, sheet)){
				return;
			}
			sheet.fireEvent('preparesettpl', span, tpl, sheet);
			/*
			 * expand the tpl span
			 */
			store.walkRange([span], function(rd){
				var row = rd.data.row, col = rd.data.col;
				if(maxcol >= col){					
					cell = store.getCell(sheetId, maxrow, col);					
					tpl = Ext.decode(cell.tpl);
				}
                if(tpl){
                    tpl.span = [].concat(span);
                    store.setCell(sheetId, row, col, {tpl: Ext.encode(tpl)}, null, true);
                }
			}, this);
			sheet.fireEvent('settpl', span, tpl, sheet);
            this.syncPlainForTplHead(tpl);
			sheet.refreshRange([span], true);
		}else if(span[3] < tplSpan[3] || span[4] < tplSpan[4]){
			if(false === sheet.fireEvent('beforesettpl', tplSpan, tpl, sheet)){
				return;
			}
			sheet.fireEvent('preparesettpl', tplSpan, tpl, sheet);
			/*
			 * narrow the tpl span
			 */
			store.walkRange([tplSpan], function(rd){
				var row = rd.data.row, col = rd.data.col;
				if(maxcol >= col){
					cell = store.getCell(sheetId, maxrow, col);
					tpl = Ext.decode(cell.tpl);
				}
				if(row <= span[3] && col <= span[4]){
					tpl.span = [].concat(span);					
					store.setCell(sheetId, row, col, {tpl: Ext.encode(tpl)}, null, true);
				}else{
					store.setCell(sheetId, row, col, null, ['tpl'], true);
				}				
			}, this);
			sheet.fireEvent('settpl', tplSpan, tpl, sheet);
            this.syncPlainForTplHead(tpl);
			sheet.refreshRange([tplSpan], true);
		}				
		var rm = sheet.getReferenceModel();
		rm.hide();
	},
	
	/*
	 * set table tpl for a span
	 */
	setTplForSpan : function(span, tpl, config){
        config = config || {
           withoutFoot: true
        };
        Ext.apply(tpl, config);
		var flag = this.checkSelection([span]);
		var sheet = this.sheet, store = sheet.getStore();		
		var minrow = span[1], mincol = span[2], maxrow = span[3], maxcol = span[4], sheetId = span[0];		
		if('none' == flag){	
			if(span[1] == span[3] && span[2] == span[4]){
				Ext.Msg.alert(SLANG['hint'], SLANG['cannot_set_table_tpl_for_single_cell']);
			}else{
				if(false === sheet.fireEvent('beforesettpl', span, tpl, sheet)){
					return;
				}
				sheet.fireEvent('preparesettpl', span, tpl, sheet);
				for(var row = minrow; row <= maxrow; row++){
					for(var col = mincol; col <= maxcol; col++){					
						tpl.span = [].concat(span);						
						var modified = {};								
						modified['tpl'] = Ext.encode(tpl);	
						if(0 === row){
							store.setColumn(sheetId, col, modified, null, true, true);
						}else if(0 === col){
							store.setRow(sheetId, row, modified, null, true, true);
						}else{
							store.setCell(sheetId, row, col, modified, null, true);
						}					
					}
				}
				sheet.fireEvent('settpl', span, tpl, sheet);
                this.syncPlainForTplHead(tpl);
				sheet.refreshRange([span], true);
			}			
		}else if('all' == flag){	
			var row = minrow, col = mincol;
			var cp = store.getCellProperty(sheetId, row, col);
			var oldTpl = Ext.decode(cp.tpl);
			span = oldTpl.span;					
			minrow = '' !== span[1] ? span[1] : 0; 
			mincol = '' !== span[2] ? span[2] : 0;
			maxrow = '' !== span[3] ? span[3] : 0;
			maxcol = '' !== span[4] ? span[4] : 0;
			span[1] = minrow, span[2] = mincol, span[3] = maxrow, span[4] = maxcol;
			if(false === sheet.fireEvent('beforesettpl', span, tpl, sheet)){
				return;
			}
			sheet.fireEvent('preparesettpl', span, tpl, sheet);
			for(var row = minrow; row <= maxrow; row++){
				for(var col = mincol; col <= maxcol; col++){					
					tpl.span = [].concat(span);
					var modified = {};								
					modified['tpl'] = Ext.encode(tpl);					
					if(0 === row){
						store.setColumn(sheetId, col, modified, null, true, true);
					}else if(0 === col){
						store.setRow(sheetId, row, modified, null, true, true);
					}else{
						store.setCell(sheetId, row, col, modified, null, true);
					}
				}
			}
			span[0] = sheetId;
			sheet.fireEvent('settpl', span, tpl, sheet);
            this.syncPlainForTplHead(tpl);
			this.sheet.refreshRange([span], true);
		}else{
			Ext.Msg.show({
				title: SLANG['hint'],
				msg: SLANG['cannot_set_tpl_for_selection'],
				icon: Ext.Msg.INFO,
				buttons: Ext.Msg.OK
			});
		}
	},
	
    syncPlainForTplHead : function(tpl){
        var span = tpl.span, store = this.sheet.getStore();
        store.walkRange([span], function(rd){
            var sheetId = rd.data.sheet, row = rd.data.row, col = rd.data.col;
            if(span[1] === row || (0 === span[1] && 1 === row)){
                /*
                 * the head cell
                 */
                var cell = this.sheet.getCellValue(sheetId, row, col);
                store.setCell(sheetId, row, col, {'plain': cell.data}, undefined, true);
            }else{
                store.setCell(sheetId, row, col, undefined, ['plain'], true);
            }
        }, this, true);
    },
           
	/*
	 * clear table tpl for a span
	 */
	clearTplForSpan : function(span){
		var deleted = ['tpl', 'trigger', 'filter', 'filterCdt', 'plain'];
		var flag = this.checkSelection([span]);
		var sheet = this.sheet, store = sheet.getStore();		
		var minrow = span[1], mincol = span[2], maxrow = span[3], maxcol = span[4], sheetId = span[0];		
		if('none' == flag){			
			if(false === sheet.fireEvent('beforesettpl', span, null, sheet)){
				return;
			}
			sheet.fireEvent('preparesettpl', span, null, sheet);
			for(var row = minrow; row <= maxrow; row++){
				for(var col = mincol; col <= maxcol; col++){															
					if(0 === row){
						store.setColumn(sheetId, col, null, deleted, true, true);
					}else if(0 === col){
						store.setRow(sheetId, row, null, deleted, true, true);
					}else{
						store.setCell(sheetId, row, col, null, deleted, true);
					}					
				}
			}
			sheet.fireEvent('settpl', span, null, sheet);
			sheet.refreshRange([span], true);
		}else if('all' == flag){	
			var row = minrow, col = mincol;
			var cp = store.getCellProperty(sheetId, row, col);
			var oldTpl = Ext.decode(cp.tpl);
			span = oldTpl.span;					
			minrow = '' !== span[1] ? span[1] : 0; 
			mincol = '' !== span[2] ? span[2] : 0;
			maxrow = '' !== span[3] ? span[3] : 0;
			maxcol = '' !== span[4] ? span[4] : 0;
			span[1] = minrow, span[2] = mincol, span[3] = maxrow, span[4] = maxcol;
			if(false === sheet.fireEvent('beforesettpl', span, null, sheet)){
				return;
			}
			sheet.fireEvent('preparesettpl', span, null, sheet);
			for(var row = minrow; row <= maxrow; row++){
				for(var col = mincol; col <= maxcol; col++){														
					if(0 === row){
						store.setColumn(sheetId, col, null, deleted, true, true);
					}else if(0 === col){
						store.setRow(sheetId, row, null, deleted, true, true);
					}else{
						store.setCell(sheetId, row, col, null, deleted, true);
					}
				}
			}
			span[0] = sheetId;
			sheet.fireEvent('settpl', span, null, sheet);
			this.sheet.refreshRange([span], true);
		}else{
			Ext.Msg.show({
				title: SLANG['hint'],
				msg: SLANG['cannot_set_tpl_for_selection'],
				icon: Ext.Msg.INFO,
				buttons: Ext.Msg.OK
			});
		}
	},
	
	/*
	 * process the tpl for the cell
	 */
	processTpl : function(cell, scope){		
		var row = scope.row, col = scope.col, sheetId = scope.sheet;		
		var style = this.getStyle(cell.tpl, sheetId, row, col);						
		
		/*
		for(var p in style){
			if(!cell[p]){
				cell[p] = style[p];
			}
		}*/		
		if(SCOM.nullOrUndefined(cell['data'])){
			cell['data'] = style['data'];
        }else{
            delete(style.cal);
            delete(style.value);
            delete(style.arg);
        }
		for(var p in cell){
			if(cell.hasOwnProperty(p) && SCOM.nullOrUndefined(cell[p])){
				delete(cell[p]);
			}
		}
		cell = Ext.applyIf(cell, style);			
		if(style.hideFilter){
			delete(cell.trigger);
		}
		
		return cell;
	},
	
	/*
	 * prepare the styles of the table template
	 */
	prepareTplStyle : function(tpl, sheetId, row, col){
        var calPro = EnterpriseSheet.sheet.calculate.Calculate.prototype;
		var sheet = this.sheet, store = sheet.getStore();
		var span = [].concat(tpl.span);
		var minrow = span[1], mincol = span[2], maxrow = span[3], maxcol = span[4];
		var tplData = this.getTplById(tpl.id);
		if(tplData){
			Ext.apply(tpl, tplData);
		}		
        var bs = tpl['bodyStyle'], hs = tpl.withoutHead ? false : tpl['headStyle'], fs = !tpl.withFoot ? false : tpl['footStyle'], fcs = tpl['firstColumn'], lcs = tpl['lastColumn'];

		var ri, style, ci; 
		var loff = store.countVisibleColumn(sheetId, col+1, maxcol), boff = store.countVisibleRow(sheetId, row+1, maxrow);
		if(hs && ((0 !== minrow && minrow === row) || (0 === minrow && 1 == row))){			
			ci = 1 == hs.length ? 0 : (store.countVisibleColumn(sheetId, mincol+1, col))%hs.length;
			style = hs[ci];
			/*
			 * for special process for header
			 */
			var filter = sheet.getFilter();
			if(filter && !tpl['hideFilter']){
				/*
				 * create filter for the head
				 */
				var tmp = [].concat(span);
				if(fs){
					tmp[3]--;
				}
				var o = filter.prepareFilterPreporty(row, tmp);				
				Ext.apply(style, o);								
			}
			style['hideFilter'] = tpl['hideFilter'];
			/*
			 * if row select then start at the first column
			 */
			var startCol = 0 === span[2] ? 1 : span[2];
			style.data = SLANG['column']+(col-startCol+1);
			/*
			 * if it's row selection, then the first column is the mini column
			 */
			if(col == mincol || (0 === mincol && 1 == col)){
				Ext.applyIf(style, fcs);
			}
			if((col == maxcol || 0 === loff) && 0 !== maxcol){
				Ext.applyIf(style, lcs);
			}
		}else{			
			if(fs && 0 !== maxrow && maxrow === row){
				ci = 1 == fs.length ? 0 : (store.countVisibleColumn(sheetId, mincol+1, col))%fs.length;
				style = fs[ci];
				/*
				 * add a class just for recognize it when we select that cell
				 */
				style.css = 'ss-tpl-foot';
				if(col !== mincol && 1 < maxrow-minrow){					
					/*
					 * add for foot summary
					 */				
					var calName = tpl.cal || 'SUM';
					var tmpSpan = ['', span[1]+1, col, span[3]-1, col];
					var data = EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String([{
						span: tmpSpan,
						type: SCONST.RELATIVE_COORD
					}], '', false);
					style.data = '='+calName+'('+data+')';
					style.cal = true;
					tmpSpan = ['', span[1]-row+1, 0, span[3]-row-1, 0];
                    calPro.transferCalculate(style, store, sheetId, row, col);
				}
			}else{
				ri = 1 == bs.length ? 0 : (store.countVisibleRow(sheetId, 0 === minrow ? 2 : minrow+1, row))%bs.length;
				ci = 1 == bs[ri].length ? 0 : (store.countVisibleColumn(sheetId, 0 === mincol ? 2 : mincol+1, col))%bs[ri].length;
				style = bs[ri][ci];
                if(minrow === row && !Ext.isDefined(style.btf)){
                    style.btf = 1;
                }
			}	
			if(col == mincol || (0 === mincol && 1 == col)){
				Ext.applyIf(style, fcs);
				if(row == maxrow && fs){
					style['data'] = SLANG['summary'];
				}				
			}
			if((col == maxcol || 0 === loff) && 0 !== maxcol){
				Ext.applyIf(style, lcs);
			}
			if(0 !== maxrow && 0 !== maxcol && (row == maxrow || 0 === boff) && (col == maxcol || 0 === loff)){
				style['rbcorner'] = '<div class="ss-tpl-rz"></div>';
			}
		}
		
		return style;
	},
	
	/*
	 * init and reset the lookup cache
	 */
	resetCache : function(){
		this.lookup = {};
	},	
	
	/*
	 * maintain the cache to make it won't beyond the max size predefined
	 */
	maintainCacheSize : function(){
		var size = SCOM.countObjMember(this.lookup);
		var beyond = size-this.MAX_CACHE_SIZE;
		if(0 < beyond){
			var i = 0;
			for(var p in this.lookup){
				delete(this.lookup[p]);
				i++;
				if(i == beyond){
					break;
				}
			}
		}
	},
	
	/*
	 * first, check the lookup, if not found then call prepareTplStyle to get
	 */
	getStyle : function(tplStr, sheetId, row, col){
		var id = [sheetId, row, col].join(this.separateChar);
		var it = this.lookup[id];
		if(it && it.tplStr == tplStr){				
			return it.style;
		}else{			
			var tpl = Ext.decode(tplStr);
			var style = this.prepareTplStyle(tpl, sheetId, row, col);
			this.maintainCacheSize();
			this.lookup[id] = {
				tplStr: tplStr,
				style: style
			};
			return style;
		}
	},
	
	/*
	 * when remove row, we need reset the tpl property
	 */
	holdRemoveRow : function(sheetId, minrow, maxrow){
		var store = this.sheet.getStore();
		var dspan = maxrow-minrow+1;
		store.each(function(rd){
			var orow = row = rd.data.row, col = rd.data.col, json = rd.data.json;
			if(sheetId == rd.data.sheet && 0 != row && json.tpl){
				var tpl = Ext.decode(json.tpl);				
				var span = tpl.span;
				var top = span[1], bottom = span[3], flag = false; 
				if(minrow < top && maxrow > top && maxrow < bottom){
					top = maxrow;
					flag = true;
				}else if(minrow >= top && maxrow <= bottom){
					bottom -= dspan;
					flag = true;
				}else if(minrow < bottom && maxrow > bottom && minrow > top){
					bottom = minrow;
					flag = true;
				}else if(maxrow < top){
					top -= dspan;
					bottom -= dspan;
					flag = true;
				}
				if(flag){					
					span[1] = top;				
					span[3] = bottom;
					store.setCell(sheetId, orow, col, {
						'tpl':Ext.encode(tpl)
					}, null, true);					
				}							
			}
		}, this);
		this.resetCache();
	},
	
	beforeRemoveRow : function(sheetId, minrow, maxrow){
		var flag = this.checkSelection();
		if('part' == flag){
			Ext.Msg.show({
				title: SLANG['hint'],
				msg: SLANG['cannot_delete_normal_tpl_cell'],
				icon: Ext.Msg.INFO,
				buttons: Ext.Msg.OK
			});
			return false;
		}
	},
	
	/*
	 * when remove column, we need reset the tpl property
	 */
	holdRemoveColumn : function(sheetId, mincol, maxcol){
		var store = this.sheet.getStore();
		var dspan = maxcol-mincol+1;
		store.each(function(rd){
			var row = rd.data.row, ocol = col = rd.data.col, json = rd.data.json;
			if(sheetId == rd.data.sheet && 0 != col && json.tpl){
				var tpl = Ext.decode(json.tpl);				
				var span = tpl.span;
				var left = span[2], right = span[4], flag = false; 
				if(mincol < left && maxcol > right && maxcol < right){
					left = maxcol;
					flag = true;
				}else if(mincol >= left && maxcol <= right){
					right -= dspan;
					flag = true;
				}else if(mincol < right && maxcol > right && mincol > left){
					right = mincol;
					flag = true;
				}else if(maxcol < left){
					left -= dspan;
					right -= dspan;
					flag = true;
				}
				if(flag){					
					span[2] = left;				
					span[4] = right;
					store.setCell(sheetId, row, ocol, {'tpl':Ext.encode(tpl)}, null, true);
				}							
			}
		}, this);
		this.resetCache();
	}, 
	
	beforeRemoveColumn : function(sheetId, mincol, maxcol){
		var flag = this.checkSelection();
		if('part' == flag){
			Ext.Msg.show({
				title: SLANG['hint'],
				msg: SLANG['cannot_delete_normal_tpl_cell'],
				icon: Ext.Msg.INFO,
				buttons: Ext.Msg.OK
			});
			return false;
		}
	},
	
	/*
	 * check whether the selection cells are all tpl cell or part or none 
	 */
	checkSelection : function(coord){
		var sheet = this.sheet, store = sheet.getStore(), sm = sheet.getSelectionModel();
		coord = coord || sm.selection2Coord(), span = coord[0];
		if(0 == span[1] && 0 == span[2]){
			return 'whole';
		}else{			
			var sheetId = span[0], minrow = span[1], maxrow = span[3], mincol = span[2], maxcol = span[4];
			if(0 == maxrow){
				/*
				 * for column selection
				 */
				var flag = true, hasTpl = false;
				store.walkRange(coord, function(rd){
					var property = store.getCellProperty(rd.data.sheet, rd.data.row, rd.data.col);
					if(property.tpl){
						hasTpl = true;
						var tpl = Ext.decode(property.tpl);
						var span = tpl.span;
						if(!((mincol > span[2] && maxcol < span[4])
							|| maxcol < span[2] || mincol > span[4])){
							flag = false;
							return false;
						}
					}
				}, this);
				if(flag){
					return hasTpl ? 'all' : 'none';
				}else{
					return 'part';
				}
			}else if(0 == maxcol){
				/*
				 * for row selection
				 */
				var flag = true, hasTpl = false;
				store.walkRange(coord, function(rd){
					var property = store.getCellProperty(rd.data.sheet, rd.data.row, rd.data.col);
					if(property.tpl){
						hasTpl = true;
						var tpl = Ext.decode(property.tpl);
						var span = tpl.span;
						if(!((minrow > span[1] && maxrow < span[3])
							|| maxrow < span[1] || minrow > span[3])){
							flag = false;
							return false;
						}
					}
				}, this);
				if(flag){
					return hasTpl ? 'all' : 'none';
				}else{
					return 'part';
				}
			}else{
				var tplCount = 0, sum = 0;
				store.walkRange(coord, function(rd){
					var property = store.getCellProperty(rd.data.sheet, rd.data.row, rd.data.col);
					if(property.tpl){
						tplCount++;
					}
					sum++;
				}, this);	
				
				if(0 === tplCount){
					return 'none';
				}else if(tplCount == sum){
					return 'all';			
				}else{
					return 'part';
				}
			}			
		}		
	},
	
	
	beforeRemoveCell : function(sheetId, minrow, maxrow, mincol, maxcol, moveDir, deleted, merged, store){
		var flag = this.checkSelection();
		if('part' == flag){
			Ext.Msg.show({
				title: SLANG['hint'],
				msg: SLANG['cannot_delete_normal_tpl_cell'],
				icon: Ext.Msg.INFO,
				buttons: Ext.Msg.OK
			});
			return false;
		}else if('all' == flag){
			var sheet = this.sheet;
			if('left' == moveDir){
				Ext.Msg.show({
					title: SLANG['confirm'],
					msg: SLANG['delete_column_in_tabletpl'],
					icon: Ext.Msg.QUESTION,
					buttons: Ext.Msg.YESNO,
					fn: function(bid){
						if('yes' == bid){
							sheet.deleteColumn();
						}
					},
					scope: this
				});				
				return false;
			}else{		
				Ext.Msg.show({
					title: SLANG['confirm'],
					msg: SLANG['delete_row_in_tabletpl'],
					icon: Ext.Msg.QUESTION,
					buttons: Ext.Msg.YESNO,
					fn: function(bid){
						if('yes' == bid){
							sheet.deleteRow();
						}
					},
					scope: this
				});			
				return false;
			}	
		}		
	},
	
	/*
	 * before insert row, we will update the tpl cell if need
	 */
	beforeInsertRow : function(sheetId, insertRow, rowSpan){
		var store = this.sheet.getStore();
		var maxrow = insertRow+rowSpan-1;
		store.each(function(rd){
			var orow = row = rd.data.row, col = rd.data.col, json = rd.data.json;			
			if(sheetId == rd.data.sheet && 0 != row && json.tpl){
				if(row > maxrow){
					/*
					 * the row need remove the insert part
					 */
					row -= rowSpan;
				}
				var tpl = Ext.decode(json.tpl);
				var span = tpl.span;
				var top = span[1], bottom = span[3]; 
				if(top < insertRow && insertRow <= bottom){
					bottom += rowSpan;					
					span[1] = top;				
					span[3] = bottom;
					store.setCell(sheetId, orow, col, {'tpl':Ext.encode(tpl)}, null, true);
				}else if(insertRow <= top){
					top += rowSpan;
					bottom += rowSpan;					
					span[1] = top;				
					span[3] = bottom;
					store.setCell(sheetId, orow, col, {'tpl':Ext.encode(tpl)}, null, true);
				}						
			}
		}, this);
		this.resetCache();
	},
	
	/*
	 * when row insert in store, we need add tpl property for it if need
	 */
	holdInsertRow : function(sheetId, insertRow, rowSpan){
		this.beforeInsertRow(sheetId, insertRow, rowSpan);
		var store = this.sheet.getStore();			
		var maxrow = insertRow+rowSpan;
		var cols = [];
		/*
		 * get the tpl cols
		 */
		store.each(function(rd){
			var row = rd.data.row, col = rd.data.col, json = rd.data.json;
			if(sheetId == rd.data.sheet && 0 != row && maxrow == row && json.tpl){
				var tpl = Ext.decode(json.tpl);
				var span = tpl.span;
				var top = span[1], bottom = span[3];
				if(top < maxrow){
					cols.push([col, tpl, top, bottom]);
				}
			}
		}, this);
		for(var i = 0, len = cols.length; i < len; i++){
			var c = cols[i];
			var col = c[0], tpl = c[1], top = c[2], bottom = c[3];
			for(var row = insertRow; row < maxrow; row++){
				tpl.span[1] = top;
				tpl.span[3] = bottom;
				/*
				 * let it refresh the UI
				 */
				store.setCell(sheetId, row, col, {
					'tpl': Ext.encode(tpl)
				}, null, true);
			}			
		}
		/*
		if(0 < cols.length){						
			e.refresh = true;
			e.stop = true;
		}*/		
	},
	
	/*
	 * before insert column, we will update the tpl cell if need
	 */
	beforeInsertColumn : function(sheetId, insertCol, colSpan){
		var store = this.sheet.getStore();
		var maxcol = insertCol+colSpan-1;
		store.each(function(rd){
			var row = rd.data.row, ocol = col = rd.data.col, json = rd.data.json;
			if(sheetId == rd.data.sheet && 0 != col && json.tpl){				
				var tpl = Ext.decode(json.tpl);
				var span = tpl.span;
				var left = span[2], right = span[4]; 
				if(left < insertCol && insertCol <= right){
					right += colSpan;					
					span[2] = left;				
					span[4] = right;
					store.setCell(sheetId, row, ocol, {'tpl':Ext.encode(tpl)}, null, true);
				}else if(insertCol <= left){
					left += colSpan;
					right += colSpan;					
					span[2] = left;				
					span[4] = right;
					store.setCell(sheetId, row, ocol, {'tpl':Ext.encode(tpl)}, null, true);
				}						
			}
		}, this);
		this.resetCache();
	},
	
	/*
	 * when column insert in store, we need add tpl property for it if need
	 */
	holdInsertColumn : function(sheetId, insertCol, colSpan){
		this.beforeInsertColumn(sheetId, insertCol, colSpan);
		var store = this.sheet.getStore();		
		var maxcol = insertCol+colSpan;
		var rows = [];
		store.each(function(rd){
			var row = rd.data.row, col = rd.data.col, json = rd.data.json;
			if(sheetId == rd.data.sheet && 0 != col && maxcol == col && json.tpl){
				var tpl = Ext.decode(json.tpl);
				var span = tpl.span;
				var left = span[2], right = span[4]; 
				if(left < maxcol){
					rows.push([row, tpl, left, right]);
				}
			}
		}, this);
		for(var i = 0, len = rows.length; i < len; i++){
			var r = rows[i];
			var row = r[0], tpl = r[1], left = r[2], right = r[3];
			for(var col = insertCol; col < maxcol; col++){
				tpl.span[2] = left;
				tpl.span[4] = right;
				/*
				 * let it refresh the UI
				 */
				store.setCell(sheetId, row, col, {
					'tpl': Ext.encode(tpl)
				}, null, true);
			}			
		}
		/*
		if(0 < rows.length){
			e.refresh = true;
			e.stop = true;
		}*/		
	},
	
	/*
	 * before insert cell, we need check the tpl issue
	 */
	beforeInsertCell : function(sheet, row, col, rowSpan, colSpan, moveDir, merged, store){
		var flag = this.checkSelection();
		if('part' == flag){
			Ext.Msg.show({
				title: SLANG['hint'],
				msg: SLANG['cannot_insert_break_tpl_cell'],
				icon: Ext.Msg.INFO,
				buttons: Ext.Msg.OK
			});
			return false;
		}else if('all' == flag){
			var sheet = this.sheet;		
			if('right' == moveDir){
				Ext.Msg.show({
					title: SLANG['confirm'],
					msg: SLANG['insert_column_in_tabletpl'],
					icon: Ext.Msg.QUESTION,
					buttons: Ext.Msg.YESNO,
					fn: function(bid){
						if('yes' == bid){
							sheet.insertColumn();
						}
					},
					scope: this
				});				
				return false;
			}else{		
				Ext.Msg.show({
					title: SLANG['confirm'],
					msg: SLANG['insert_row_in_tabletpl'],
					icon: Ext.Msg.QUESTION,
					buttons: Ext.Msg.YESNO,
					fn: function(bid){
						if('yes' == bid){
							sheet.insertRow();
						}
					},
					scope: this
				});			
				return false;
			}
		}
	},
	
	initSummaryMenu : function(){
		this.summaryMenu = this.summaryMenu || new Ext.menu.Menu({			
			items:[{
				text: SLANG['sum'],
				cal: 'sum',
				handler: this.selectSummaryCal,
				scope: this
			}, {
				text: SLANG['average'],
				cal: 'average',
				handler: this.selectSummaryCal,
				scope: this
			}, {
				text: SLANG['count'],
				cal: 'count',
				handler: this.selectSummaryCal,
				scope: this
			}, {
				text:SLANG['max'],
				cal: 'max',
				handler: this.selectSummaryCal,
				scope: this
			}, {
				text:SLANG['min'],
				cal: 'min',
				handler: this.selectSummaryCal,
				scope: this
			}, '-', {
				text:SLANG['more_functions']+'..'
			}]
		}); 		
	},
	
	/*
	 * show a summary toolkit on the UI
	 */
	showSummaryKit : function(row, col){		
		var store = this.sheet.getStore(), sheetId = this.sheet.getSheetId();
		var x = store.getRangeWidth(sheetId, 1, col)+this.kitOffset[0];
		var y = store.getRangeHeight(sheetId, 1, row)+this.kitOffset[1];
		if(!this.summaryKit){						
			this.summaryKit = new EnterpriseSheet.sheet.floating.Floor({
				sheet:this.sheet,
                localKit: true,                                                                       
				floatingConfig:{
					xtype:'button',
					iconCls:'icon-sum',
					x:x,
					y:y,
					ddConfig:false,
					resizeConfig:false,
					destroyMenu: false,
					menu:this.summaryMenu
				}
			});
		}else{
			this.summaryKit.setXY([x, y]);
		}	
		/*
		 * ref to cell position in menu
		 */
		this.summaryMenu.cellPos = [sheetId, row, col];
		this.summaryKit.show();
	},
	
	/*
	 * hide the clipKit and destory related comp
	 */
	hideSummaryKit : function(){
		if(this.summaryKit){			
			//this.summaryKit.destroy();
			//delete(this.summaryKit);
			this.summaryKit.hide();
		}
	},
	
	/*
	 * select a cal for summary
	 */
	selectSummaryCal : function(item){		
		var menu = item.parentMenu;
		var pos = menu.cellPos;
		if(pos){
			var cal = item.cal;
			var sheet = this.sheet, store = sheet.getStore();
			var cell = store.getCell(pos[0], pos[1], pos[2]);
			var tpl = Ext.decode(cell.tpl);
			tpl.cal = cal;
			var modified = {tpl: Ext.encode(tpl)};
			var ret = store.setCell(pos[0], pos[1], pos[2], modified, null, true);
			/*
			 * simulate to make store fire datachange event
			 */
			/*
			 * generate a timestamp
			 */
			var timestamp = SCOM.genTimeStamp();
            var changedCalCells = sheet.findDirectRecalculateCellsOfCell(pos[0], pos[1], pos[2]) || {};

            this.clearValueForCalCells(changedCalCells);
            sheet.refreshCalCdt(changedCalCells, undefined, undefined, [pos[0], pos[1], pos[2], pos[1], pos[2]]);
           
			store.fireEvent('tplsummarychange', timestamp, pos[0], pos[1], pos[2], modified, null, ret[0], ret[1], store, false, changedCalCells);
		}
	},
	
	/*
	 * get tpl styles by id
	 */
	getTplById : function(id){
		var tpls = this.tableTplData;
		if(tpls){
			for(var i = 0, len = tpls.length; i < len; i++){
				if(id == tpls[i].id){
					return SCOM.copy(tpls[i].tpl);
				}
			}
		}		
	},
	
	/*
	 * toggle tpl filter for the span
	 */
	toggleTplFilterForSpan : function(span){
		var sheet = this.sheet, store = sheet.getStore(), sheetId = sheet.getSheetId();
		var row = span[1], col = span[2];
		var cp = store.getCellProperty(sheetId, row, col);
		var oldTpl = Ext.decode(cp.tpl);
		/*
		 * toggle the filter by change hideFilter property
		 */
		if(oldTpl.hideFilter){
			delete(oldTpl.hideFilter);
		}else{
			oldTpl.hideFilter = true;
		}		
		var newTpl = Ext.encode(oldTpl);
		span = oldTpl.span;					
		minrow = '' !== span[1] ? span[1] : 0; 
		mincol = '' !== span[2] ? span[2] : 0;
		maxrow = '' !== span[3] ? span[3] : 0;
		maxcol = '' !== span[4] ? span[4] : 0;
		span[1] = minrow, span[2] = mincol, span[3] = maxrow, span[4] = maxcol;		
		if(false === sheet.fireEvent('beforesettpl', span, newTpl, sheet)){
			return;
		}
		sheet.fireEvent('preparesettpl', span, null, sheet);
		for(var row = minrow; row <= maxrow; row++){
			for(var col = mincol; col <= maxcol; col++){														
				if(0 === row){
					store.setColumn(sheetId, col, {'tpl': newTpl}, null, true, true);
				}else if(0 === col){
					store.setRow(sheetId, row, {'tpl': newTpl}, null, true, true);
				}else{
					store.setCell(sheetId, row, col, {'tpl': newTpl}, null, true);
				}
			}
		}
		span[0] = sheetId;
		sheet.fireEvent('settpl', span, newTpl, sheet);
		sheet.refreshRange([span]);
	}
}, function(){
	/**********************************************
	 * template datas 
	 *********************************************/

	EnterpriseSheet.sheet.tpl.TableTemplate.prototype.tableTplData = [{
		'id': 'tpl_0',
		'url':SCONFIG.ICONS_PATH+'/64px/tpl_light_0.png',
		'tip':SLANG[''],
		'type':'light',
		'tpl':{
			'headStyle' : [{			
				btf:1,			
				btc:'black',	    	
				bbc:'black',																		
				fw:'bold'
			}],	
			'footStyle' : [{
				btf:1,
		    	btc:'black',	    				    	
		    	bbc:'black',	    		    	
				fw:'bold'
			}],
			'bodyStyle' : [		    
			    [{
			    	
			    }],
			    [{
			    	bgc:'rgb(217,217,217)'		    	
			    }]
			]
		}
	}, {
		'id': 'tpl_1',
		'url':SCONFIG.ICONS_PATH+'/64px/tpl_light_1.png',
		'type':'light',
		'tip':SLANG[''],
		'tpl':{
			'headStyle' : [{			
				btf:1,			
				btc:'rgb(79,129,189)',	    	
				bbc:'rgb(79,129,189)',																		
				fw:'bold',
				color:'rgb(54,96,146)'
			}],	
			'footStyle' : [{
				btf:1,
		    	btc:'rgb(79,129,189)',	    				    	
		    	bbc:'rgb(79,129,189)',	    		    	
				fw:'bold',
				color:'rgb(54,96,146)'
			}],
			'bodyStyle' : [		    
			    [{}],
			    [{
			    	bgc:'rgb(230,230,241)'		    	
			    }]
			]	
		}
	}, {
		'id': 'tpl_2',
		'url':SCONFIG.ICONS_PATH+'/64px/tpl_light_2.png',
		'type':'light',
		'tip':SLANG[''],
		'tpl':{
			'headStyle' : [{			
				btf:1,			
				btc:'rgb(192,80,77)',	    	
				bbc:'rgb(192,80,77)',																		
				fw:'bold',
				color:'rgb(150,54,52)'
			}],	
			'footStyle' : [{
				btf:1,
				btc:'rgb(192,80,77)',	    	
				bbc:'rgb(192,80,77)',    		    	
				fw:'bold',
				color:'rgb(150,54,52)'
			}],
			'bodyStyle' : [		    
			    [{}],
			    [{
			    	bgc:'rgb(242,220,219)'		    	
			    }]
			]	
		}
	}, {
		'id': 'tpl_3',
		'url':SCONFIG.ICONS_PATH+'/64px/tpl_light_3.png',
		'type':'light',
		'tip':SLANG[''],
		'tpl':{
			'headStyle' : [{			
				btf:1,			
				btc:'rgb(155,187,89)',	    	
				bbc:'rgb(155,187,89)',																		
				fw:'bold',
				color:'rgb(118,147,60)'
			}],	
			'footStyle' : [{
				btf:1,
				btc:'rgb(155,187,89)',	    	
				bbc:'rgb(155,187,89)',    		    	
				fw:'bold',
				color:'rgb(118,147,60)'
			}],
			'bodyStyle' : [		    
			    [{}],
			    [{
			    	bgc:'rgb(235,241,222)'		    	
			    }]
			]	
		}
	}, {
		'id': 'tpl_4',
		'url':SCONFIG.ICONS_PATH+'/64px/tpl_light_4.png',
		'type':'light',
		'tip':SLANG[''],
		'tpl':{
			'headStyle' : [{			
				btf:1,			
				btc:'rgb(128,100,162)',	    	
				bbc:'rgb(128,100,162)',    		    	
				fw:'bold',
				color:'rgb(96,73,122)'
			}],	
			'footStyle' : [{
				btf:1,
				btc:'rgb(128,100,162)',	    	
				bbc:'rgb(128,100,162)',    		    	
				fw:'bold',
				color:'rgb(96,73,122)'
			}],
			'bodyStyle' : [		    
			    [{}],
			    [{
			    	bgc:'rgb(228,226,236)'		    	
			    }]
			]	
		}
	}, {
		'id': 'tpl_5',
		'url':SCONFIG.ICONS_PATH+'/64px/tpl_light_5.png',
		'type':'light',
		'tip':SLANG[''],
		'tpl':{
			'headStyle' : [{			
				btf:1,			
				btc:'rgb(75,172,198)',	    	
				bbc:'rgb(75,172,198)',    		    	
				fw:'bold',
				color:'rgb(49,134,155)'
			}],	
			'footStyle' : [{
				btf:1,
				btc:'rgb(75,172,198)',	    	
				bbc:'rgb(75,172,198)',    		    	
				fw:'bold',
				color:'rgb(49,134,155)'
			}],
			'bodyStyle' : [		    
			    [{}],
			    [{
			    	bgc:'rgb(218,238,243)'		    	
			    }]
			]	
		}
	}, {
		'id': 'tpl_6',
		'url':SCONFIG.ICONS_PATH+'/64px/tpl_light_6.png',
		'type':'light',
		'tip':SLANG[''],
		'tpl':{
			'headStyle' : [{			
				btf:1,			
				btc:'rgb(247,150,70)',	    	
				bbc:'rgb(247,150,70)',    		    	
				fw:'bold',
				color:'rgb(226,107,10)'
			}],	
			'footStyle' : [{
				btf:1,
				btc:'rgb(247,150,70)',	    	
				bbc:'rgb(247,150,70)',    		    	
				fw:'bold',
				color:'rgb(226,107,10)'
			}],
			'bodyStyle' : [		    
			    [{}],
			    [{
			    	bgc:'rgb(253,233,217)'		    	
			    }]
			]	
		}
	}, {
		'id': 'tpl_7',
		'url':SCONFIG.ICONS_PATH+'/64px/tpl_light_7.png',
		'type':'light',
		'tip':SLANG[''],
		'tpl':{
			'headStyle' : [{
				bgc:'black',
				brc:'black',
				btf:1,					
				btc:'black',	    	
				bbc:'black',    		    	
				fw:'bold',
				color:'white'
			}],	
			'footStyle' : [{
				wrap:true,
				btw:1,
				btt:'double',
				bts:'solid',
				pt:1,
				btc:'black',	    	
				bbc:'black',    		    	
				fw:'bold'			
			}],
			'firstColumn' : {
				blf:1,
				blc:'black'
			},
			'lastColumn' : {			
				brc:'black'
			},
			'bodyStyle' : [
			    [{
			    	bbc:'black'		    	
			    }]
			]	
		}
	}, {
		'id': 'tpl_8',
		'url':SCONFIG.ICONS_PATH+'/64px/tpl_light_8.png',
		'type':'light',
		'tip':SLANG[''],
		'tpl':{
			'headStyle' : [{
				bgc:'rgb(79,129,189)',
				brc:'rgb(79,129,189)',
				btf:1,					
				btc:'rgb(79,129,189)',	    	
				bbc:'rgb(79,129,189)',    		    	
				fw:'bold',
				color:'white'
			}],	
			'footStyle' : [{
				wrap:true,
				btw:1,
				btt:'double',
				bts:'solid',
				pt:1,
				btc:'rgb(79,129,189)',	    	
				bbc:'rgb(79,129,189)',    		    	
				fw:'bold'			
			}],
			'firstColumn' : {
				blf:1,
				blc:'rgb(79,129,189)'
			},
			'lastColumn' : {			
				brc:'rgb(79,129,189)'
			},
			'bodyStyle' : [
			    [{
			    	bbc:'rgb(79,129,189)'		    	
			    }]
			]	
		}
	}, {
		'id': 'tpl_9',
		'url':SCONFIG.ICONS_PATH+'/64px/tpl_light_9.png',
		'type':'light',
		'tip':SLANG[''],
		'tpl':{
			'headStyle' : [{
				bgc:'rgb(192,80,77)',
				brc:'rgb(192,80,77)',
				btf:1,					
				btc:'rgb(192,80,77)',	    	
				bbc:'rgb(192,80,77)',    		    	
				fw:'bold',
				color:'white'
			}],	
			'footStyle' : [{
				wrap:true,
				btw:1,
				btt:'double',
				bts:'solid',
				pt:1,
				btc:'rgb(192,80,77)',	    	
				bbc:'rgb(192,80,77)',    		    	
				fw:'bold'			
			}],
			'firstColumn' : {
				blf:1,
				blc:'rgb(192,80,77)'
			},
			'lastColumn' : {			
				brc:'rgb(192,80,77)'
			},
			'bodyStyle' : [
			    [{
			    	bbc:'rgb(192,80,77)'		    	
			    }]
			]	
		}
	}, {
		'id': 'tpl_10',
		'url':SCONFIG.ICONS_PATH+'/64px/tpl_light_10.png',
		'type':'light',
		'tip':SLANG[''],
		'tpl':{
			'headStyle' : [{
				bgc:'rgb(155,187,89)',
				brc:'rgb(155,187,89)',
				btf:1,					
				btc:'rgb(155,187,89)',	    	
				bbc:'rgb(155,187,89)',    		    	
				fw:'bold',
				color:'white'
			}],	
			'footStyle' : [{
				wrap:true,
				btw:1,
				btt:'double',
				bts:'solid',
				pt:1,
				btc:'rgb(155,187,89)',	    	
				bbc:'rgb(155,187,89)',    		    	
				fw:'bold'			
			}],
			'firstColumn' : {
				blf:1,
				blc:'rgb(155,187,89)'
			},
			'lastColumn' : {			
				brc:'rgb(155,187,89)'
			},
			'bodyStyle' : [
			    [{
			    	bbc:'rgb(155,187,89)'		    	
			    }]
			]	
		}
	}, {
		'id': 'tpl_11',
		'url':SCONFIG.ICONS_PATH+'/64px/tpl_light_11.png',
		'type':'light',
		'tip':SLANG[''],
		'tpl':{
			'headStyle' : [{
				bgc:'rgb(128,100,162)',
				brc:'rgb(128,100,162)',
				btf:1,					
				btc:'rgb(128,100,162)',	    	
				bbc:'rgb(128,100,162)',    		    	
				fw:'bold',
				color:'white'
			}],	
			'footStyle' : [{
				wrap:true,
				btw:1,
				btt:'double',
				bts:'solid',
				pt:1,
				btc:'rgb(128,100,162)',	    	
				bbc:'rgb(128,100,162)',    		    	
				fw:'bold'			
			}],
			'firstColumn' : {
				blf:1,
				blc:'rgb(128,100,162)'
			},
			'lastColumn' : {			
				brc:'rgb(128,100,162)'
			},
			'bodyStyle' : [
			    [{
			    	bbc:'rgb(128,100,162)'		    	
			    }]
			]	
		}
	}, {
		'id': 'tpl_12',
		'url':SCONFIG.ICONS_PATH+'/64px/tpl_light_12.png',
		'type':'light',
		'tip':SLANG[''],
		'tpl':{
			'headStyle' : [{
				bgc:'rgb(75,172,198)',
				brc:'rgb(75,172,198)',
				btf:1,					
				btc:'rgb(75,172,198)',	    	
				bbc:'rgb(75,172,198)',    		    	
				fw:'bold',
				color:'white'
			}],	
			'footStyle' : [{
				wrap:true,
				btw:1,
				btt:'double',
				bts:'solid',
				pt:1,
				btc:'rgb(75,172,198)',	    	
				bbc:'rgb(75,172,198)',    		    	
				fw:'bold'			
			}],
			'firstColumn' : {
				blf:1,
				blc:'rgb(75,172,198)'
			},
			'lastColumn' : {			
				brc:'rgb(75,172,198)'
			},
			'bodyStyle' : [
			    [{
			    	bbc:'rgb(75,172,198)'		    	
			    }]
			]	
		}
	}, {
		'id': 'tpl_13',
		'url':SCONFIG.ICONS_PATH+'/64px/tpl_light_13.png',
		'type':'light',
		'tip':SLANG[''],
		'tpl':{
			'headStyle' : [{
				bgc:'rgb(247,150,70)',
				brc:'rgb(247,150,70)',
				btf:1,					
				btc:'rgb(247,150,70)',	    	
				bbc:'rgb(247,150,70)',    		    	
				fw:'bold',
				color:'white'
			}],	
			'footStyle' : [{
				wrap:true,
				btw:1,
				btt:'double',
				bts:'solid',
				pt:1,
				btc:'rgb(247,150,70)',	    	
				bbc:'rgb(247,150,70)',    		    	
				fw:'bold'			
			}],
			'firstColumn' : {
				blf:1,
				blc:'rgb(247,150,70)'
			},
			'lastColumn' : {			
				brc:'rgb(247,150,70)'
			},
			'bodyStyle' : [
			    [{
			    	bbc:'rgb(247,150,70)'		    	
			    }]
			]	
		}
	}, {
		'id': 'tpl_14',
		'url':SCONFIG.ICONS_PATH+'/64px/tpl_light_14.png',
		'type':'light',
		'tip':SLANG[''],
		'tpl':{
			'headStyle' : [{			
				btf:1,
				blf:1,
				btc:'black',
		    	blc:'black',		    	
		    	brc:'black',
				bbc:'black',												
				pb:1,
				bbw:2,
				color:'black',
				fw:'bold'
			}],	
			'footStyle' : [{
				wrap:true,
				blf:1,		
				btw:1,
				btt:'double',
				bts:'solid',
				pt:1,
				btc:'black',
		    	blc:'black',			    	
		    	bbc:'black',
		    	brc:'black',	    	
		    	color:'black',
				fw:'bold'				
			}],
			'bodyStyle' : [		    
			    [{		    	
			    	blf:1,		
			    	btc:'black',
			    	blc:'black',			    	
			    	bbc:'black',
			    	brc:'black'
			    }],
			    [{
			    	bgc:'rgb(217,217,217)',			    	
			    	blf:1,		
			    	btc:'black',
			    	blc:'black',			    	
			    	bbc:'black',
			    	brc:'black'
			    }]
			]	
		}
	}, {
		'id': 'tpl_15',
		'url':SCONFIG.ICONS_PATH+'/64px/tpl_light_15.png',
		'type':'light',
		'tip':SLANG[''],
		'tpl':{
			'headStyle' : [{			
				btf:1,
				blf:1,
				btc:'rgb(79,129,189)',
		    	blc:'rgb(79,129,189)',		    	
		    	brc:'rgb(79,129,189)',
				bbc:'rgb(79,129,189)',												
				pb:1,
				bbw:2,
				color:'black',
				fw:'bold'
			}],	
			'footStyle' : [{
				wrap:true,
				blf:1,		
				btw:1,
				btt:'double',
				bts:'solid',
				pt:1,
				btc:'rgb(79,129,189)',	
		    	blc:'rgb(79,129,189)',			    	
		    	bbc:'rgb(79,129,189)',
		    	brc:'rgb(79,129,189)',
		    	color:'black',
				fw:'bold'				
			}],
			'bodyStyle' : [		    
			    [{		    	
			    	blf:1,		
			    	btc:'rgb(79,129,189)',
			    	blc:'rgb(79,129,189)',			    	
			    	bbc:'rgb(79,129,189)',
			    	brc:'rgb(79,129,189)'
			    }],
			    [{
			    	bgc:'rgb(220,230,241)',			    	
			    	blf:1,		
			    	btc:'rgb(79,129,189)',
			    	blc:'rgb(79,129,189)',			    	
			    	bbc:'rgb(79,129,189)',
			    	brc:'rgb(79,129,189)'
			    }]
			]	
		}
	}, {
		'id': 'tpl_16',
		'url':SCONFIG.ICONS_PATH+'/64px/tpl_light_16.png',
		'type':'light',
		'tip':SLANG[''],
		'tpl':{
			'headStyle' : [{			
				btf:1,
				blf:1,
				btc:'rgb(192,80,77)',
		    	blc:'rgb(192,80,77)',		    	
		    	brc:'rgb(192,80,77)',
				bbc:'rgb(192,80,77)',												
				pb:1,
				bbw:2,
				color:'black',
				fw:'bold'
			}],	
			'footStyle' : [{
				wrap:true,
				blf:1,		
				btw:1,
				btt:'double',
				bts:'solid',
				pt:1,
				btc:'rgb(192,80,77)',
		    	blc:'rgb(192,80,77)',			    	
		    	bbc:'rgb(192,80,77)',
		    	brc:'rgb(192,80,77)',
		    	color:'black',
				fw:'bold'				
			}],
			'bodyStyle' : [		    
			    [{		    	
			    	blf:1,		
			    	btc:'rgb(192,80,77)',
			    	blc:'rgb(192,80,77)',			    	
			    	bbc:'rgb(192,80,77)',
			    	brc:'rgb(192,80,77)'
			    }],
			    [{
			    	bgc:'rgb(242,220,219)',			    	
			    	blf:1,		
			    	btc:'rgb(192,80,77)',
			    	blc:'rgb(192,80,77)',			    	
			    	bbc:'rgb(192,80,77)',
			    	brc:'rgb(192,80,77)'
			    }]
			]	
		}
	}, {
		'id': 'tpl_17',
		'url':SCONFIG.ICONS_PATH+'/64px/tpl_light_17.png',
		'type':'light',
		'tip':SLANG[''],
		'tpl':{
			'headStyle' : [{			
				btf:1,
				blf:1,
				btc:'rgb(155,187,89)',
		    	blc:'rgb(155,187,89)',		    	
		    	brc:'rgb(155,187,89)',
				bbc:'rgb(155,187,89)',												
				pb:1,
				bbw:2,
				color:'black',
				fw:'bold'
			}],	
			'footStyle' : [{
				wrap:true,
				blf:1,		
				btw:1,
				btt:'double',
				bts:'solid',
				pt:1,
		    	btc:'rgb(155,187,89)',
		    	blc:'rgb(155,187,89)',
		    	bbc:'rgb(155,187,89)',
		    	brc:'rgb(155,187,89)',
		    	color:'black',
				fw:'bold'				
			}],
			'bodyStyle' : [		    
			    [{		    	
			    	blf:1,		
			    	btc:'rgb(155,187,89)',
			    	blc:'rgb(155,187,89)',			    	
			    	bbc:'rgb(155,187,89)',
			    	brc:'rgb(155,187,89)'
			    }],
			    [{
			    	bgc:'rgb(235,241,222)',			    	
			    	blf:1,		
			    	btc:'rgb(155,187,89)',
			    	blc:'rgb(155,187,89)',			    	
			    	bbc:'rgb(155,187,89)',
			    	brc:'rgb(155,187,89)'
			    }]
			]	
		}
	}, {
		'id': 'tpl_18',
		'url':SCONFIG.ICONS_PATH+'/64px/tpl_light_18.png',
		'type':'light',
		'tip':SLANG[''],
		'tpl':{
			'headStyle' : [{			
				btf:1,
				blf:1,
				btc:'rgb(128,100,162)',
		    	blc:'rgb(128,100,162)',		    	
		    	brc:'rgb(128,100,162)',
				bbc:'rgb(128,100,162)',												
				pb:1,
				bbw:2,
				color:'black',
				fw:'bold'
			}],	
			'footStyle' : [{
				wrap:true,
				blf:1,		
				btw:1,
				btt:'double',
				bts:'solid',
				pt:1,
		    	btc:'rgb(128,100,162)',
		    	blc:'rgb(128,100,162)',
		    	bbc:'rgb(128,100,162)',
		    	brc:'rgb(128,100,162)',
		    	color:'black',
				fw:'bold'				
			}],
			'bodyStyle' : [		    
			    [{		    	
			    	blf:1,		
			    	btc:'rgb(128,100,162)',
			    	blc:'rgb(128,100,162)',			    	
			    	bbc:'rgb(128,100,162)',
			    	brc:'rgb(128,100,162)'
			    }],
			    [{
			    	bgc:'rgb(228,223,236)',			    	
			    	blf:1,		
			    	btc:'rgb(128,100,162)',
			    	blc:'rgb(128,100,162)',			    	
			    	bbc:'rgb(128,100,162)',
			    	brc:'rgb(128,100,162)'
			    }]
			]	
		}
	}, {
		'id': 'tpl_19',
		'url':SCONFIG.ICONS_PATH+'/64px/tpl_light_19.png',
		'type':'light',
		'tip':SLANG[''],
		'tpl':{
			'headStyle' : [{			
				btf:1,
				blf:1,
				btc:'rgb(75,172,198)',
		    	blc:'rgb(75,172,198)',		    	
		    	brc:'rgb(75,172,198)',
				bbc:'rgb(75,172,198)',												
				pb:1,
				bbw:2,
				color:'black',
				fw:'bold'
			}],	
			'footStyle' : [{
				wrap:true,
				blf:1,		
				btw:1,
				btt:'double',
				bts:'solid',
				pt:1,
		    	btc:'rgb(75,172,198)',
		    	blc:'rgb(75,172,198)',
		    	bbc:'rgb(75,172,198)',
		    	brc:'rgb(75,172,198)',
		    	color:'black',
				fw:'bold'				
			}],
			'bodyStyle' : [		    
			    [{		    	
			    	blf:1,		
			    	btc:'rgb(75,172,198)',
			    	blc:'rgb(75,172,198)',			    	
			    	bbc:'rgb(75,172,198)',
			    	brc:'rgb(75,172,198)'
			    }],
			    [{
			    	bgc:'rgb(218,238,243)',			    	
			    	blf:1,		
			    	btc:'rgb(75,172,198)',
			    	blc:'rgb(75,172,198)',			    	
			    	bbc:'rgb(75,172,198)',
			    	brc:'rgb(75,172,198)'
			    }]
			]	
		}
	}, {
		'id': 'tpl_20',
		'url':SCONFIG.ICONS_PATH+'/64px/tpl_light_20.png',
		'type':'light',
		'tip':SLANG[''],
		'tpl':{
			'headStyle' : [{			
				btf:1,
				blf:1,
				btc:'rgb(247,150,70)',
		    	blc:'rgb(247,150,70)',		    	
		    	brc:'rgb(247,150,70)',
				bbc:'rgb(247,150,70)',												
				pb:1,
				bbw:2,
				color:'black',
				fw:'bold'
			}],	
			'footStyle' : [{
				wrap:true,
				blf:1,		
				btw:1,
				btt:'double',
				bts:'solid',
				pt:1,
		    	btc:'rgb(247,150,70)',
		    	blc:'rgb(247,150,70)',
		    	bbc:'rgb(247,150,70)',
		    	brc:'rgb(247,150,70)',
		    	color:'black',
				fw:'bold'				
			}],
			'bodyStyle' : [		    
			    [{		    	
			    	blf:1,		
			    	btc:'rgb(247,150,70)',
			    	blc:'rgb(247,150,70)',			    	
			    	bbc:'rgb(247,150,70)',
			    	brc:'rgb(247,150,70)'
			    }],
			    [{
			    	bgc:'rgb(253,233,217)',			    	
			    	blf:1,		
			    	btc:'rgb(247,150,70)',
			    	blc:'rgb(247,150,70)',			    	
			    	bbc:'rgb(247,150,70)',
			    	brc:'rgb(247,150,70)'
			    }]
			]	
		}
	}, {
		'id': 'tpl_21',
		'url':SCONFIG.ICONS_PATH+'/64px/tpl_medium_0.png',
		'type':'medium',
		'tip':SLANG[''],
		'tpl':{
			'headStyle' : [{			
				btf:1,
				btc:'black',	    			    		    
				bbc:'black',												
				pb:1,
				bbw:2,
				color:'white',
				bgc:'black',
				fw:'bold'
			}],	
			'footStyle' : [{
				wrap:true,			
				btw:1,
				btt:'double',
				bts:'solid',
				pt:1,
		    	btc:'black',	    	
		    	bbc:'black',	    	
		    	color:'black',
				fw:'bold'				
			}],
			'bodyStyle' : [
				[{
					bbc:'black'
				}],           
			    [{		    			    
			    	bgc:'rgb(217,217,217)',
			    	bbc:'black'
			    }]		    
			],
			'firstColumn' : {
				blf:1,
				blc:'black'
			},
			'lastColumn' : {			
				brc:'black'
			}
		}
	}, {
		'id': 'tpl_22',
		'url':SCONFIG.ICONS_PATH+'/64px/tpl_medium_1.png',
		'type':'medium',
		'tip':SLANG[''],
		'tpl':{
			'headStyle' : [{			
				btf:1,			
				btc:'rgb(149,179,215)',	    	
				bbc:'rgb(149,179,215)',												
				pb:1,
				bbw:2,
				color:'white',
				bgc:'rgb(79,129,189)',
				fw:'bold'
			}],	
			'footStyle' : [{
				wrap:true,			
				btw:1,
				btt:'double',
				bts:'solid',
				pt:1,
		    	btc:'rgb(149,179,215)',	    	
		    	bbc:'rgb(149,179,215)',	    	
		    	color:'black',
				fw:'bold'				
			}],
			'bodyStyle' : [		    
			    [{
			    	bbc:'rgb(149,179,215)'
			    }],
			    [{		    			    
			    	bgc:'rgb(220,230,241)',
			    	bbc:'rgb(149,179,215)'
			    }]
			],
			'firstColumn' : {
				blf:1,
				blc:'rgb(149,179,215)'
			},
			'lastColumn' : {			
				brc:'rgb(149,179,215)'
			}
		}
	}, {
		'id': 'tpl_23',
		'url':SCONFIG.ICONS_PATH+'/64px/tpl_medium_2.png',
		'type':'medium',
		'tip':SLANG[''],
		'tpl':{
			'headStyle' : [{			
				btf:1,			
				btc:'rgb(218,150,148)',	    	
				bbc:'rgb(218,150,148)',												
				pb:1,
				bbw:2,
				color:'white',
				bgc:'rgb(192,80,77)',
				fw:'bold'
			}],	
			'footStyle' : [{
				wrap:true,			
				btw:1,
				btt:'double',
				bts:'solid',
				pt:1,
		    	btc:'rgb(218,150,148)',	    	
		    	bbc:'rgb(218,150,148)',	    	
		    	color:'black',
				fw:'bold'				
			}],
			'bodyStyle' : [		    
			    [{
			    	bbc:'rgb(218,150,148)'
			    }],
			    [{		    			    
			    	bgc:'rgb(242,220,219)',
			    	bbc:'rgb(218,150,148)'
			    }]
			],
			'firstColumn' : {
				blf:1,
				blc:'rgb(218,150,148)'
			},
			'lastColumn' : {			
				brc:'rgb(218,150,148)'
			}
		}
	}, {
		'id': 'tpl_24',
		'url':SCONFIG.ICONS_PATH+'/64px/tpl_medium_3.png',
		'type':'medium',
		'tip':SLANG[''],
		'tpl':{
			'headStyle' : [{			
				btf:1,			
				btc:'rgb(196,215,155)',	    	
				bbc:'rgb(196,215,155)',												
				pb:1,
				bbw:2,
				color:'white',
				bgc:'rgb(155,187,89)',
				fw:'bold'
			}],	
			'footStyle' : [{
				wrap:true,			
				btw:1,
				btt:'double',
				bts:'solid',
				pt:1,
		    	btc:'rgb(196,215,155)',	    	
		    	bbc:'rgb(196,215,155)',	    	
		    	color:'black',
				fw:'bold'				
			}],
			'bodyStyle' : [		    
			    [{
			    	bbc:'rgb(196,215,155)'
			    }],
			    [{		    			    
			    	bgc:'rgb(235,241,222)',
			    	bbc:'rgb(196,215,155)'
			    }]
			],
			'firstColumn' : {
				blf:1,
				blc:'rgb(196,215,155)'
			},
			'lastColumn' : {			
				brc:'rgb(196,215,155)'
			}
		}
	}, {
		'id': 'tpl_25',
		'url':SCONFIG.ICONS_PATH+'/64px/tpl_medium_4.png',
		'type':'medium',
		'tip':SLANG[''],
		'tpl':{
			'headStyle' : [{			
				btf:1,			
				btc:'rgb(177,160,199)',	    	
				bbc:'rgb(177,160,199)',												
				pb:1,
				bbw:2,
				color:'white',
				bgc:'rgb(128,100,162)',
				fw:'bold'
			}],	
			'footStyle' : [{
				wrap:true,			
				btw:1,
				btt:'double',
				bts:'solid',
				pt:1,
		    	btc:'rgb(177,160,199)',	    	
		    	bbc:'rgb(177,160,199)',	    	
		    	color:'black',
				fw:'bold'				
			}],
			'bodyStyle' : [		    
			    [{
			    	bbc:'rgb(177,160,199)'
			    }],
			    [{		    			    
			    	bgc:'rgb(228,223,236)',
			    	bbc:'rgb(177,160,199)'
			    }]
			],
			'firstColumn' : {
				blf:1,
				blc:'rgb(177,160,199)'
			},
			'lastColumn' : {			
				brc:'rgb(177,160,199)'
			}
		}
	}, {
		'id': 'tpl_26',
		'url':SCONFIG.ICONS_PATH+'/64px/tpl_medium_5.png',
		'type':'medium',
		'tip':SLANG[''],
		'tpl':{
			'headStyle' : [{			
				btf:1,			
				btc:'rgb(146,205,220)',	    	
				bbc:'rgb(146,205,220)',												
				pb:1,
				bbw:2,
				color:'white',
				bgc:'rgb(75,172,198)',
				fw:'bold'
			}],	
			'footStyle' : [{
				wrap:true,			
				btw:1,
				btt:'double',
				bts:'solid',
				pt:1,
		    	btc:'rgb(146,205,220)',	    	
		    	bbc:'rgb(146,205,220)',	    	
		    	color:'black',
				fw:'bold'				
			}],
			'bodyStyle' : [		    
			    [{
			    	bbc:'rgb(146,205,220)'
			    }],
			    [{		    			    
			    	bgc:'rgb(218,238,243)',
			    	bbc:'rgb(146,205,220)'
			    }]
			],
			'firstColumn' : {
				blf:1,
				blc:'rgb(146,205,220)'
			},
			'lastColumn' : {			
				brc:'rgb(146,205,220)'
			}
		}
	}, {
		'id': 'tpl_27',
		'url':SCONFIG.ICONS_PATH+'/64px/tpl_medium_6.png',
		'type':'medium',
		'tip':SLANG[''],
		'tpl':{
			'headStyle' : [{			
				btf:1,			
				btc:'rgb(250,191,143)',	    	
				bbc:'rgb(250,191,143)',												
				pb:1,
				bbw:2,
				color:'white',
				bgc:'rgb(247,150,70)',
				fw:'bold'
			}],	
			'footStyle' : [{
				wrap:true,			
				btw:1,
				btt:'double',
				bts:'solid',
				pt:1,
		    	btc:'rgb(250,191,143)',	    	
		    	bbc:'rgb(250,191,143)',	    	
		    	color:'black',
				fw:'bold'				
			}],
			'bodyStyle' : [		    
			    [{
			    	bbc:'rgb(250,191,143)'
			    }],
			    [{		    			    
			    	bgc:'rgb(253,233,217)',
			    	bbc:'rgb(250,191,143)'
			    }]
			],
			'firstColumn' : {
				blf:1,
				blc:'rgb(250,191,143)'
			},
			'lastColumn' : {			
				brc:'rgb(250,191,143)'
			}
		}
	}, {
		'id': 'tpl_28',
		'url':SCONFIG.ICONS_PATH+'/64px/tpl_medium_7.png',
		'type':'medium',
		'tip':SLANG[''],
		'tpl':{
			'headStyle' : [{
				bgc:'black',
				btf:1,
				blf:1,
				btc:'white',
		    	blc:'white',		    	
		    	brc:'white',
				bbc:'white',												
				pb:1,
				bbw:2,
				color:'white',
				fw:'bold'
			}],	
			'footStyle' : [{
				bgc:'black',
				blf:1,
				btf:2,
		    	btc:'white',
		    	blc:'white',			    	
		    	bbc:'white',
		    	brc:'white',
		    	color:'white',
				fw:'bold'
			}],
			'bodyStyle' : [		    
			    [{
			    	bgc:'rgb(217,217,217)',
			    	blf:1,		
			    	btc:'white',
			    	blc:'white',			    	
			    	bbc:'white',
			    	brc:'white'
			    }],
			    [{
			    	bgc:'rgb(166,166,166)',			    	
			    	blf:1,		
			    	btc:'white',
			    	blc:'white',			    	
			    	bbc:'white',
			    	brc:'white'
			    }]
			]	
		}
	}, {
		'id': 'tpl_29',
		'url':SCONFIG.ICONS_PATH+'/64px/tpl_medium_8.png',
		'type':'medium',
		'tip':SLANG[''],
		'tpl':{
			'headStyle' : [{
				bgc:'rgb(79,129,189)',
				btf:1,
				blf:1,
				btc:'white',
		    	blc:'white',		    	
		    	brc:'white',
				bbc:'white',												
				pb:1,
				bbw:2,
				color:'white',
				fw:'bold'
			}],	
			'footStyle' : [{
				bgc:'rgb(79,129,189)',
				blf:1,
				btf:2,
		    	btc:'white',
		    	blc:'white',			    	
		    	bbc:'white',
		    	brc:'white',
		    	color:'white',
				fw:'bold'
			}],
			'bodyStyle' : [		    
			    [{
			    	bgc:'rgb(220,230,241)',
			    	blf:1,		
			    	btc:'white',
			    	blc:'white',			    	
			    	bbc:'white',
			    	brc:'white'
			    }],
			    [{
			    	bgc:'rgb(184,204,228)',			    	
			    	blf:1,		
			    	btc:'white',
			    	blc:'white',			    	
			    	bbc:'white',
			    	brc:'white'
			    }]
			]	
		}
	}, {
		'id': 'tpl_30',
		'url':SCONFIG.ICONS_PATH+'/64px/tpl_medium_9.png',
		'type':'medium',
		'tip':SLANG[''],
		'tpl':{
			'headStyle' : [{
				bgc:'rgb(192,80,77)',
				btf:1,
				blf:1,
				btc:'white',
		    	blc:'white',		    	
		    	brc:'white',
				bbc:'white',												
				pb:1,
				bbw:2,
				color:'white',
				fw:'bold'
			}],	
			'footStyle' : [{
				bgc:'rgb(192,80,77)',
				blf:1,	
				btf:2,
		    	btc:'white',
		    	blc:'white',			    	
		    	bbc:'white',
		    	brc:'white',
		    	color:'white',
				fw:'bold'
			}],
			'bodyStyle' : [		    
			    [{
			    	bgc:'rgb(242,220,219)',
			    	blf:1,		
			    	btc:'white',
			    	blc:'white',			    	
			    	bbc:'white',
			    	brc:'white'
			    }],
			    [{
			    	bgc:'rgb(230,184,183)',			    	
			    	blf:1,		
			    	btc:'white',
			    	blc:'white',			    	
			    	bbc:'white',
			    	brc:'white'
			    }]
			]	
		}
	}, {
		'id': 'tpl_31',
		'url':SCONFIG.ICONS_PATH+'/64px/tpl_medium_10.png',
		'type':'medium',
		'tip':SLANG[''],
		'tpl':{
			'headStyle' : [{
				bgc:'rgb(155,187,89)',
				btf:1,
				blf:1,
				btc:'white',
		    	blc:'white',		    	
		    	brc:'white',
				bbc:'white',												
				pb:1,
				bbw:2,
				color:'white',
				fw:'bold'
			}],	
			'footStyle' : [{
				bgc:'rgb(155,187,89)',
				blf:1,
				btf:2,
		    	btc:'white',
		    	blc:'white',			    	
		    	bbc:'white',
		    	brc:'white',
		    	color:'white',
				fw:'bold'
			}],
			'bodyStyle' : [		    
			    [{
			    	bgc:'rgb(235,241,222)',
			    	blf:1,		
			    	btc:'white',
			    	blc:'white',			    	
			    	bbc:'white',
			    	brc:'white'
			    }],
			    [{
			    	bgc:'rgb(216,228,188)',			    	
			    	blf:1,		
			    	btc:'white',
			    	blc:'white',			    	
			    	bbc:'white',
			    	brc:'white'
			    }]
			]	
		}
	}, {
		'id': 'tpl_32',
		'url':SCONFIG.ICONS_PATH+'/64px/tpl_medium_11.png',
		'type':'medium',
		'tip':SLANG[''],
		'tpl':{
			'headStyle' : [{
				bgc:'rgb(128,100,162)',
				btf:1,
				blf:1,
				btc:'white',
		    	blc:'white',		    	
		    	brc:'white',
				bbc:'white',												
				pb:1,
				bbw:2,
				color:'white',
				fw:'bold'
			}],	
			'footStyle' : [{
				bgc:'rgb(128,100,162)',
				blf:1,
				btf:2,
		    	btc:'white',
		    	blc:'white',			    	
		    	bbc:'white',
		    	brc:'white',
		    	color:'white',
				fw:'bold'
			}],
			'bodyStyle' : [		    
			    [{
			    	bgc:'rgb(228,223,236)',
			    	blf:1,		
			    	btc:'white',
			    	blc:'white',			    	
			    	bbc:'white',
			    	brc:'white'
			    }],
			    [{
			    	bgc:'rgb(204,192,218)',		    				    
			    	blf:1,		
			    	btc:'white',
			    	blc:'white',			    	
			    	bbc:'white',
			    	brc:'white'
			    }]
			]	
		}
	}, {
		'id': 'tpl_33',
		'url':SCONFIG.ICONS_PATH+'/64px/tpl_medium_12.png',
		'type':'medium',
		'tip':SLANG[''],
		'tpl':{
			'headStyle' : [{
				bgc:'rgb(75,172,198)',
				btf:1,
				blf:1,
				btc:'white',
		    	blc:'white',		    	
		    	brc:'white',
				bbc:'white',												
				pb:1,
				bbw:2,
				color:'white',
				fw:'bold'
			}],	
			'footStyle' : [{
				bgc:'rgb(75,172,198)',
				blf:1,
				btf:2,
		    	btc:'white',
		    	blc:'white',			    	
		    	bbc:'white',
		    	brc:'white',
		    	color:'white',
				fw:'bold'
			}],
			'bodyStyle' : [		    
			    [{
			    	bgc:'rgb(218,238,243)',
			    	blf:1,		
			    	btc:'white',
			    	blc:'white',			    	
			    	bbc:'white',
			    	brc:'white'
			    }],
			    [{
			    	bgc:'rgb(183,222,232)',			    	
			    	blf:1,		
			    	btc:'white',
			    	blc:'white',			    	
			    	bbc:'white',
			    	brc:'white'
			    }]
			]	
		}
	}, {
		'id': 'tpl_34',
		'url':SCONFIG.ICONS_PATH+'/64px/tpl_medium_13.png',
		'type':'medium',
		'tip':SLANG[''],
		'tpl':{
			'headStyle' : [{
				bgc:'rgb(247,150,70)',
				btf:1,
				blf:1,
				btc:'white',
		    	blc:'white',		    	
		    	brc:'white',
				bbc:'white',												
				pb:1,
				bbw:2,
				color:'white',
				fw:'bold'
			}],	
			'footStyle' : [{
				bgc:'rgb(247,150,70)',
				blf:1,
				btf:2,
		    	btc:'white',
		    	blc:'white',			    	
		    	bbc:'white',
		    	brc:'white',
		    	color:'white',
				fw:'bold'
			}],
			'bodyStyle' : [		    
			    [{
			    	bgc:'rgb(253,233,217)',
			    	blf:1,		
			    	btc:'white',
			    	blc:'white',			    	
			    	bbc:'white',
			    	brc:'white'
			    }],
			    [{
			    	bgc:'rgb(252,213,180)',			    	
			    	blf:1,		
			    	btc:'white',
			    	blc:'white',			    	
			    	bbc:'white',
			    	brc:'white'
			    }]
			]	
		}
	}, {
		'id': 'tpl_35',
		'url':SCONFIG.ICONS_PATH+'/64px/tpl_medium_14.png',
		'type':'medium',
		'tip':SLANG[''],
		'tpl':{
			'headStyle' : [{			
				btf:1,
				btc:'black',	    			    		    
				bbc:'black',												
				pb:1,
				bbw:2,
				color:'white',
				bgc:'black',
				fw:'bold'
			}],	
			'footStyle' : [{
				wrap:true,			
				btw:1,
				btt:'double',
				bts:'solid',
				pt:0,
		    	btc:'black',
		    	brc:'black',
		    	bbw:2,
		    	bbc:'black',	    	
		    	color:'black',
				fw:'bold'				
			}],
			'bodyStyle' : [
			    [{		    			    
			    	bgc:'rgb(217,217,217)',
			    	bbc:'black',
			    	brc:'black'
			    }],
			    [{
			    	brc:'black',
			    	bbc:'black'
			    }]
			],
			'firstColumn' : {
				blf:1,
				blc:'black'
			},
			'lastColumn' : {			
				brc:'black'
			}
		}
	}, {
		'id': 'tpl_36',
		'url':SCONFIG.ICONS_PATH+'/64px/tpl_medium_15.png',
		'type':'medium',
		'tip':SLANG[''],
		'tpl':{
			'headStyle' : [{
				bgc:'rgb(79,129,189)',
				btf:2,			
				btc:'black',
				bbw:2,
				pt:1,
				bbc:'black',
				color:'white',
				fw:'bold'
			}],	
			'footStyle' : [{
				wrap:true,			
				btw:1,
				btt:'double',
				bts:'solid',
				pt:0,
		    	btc:'black',	    	
		    	bbw:2,
		    	bbc:'black',	    	
		    	color:'black',
				fw:'bold'				
			}],
			'bodyStyle' : [		    
			    [{}],
			    [{
			    	bgc:'rgb(217,217,217)'		    	
			    }]
			]
		}
	}, {
		'id': 'tpl_37',
		'url':SCONFIG.ICONS_PATH+'/64px/tpl_medium_16.png',
		'type':'medium',
		'tip':SLANG[''],
		'tpl':{
			'headStyle' : [{
				bgc:'rgb(192,80,77)',
				btf:2,			
				btc:'black',
				bbw:2,
				pt:1,
				bbc:'black',
				color:'white',
				fw:'bold'
			}],	
			'footStyle' : [{
				wrap:true,			
				btw:1,
				btt:'double',
				bts:'solid',
				pt:0,
		    	btc:'black',	    	
		    	bbw:2,
		    	bbc:'black',	    	
		    	color:'black',
				fw:'bold'				
			}],
			'bodyStyle' : [		    
			    [{}],
			    [{
			    	bgc:'rgb(217,217,217)'		    	
			    }]
			]
		}
	}, {
		'id': 'tpl_38',
		'url':SCONFIG.ICONS_PATH+'/64px/tpl_medium_17.png',
		'type':'medium',
		'tip':SLANG[''],
		'tpl':{
			'headStyle' : [{
				bgc:'rgb(155,187,89)',
				btf:2,			
				btc:'black',
				bbw:2,
				pt:1,
				bbc:'black',
				color:'white',
				fw:'bold'
			}],	
			'footStyle' : [{
				wrap:true,			
				btw:1,
				btt:'double',
				bts:'solid',
				pt:0,
		    	btc:'black',	    	
		    	bbw:2,
		    	bbc:'black',	    	
		    	color:'black',
				fw:'bold'				
			}],
			'bodyStyle' : [		    
			    [{}],
			    [{
			    	bgc:'rgb(217,217,217)'		    	
			    }]
			]
		}
	}, {
		'id': 'tpl_39',
		'url':SCONFIG.ICONS_PATH+'/64px/tpl_medium_18.png',
		'type':'medium',
		'tip':SLANG[''],
		'tpl':{
			'headStyle' : [{
				bgc:'rgb(128,100,162)',
				btf:2,			
				btc:'black',
				bbw:2,
				pt:1,
				bbc:'black',
				color:'white',
				fw:'bold'
			}],	
			'footStyle' : [{
				wrap:true,			
				btw:1,
				btt:'double',
				bts:'solid',
				pt:0,
		    	btc:'black',	    	
		    	bbw:2,
		    	bbc:'black',	    	
		    	color:'black',
				fw:'bold'				
			}],
			'bodyStyle' : [		    
			    [{}],
			    [{
			    	bgc:'rgb(217,217,217)'		    	
			    }]
			]
		}
	}, {
		'id': 'tpl_40',
		'url':SCONFIG.ICONS_PATH+'/64px/tpl_medium_19.png',
		'type':'medium',
		'tip':SLANG[''],
		'tpl':{
			'headStyle' : [{
				bgc:'rgb(75,172,198)',
				btf:2,			
				btc:'black',
				bbw:2,
				pt:1,
				bbc:'black',
				color:'white',
				fw:'bold'
			}],	
			'footStyle' : [{
				wrap:true,			
				btw:1,
				btt:'double',
				bts:'solid',
				pt:0,
		    	btc:'black',	    	
		    	bbw:2,
		    	bbc:'black',	    	
		    	color:'black',
				fw:'bold'				
			}],
			'bodyStyle' : [		    
			    [{}],
			    [{
			    	bgc:'rgb(217,217,217)'		    	
			    }]
			]
		}
	}, {
		'id': 'tpl_41',
		'url':SCONFIG.ICONS_PATH+'/64px/tpl_medium_20.png',
		'type':'medium',
		'tip':SLANG[''],
		'tpl':{
			'headStyle' : [{
				bgc:'rgb(247,150,70)',
				btf:2,			
				btc:'black',
				bbw:2,
				pt:1,
				bbc:'black',
				color:'white',
				fw:'bold'
			}],	
			'footStyle' : [{
				wrap:true,			
				btw:1,
				btt:'double',
				bts:'solid',
				pt:0,
		    	btc:'black',	    	
		    	bbw:2,
		    	bbc:'black',	    	
		    	color:'black',
				fw:'bold'				
			}],
			'bodyStyle' : [		    
			    [{}],
			    [{
			    	bgc:'rgb(217,217,217)'		    	
			    }]
			]
		}
	}, {
		'id': 'tpl_42',
		'url':SCONFIG.ICONS_PATH+'/64px/tpl_medium_21.png',
		'type':'medium',
		'tip':SLANG[''],
		'tpl':{
			'headStyle' : [{	
				bgc:'rgb(217,217,217)',
				btf:1,
				btc:'black',
				brc:'black',
				bbc:'black',															
				color:'black',			
				fw:'bold'
			}],	
			'footStyle' : [{
				bgc:'rgb(217,217,217)',			
				blf:1,
				btf:2,
		    	btc:'black',
		    	blc:'black',			    	
		    	bbc:'black',
		    	brc:'black',
		    	color:'black',
				fw:'bold'			
			}],
			'bodyStyle' : [
			    [{		    			    
			    	bgc:'rgb(217,217,217)',
			    	bbc:'black',
			    	brc:'black'
			    }],
			    [{
			    	bgc:'rgb(166,166,166)',
			    	brc:'black',
			    	bbc:'black'
			    }]
			],
			'firstColumn' : {
				blf:1,
				blc:'black'
			},
			'lastColumn' : {			
				brc:'black'
			}
		}
	}, {
		'id': 'tpl_43',
		'url':SCONFIG.ICONS_PATH+'/64px/tpl_medium_22.png',
		'type':'medium',
		'tip':SLANG[''],
		'tpl':{
			'headStyle' : [{	
				bgc:'rgb(220,230,241)',
				btf:1,
				btc:'rgb(149,179,215)',
				brc:'rgb(149,179,215)',
				bbc:'rgb(149,179,215)',															
				color:'black',			
				fw:'bold'
			}],	
			'footStyle' : [{
				bgc:'rgb(220,230,241)',			
				blf:1,
				btf:2,
		    	btc:'rgb(149,179,215)',
		    	blc:'rgb(149,179,215)',			    	
		    	bbc:'rgb(149,179,215)',
		    	brc:'rgb(149,179,215)',
		    	color:'black',
				fw:'bold'			
			}],
			'bodyStyle' : [
			    [{		    			    
			    	bgc:'rgb(220,230,241)',
			    	bbc:'rgb(149,179,215)',
			    	brc:'rgb(149,179,215)'
			    }],
			    [{
			    	bgc:'rgb(184,204,228)',
			    	brc:'rgb(149,179,215)',
			    	bbc:'rgb(149,179,215)'
			    }]
			],
			'firstColumn' : {
				blf:1,
				blc:'rgb(149,179,215)'
			},
			'lastColumn' : {			
				brc:'rgb(149,179,215)'
			}
		}
	}, {
		'id': 'tpl_44',
		'url':SCONFIG.ICONS_PATH+'/64px/tpl_medium_23.png',
		'type':'medium',
		'tip':SLANG[''],
		'tpl':{
			'headStyle' : [{	
				bgc:'rgb(242,220,219)',
				btf:1,
				btc:'rgb(218,150,148)',
				brc:'rgb(218,150,148)',
				bbc:'rgb(218,150,148)',															
				color:'black',			
				fw:'bold'
			}],	
			'footStyle' : [{
				bgc:'rgb(242,220,219)',	
				blf:1,
				btf:2,
		    	btc:'rgb(218,150,148)',
		    	blc:'rgb(218,150,148)',			    	
		    	bbc:'rgb(218,150,148)',
		    	brc:'rgb(218,150,148)',
		    	color:'black',
				fw:'bold'			
			}],
			'bodyStyle' : [
			    [{		    			    
			    	bgc:'rgb(242,220,219)',
			    	bbc:'rgb(218,150,148)',
			    	brc:'rgb(218,150,148)'
			    }],
			    [{
			    	bgc:'rgb(230,184,183)',
			    	brc:'rgb(218,150,148)',
			    	bbc:'rgb(218,150,148)'
			    }]
			],
			'firstColumn' : {
				blf:1,
				blc:'rgb(218,150,148)'
			},
			'lastColumn' : {			
				brc:'rgb(218,150,148)'
			}
		}
	}, {
		'id': 'tpl_45',
		'url':SCONFIG.ICONS_PATH+'/64px/tpl_medium_24.png',
		'type':'medium',
		'tip':SLANG[''],
		'tpl':{
			'headStyle' : [{	
				bgc:'rgb(235,241,222)',
				btf:1,
				btc:'rgb(196,215,155)',
				brc:'rgb(196,215,155)',
				bbc:'rgb(196,215,155)',															
				color:'black',			
				fw:'bold'
			}],	
			'footStyle' : [{
				bgc:'rgb(235,241,222)',			
				blf:1,
				btf:2,
		    	btc:'rgb(196,215,155)',
		    	blc:'rgb(196,215,155)',			    	
		    	bbc:'rgb(196,215,155)',
		    	brc:'rgb(196,215,155)',
		    	color:'black',
				fw:'bold'			
			}],
			'bodyStyle' : [
			    [{		    			    
			    	bgc:'rgb(235,241,222)',
			    	bbc:'rgb(196,215,155)',
			    	brc:'rgb(196,215,155)'
			    }],
			    [{
			    	bgc:'rgb(216,228,188)',
			    	brc:'rgb(196,215,155)',
			    	bbc:'rgb(196,215,155)'
			    }]
			],
			'firstColumn' : {
				blf:1,
				blc:'rgb(196,215,155)'
			},
			'lastColumn' : {			
				brc:'rgb(196,215,155)'
			}
		}
	}, {
		'id': 'tpl_46',
		'url':SCONFIG.ICONS_PATH+'/64px/tpl_medium_25.png',
		'type':'medium',
		'tip':SLANG[''],
		'tpl':{
			'headStyle' : [{	
				bgc:'rgb(228,223,236)',
				btf:1,
				btc:'rgb(177,160,199)',
				brc:'rgb(177,160,199)',
				bbc:'rgb(177,160,199)',															
				color:'black',			
				fw:'bold'
			}],	
			'footStyle' : [{
				bgc:'rgb(228,223,236)',			
				blf:1,
				btf:2,
		    	btc:'rgb(177,160,199)',
		    	blc:'rgb(177,160,199)',			    	
		    	bbc:'rgb(177,160,199)',
		    	brc:'rgb(177,160,199)',
		    	color:'black',
				fw:'bold'			
			}],
			'bodyStyle' : [
			    [{		    			    
			    	bgc:'rgb(228,223,236)',
			    	bbc:'rgb(177,160,199)',
			    	brc:'rgb(177,160,199)'
			    }],
			    [{
			    	bgc:'rgb(204,192,218)',
			    	brc:'rgb(177,160,199)',
			    	bbc:'rgb(177,160,199)'
			    }]
			],
			'firstColumn' : {
				blf:1,
				blc:'rgb(177,160,199)'
			},
			'lastColumn' : {			
				brc:'rgb(177,160,199)'
			}
		}
	}, {
		'id': 'tpl_47',
		'url':SCONFIG.ICONS_PATH+'/64px/tpl_medium_26.png',
		'type':'medium',
		'tip':SLANG[''],
		'tpl':{
			'headStyle' : [{	
				bgc:'rgb(218,238,243)',
				btf:1,
				btc:'rgb(149,205,220)',
				brc:'rgb(149,205,220)',
				bbc:'rgb(149,205,220)',															
				color:'black',			
				fw:'bold'
			}],	
			'footStyle' : [{
				bgc:'rgb(218,238,243)',			
				blf:1,
				btf:2,
		    	btc:'rgb(149,205,220)',
		    	blc:'rgb(149,205,220)',			    	
		    	bbc:'rgb(149,205,220)',
		    	brc:'rgb(149,205,220)',
		    	color:'black',
				fw:'bold'			
			}],
			'bodyStyle' : [
			    [{		    			    
			    	bgc:'rgb(218,238,243)',
			    	bbc:'rgb(149,205,220)',
			    	brc:'rgb(149,205,220)'
			    }],
			    [{
			    	bgc:'rgb(183,222,232)',
			    	brc:'rgb(149,205,220)',
			    	bbc:'rgb(149,205,220)'
			    }]
			],
			'firstColumn' : {
				blf:1,
				blc:'rgb(149,205,220)'
			},
			'lastColumn' : {			
				brc:'rgb(149,205,220)'
			}
		}
	}, {
		'id': 'tpl_48',
		'url':SCONFIG.ICONS_PATH+'/64px/tpl_medium_27.png',
		'type':'medium',
		'tip':SLANG[''],
		'tpl':{
			'headStyle' : [{	
				bgc:'rgb(253,233,217)',
				btf:1,
				btc:'rgb(250,191,143)',
				brc:'rgb(250,191,143)',
				bbc:'rgb(250,191,143)',															
				color:'black',			
				fw:'bold'
			}],	
			'footStyle' : [{
				bgc:'rgb(253,233,217)',			
				blf:1,
				btf:2,
		    	btc:'rgb(250,191,143)',
		    	blc:'rgb(250,191,143)',			    	
		    	bbc:'rgb(250,191,143)',
		    	brc:'rgb(250,191,143)',
		    	color:'black',
				fw:'bold'			
			}],
			'bodyStyle' : [
			    [{		    			    
			    	bgc:'rgb(253,233,217)',
			    	bbc:'rgb(250,191,143)',
			    	brc:'rgb(250,191,143)'
			    }],
			    [{
			    	bgc:'rgb(252,213,180)',
			    	brc:'rgb(250,191,143)',
			    	bbc:'rgb(250,191,143)'
			    }]
			],
			'firstColumn' : {
				blf:1,
				blc:'rgb(250,191,143)'
			},
			'lastColumn' : {			
				brc:'rgb(250,191,143)'
			}
		}
	}, {
		'id': 'tpl_49',
		'url':SCONFIG.ICONS_PATH+'/64px/tpl_dark_0.png',
		'type':'dark',
		'tip':SLANG[''],
		'tpl':{
			'headStyle' : [{			
				bgc:'black',																		
				fw:'bold',
				pt:1,
				bbw:2,			
				bbc:'white',
				color:'white'
			}],	
			'footStyle' : [{
				btf:2,
		    	btc:'white',	    				    	
		    	bgc:'black',
		    	color:'white',
				fw:'bold'
			}],
			'bodyStyle' : [		    
			    [{
			    	bgc:'rgb(115,115,115)',
			    	color:'white'
			    }],
			    [{
			    	bgc:'rgb(64,64,64)',
			    	color:'white'
			    }]
			]
		}
	}, {
		'id': 'tpl_50',
		'url':SCONFIG.ICONS_PATH+'/64px/tpl_dark_1.png',
		'type':'dark',
		'tip':SLANG[''],
		'tpl':{
			'headStyle' : [{			
				bgc:'black',																		
				fw:'bold',
				pt:1,
				bbw:2,			
				bbc:'white',
				color:'white'
			}],	
			'footStyle' : [{
				btf:2,
		    	btc:'white',	    				    	
		    	bgc:'rgb(36,64,98)',
		    	color:'white',
				fw:'bold'
			}],
			'bodyStyle' : [		    
			    [{
			    	bgc:'rgb(79,129,189)',
			    	color:'white'
			    }],
			    [{
			    	bgc:'rgb(54,96,146)',
			    	color:'white'
			    }]
			]
		}
	}, {
		'id': 'tpl_51',
		'url':SCONFIG.ICONS_PATH+'/64px/tpl_dark_2.png',
		'type':'dark',
		'tip':SLANG[''],
		'tpl':{
			'headStyle' : [{			
				bgc:'black',																		
				fw:'bold',
				pt:1,
				bbw:2,			
				bbc:'white',
				color:'white'
			}],	
			'footStyle' : [{
				btf:2,
		    	btc:'white',	    				    	
		    	bgc:'rgb(99,37,35)',
		    	color:'white',
				fw:'bold'
			}],
			'bodyStyle' : [		    
			    [{
			    	bgc:'rgb(192,80,77)',
			    	color:'white'
			    }],
			    [{
			    	bgc:'rgb(150,54,52)',
			    	color:'white'
			    }]
			]
		}
	}, {
		'id': 'tpl_52',
		'url':SCONFIG.ICONS_PATH+'/64px/tpl_dark_3.png',
		'type':'dark',
		'tip':SLANG[''],
		'tpl':{
			'headStyle' : [{			
				bgc:'black',																		
				fw:'bold',
				pt:1,
				bbw:2,			
				bbc:'white',
				color:'white'
			}],	
			'footStyle' : [{
				btf:2,
		    	btc:'white',	    				    	
		    	bgc:'rgb(79,98,40)',
		    	color:'white',
				fw:'bold'
			}],
			'bodyStyle' : [		    
			    [{
			    	bgc:'rgb(155,187,89)',
			    	color:'white'
			    }],
			    [{
			    	bgc:'rgb(118,147,60)',
			    	color:'white'
			    }]
			]
		}
	}, {
		'id': 'tpl_53',
		'url':SCONFIG.ICONS_PATH+'/64px/tpl_dark_4.png',
		'type':'dark',
		'tip':SLANG[''],
		'tpl':{
			'headStyle' : [{			
				bgc:'black',																		
				fw:'bold',
				pt:1,
				bbw:2,			
				bbc:'white',
				color:'white'
			}],	
			'footStyle' : [{
				btf:2,
		    	btc:'white',	    				    	
		    	bgc:'rgb(64,49,81)',
		    	color:'white',
				fw:'bold'
			}],
			'bodyStyle' : [		    
			    [{
			    	bgc:'rgb(128,100,162)',
			    	color:'white'
			    }],
			    [{
			    	bgc:'rgb(96,73,122)',
			    	color:'white'
			    }]
			]
		}
	}, {
		'id': 'tpl_54',
		'url':SCONFIG.ICONS_PATH+'/64px/tpl_dark_5.png',
		'type':'dark',
		'tip':SLANG[''],
		'tpl':{
			'headStyle' : [{			
				bgc:'black',																		
				fw:'bold',
				pt:1,
				bbw:2,			
				bbc:'white',
				color:'white'
			}],	
			'footStyle' : [{
				btf:2,
		    	btc:'white',	    				    	
		    	bgc:'rgb(33,89,103)',
		    	color:'white',
				fw:'bold'
			}],
			'bodyStyle' : [		    
			    [{
			    	bgc:'rgb(75,172,198)',
			    	color:'white'
			    }],
			    [{
			    	bgc:'rgb(49,134,155)',
			    	color:'white'
			    }]
			]
		}
	}, {
		'id': 'tpl_55',
		'url':SCONFIG.ICONS_PATH+'/64px/tpl_dark_6.png',
		'type':'dark',
		'tip':SLANG[''],
		'tpl':{
			'headStyle' : [{			
				bgc:'black',																		
				fw:'bold',
				pt:1,
				bbw:2,			
				bbc:'white',
				color:'white'
			}],	
			'footStyle' : [{
				btf:2,
		    	btc:'white',	    				    	
		    	bgc:'rgb(151,71,6)',
		    	color:'white',
				fw:'bold'
			}],
			'bodyStyle' : [		    
			    [{
			    	bgc:'rgb(247,150,70)',
			    	color:'white'
			    }],
			    [{
			    	bgc:'rgb(226,107,10)',
			    	color:'white'
			    }]
			]
		}
	}, {
		'id': 'tpl_56',
		'url':SCONFIG.ICONS_PATH+'/64px/tpl_dark_7.png',
		'type':'dark',
		'tip':SLANG[''],
		'tpl':{
			'headStyle' : [{			
				bgc:'black',																								
				color:'white'
			}],	
			'footStyle' : [{
				bgc:'rgb(217,217,217)',
				wrap:true,			
				btw:1,
				btt:'double',
				bts:'solid',
				pt:1,
		    	btc:'black',	    	
		    	color:'black',
				fw:'bold'	
			}],
			'bodyStyle' : [		    
			    [{
			    	bgc:'rgb(217,217,217)'		    	
			    }],
			    [{
			    	bgc:'rgb(166,166,166)'
			    }]
			]
		}
	}, {
		'id': 'tpl_57',
		'url':SCONFIG.ICONS_PATH+'/64px/tpl_dark_8.png',
		'type':'dark',
		'tip':SLANG[''],
		'tpl':{
			'headStyle' : [{			
				bgc:'rgb(192,80,77)',																								
				color:'white'
			}],	
			'footStyle' : [{
				bgc:'rgb(220,230,241)',
				wrap:true,			
				btw:1,
				btt:'double',
				bts:'solid',
				pt:1,
		    	btc:'black',	    	
		    	color:'black',
				fw:'bold'	
			}],
			'bodyStyle' : [		    
			    [{
			    	bgc:'rgb(220,230,241)'		    	
			    }],
			    [{
			    	bgc:'rgb(184,204,228)'
			    }]
			]
		}
	}, {
		'id': 'tpl_58',
		'url':SCONFIG.ICONS_PATH+'/64px/tpl_dark_9.png',
		'type':'dark',
		'tip':SLANG[''],
		'tpl':{
			'headStyle' : [{			
				bgc:'rgb(128,100,162)',																								
				color:'white'
			}],	
			'footStyle' : [{
				bgc:'rgb(235,241,222)',
				wrap:true,			
				btw:1,
				btt:'double',
				bts:'solid',
				pt:1,
		    	btc:'black',	    	
		    	color:'black',
				fw:'bold'	
			}],
			'bodyStyle' : [		    
			    [{
			    	bgc:'rgb(235,241,222)'		    	
			    }],
			    [{
			    	bgc:'rgb(216,228,188)'
			    }]
			]
		}
	}, {
		'id': 'tpl_59',
		'url':SCONFIG.ICONS_PATH+'/64px/tpl_dark_10.png',
		'type':'dark',
		'tip':SLANG[''],
		'tpl':{
			'headStyle' : [{			
				bgc:'rgb(247,150,70)',																								
				color:'white'
			}],	
			'footStyle' : [{
				bgc:'rgb(218,238,243)',
				wrap:true,			
				btw:1,
				btt:'double',
				bts:'solid',
				pt:1,
		    	btc:'black',	    	
		    	color:'black',
				fw:'bold'	
			}],
			'bodyStyle' : [		    
			    [{
			    	bgc:'rgb(218,238,243)'		    	
			    }],
			    [{
			    	bgc:'rgb(183,222,232)'
			    }]
			]
		}
	}];
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.model.CustomModel', {
	
	/* Begin Definitions */
	
	extend : 'Ext.data.Model',		
	
	/* End Definitions */
	
	fields : ['id', 'text', 'iconCls']
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.model.FileModel', {
    extend: 'Ext.data.Model',
    fields: [
        {name: 'id', type: 'string'},
        {name: 'author', type: 'string'},
        {name: 'exname', type: 'string'},
        {name: 'name', type: 'string'},
        {name: 'title', type: 'string'},
        {name: 'permission', type: 'string'},
        {name: 'updateDate', type: 'string'},
        {name: 'userRole', type: 'string'}
    ]
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.model.CellModel', {
	
	/* Begin Definitions */
	
	extend : 'Ext.data.Model',
           
    requires: ['EnterpriseSheet.common.Common'],
	
	/* End Definitions */
	
	fields : [	      
	    {name : 'sheet', type : 'int'},
	    {name : 'row', type : 'int'},
	    {name : 'col', type : 'int'},
        {name : 'isCal', type : 'int'},
	    {name : 'json', type : 'auto', convert : function(value, rec){
	    	/*
	    	 * decode if the value is a json string
	    	 */
            var o;
	    	if(Ext.isString(value)){
                try{
                    o = Ext.decode(value);
                }catch(e){
                    console.log(e);
                }
            }else{
                o = value;
            }
            if(Ext.isObject(o)){
                delete(o.timestamp);
                delete(o.value);
                delete(o.cdtVal);
                if(Ext.isNumber(o.afrow)){
                    /*
                     * special process for array formula cells
                     */
                    var row = o.afrow+rec.data.row, col = o.afcol+rec.data.col;
                    if(row !== rec.data.row || col !== rec.data.col){
                        o.data = '='+SCOM.number2Letter(col)+row;
                    }
                }
            }else{
                o = {};
            }
            
	    	return o;
	    }}
	]
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.model.CellTplModel', {
	
	/* Begin Definitions */
	
	extend : 'Ext.data.Model',		
	
	/* End Definitions */
	
	fields : [	      
	    {name:'text', type : 'string'},
		{name:'tip', type : 'string'},
		{name:'style', type : 'string'},
		{name:'property', type : 'auto', convert: function(val, rec){
            if(Ext.isString(val) && val){
                val = Ext.decode(val);
            }
            return val;
        }},
		{name:'fn', type : 'auto'}
	]
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.model.ConditionModel', {
	
	/* Begin Definitions */
	
	extend : 'Ext.data.Model',		
	
	/* End Definitions */
	
	fields : [	      
		{name : 'id', type : 'string'},
		{name : 'sheet', type : 'int'},
		{name : 'name', type : 'string'},
		{name : 'opt', type : 'auto', convert: function(val, rec){
            if(Ext.isString(val) && val){
                val = Ext.decode(val);
            }
            return val;
        }},
		{name : 'rng', type : 'auto'},
		{name : 'coord', type : 'auto'}
	]
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.model.InfoModel', {
	
	/* Begin Definitions */
	
	extend : 'Ext.data.Model',		
	
	/* End Definitions */
	
	fields : [	      
	    {name : 'name'},
	    {name : 'display'},
	    {name : 'value'}
	]
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.model.TableTplModel', {
	
	/* Begin Definitions */
	
	extend : 'Ext.data.Model',		
	
	/* End Definitions */
	
	fields : [	      
	    {name:'url', type : 'string'},
		{name:'tip', type : 'string'},
		{name:'tpl', type : 'auto', convert: function(val, rec){
            if(Ext.isString(val) && val){
                val = Ext.decode(val);
            }
            return val;
        }}
	]
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.model.TargetModel', {
	
	/* Begin Definitions */
	
	extend : 'Ext.data.Model',		
	
	/* End Definitions */
	
	fields : [	      
	    {name : 'sheet', type : 'int'},
	    {name : 'sheetName'},
	    {name : 'row', type : 'int'},
	    {name : 'col', type : 'int'},	
	    {name : 'cell'},
	    {name : 'data'}
	]
});
Ext.define('EnterpriseSheet.sheet.data.CustomStore', {
	/* Begin Definitions */
	
	extend : 'Ext.data.Store',
	
	model: 'EnterpriseSheet.sheet.model.CustomModel',
	
	constructor : function(){	
		this.callParent(arguments);	
	},

    proxy: {
        type: 'ajax',
        url: SCONFIG.js_standalone ? '' : SCONFIG.urls['listCustom'],
        reader: {
            type: 'json',
            rootProperty: 'root'
        }
    }
});
Ext.define('EnterpriseSheet.sheet.data.Store', {
	/* Begin Definitions */
	
    extend : 'Ext.util.Observable',
           
	requires : [	    
	    'EnterpriseSheet.sheet.data.reader.CellReader',
	    'EnterpriseSheet.sheet.model.CellModel'
	],
	
	statics : {
		borderStyles : [
		    'blf', 'blt', 'blw', 'bls', 'blc', 
		    'brf', 'brt', 'brw', 'brs', 'brc',
		    'btf', 'btt', 'btw', 'bts', 'btc',
		    'bbf', 'bbt', 'bbw', 'bbs', 'bbc'
		],
		paddingStyles : ['pl', 'pr', 'pt', 'pb', 'wpr', 'wpb', 'woff', 'hoff'],
		colProperties: {'dcfg': true},
		rowProperties: {'dcfg': true},
        inheritProperities: {'comment':true, 'bgc':true, 'color':true, 'ff':true, 'fs':true, 'fz':true, 'fw':true, 'blf':true, 'blt': true, 'blw': true, 'bls':true, 'blc': true, 'brf': true, 'brt': true, 'brw': true, 'brs': true, 'brc': true, 'btf': true, 'btt': true, 'btw': true, 'bts': true, 'btc': true, 'bbf': true, 'bbt': true, 'bbw': true, 'bbs': true, 'bbc': true, 'ta': true, 'va': true, 'pl': true, 'pr': true, 'pt': true, 'pb': true, 'wpr': true, 'wpb': true, 'woff': true, 'hoff': true, 'ws': true, 'ww': true, 'ti': true, 'u': true, 'o': true, 's': true, 'fm': true, 'it': true, 'itn': true}
	},
	
	// to set limt per time ...
	limitCellNumAtSingleLoad : 3000,
           
    loadUrl: SCONFIG.urls['loadActivedSheetOfFile'],
           
    loadMoreUrl: SCONFIG.urls['loadCellOnDemand'],
    
    loadFloatingsUrl : SCONFIG.urls['loadElementOnDemand'],
	/* End Definitions */	
	
	constructor : function(config){
		Ext.apply(this, config);
           
        this.reader = Ext.create('EnterpriseSheet.sheet.data.reader.CellReader', {});
		
		this.separateChar = EnterpriseSheet.sheet.data.reader.CellReader.prototype.separateChar;
		/*
		 * get ID by data
		 */
		var separateChar = this.separateChar;
		
		var getIdBasedData = EnterpriseSheet.sheet.data.reader.CellReader.prototype.getIdBasedData;
		
		this.getIdBasedData = getIdBasedData;	            
		
		this.callParent();	
		
        this.floatings = {};
           
        this.mergeLookup = {};
		
        this.cdtLookup = {};
		
		
		
		/*
		 * init the empty sheets for the store, as default, there is 3 sheets
		 */
		this.initSheets();		
	},
	
	/*
	 * default sheet number as initial if the store is empty
	 */
	defaultSheetNumber : 3,		
	
	/*
	 * the default lefter width
	 */
	defaultLeftWidth : 21,
	
	/*
	 * store the lefter width for different sheet
	 */
	leftWidthSet : {},
	
	splitOffset : 6,
	
	minFontSize : 6,
	
	defaultFontSize : 14,
	
	/*
	 * avoid members from corner
	 */
	avoidMembers : ['config'],
	
	uuid: 1,
	uut: 1,
	
	propertyNameArray: [
	    'bgc', 'ff', 'fz', 'fs', 'fw', 'color', 'ws', 'ww', 'ta', 'va', 'u', 'o', 's', 'pl', 'pr', 'pt', 'pb',
	    'blw', 'bls', 'blc', 'blt', 'blf', 
	    'brw', 'brs', 'brc', 'brt', 'brf', 
	    'btw', 'bts', 'btc', 'btt', 'btf',
	    'bbw', 'bbs', 'bbc', 'bbt', 'bbf',
	    'wpr', 'wpb'],
	
	/*
	 * define the default property, such as padding, border, margin etc
	 * it need be the same with the css define
	 */
	defaultProperty : {
		/*
		 * "cal" field is for calculate, and "arg" field is for the arguments 
		 * used in calculating
		 */  		 
		//cal,
		/*
		 * "arg" is for the parsed formula, for example, =sum(A1:A2) will be transfered sum({\\\"span\\\":[\\\"\\\",-17,-3,-16,-3],\\\"type\\\":2})\"}
		 */
		//arg,
		/*
		 * "cdt" field is for conditional cell, which is also using calcaulte actually		 
		 * notice, we set it to '' in default, so it won't get from column/row setting when do clear action
		 */
		cdt: '',
		/*
		 * "tpl" filed is for table tpl
		 */
		//tpl,
		/*
		 * size
		 */
		width:75,
		height:15,
		/*
		 * font
		 * ff for font-family
		 * fz for font-size
		 * fs for font-style
		 * fw for font-weight
		 * color for color
		 */
		ff:'',
		fz:10,
		fs:'',
		fw:'',
		color:'',	
		/*
		 * background color
		 * need be ''
		 */
		bgc:'',			
		/*
		 * word wrap and white space
		 */
		ws:'nowrap',
		ww:'normal',		
		/*
		 * align
		 * ta for text-align
		 */
		ta:'',
		/*
		 * ti for indent
		 */
		ti:0,
		/*
		 * va for vertical-align
		 */
		va:'',
		/*
		 * u, o and s are for underline, overline and strike
		 */
		u:'',
		o:'',
		s:'',
		/*
		 * padding left right top and bottom
		 */
		pl:2,
		pr:2,
		pt:2,
		pb:2,
		/*
		 * border-width, border-style, border-color
		 * blw means border-left-width, so and other
		 * 
		 */
		blw:0,
		bls:'',
		blc:'',
		blt:'',
		blf:'',
		
		brw:1,
		brs:'',
		/*
		 * need be ''
		 */
		brc:'',
		brt:'',
		brf:'',
		
		btw:0,
		bts:'',
		btc:'',
		btt:'',
		btf:'',
		
		bbw:1,
		bbs:'',
		/*
		 * need be ''
		 */
		bbc:'',
		bbt:'',
		bbf:'',
		/*
		 * wrap padding
		 */
		wpr:5,
		wpb:5,
		
		it: '',
		itn: '',
		fm: ''
	},
	
	borderOffset :1,
	
	cellPaddingOffset : 4,
	/*
	 * to process the cell width offset, for different browsers issue
	 */
	cellWidthOffset : 5,
	
	cellHeightOffset : 5,
	
	defaultCellWidth : 75,
	
	defaultCellHeight : 15,
	
    originDefaultCellWidth : 75,
           
    originDefaultCellHeight : 15,
    
    headerCellHeight : 15,
           
	defaultBackgroundColor : 'white',
	
	defaultBorderColor : 'silver',
    
    getByMapId : function(id) {
    	var data = this.getData();
        var o = data[id];
        if(o){
            return {
                'data': {
                    'sheet': o[0],
                    'row': o[1],
                    'col': o[2],
                    'json': o[3]
                }
            };
        }
    },
    
	/*
	 * set the lefter width, usually it won't load from backend
	 * it changed based on the row index
	 * @param {int} sheet: the sheet id
	 * @param {int} lw: the lefter width for the sheet
	 */
	setLeftWidth : function(sheet, lw){		
		if(false !== SCOM.typeOf(lw)){
			this.leftWidthSet[sheet] = lw;			
		}		
	},
	
	/*
	 * _private
	 * create a new record and add store
	 * @param {int} sheet:the sheet id
	 * @param {int} row:the index of the row
	 * @param {int} col:the index of the column
	 * @param {object} data:the data object of the new cell
	 */
	newRecord : function(sheet, row, col, data){		
        var json = Ext.apply({}, data);
		var o = {
			'sheet':sheet,
			'row':row,
			'col':col,
			'json': json
		};
        var id = this.getIdBasedData(o);
        var r = {'data': o};
        o = [sheet, row, col, json];
        this.getData()[id] = o;
        if(json.cal){
            this.getCalLookup()[id] = o;
        }
        
		return r;
	},
           
    getCalLookup : function(){
        if(!this.calLookup){
            this.calLookup = {};
        }
        return this.calLookup;
    },
           
    setCalLookup : function(lookup){
        this.calLookup = lookup;
    },
           
           
    loadRecords : function(recs, options){
        options = options || {};
        var data, calLookup;
        if(options.addRecords){
            data = this.getData();
            calLookup = this.getCalLookup();
        }else{
            data = {};
            calLookup = {};
        }
        var notOverwrite = options.notOverwrite;
        for(var i = 0, len = recs.length; i < len; i++){
            var rec = recs[i];
            var id = [rec[0], rec[1], rec[2]].join(this.separateChar);
            if(!notOverwrite || !data[id]){
                data[id] = rec;
                if(rec[3].cal){
                    calLookup[id] = rec;
                }
            }
        }
        
        this.setData(data);
        this.setCalLookup(calLookup);
    },
	
	/*
	 * get the width of a col range
	 * @param {int} sheet:the sheet id
	 * @param {int} start: the start col index
	 * @param {int} end: the end col index
	 * @param {boolean} includeHidden: a flag if true then include the hidden col	
	 */	
	getRangeWidthOld : function(sheet, start, end, includeHidden){
		var me = this;
		var dw = me.defaultCellWidth+me.cellWidthOffset;
		
		var w = 0, empty = 0;
		var len = end-start+1, count = me.getCount()/4;
		if(10 < len && len > count){
			/*
			 * if the rec number in store is less than the range length
			 */
			me.each(function(rd){
				var col = rd.data.col;
				if(sheet == rd.data.sheet && 0 === rd.data.row && start <= col && col <= end){
					w += me.getColWidth(sheet, col, !includeHidden);
					empty++;
				}
			});			
			return w+(len-empty)*dw;
		}else{
			for(var i = start; i <= end; i++){			
				if(0 == i || me.isExistedCell(sheet, 0, i)){
					w += me.getColWidth(sheet, i, !includeHidden);
				}else{
					empty++;
				}			
			}
			return w+empty*dw;
		}		
	},
           
    cacheRangeWidth : function(x, startCol, endCol, sheet){
        this.colWRangeLookup = this.colWRangeLookup || {};
        var id = [sheet, startCol, endCol].join(this.separateChar);
        this.colWRangeLookup[id] = x;        
    },
    
    cacheRangeHeight : function(y, startRow, endRow, sheet){                
        var id = [sheet, startRow, endRow].join(this.separateChar);
        this.rowHRangeLookup = this.rowHRangeLookup || {};
        this.rowHRangeLookup[id] = y;
    },
           
    getRangeWidth : function(sheet, start, end, includeHidden){
        var me = this;
		var dw = me.defaultCellWidth+me.cellWidthOffset;
        this.colWRangeLookup = this.colWRangeLookup || {};
        var id = [sheet, start, end].join(this.separateChar);
        if(0 < end && this.colWRangeLookup[id]){
            return this.colWRangeLookup[id];
        }
        var w = 0, empty = 0, lookup = this.getColWidthCache(sheet);        
        var len = end-start+1;
        if(100 < len){
            for(var p in lookup){
                if(lookup.hasOwnProperty(p)){
                    if(start <= p && p <= end){
                        w += lookup[p];
                        empty++;
                    }
                }
            }
			var rs = w+(len-empty)*dw;
            this.colWRangeLookup[id] = rs;
            return rs;
        }else{
            for(var i = start; i <= end; i++){
                if(Ext.isNumber(lookup[i])){
                    w += lookup[i];
                }else{
                    empty++;
                }
            }
			var rs = w+empty*dw;
            this.colWRangeLookup[id] = rs;
            return rs;
        }
    },
	
	getColRenderWidth : function(sheet, col){
		var w;
		if(0 == col){
			if(this.rowNameHidden){
				w = 0;
			}else{
				w = this.leftWidthSet[sheet] || this.defaultLeftWidth;
			}			
		}else{
			var w = this.getCell(sheet, 0, col).width;
			if(!SCOM.canbeNumber(w)){
				w = this.defaultCellWidth;
			}
		}
		return w;
	},
	
	/*
	 * for sub padding and border offset of the render width
	 */
	correctRenderWidth : function(w){
		return w-this.cellWidthOffset;
	},
	
	/*
	 * just in case we need use it in future
	 */
	correctRenderHeight : function(h){
		return h-this.cellHeightOffset;
	},
	
	/*
	 * get the width of a col
	 * @param {int} sheet: the sheet id
	 * @param {int} col: the column index
	 * @param {boolean} skipHidden: a flag, if true then return 0 for a hidden row
	 */
	getColWidth : function(sheet, col, skipHidden){
		/*
		 * for the left width, it's special
		 */
		if(0 == col){
			if(this.rowNameHidden){
				return 0;
			}else{
				var lw = this.leftWidthSet[sheet] || this.defaultLeftWidth;
				return lw+this.cellWidthOffset;
			}			
		}else{
			var cell = this.getCell(sheet, 0, col);
			if(skipHidden && cell.hidden){
				return 0;
			}else{				
				var w = cell.width;					
				if(!SCOM.canbeNumber(w)){
					w = this.defaultCellWidth;
				}		
				w += this.cellWidthOffset;
				if(cell.woff){
					w += cell.woff;
				}
				return w;
			}
		}
	},
    
    getRowHeightCache : function(sheetId){
        this.rowHCache = this.rowHCache || {};
        if(!this.rowHCache[sheetId]){
            var lookup = {};
            this.each(function(rd){
                var row = rd.data.row, json = rd.data.json;
                if(sheetId == rd.data.sheet && 0 === rd.data.col){
                    if(0 !== row){
                        if(json.hidden){
                            lookup[row] = 0;
                        }else{
                            var h = json.height;
                            if(!Ext.isNumber(h)){
                                h = json.autoHeight;
                            }
                            if(Ext.isNumber(h)){
                                h += this.cellHeightOffset;
                                if(json.hoff){
                                    h += json.hoff;
                                }
                                lookup[row] = h;
                            }else{
                                delete(lookup[row]);
                            }
                        }
                    }
                }
            }, this);
            this.rowHCache[sheetId] = lookup;
        }
        this.rowHCache[sheetId][0] = this.headerCellHeight+this.cellHeightOffset;
        return this.rowHCache[sheetId];
    },
           
    resetRowHeightColWidthCache : function(sheetId){
        this.rowHRangeLookup = {};
        this.colWRangeLookup = {};
        this.colWCache = this.colWCache || {};
        this.rowHCache = this.rowHCache || {};
        delete(this.colWCache[sheetId]);
        delete(this.rowHCache[sheetId]);
        this.getRowHeightCache(sheetId);
        this.getColWidthCache(sheetId);
    },
           
    resetRowHeightCache : function(sheetId){
        this.rowHRangeLookup = {};
        this.rowHCache = this.rowHCache || {};
        delete(this.rowHCache[sheetId]);
        this.getRowHeightCache(sheetId);
    },
           
    resetColWidthCache : function(sheetId){
        this.colWRangeLookup = {};
        this.colWCache = this.colWCache || {};
        delete(this.colWCache[sheetId]);
        this.getColWidthCache(sheetId);
    },
           
    syncRowHeightCache : function(sheetId, row){
        this.rowHRangeLookup = {};
        this.rowHCache = this.rowHCache || {};
        var lookup = this.rowHCache[sheetId] || {};
        var json = this.getCell(sheetId, row, 0);
        if(json.hidden){
            lookup[row] = 0;
        }else{
            var h = json.height;
            if(!Ext.isNumber(h)){
                h = json.autoHeight;
            }
            if(Ext.isNumber(h)){
                h += this.cellHeightOffset;
                if(json.hoff){
                    h += json.hoff;
                }
                lookup[row] = h;
            }else{
                delete(lookup[row]);
            }
        }
        this.rowHCache[sheetId] = lookup;
    },
           
    syncColWidthCache : function(sheetId, col){
        this.colWRangeLookup = {};
        this.colWCache = this.colWCache || {};
        var lookup = this.colWCache[sheetId] || {};
        var json = this.getCell(sheetId, 0, col);
        if(json.hidden){
            lookup[col] = 0;
        }else{
            var w = json.width;
            if(Ext.isNumber(w)){
                w += this.cellWidthOffset;
                if(json.woff){
                    w += json.woff;
                }
                lookup[col] = w;
            }else{
                delete(lookup[col]);
            }
        }
        this.colWCache[sheetId] = lookup;
    },
           
    getColWidthCache : function(sheetId){
        this.colWCache = this.colWCache || {};
        if(!this.colWCache[sheetId]){
            var lookup = {};
            this.each(function(rd){
                var col = rd.data.col, json = rd.data.json;
                if(sheetId == rd.data.sheet && 0 === rd.data.row){
                    if(0 !== col){
                        if(json.hidden){
                            lookup[col] = 0;
                        }else{
                            var w = json.width;
                            if(Ext.isNumber(w)){
                                w += this.cellWidthOffset;
                                if(json.woff){
                                    w += json.woff;
                                }
                                lookup[col] = w;
                            }else{
                                delete(lookup[col]);
                            }
                        }
                    }
                }
            }, this);
            this.colWCache[sheetId] = lookup;
        }
        var lw = this.leftWidthSet[sheetId] || this.defaultLeftWidth;
        this.colWCache[sheetId][0] = lw+this.cellWidthOffset;
        return this.colWCache[sheetId];
    },
	
	/*
	 * get the height of a row range
	 * @param {int} sheet: the sheet id
	 * @param {int} start: the start row index
	 * @param {int} end: the end row index
	 * @param {boolean} includeHidden: a flag if true then include the hidden row
	 */
	getRangeHeightOld : function(sheet, start, end, includeHidden){
		var me = this;
		var dh = me.defaultCellHeight+me.cellHeightOffset;

		var h = 0, empty = 0;
		var count = me.getCount()/4;
		var len = end-start+1;
		if(10 < len && len > count){
			/*
			 * if the rec number in store is less than the range length
			 */
			me.each(function(rd){
				var row = rd.data.row;
				if(sheet == rd.data.sheet && 0 === rd.data.col && start <= row && row <= end){
					h += me.getRowHeight(sheet, row, !includeHidden);
					empty++;
				}
			});			
			return h+(len-empty)*dh;
		}else{
			for(var i = start; i <= end; i++){
				if(0 == i || me.isExistedCell(sheet, i, 0)){
					h += me.getRowHeight(sheet, i, !includeHidden);
				}else{
					empty++;
				}			
			}
			return h+empty*dh;
		}		
	},
           
    getRangeHeight : function(sheet, start, end, includeHidden){
        var me = this;
        var dh = me.defaultCellHeight+me.cellHeightOffset;
        this.rowHRangeLookup = this.rowHRangeLookup || {};
        var id = [sheet, start, end].join(this.separateChar);
        if(this.rowHRangeLookup[id]){
            return this.rowHRangeLookup[id];
        }
        var h = 0, empty = 0, lookup = this.getRowHeightCache(sheet);
        var len = end-start+1;
        if(100 < len){
            for(var p in lookup){
                if(lookup.hasOwnProperty(p)){
                    if(start <= p && p <= end){
                        h += lookup[p];
                        empty++;
                    }
                }
            }
            var rs = h+(len-empty)*dh;
            this.rowHRangeLookup[id] = rs;
            return rs;
        }else{
            for(var i = start; i <= end; i++){
                if(Ext.isNumber(lookup[i])){
                    h += lookup[i];
                }else{
                    empty++;
                }
            }
            var rs = h+empty*dh;
            this.rowHRangeLookup[id] = rs;
            return rs;
        }
    },
	
	getRowRenderHeight : function(sheet, row){				
		var h;
		if(0 == row){
			h = this.colNameHidden ? 0 : this.headerCellHeight;
		}else{
			h = this.getCell(sheet, row, 0).height;
			if(!SCOM.canbeNumber(h)){
				h = this.defaultCellHeight;
			}
		}
		return h;
	},
	
	/**
	 * get the height of a row
	 * @param {int} sheet: the sheet id
	 * @param {int} row: the row index
	 * @param {boolean} skipHidden: a flag, if true then return 0 for a hidden row
	 */
	getRowHeight : function(sheet, row, skipHidden){
		if(0 == row){
			/*
			 * treat the header specially, the height will always be the default
			 */
			return this.colNameHidden ? 0 : this.headerCellHeight+this.cellHeightOffset;
		}else{
			var cell = this.getCell(sheet, row, 0);
			if(skipHidden && cell.hidden){
				return 0;
			}else{
				var h = cell.height;
				if(!SCOM.canbeNumber(h)){
					h = cell.autoHeight || this.defaultCellHeight;
				}
				h += this.cellHeightOffset;
				if(cell.hoff){
					h += cell.hoff;
				}
				return h;
			}
		}
	},
	
	/*
	 * return true if a cell is existed
	 * @param {int} sheet: sheet id
	 * @param {int} row: row index
	 * @param {int} col: col index
	 * @return {boolean}: return true if this cell is existed
	 */
	isExistedCell : function(sheet, row, col){		
		var id = this.getIdBasedData({sheet:sheet, row:row, col:col});
		var c = this.getByMapId(id);
		return c;
	},
	
	/*
	 * return cell json object directly or a copy
	 * @param {int} sheet: sheet id
	 * @param {int} row: row index
	 * @param {int} col: col index
	 * @param {boolean} returnCopy: return the json object directly or return a copy
	 */
	getCell : function(sheet, row, col, returnCopy, id){		
		var id = id || this.getIdBasedData({sheet:sheet, row:row, col:col});
		var c = this.getByMapId(id);
		var json = {};
		if(c){
			if(returnCopy){
				json = Ext.apply({}, c.data['json']);
			}else{
				json = c.data['json'];
			}
		}
         
		return json;
	},
	
	/*
	 * private
	 * get the property of a cell, the property could from the cell setting or row/column/whole setting
	 * @param {int} sheet: the sheet id
	 * @param {int} row: the row index for a cell
	 * @param {int} col: the col index for a cell
	 * @param {boolean} discareMerge: a flag, if true then don't care the merged cell, just treat it as a normal cell
	 * @param {boolean} discareSelf: a flag, if true then don't apply self's property
	 * @param {object}: the property of this cell
	 */
	getCellProperty : function(sheet, row, col, discareMerge, discareSelf){
		var o = this.getCell(sheet, row, col);	
		if(!discareMerge && this.isMergedCell(o, sheet, row, col)){
			var minrow = row+o.minrow;
			var mincol = col+o.mincol;				
			if(!discareSelf){		
				o = this.getCell(sheet, minrow, mincol, true);
			}else{
				o = {};
			}
			o['data'] = o['data'] || '';
			/*
			 * get lefter
			 */			
			var l = this.getCell(sheet, minrow, 0);
			var h = this.getCell(sheet, 0, mincol);
			var c = this.getCell(sheet, 0, 0);
			//Ext.applyIf(o, l);
			/*
			 * get the header
			 */			

			//Ext.applyIf(o, h);
			/*
			 * get the corner
			 */

			//Ext.applyIf(o, c);
            this.applyProperty(o, l, h, c);
			SCOM.deleteMembers(o, this.avoidMembers);
		}else{
			if(!discareSelf){
				o = Ext.apply({}, o);
			}else{
				o = {};
			}
			o['data'] = o['data'] || '';
			/*
			 * get lefter
			 */			
			var l = this.getCell(sheet, row, 0);
            var h = this.getCell(sheet, 0, col);
			var c = this.getCell(sheet, 0, 0);
			delete(o.width);
			//Ext.applyIf(o, l);
			/*
			 * get the header
			 */

			//Ext.applyIf(o, h);
			/*
			 * get the corner
			 */
			//Ext.applyIf(o, c);
            this.applyProperty(o, l, h, c);
			SCOM.deleteMembers(o, this.avoidMembers);
		}
		
		return o;
	},
	
	/*
	 * _private, process the border for a cell, cause the border will affected by the neighbour of this cell
	 */
	processBorder : function(sheet, row, col, o){
		/*
		 * clean empty property first
		 */
		this.avoidEmptyProperty(o);
		this.fireEvent('beforeprocessborder', sheet, row, col, o, this);
		/*
		 * border and fill color issue, need get right/bottom cell bgc if this cell own's is empty
		 */				
		var property = this.getCellProperty(sheet, row, col+1, true);
		this.fireEvent('beforeprocessborder', sheet, row, col+1, property, this);
		
		if(property.wrap && property.blt){
			/*
			 * if right neighbour has 3 width left border, then this cell need have related right border 
			 */
			Ext.apply(o, this.getBorderConfig('r', 3, property.blt, property.blc, true));
		}else if(property.blf){
			/*
			 * if right neighbour has 1 or 2 width left border, then this cell need have related right border 
			 * notice the last param need to be true, to set the border not reset
			 */
			Ext.apply(o, this.getBorderConfig('r', property.blf, property.bls, property.blc, true));
		}
		/*
		 * border and fill color issue, need get right/bottom cell bgc if this cell own's is empty
		 */	
		o.brc = o.brc || o.cbgc || o.bgc || property.cbgc || property.bgc;
		//o.brc = o.brc || o.bgc || property.bgc;
		property = this.getCellProperty(sheet, row+1, col, true);
		this.fireEvent('beforeprocessborder', sheet, row+1, col, property, this);
		if(property.wrap && property.btt){
			/*
			 * if bottom neighbour has 3 width top border, then this cell need have related bottom border 
			 */
			Ext.apply(o, this.getBorderConfig('b', 3, property.btt, property.btc, true));
		}else if(property.btf){
			/*
			 * if bottom neighbour has 1 or 2 width top border, then this cell need have related bottom border 
			 * notice the last param need to be true, to set the border not reset
			 */
			Ext.apply(o, this.getBorderConfig('b', property.btf, property.bts, property.btc, true));
		}
		/*
		 * border and fill color issue, need get right/bottom cell bgc if this cell own's is empty
		 */	
		o.bbc = o.bbc || o.cbgc || o.bgc || property.cbgc || property.bgc;							
		//o.bbc = o.bbc || o.bgc || property.bgc;
		if(1 < col){
			property = this.getCellProperty(sheet, row, col-1, true);
			this.fireEvent('beforeprocessborder', sheet, row, col-1, property, this);
			if(property.wrap && property.brt){				
				Ext.apply(o, this.getBorderConfig('l', 3, property.brt, property.brc, true));
			}
		}	
		if(1 < row){
			property = this.getCellProperty(sheet, row-1, col, true);
			this.fireEvent('beforeprocessborder', sheet, row-1, col, property, this);
			if(property.wrap && property.bbt){
				Ext.apply(o, this.getBorderConfig('t', 3, property.bbt, property.bbc, true));
			}
		}	
		return o;
	},
	
	/*
	 * _private 
	 * clean the empty property
	 */
	avoidEmptyProperty : function(json){
		for(var p in json){
			if(json.hasOwnProperty(p)){
				var v = json[p];
				if('' === v || null === v){
					delete(json[p]);
				}
			}
		}
	},
           
    lgUUStamp : function(a, b){
        return a[0] > b[0] || (a[0] === b[0] && a[1] > b[1]);
    },
           
    applyProperty : function(){
        var target = arguments[0], lookup = {};
        for(var i = 1, len = arguments.length; i < len; i++){
            var source = arguments[i];
            for(var p in source){
                if(source.hasOwnProperty(p)){
                	if('_' !== p.charAt(0)){
                		var q = '_'+p;
                        if(source.hasOwnProperty(q)){
                            if(!target.hasOwnProperty(q) || this.lgUUStamp(source[q], target[q])){
                                target[p] = source[p];
                                target[q] = source[q];
                            }
                        }else if(!target.hasOwnProperty(q) && !target.hasOwnProperty(p)){
                            target[p] = source[p];
                        }
                	}else{
                		var q = p.slice(1);
                		if(!target.hasOwnProperty(p) || this.lgUUStamp(source[p], target[p])){
                            target[p] = source[p];
                            delete(target[q]);
                        }
                	}                    
                }
            }
        }
    },
		
	/**
	 * this function is for packing the data for render purpose,
	 * it get the orgin data from cache and process it for combined cell, formula and so on
	 * @param {int} sheet: the sheet id
	 * @param {int} row: the row index
	 * @param {int} col: the column index
	 * @param {boolean} cleanData: true then remove the html tags in data
	 * @param {boolean} withoutDefault: true then not apply the default property
	 * @return {object}: the setting/data of the cell
	 */
	getCellData : function(sheet, row, col, cleanData, withoutDefault){	
		
		/*
		 * body is a flag for the cells not in header/lefter
		 */
		var o, body = true, merged = false, defaultProperty = this.defaultProperty, defaultHeight = defaultProperty.height, defaultWidth = defaultProperty.width;
		/*
		 * the default property for header and lefter
		 */
		var lhDefault = {
			incell:false,
			va:'top'
		};
		/*
		 * below is for getting style/setting from row/col/corner(corner is cell[0, 0], which is for the whole sheet style)
		 */						
		if(0 == col){
			body = false;					
			/*
			 * get the corner
			 */
			if(0 != row){				
				o = Ext.apply({			
					/*
					 * get the lefter width from the cache
					 */
					width:this.leftWidthSet[sheet] || this.defaultLeftWidth				
				}, lhDefault);
				/*
				 * get lefter
				 */
				var l = this.getCell(sheet, row, 0); 
				Ext.applyIf(o, l);
				/*
				 * for header the wrap always be false
				 */
				if(o.wrap){
					o.wrap = false;					
				}				
				if(!SCOM.canbeNumber(o.height)){
					o.height = o.autoHeight || defaultHeight;
				}				
				var hoff = o.hoff || 0;
				o.height += 4+hoff;				
				
				o.data = o.data || this.getRowName(row);
				
				/*
				 * process row group
				 */
				this.processRowGroup(o, sheet, row, col);
				
				if(this.getCell(sheet, row-1, col).hidden){
					o.css = 'ss-hdrow';
				}
			}else{
				/*
				 * return the copy of corner
				 */
				o = this.getCell(sheet, 0, 0, true);
                o.height = this.headerCellHeight;
				var hoff = o.hoff || 0;
				o.height += 4+hoff;	
			}					
		}else if(0 != row){			
			o = this.getCell(sheet, row, col);	
			var l = this.getCell(sheet, row, 0);
			var height = l.height, hoff = l.hoff;
			if(!SCOM.canbeNumber(height)){
				height = l.autoHeight || defaultHeight;
			}			
			merged = this.isMergedCell(o, sheet, row, col);

			if(merged){				
				/*
				 * process combined cell if need
				 */
				o = this.processMergedCell(sheet, row, col, o, withoutDefault); 
			}else{
                var w = this.getCell(sheet, 0, 0);
				/*
				 * here we make a copy of the original data, cause we don't want to pollute the original one
				 */
				o = Ext.apply({
                    incell:false,
                    data: ''
                }, o);
                delete(o.width);
                delete(o.woff);
                /*
                 * get the header
                 */
                var h = this.getCell(sheet, 0, col);
				/*
				 * get lefter
				 */
				//Ext.applyIf(o, l);

				//Ext.applyIf(o, h);
				/*
				 * get the corner
				 */				
				//Ext.applyIf(o, w);
                this.applyProperty(o, l, h, w);
				
				/*
				 * process border issue
				 */
				o = this.processBorder(sheet, row, col, o);
				
				/*
				 * process for the vertical align
				 */		
				if(!this.isVerticalAlign(o.va)){					
					o.va = 'top';
				}				
			}	
			o = SCOM.deleteMembers(o, this.avoidMembers);
			o.height = height;	
			o.hoff = hoff;
			
		}else{	
			body = false;
			/*
			 * get the header
			 */
			o = this.getCell(sheet, 0, col, true);
			Ext.apply(o, lhDefault);
			/*
			 * for header the wrap always be false
			 */
			if(o.wrap){
				o.wrap = false;				
			}
			/*
			 * get the corner
			 */			
			if(!SCOM.canbeNumber(o.width)){
				o.width = defaultWidth;
			}			
			
			var woff = o.woff || 0;
			o.width += 4+woff;
            o.height = this.headerCellHeight;
        
			o.data = o.data || this.getColName(col);
			/*
			 * process column group
			 */
			this.processColumnGroup(o, sheet, row, col);
			
			if(this.getCell(sheet, row, col-1).hidden){
				o.css = 'ss-hdcol';
			}			
		}
		o.wrap = o.wrap || false;					
		o.body = body;
		/*
		 * apply the default property if missing
		 */
		if(!withoutDefault){
			Ext.applyIf(o, this.defaultProperty);
		}		
		
		o = this.processOffset(o);
		
		if(cleanData){
			/*
			 * remove html tags in data
			 */
			o.data = SCOM.removeHTMLTag(o.data);
		}
        /*
         * temporay process for hyperlink formula, which will cause the link and fm change
         */
        for(var p in EnterpriseSheet.sheet.calculate.Calculate.calGeneratedStyleMap){
            if(EnterpriseSheet.sheet.calculate.Calculate.calGeneratedStyleMap.hasOwnProperty(p)){
                var q = EnterpriseSheet.sheet.calculate.Calculate.calGeneratedStyleMap[p];
                if(Ext.isDefined(o[p])){
                    o[q] = o[p];
                }
            }
        }
		
		return o;
	},
	
	/*
	 * process row group
	 */
	processRowGroup : function(o, sheet, row, col){
		this.fireEvent('processrowgroup', o, sheet, row, col, this);
	},
	
	/*
	 * process column group
	 */
	processColumnGroup : function(o, sheet, row, col){		
		this.fireEvent('processcolumngroup', o, sheet, row, col, this);
	},
	
	/*
	 * private
	 * this function is for process the column width or row height less than 5px, cause 5px is the padding and border offset, so if the width
	 * is less than 5px, then woff/hoff should be a nagetive number which means we need subtract from the padding of border width
	 */
	processOffset : function(o){
		var dp = this.defaultProperty;
		if(o.woff){
			var off = o.woff;
			if(o.wrap){
				o.wpr += off;
			}
			o.pr += off;
			if(0 > o.pr){
				off = o.pr;
				o.pr = 0;
			}else{
				off = 0;
			}
			if(0 > off){
				o.pl += off;
				if(0 > o.pl){
					off = o.pl;
					o.pl = 0;
				}else{
					off = 0;
				}
				if(0 > off){
					off += o.blw;
					o.blw = 0;
					if(0 > off){
						o.brw += off;						
					}
				}				
			}
		}
		if(o.hoff){
			var off = o.hoff;
			o.wpb += off;
			o.pb += off;
			if(0 > o.pb){
				off = o.pb;
				o.pb = 0;
			}else{
				off = 0;
			}
			if(0 > off){
				o.pt += off;
				if(0 > o.pt){
					off = o.pt;
					o.pt = 0;
				}else{
					off = 0;
				}
				if(0 > off){
					off += o.btw;
					o.btw = 0;
					if(0 > off){
						o.bbw += off;						
					}
				}				
			}
		}
		return o;
	},
	
	isVerticalAlign : function(va){
		return 'middle' == va || 'bottom' == va;
	},
	
	/*
	 * @param {object} cell: the cell data object
	 * @param {int} sheet: the sheet id
	 * @param {int} row: the row index of a cell
	 * @param {int} col: the column index of a cell
	 * @return {boolean}:true means it's a merged cell, or false
	 * return true if this is a merged cell
	 */
	isMergedCell : function(cell, sheet, row, col){
		if(!cell){
			cell = this.getCell(sheet, row, col);
		}
		
		if(false != SCOM.typeOf(cell.minrow)){
			return true;		
		}
		return false;
	},
		
	/*
	 * private
	 * add some more property if this cell is a merged cell
	 * @param {int} sheet: the sheet id
	 * @param {int} row: the row index of a cell
	 * @param {int} col: the column index of a cell
	 * @param {object} o: the cell data object
	 * @param {boolean} withoutDefault: true then not apply the default property
	 */
	processMergedCell : function(sheet, row, col, o, withoutDefault){	
		/*
		 * keep the minrow/mincol/maxrow/maxcol
		 */
		var incell = {
			minrow:o.minrow,
			mincol:o.mincol,
			maxrow:o.maxrow,
			maxcol:o.maxcol			
		};				
		var minrow = row+o.minrow;
		var mincol = col+o.mincol;
		var maxrow = row+o.maxrow;
		var maxcol = col+o.maxcol;		
		/*
		 * find the visible max col and visible max row
		 */
		for(var i = maxcol; i >= mincol; i--){
			if(!this.isVisibleColumn(sheet, i)){
				maxcol--;
			}else{
				break;
			}
		}
		for(var i = maxrow; i >= minrow; i--){
			if(!this.isVisibleRow(sheet, i)){
				maxrow--;
			}else{
				break;
			}
		}
		
		o = this.getCell(sheet, minrow, mincol, true);	
		/*
		 * resume the minrow/mincol/maxrow/maxcol
		 */	
		Ext.apply(o, incell);
		/*
		 * get lefter
		 */
		var l = this.getCell(sheet, minrow, 0);
		//Ext.applyIf(o, l);
		
		/*
		 * get the header
		 */			
		var h = this.getCell(sheet, 0, mincol);
		delete(o.width);
		delete(o.woff);
		//Ext.applyIf(o, h);
		/*
		 * get the corner
		 */
		var c = this.getCell(sheet, 0, 0);
		//Ext.applyIf(o, c);
		this.applyProperty(o, l, h, c);
		

		if(mincol != col){
			/*
			 * if it's a merged cell, we get all setting from the left-top cell of the merged cell,
			 * and only need get the width of current column
			 * get the header
			 */
			 h = this.getCell(sheet, 0, col);
			 o.width = h.width;
		}
		/*
		 * we need sub the padding and border offset,
		 * the padding and border offset we defined in store config need be as the same as the related css
		 */
		o.w = this.getRangeWidth(sheet, mincol, maxcol)-this.cellPaddingOffset-this.borderOffset;
		if(o.w < 0){
			o.w = 0;
		}
		o.h = this.getRangeHeight(sheet, minrow, maxrow)-this.cellPaddingOffset-this.borderOffset;
		if(o.h < 0){
			o.h = 0;
		}
		o.l = -this.getRangeWidth(sheet, mincol, col-1);
		o.t = -this.getRangeHeight(sheet, minrow, row-1);	
		/*
		 * here need handle the border issue, cause the border is a little different with other property, it's standalone,
		 * the merged cells should not use the border setting of left-top cell instead of its own,
		 * but for other property, such as font-size, fill color, it will use the left-top cell's properrty.
		 */
		if(minrow == row && mincol == col){			
			if(!withoutDefault){
				Ext.applyIf(o, this.defaultProperty);
			}			
		}		
		if(col == mincol || col == maxcol || row == minrow || row == maxrow){
			/*
			 * if not left-top cell, then need get own border property
			 */
			var c = this.getCellProperty(sheet, row, col, true);			
			/*
			 * set border to default value if it's undefined
			 */
			if(!withoutDefault){
				Ext.applyIf(c, this.defaultProperty);
			}				
			var tmp = ['brc', 'brw', 'brs', 
		               'blc', 'blw', 'bls', 
		               'bbc', 'bbw', 'bbs', 
		               'btc', 'btw', 'bts', 
		               'wrap', 'pl', 'pr', 
		               'pt', 'pb', 'hoff', 
		               'woff', 'wpr', 'wpb'];
			for(var i = 0, len = tmp.length; i < len; i++){
				var p = tmp[i];
				delete(o[p]);
				o[p] = c[p];
			}
			/*
			 * process border issue
			 */
			o = this.processBorder(sheet, row, col, o);
		}
		/*
		 * need change the border and margin to make it look as combined cell
		 */
		if(row != maxrow){			
			o.pb = this.defaultProperty.pb+1;
			o.bbw = 0;			
		}			
		if(col != maxcol){			
			o.pr = this.defaultProperty.pr+1;
			o.brw = 0;			
		}
		if(col != mincol){
			o.pl += o.blw;
			o.blw = 0;			
		}
		if(row != minrow){
			o.pt += o.btw;			
			o.btw = 0;
		}
						
		/*
		 * incell is a flag for combined cell, which is used in the templates
		 * if 1 means there is a merged cell
		 */	
		o.incell = true;								
		
		/*
		 * process for the vertical align
		 */		
		if(!this.isVerticalAlign(o.va)){			
			o.va = 'top';
		}
		
		return o;
	},
	
	/*
	 * to transfer the decial number to A-Z
	 */
	getColName : function(col){
		return SCOM.number2Letter(col);
	},
	
	getRowName : function(row){
		return row;
	},		
	
	
	withStyleProperty : function(json){
		if(json){
			for(var i = 0, len = this.propertyNameArray.length; i < len; i++){
				var p = this.propertyNameArray[i];
				if(json.hasOwnProperty(p)){
					return true;
				}
			}
		}
	},
	
	/*
	 * change the data of a cell, it will cause the related record change and cache update
	 * and fire a "cellchange" event, which will catch by region to update the cell element
	 * @param {int} sheet: the sheet id
	 * @param {int} row: the row index
	 * @param {int} col: the column index
	 * @param {object} modified: the object hold all property need be modified for this cell
	 * @param {array} deleted: the array hold all property need be deleted from this cell
	 * @param {boolean} suspendEvent: the flag to hold or fire "cellchange" event
	 * @param {string} applyWay: could be ['apply', 'applyIf', 'clear'], default to 'apply'
	 */
	setCell : function(sheet, row, col, modified, deleted, suspendEvent, applyWay){
        var ips = EnterpriseSheet.sheet.data.Store.inheritProperities;
        modified = modified || {};
        for(var p in modified){
            if(modified.hasOwnProperty(p) && '_' !== p.charAt(0) && ips.hasOwnProperty(p)){
                var q = '_'+p;
                if(!modified[q]){
                    modified[q] = this.getUUStamp();
                }
            }
        }
        if(deleted){
            for(var i = 0, len = deleted.length; i < len; i++){
                var p = deleted[i];
                if('_' !== p.charAt(0) && ips.hasOwnProperty(p)){
                    var q = '_'+p;
                    if(!modified[q]){
                        modified[q] = this.getUUStamp();
                    }
                }
            }
        }
		var id = this.getIdBasedData({sheet:sheet, row:row, col:col});
		var cell = this.getByMapId(id);
		
		var origin;
		if(cell){
			/*
			 * update the exist record with modified obj
			 */
			origin = Ext.apply({}, cell.data['json']);
			if('applyIf' == applyWay){
				Ext.applyIf(cell.data['json'], modified);
			}else if('clear' == applyWay){
				cell.data['json'] = Ext.apply({}, modified);
                this.getData()[id][3] = cell.data['json'];
			}else{
				Ext.apply(cell.data['json'], modified);
			}					
		}else{			
			/*
			 * create a new record if don't exist
			 */
			cell = this.newRecord(sheet, row, col, modified);			
		}
		var originCopy = Ext.apply({}, origin);
		var json = cell.data.json;
        /*
         * special process for itms
         */
        if(modified && Ext.isDefined(modified['data']) && modified['data'] !== originCopy['data'] && !Ext.isDefined(modified['itms'])){
            deleted = deleted || [];
            deleted.push('itms');
        }
		/*
		 * process deleted porperty
		 */
		if(deleted){			
			for(var i = 0, len = deleted.length; i < len; i++){
				var p = deleted[i];
				/*
				 * delete the porperty from the record
				 */
				delete(json[p]);
			}
		}	
        if(0 === row && 0 === col){
            this.prepareDefaultWidthHeight(json);
        }
		
		var current = Ext.apply({}, json);
		
        if(!Ext.isNumber(current.afrow)){
            delete(current.afrow);
            delete(current.afcol);
            delete(current.aerow);
            delete(current.aecol);
        }
        if(!Ext.isNumber(originCopy.afrow)){
           delete(originCopy.afrow);
           delete(originCopy.afcol);
           delete(originCopy.aerow);
           delete(originCopy.aecol);
        }
        if(0 !== row && 0 === col){
            this.syncRowHeightCache(sheet, row);
        }else if(0 === row && 0 !== col){
            this.syncColWidthCache(sheet, col);
        }
		/*
		 * flag to show whether the data is changed
		 */
		var dataChanged = (originCopy['data'] !== current['data'] || originCopy['itchk'] !== current['itchk'] || originCopy['afrow'] !== current['afrow'] || 
			originCopy['afcol'] !== current['afcol'] || originCopy['aerow'] !== current['aerow'] || originCopy['aecol'] !== current['aecol']);
		/*
		 * fire an event for cell changed
		 */
		if(!suspendEvent){						
			if(dataChanged){
				/*
				 * generate a timestamp
				 */
				var timestamp = SCOM.genTimeStamp();						
				this.fireEvent('datachange', timestamp, sheet, row, col, modified, deleted, origin, current, this, false);
			}
			this.fireEvent('cellchange', sheet, row, col, modified, deleted, origin, current, this);			
		}
		/*
		 * check whether the value is changed
		 */
        var oldVal = originCopy['value'];
        if(!Ext.isDefined(oldVal)){
            oldVal = originCopy['data'];
        }
        var curVal = current['value'];
        if(!Ext.isDefined(curVal)){
            curVal = current['data'];
        }

		if(oldVal !== curVal){
            
			/*
			 * fire valuechange event, it will also fire if the value or data changed
			 */
			this.fireEvent('valuechange', sheet, row, col, modified, deleted, origin, current, this);
		}
        if(current.cal){
            this.getCalLookup()[id] = this.getData()[id];
        }
		return [origin, current, dataChanged];
	},
	
	/**
	 * get broken merged cell
	 */
	getBrokenMergedCells : function(sheetId, minrow, maxrow, mincol, maxcol, dir){
		var brokens = {};
		this.each(function(rec){
			var data = rec.data;
			var json = data.json;			
			var r = data.row, c = data.col;
			if(sheetId == data.sheet && false != SCOM.typeOf(json['minrow'])){
				var minr = json.minrow+r;
				var minc = json.mincol+c;
				var maxr = json.maxrow+r;
				var maxc = json.maxcol+c;
				var id = [minr, minc, maxr, maxc].join(this.separateChar);
				if('row' == dir){
					if(minrow <= maxr){
						if((mincol > minc && mincol < maxc) || (maxcol > minc && maxcol < maxc)){
							brokens[id] = {
								minrow: minr,
								mincol: minc,
								maxrow: maxr,
								maxcol: maxc
							}
						}
					}
				}else if('col' == dir){
					if(mincol <= maxc){
						if((minrow > minr && minrow < maxr) || (maxrow > minr && maxrow < maxr)){
							brokens[id] = {
								minrow: minr,
								mincol: minc,
								maxrow: maxr,
								maxcol: maxc
							}
						}
					}
				}
			}
		}, this);
		return brokens;
	},
           
    /**
     * return true if array formula cells is broken
     */
    isBrokenArrayFormulaCells : function(sheetId, minrow, maxrow, mincol, maxcol, dir){
        var lookup = {}, flag = false, span = [sheetId, minrow, mincol, maxrow, maxcol];
        this.each(function(rec){
            var data = rec.data;
            var json = data.json;
            var r = data.row, c = data.col;
            if(sheetId == data.sheet && Ext.isNumber(json['afrow'])){
                var afrow = json['afrow']+r, afcol = json['afcol']+c, aerow = json['aerow'], aecol = json.aecol;
                var id = afrow+'-'+afcol;
                if(!lookup[id]){
                    if(!Ext.isNumber(aerow)){
                        var cell = this.getCell(data.sheet, afrow, afcol);
                        aerow = cell.aerow;
                        aecol = cell.aecol;
                    }
                    aerow += r;
                    aecol += c;
                    if('row' == dir){
                        if(minrow <= aerow){
                            if(0 === mincol){
                                if(!(minrow <= afrow && maxrow >= aerow) && maxrow >= afrow){
                                    flag = true;
                                    return false;
                                }
                            }else if(((mincol >= afcol && mincol <= aecol) || (maxcol >= afcol && maxcol <= aecol))
                                && !(mincol === afcol && maxcol === aecol)){
                                flag = true;
                                return false;
                            }
                        }
                    }else{
                        if(mincol <= aecol){
                            if(0 === minrow){
                                if(!(mincol <= afcol && maxcol >= aecol) && maxcol >= afcol){
                                    flag = true;
                                    return false;
                                }
                            }else if(((minrow >= afrow && minrow <= aerow) || (maxrow >= afrow && maxrow <= aerow))
                                && !(minrow === afrow && maxrow === aerow)){
                                flag = true;
                                return false;
                            }
                        }
                    }
                  
                    lookup[id] = true;
                }
            }
        }, this);
        return flag;
    },
	
	/*
	 * private
	 * Check whether when the row/col is changed, whether there is combined cell related need change too
	 */
	checkMergedCellChange : function(sheet, rowSpan, colSpan, suspendEvent){
		
		var beforeFn, insideFn;
		if(rowSpan && colSpan){
			insideFn = function(r, m){
				return r.sheet == sheet && rowSpan.min <= r.row && rowSpan.max >= r.row && colSpan.min <= r.col && colSpan.max >= r.col &&
                    !(rowSpan.min <= m[0] && m[2] <= rowSpan.max && colSpan.min <= m[1] && m[3] <= colSpan.max);
			}
			beforeFn = function(r){
				return r.sheet == sheet && rowSpan.min <= r.row && colSpan.min <= r.col;
			}
		}else if(rowSpan){
			insideFn = function(r, m){
				return r.sheet == sheet && rowSpan.min <= r.row && rowSpan.max >= r.row && !(rowSpan.min <= m[0] && m[2] <= rowSpan.max);
			}
			beforeFn = function(r){
				return r.sheet == sheet && rowSpan.min <= r.row;
			}
		}else if(colSpan){
			insideFn = function(r, m){
                return r.sheet == sheet && colSpan.min <= r.col && colSpan.max >= r.col && !(colSpan.min <= m[1] && m[3] <= colSpan.max);
			}
			beforeFn = function(r){
				return r.sheet == sheet && colSpan.min <= r.col;
			}
		}else{
			return;
		}
		/*
		 * find whether there is combined cell related to this row/col
		 */
		var merged = {}, s = this.separateChar;
		
		this.each(function(rec){
			var data = rec.data;
			var json = data.json;
			var row = data.row, col = data.col;
            if(false != SCOM.typeOf(json['minrow']) && beforeFn(data)){
				var minrow = row+json['minrow'];				
				var maxrow = row+json['maxrow'];
				var mincol = col+json['mincol'];				
				var maxcol = col+json['maxcol'];				
                var inside = insideFn(data, [minrow, mincol, maxrow, maxcol]);
				var id = [minrow, mincol, maxrow, maxcol].join(s);		
				if(merged[id]){
					if(inside){
						merged[id]['inside'] = inside;
					}					
				}else{
					merged[id] = {
						minrow:minrow,
						mincol:mincol,
						maxrow:maxrow,
						maxcol:maxcol,
						inside: inside
					};
				}				
			}
		}, this);
		
		/*
		 * loop cells object, to fire cell change event
		 */
		if(suspendEvent){
			return merged;
		}else{
			var cells = {};
			/*
			 * get related cells from merged object
			 */
			for(var p in merged){
				var o = merged[p];
				var minrow = o.minrow;
				var mincol = o.mincol;
				var maxrow = o.maxrow;
				var maxcol = o.maxcol;
				for(var i = minrow; i <= maxrow; i++){
					for(var j = mincol; j <= maxcol; j++){
						this.setCell(sheet, i, j, null, null);						
					}
				}
			}
		}
	},
	
	/*
	 * the same as setCell, but will handle a little different, because it will affect all cells
	 */
	setWhole : function(sheet, modified, deleted, suspendEvent, applyWay){		
		applyWay = applyWay || 'apply';
		
		this.each(function(rd){
			if(rd.data.sheet == sheet){
				var row = rd.data.row, col = rd.data.col;
				if(0 != row || 0 != col){
					var json = rd.data.json;
					var md = {};
					for(var p in modified){
						if(modified.hasOwnProperty(p)){
							if(json.hasOwnProperty(p) && json[p] != modified[p]){
								if(0 !== row && 0 !== col){
									if(!EnterpriseSheet.sheet.data.Store.colProperties[p] && !EnterpriseSheet.sheet.data.Store.rowProperties[p]){
										md[p] = modified[p];
									}
								}else if(0 !== row){
									if(!EnterpriseSheet.sheet.data.Store.colProperties[p]){
										md[p] = modified[p];
									}
								}else{
									if(!EnterpriseSheet.sheet.data.Store.rowProperties[p]){
										md[p] = modified[p];
									}
								}								
							}
						}
					}
					var dt = [];
					if(deleted){
						for(var k = 0, size = deleted.length; k < size; k++){
							var p = deleted[k];
							if(json.hasOwnProperty(p)){
								dt.push(p);
							}
						}
					}
					if(0 < SCOM.countObjMember(md) || 0 < dt.length){
						this.setCell(sheet, row, col, md, dt, true, applyWay);
					}
				}
			}
		}, this);		
		
		this.setCell(sheet, 0, 0, modified, deleted, suspendEvent, applyWay);
           
        if((modified && (modified.hasOwnProperty('dw') || modified.hasOwnProperty('dh') || modified.hasOwnProperty('height') || modified.hasOwnProperty('width'))) || (deleted && (-1 !== deleted.indexOf('dw') || -1 !== deleted.indexOf('dh')|| -1 !== deleted.indexOf('width') || -1 !== deleted.indexOf('height')))){
            this.prepareDefaultWidthHeightForActiveSheet();
        }
	},
	
	/*
	 * the same as setCell, but will fire a different event
	 * @param {int} sheet: the sheet id
	 * @param {int} col: the column index
	 * @param {object} modified: the object hold all property need be modified for this cell
	 * @param {array} deleted: the array hold all property need be deleted from this cell
	 * @param {boolean} suspendCellChange: the flag to hold or fire "cellchange" event
	 * @param {boolean} suspendColChange: the flag to hold or fire "columnchange" event
	 * @param {string} applyWay: could be ['apply', 'applyIf'], default to 'apply'
	 * @param {boolean} noNeedCellProcess: true then no need care about cells in this column, this flag is for property such as width, woff, hidden
	 */
	setColumn : function(sheet, col, modified, deleted, suspendCellChange, suspendColChange, applyWay, noNeedCellProcess){
		applyWay = applyWay || 'apply';
		
		var rs = this.setCell(sheet, 0, col, modified, deleted, suspendCellChange, applyWay);
		
		if(!suspendColChange){
			this.checkMergedCellChange(sheet, null, {
				min:col,
				max:col
			});

			this.fireEvent('columnchange', sheet, col, modified, deleted, rs[0], rs[1], this);
		}
	},
	
	/*
	 * the same as setCell, but will fire a different event
	 * @param {int} sheet: the sheet id
	 * @param {int} row: the row index
	 * @param {object} modified: the object hold all property need be modified for this cell
	 * @param {array} deleted: the array hold all property need be deleted from this cell
	 * @param {boolean} suspendCellChange: the flag to hold or fire "cellchange" event
	 * @param {boolean} suspendRowChange: the flag to hold or fire "rowchange" event
	 * @param {string} applyWay: could be ['apply', 'applyIf'], default to 'apply'
	 * @param {boolean} noNeedCellProcess: true then no need care about cells in this column, this flag is for property such as width, woff, hidden
	 */
	setRow : function(sheet, row, modified, deleted, suspendCellChange, suspendRowChange, applyWay, noNeedCellProcess){
		applyWay = applyWay || 'apply';
        
		var rs = this.setCell(sheet, row, 0, modified, deleted, suspendCellChange, applyWay);
		
		if(!suspendRowChange){
			this.checkMergedCellChange(sheet, {
				min:row,
				max:row
			});
			this.fireEvent('rowchange', sheet, row, modified, deleted, rs[0], rs[1], this);
		}
	},
	
	syncMaxRowColOfSheet : function(sheetId, dir){		
		var sheetObj = this.getSheetById(sheetId);
		if('row' === dir){
			this.each(function(rec){
				if(rec.data.sheet === sheetId){
					if(rec.data.row > sheetObj.maxRow){
						sheetObj.maxRow = rec.data.row;
					}					
				}
			}, this);
		}else if('col' === dir){
			this.each(function(rec){
				if(rec.data.sheet === sheetId){					
					if(rec.data.col > sheetObj.maxCol){
						sheetObj.maxCol = rec.data.col;
					}
				}
			}, this);
		}else{
			this.each(function(rec){
				if(rec.data.sheet === sheetId){
					if(rec.data.row > sheetObj.maxRow){
						sheetObj.maxRow = rec.data.row;
					}
					if(rec.data.col > sheetObj.maxCol){
						sheetObj.maxCol = rec.data.col;
					}
				}
			}, this);
		}
	},
	
	/*
	 * remove cell(s), and move the rest cells to fill the empty space based on "moveDir"
	 * @param {int} sheet: the sheet id
	 * @param {int} minrow: the min row index
	 * @param {int} mincol: the min column index
	 * @param {int} maxrow: the max row index
	 * @param {int} maxcol: the max column index, these 4 params define the range of cells to remove	 
	 * top means the rest cells move up to fill the empty range
	 * @param {boolean} suspendEvent: the flag to fire or not fire a removecell event
	 */
	removeCellMoveLeft : function(sheet, minrow, maxrow, mincol, maxcol, suspendEvent, suspendPull){
		/*
		 * if one of minrow and maxrow is 0, then means remove whole column
		 */
		var removeCol = !minrow || !maxrow ? true : false;
		var moveDir = 'left';
		var span = maxcol-mincol+1;
		if(0 >= span){
			return;
		}
		/*
		 * get the related merged cells before remove these rows
		 * set supendEvent to true, cause don't need fire the event right now
		 */
		var merged = this.checkMergedCellChange(sheet, removeCol ? null : {
			min:minrow,
			max:maxrow
		}, {
			min:mincol,
			max:maxcol
		}, true);
		if(!suspendEvent){
			/*
			 * get the record will be removed
			 */
			var deleted = this.queryBy(function(rec){
				var col = rec.data.col, row = rec.data.row;
				if(rec.data.sheet == sheet && mincol <= col && col <= maxcol 
						&& (removeCol || (minrow <= row && row <= maxrow))){
					return true;
				}
			}, this);
			
			if(removeCol){
				/*
				 * fire beforeremovecolumn event, if any listener return false, then cancel remove
				 */
				if(false === this.fireEvent('beforeremovecolumn', sheet, mincol, maxcol, deleted, merged, this)){
					return;
				}
				if(!suspendPull){
					if(false === this.fireEvent('beforegoremovecolumn', sheet, mincol, maxcol, deleted, merged, this)){
						return;
					}
				}
				this.fireEvent('prepareremovecolumn', sheet, mincol, maxcol, deleted, merged, this);
			}else{
				/*
				 * fire beforeremovecell event, if any listener return false, then cancel remove
				 */
				if(false === this.fireEvent('beforeremovecell', sheet, minrow, maxrow, mincol, maxcol, moveDir, deleted, merged, this)){
					return;
				}		
				if(!suspendPull){
					if(false === this.fireEvent('beforegoremovecell', sheet, minrow, maxrow, mincol, maxcol, moveDir, deleted, merged, this)){
						return;
					}
				}
				this.fireEvent('prepareremovecell', sheet, minrow, maxrow, mincol, maxcol, moveDir, deleted, merged, this)
			}							
		}else{
			if(removeCol){
				if(!suspendPull){
					if(false === this.fireEvent('beforegoremovecolumn', sheet, mincol, maxcol, deleted, merged, this)){
						return;
					}
				}
			}else{
				if(!suspendPull){
					if(false === this.fireEvent('beforegoremovecell', sheet, minrow, maxrow, mincol, maxcol, moveDir, deleted, merged, this)){
						return;
					}
				}
			}
		}
				
		var data = this.getData();
        var oldP = {}, newP = {};
        /*
		 * then move left the columns and update map
		 * remember have to do delete and update in 2 loops
		 */
        var separateChar = this.separateChar;
		for(var p in data){
            if(data.hasOwnProperty(p)){
                var it = data[p];
                var s = it[0], c = it[2], r = it[1];
                if(s == sheet && (removeCol || (minrow <= r && r <= maxrow))){
                    if(c > maxcol){
                        it[2] -= span;
                        var id = [s, r, it[2]].join(separateChar);
           
                        newP[id] = it;
                        if(!newP[p]){
                            oldP[p] = true;
                        }
                    }else if(mincol <= c){
                        delete(data[p]);
                    }
                }
            }
        }
        for(var p in oldP){
            if(oldP.hasOwnProperty(p) && !newP.hasOwnProperty(p)){
                delete(data[p]);
            }
        }
        Ext.apply(data, newP);
        if(removeCol){
            this.resetColWidthCache(sheet);
            if(!suspendPull){
            	this.fireEvent('beforeholdremovecolumn', sheet, mincol, maxcol, deleted, merged, this);
            }
        }else{
        	if(!suspendPull){
        		this.fireEvent('beforeholdremovecell', sheet, minrow, maxrow, mincol, maxcol, moveDir, deleted, merged, this);
        	}
        }
        this.syncMaxRowColOfSheet(sheet, removeCol ? 'col' : undefined);
		if(!suspendEvent){	
			if(removeCol){				
				/*
				 * provide a way to call off to fire removecolumn, notice the removecolumn event will cause the region to render the UI
				 */
				if(false !== this.fireEvent('holdremovecolumn', sheet, mincol, maxcol, deleted, merged, this)){
					/*
					 * fire removecolumn event, notice when this event is fired, the merged cell is not updated yet
					 * after merged cell is updated, there is another event "columnremoved" will fire,
					 * it's a little ugly, but I don't have a better idea yet
					 */		
					this.fireEvent('removecolumn', sheet, mincol, maxcol, deleted, merged, this);
				}
			}else{				
				/*
				 * provide a way to call off to fire removecell, notice the removecell event will cause the region to render the UI
				 */
				if(false !== this.fireEvent('holdremovecell', sheet, minrow, maxrow, mincol, maxcol, moveDir, deleted, merged, this)){
					/*
					 * fire removecell event, notice when this event is fired, the merged cell is not updated yet
					 * after merged cell is updated, there is another event "cellremoved" will fire,
					 * it's a little ugly, but I don't have a better idea yet
					 */		
					this.fireEvent('removecell', sheet, minrow, maxrow, mincol, maxcol, moveDir, deleted, merged, this);
				}
			}
            var changedMerged = {};
			/*
			 * for merged cells, need update the [minrow, mincol, maxrow, maxcol], cause there is some rows removed
			 */			
			for(var p in merged){
				var o = merged[p];
				var minr = o.minrow;
				var minc = o.mincol;
				var maxr = o.maxrow;
				var maxc = o.maxcol;
				var span = maxcol-mincol+1;
				if(o.inside){
					/*
					 * update the mincol and maxcol
					 */
					if(mincol > minc && maxc > maxcol){
						maxc -= span;
					}else if(mincol > minc){
						maxc = mincol-1;
					}else{
						maxc -= span;
						minc = mincol;
					}
                    if(minr > maxr || maxc < minc || (minr === maxr && minc === maxc)){
                        if(minr === maxr && minc === maxc){
                            /*
                             * if 0, then means this cell is not a merged cell any more, need delete the minrow/mincol/maxrow/maxcol
                             */
                            this.setCell(sheet, minr, minc, null, ['minrow', 'mincol', 'maxrow', 'maxcol', 'abminrow', 'abmincol', 'abmaxrow', 'abmaxcol']);
                        }
                    }else{
                        changedMerged[p] = {
                            minrow: minr,
                            mincol: minc,
                            maxrow: maxr,
                            maxcol: maxc,
                            inside: true
                        };
						for(var row = minr; row <= maxr; row++){
							for(var col = minc; col <= maxc; col++){
								/*
								 * update the mincol/maxcol
								 */
								this.setCell(sheet, row, col, {
									'mincol':minc-col,
									'maxcol':maxc-col
								});						
							} 
						}
					}
				}else{
                    minc -= span;
                    maxc -= span;
                    changedMerged[p] = {
                        minrow: minr,
                        mincol: minc,
                        maxrow: maxr,
                        maxcol: maxc,
                        inside: false
                    };
					this.setCell(sheet, minr, minc, null, null);
				}
			}
			if(removeCol){
				/*
				 * after merged cell is updated, fire "columnremoved" event
				 */
				this.fireEvent('columnremoved', sheet, mincol, maxcol, deleted, changedMerged, this);
			}else{
				/*
				 * after merged cell is updated, fire "cellremoved" event
				 */
				this.fireEvent('cellremoved', sheet, minrow, maxrow, mincol, maxcol, moveDir, deleted, changedMerged, this);
			}			
		}
	},
	
	/*
	 * remove cell(s), and move the rest cells to fill the empty space based on "moveDir"
	 * @param {int} sheet: the sheet id
	 * @param {int} minrow: the min row index
	 * @param {int} mincol: the min column index
	 * @param {int} maxrow: the max row index
	 * @param {int} maxcol: the max column index, these 4 params define the range of cells to remove	 
	 * top means the rest cells move up to fill the empty range
	 * @param {boolean} suspendEvent: the flag to fire or not fire a removecell event
	 */
	removeCellMoveUp : function(sheet, minrow, maxrow, mincol, maxcol, suspendEvent, suspendPull){
		/*
		 * if one of mincol and maxcol is 0, then means remove whole row
		 */
		var removeRow = !mincol || !maxcol ? true : false;
		var moveDir = 'up';
		var span = maxrow-minrow+1;
		if(0 >= span){
			return;
		}
		/*
		 * get the related merged cells before remove these rows
		 * set supendEvent to true, cause don't need fire the event right now
		 */
		var merged = this.checkMergedCellChange(sheet, {
			min:minrow,
			max:maxrow
		}, removeRow ? null : {
			min:mincol,
			max:maxcol
		}, true);
		if(!suspendEvent){
			/*
			 * get the record will be removed for the event
			 */
			var deleted = this.queryBy(function(rec){
				var row = rec.data.row, col = rec.data.col;
				if(sheet == rec.data.sheet && minrow <= row && row <= maxrow 						
						&& (removeRow || (mincol <= col && col <= maxcol))){
					return true;
				}
			}, this);	
			
			if(removeRow){
				/*
				 * fire beforeremoverow event, if any listener return false, then cancel remove
				 */				
				if(false === this.fireEvent('beforeremoverow', sheet, minrow, maxrow, deleted, merged, this)){
					return;
				}
				if(!suspendPull){
					if(false === this.fireEvent('beforegoremoverow', sheet, minrow, maxrow, deleted, merged, this)){
						return;
					}
				}	
				/*
				 * fire an event to let history save cal/cdt data for the undo/redo 
				 */
				this.fireEvent('prepareremoverow', sheet, minrow, maxrow, deleted, merged, this);
			}else{
				/*
				 * fire beforeremoverow event, if any listener return false, then cancel remove
				 */
				if(false === this.fireEvent('beforeremovecell', sheet, minrow, maxrow, mincol, maxcol, moveDir, deleted, merged, this)){
					return;
				}	
				if(!suspendPull){
					if(false === this.fireEvent('beforegoremovecell', sheet, minrow, maxrow, mincol, maxcol, moveDir, deleted, merged, this)){
						return;
					}
				}
				/*
				 * fire an event to let history save cal/cdt data for the undo/redo 
				 */
				this.fireEvent('prepareremovecell', sheet, minrow, maxrow, mincol, maxcol, moveDir, deleted, merged, this);
			}			
		}else{
			if(removeRow){
				if(!suspendPull){
					if(false === this.fireEvent('beforegoremoverow', sheet, minrow, maxrow, deleted, merged, this)){
						return;
					}
				}
			}else{
				if(!suspendPull){
					if(false === this.fireEvent('beforegoremovecell', sheet, minrow, maxrow, mincol, maxcol, moveDir, deleted, merged, this)){
						return;
					}
				}
			}
		}
				
		var data = this.getData();
        var oldP = {}, newP = {}, separateChar = this.separateChar;
		/*
		 * then move up the rows and update map
		 * remember have to do delete and update in 2 loops
		 */
        for(var p in data){
            if(data.hasOwnProperty(p)){
                var it = data[p];
                var s = it[0], r = it[1], c = it[2];
                if(s == sheet && (removeRow || (mincol <= c && c <= maxcol))){
                    if(r > maxrow){
                        /*
                         * for these rows below the removed one, need move up span step
                         * so sub the row property, and then save to new map
                         */
                        it[1] -= span;
                        var id = [s, it[1], c].join(separateChar);

                        newP[id] = it;
                        if(!newP[p]){
                            oldP[p] = true;
                        }
                    }else if(minrow <= r){
                        delete(data[p]);
                    }
                }
            }
        }	
        for(var p in oldP){
            if(oldP.hasOwnProperty(p) && !newP.hasOwnProperty(p)){
                delete(data[p]);
            }
        }
        Ext.apply(data, newP);
        /*
         * fire an event for table tpl to sync the table range
         */
        if(removeRow){
            this.resetRowHeightCache(sheet);
            if(!suspendPull){
            	this.fireEvent('beforeholdremoverow', sheet, minrow, maxrow, deleted, merged, this);
            }        	
        }else{
        	if(!suspendPull){
        		this.fireEvent('beforeholdremovecell', sheet, minrow, maxrow, mincol, maxcol, moveDir, deleted, merged, this);
        	}
        }
        this.syncMaxRowColOfSheet(sheet, removeRow ? 'row' : undefined);
        if(!suspendEvent){		
        	if(removeRow){        		
        		/*
				 * provide a way to call off firing removerow, notice the removerow event will cause the region to render the UI
				 */
				if(false !== this.fireEvent('holdremoverow', sheet, minrow, maxrow, deleted, merged, this)){
	        		/*
	    			 * fire removerow event, notice when this event is fired, the merged cell is not updated yet
	    			 * after merged cell is updated, there is another event "rowremoved" will fire,
	    			 * it's a little ugly, but I don't have a better idea yet
	    			 */
	    			this.fireEvent('removerow', sheet, minrow, maxrow, deleted, merged, this);
				}
        	}else{        		
        		/*
				 * provide a way to call off to fire removecell, notice the removecell event will cause the region to render the UI
				 */
				if(false !== this.fireEvent('holdremovecell', sheet, minrow, maxrow, mincol, maxcol, moveDir, deleted, merged, this)){
	        		/*
					 * fire removecell event, notice when this event is fired, the merged cell is not updated yet
					 * after merged cell is updated, there is another event "cellremoved" will fire,
					 * it's a little ugly, but I don't have a better idea yet
					 */
					this.fireEvent('removecell', sheet, minrow, maxrow, mincol, maxcol, moveDir, deleted, merged, this);
				}
        	}        
	        /*
			 * for merged cells, need update the [minrow, mincol, maxrow, maxcol], cause there is some rows removed
			 */
            var changedMerged = {};
			for(var p in merged){
				var o = merged[p];
				var span = maxrow-minrow+1;
				var minr = o.minrow;
				var minc = o.mincol;
				var maxr = o.maxrow;
				var maxc = o.maxcol;	
				if(o.inside){								
					/*
					 * update the minrow and maxrow
					 */
					if(minrow > minr && maxr > maxrow){
						maxr -= span;
					}else if(minrow > minr){
						maxr = minrow-1;
					}else{
						maxr -= span;
						minr = minrow;
					}
					if(minr > maxr || minc > maxc || (minr == maxr && maxc == minc)){
                        if(minr == maxr && maxc == minc){
                            /*
                             * if 0, then means this cell is not a merged cell any more, need delete the minrow/mincol/maxrow/maxcol
                             */
                            this.setCell(sheet, minr, minc, null, ['minrow', 'mincol', 'maxrow', 'maxcol', 'abminrow', 'abmincol', 'abmaxrow', 'abmaxcol']);
                        }
					}else{
                        changedMerged[p] = {
                            minrow: minr,
                            mincol: minc,
                            maxrow: maxr,
                            maxcol: maxc,
                            inside: true
                        };
						for(var row = minr; row <= maxr; row++){
							for(var col = minc; col <= maxc; col++){
								/*
								 * update the minrow/maxrow
								 */
								this.setCell(sheet, row, col, {
									'minrow':minr-row,
									'maxrow':maxr-row
								});						
							} 
						}
					}
				}else{
                    minr -= span;
                    maxr -= span;
                    changedMerged[p] = {
                        minrow: minr,
                        mincol: minc,
                        maxrow: maxr,
                        maxcol: maxc,
                        inside: false
                    };
					this.setCell(sheet, minr, minc, null, null);
				}
			}
			if(removeRow){
				/*
				 * after merged cell is updated, fire "rowremoved" event
				 */
				this.fireEvent('rowremoved', sheet, minrow, maxrow, deleted, changedMerged, this);
			}else{
				/*
				 * after merged cell is updated, fire "cellremoved" event
				 */
				this.fireEvent('cellremoved', sheet, minrow, maxrow, mincol, maxcol, moveDir, deleted, changedMerged, this);
			}		
		}
	},
	
	/*
	 * remove cell(s), and move the rest cells to fill the empty space based on "moveDir"
	 * @param {int} sheet: the sheet id
	 * @param {int} minrow: the min row index
	 * @param {int} mincol: the min column index
	 * @param {int} maxrow: the max row index
	 * @param {int} maxcol: the max column index, these 4 params define the range of cells to remove
	 * @param {string} moveDir: could be ['left', 'up'], left means the rest cells move left to fill the empty range,
	 * top means the rest cells move up to fill the empty range
	 * @param {boolean} suspendEvent: the flag to fire or not fire a removecell event
	 */
	removeCell : function(sheet, minrow, maxrow, mincol, maxcol, moveDir, suspendEvent){
		if('left' == moveDir){
			this.removeCellMoveLeft(sheet, minrow, maxrow, mincol, maxcol, suspendEvent);
		}else{
			this.removeCellMoveUp(sheet, minrow, maxrow, mincol, maxcol, suspendEvent);
		}		
	},
	
	/*
	 * remove row(s), and the row after this row need move up one step
	 * @param {int} sheet: the sheet id
	 * @param {int} minrow: the min row index to remove
	 * @param {int} maxrow: the max row index to remove
	 * @param {boolean} suspendEvent: the flag to fire or not fire a removerow event
	 */
	removeRow : function(sheet, minrow, maxrow, suspendEvent){	
		this.removeCellMoveUp(sheet, minrow, maxrow, 0, 0, suspendEvent);		
	},
	
	/*
	 * remove column(s), and the clumns after this column need move left one step
	 * @param {int} sheet: the sheet id
	 * @param {int} mincol: the min column index to remove
	 * @param {int} maxcol: the max column index to remove
	 * @param {boolean} suspendEvent: the flag to fire or not fire a removecolumn event
	 */
	removeColumn : function(sheet, mincol, maxcol, suspendEvent){
		this.removeCellMoveLeft(sheet, 0, 0, mincol, maxcol, suspendEvent);		
	},
	
	
	/**
	 * insert some cells at a speicial row/col index, and move the original cells to right or bottom
	 * @param {int} sheet: the sheet id
	 * @param {int} row: the row index, where to insert cells
	 * @param {int} col: the column index, where to insert cells
	 * @param {int} rowSpan: the row span of inserted cells
	 * @param {int} colSpan: the column span of inserted cells	 
	 * @param {boolean} suspendEvent: whether suspend the event
	 * @param {object} insertCellCache: the cache for the cells to insert
	 */
	insertCellMoveRight : function(sheet, row, col, rowSpan, colSpan, suspendEvent, insertCellCache, suspendPull){
		var insertCol = !row || !rowSpan ? true : false;
		var moveDir = 'right';
		
		var merged= this.checkMergedCellChange(sheet, insertCol ? null : {
			min:row,
			max:row+rowSpan-1
		}, {
			min:col,
			max:col+colSpan-1
		}, true);
		if(!suspendEvent){
			/*
			 * add before insert event
			 */
			if(insertCol){			
				if(false === this.fireEvent('beforeinsertcolumn', sheet, col, colSpan, merged, this)){
					return;
				}
				if(!suspendPull){
					if(false === this.fireEvent('beforegoinsertcolumn', sheet, col, colSpan, merged, this)){
						return;
					}
				}	
				this.fireEvent('prepareinsertcolumn', sheet, col, colSpan, merged, this);
			}else{			
				if(false === this.fireEvent('beforeinsertcell', sheet, row, col, rowSpan, colSpan, moveDir, merged, this)){
					return;
				}
				if(!suspendPull){
					if(false === this.fireEvent('beforegoinsertcell', sheet, row, col, rowSpan, colSpan, moveDir, merged, this)){
						return;
					}
				}
				this.fireEvent('prepareinsertcell', sheet, row, col, rowSpan, colSpan, moveDir, merged, this);
			}
		}else{
			if(insertCol){
				if(!suspendPull){
					if(false === this.fireEvent('beforegoinsertcolumn', sheet, col, colSpan, merged, this)){
						return;
					}
				}
			}else{
				if(!suspendPull){
					if(false === this.fireEvent('beforegoinsertcell', sheet, row, col, rowSpan, colSpan, moveDir, merged, this)){
						return;
					}
				}
			}
		}
		var data = this.getData();
				
		var minrow = row, maxrow = row+rowSpan-1;
        var oldP = {}, newP = {}, separateChar = this.separateChar;
		for(var p in data){
            if(data.hasOwnProperty(p)){
                var it = data[p];
                var s = it[0], r = it[1], c = it[2];
                if(s == sheet && c >= col
					&& (insertCol || (minrow <= r && r <= maxrow))){
                    /*
                     * update col index, add span
                     */
                    it[2] += colSpan;
                    /*
                     * reproduce id
                     */
                    id = [s, r, it[2]].join(separateChar);
				
                    newP[id] = it;
                    if(!newP[p]){
                        oldP[p] = true;
                    }
                }
            }
		}
        for(var p in oldP){
            if(oldP.hasOwnProperty(p) && !newP.hasOwnProperty(p)){
                delete(data[p]);
            }
        }
        Ext.apply(data, newP);
           
		if(insertCol){
            this.resetColWidthCache(sheet);
            if(!suspendPull){
            	this.fireEvent('beforeholdinsertcolumn', sheet, col, colSpan, merged, this);
            }
		}else{
			if(!suspendPull){
				this.fireEvent('beforeholdinsertcell', sheet, row, col, rowSpan, colSpan, moveDir, merged, this);
			}
		}
		/*
		 * update the inserted cells
		 */
		if(insertCellCache){
			for(var p in insertCellCache){
				if(insertCellCache.hasOwnProperty(p)){
					var it = insertCellCache[p];
					var sid = it.sheetId, r = it.row, c = it.col, json = it.json;
					this.setCell(sid, r, c, json, undefined, true, 'clear');
				}
			}
		}
		this.syncMaxRowColOfSheet(sheet, insertCol ? 'col' : undefined);
		if(!suspendEvent){	
			if(insertCol){				
				/*
				 * provide a way to call off to fire insertcolumn, notice the insertcolumn event will cause the region to render the UI
				 */
				if(false !== this.fireEvent('holdinsertcolumn', sheet, col, colSpan, merged, this, insertCellCache)){
					/*
					 * fire insertcolumn event, notice when this event is fired, the merged cell is not updated yet
					 * after merged cell is updated, there is another event "columninserted" will fire,
					 * it's a little ugly, but I don't have a better idea yet
					 */	
					this.fireEvent('insertcolumn', sheet, col, colSpan, merged, this);
				}
			}else{				
				/*
				 * provide a way to call off to fire insertcell, notice the insertcell event will cause the region to render the UI
				 */
				if(false !== this.fireEvent('holdinsertcell', sheet, row, col, rowSpan, colSpan, moveDir, merged, this, insertCellCache)){
					/*
					 * fire insertrow event, notice when this event is fired, the merged cell is not updated yet
					 * after merged cell is updated, there is another event "rowinserted" will fire,
					 * it's a little ugly, but I don't have a better idea yet
					 */			
					this.fireEvent('insertcell', sheet, row, col, rowSpan, colSpan, moveDir, merged, this);
				}
			}		
			/*
			 * for merged cells, need update the [minrow, mincol, maxrow, maxcol], cause there is some rows inserted
			 */
			for(var p in merged){
				var o = merged[p];
				var minr = o.minrow;
				var minc = o.mincol;
				var maxr = o.maxrow;
				var maxc = o.maxcol+colSpan;
				if(o.inside){
					for(var r = minr; r <= maxr; r++){
						for(var c = maxc; c >= minc; c--){
							this.setCell(sheet, r, c, {
								'mincol':minc-c,
								'maxcol':maxc-c,
								'minrow':minr-r,
								'maxrow':maxr-r								
							});	
						} 
					}
				}else{
					this.setCell(sheet, minr, minc+colSpan, null, null);
				}				
			}						
			if(insertCol){
				this.fireEvent('columninserted', sheet, col, colSpan, merged, this);		
			}else{
				this.fireEvent('cellinserted', sheet, row, col, rowSpan, colSpan, moveDir, merged, this);
			}			
		}
	},
	
	/**
	 * insert some cells at a speicial row/col index, and move the original cells to right or bottom
	 * @param {int} sheet: the sheet id
	 * @param {int} row: the row index, where to insert cells
	 * @param {int} col: the column index, where to insert cells
	 * @param {int} rowSpan: the row span of inserted cells
	 * @param {int} colSpan: the column span of inserted cells	 
	 * @param {boolean} suspendEvent: whether suspend the event
	 * @param {object} insertCellCache: the cache for the cells to insert
	 */
	insertCellMoveDown : function(sheet, row, col, rowSpan, colSpan, suspendEvent, insertCellCache, suspendPull){
		var insertRow = !col || !colSpan ? true : false;
		var moveDir = 'down';			
		/*
		 * get the related merged cells before remove these rows
		 * set supendEvent to true, cause don't need fire the event right now
		 */				 
		var merged = this.checkMergedCellChange(sheet, {
			min:row,
			max:row+rowSpan-1
		}, insertRow ? null : {
			min:col,
			max:col+colSpan-1
		}, true);
		
		if(!suspendEvent){
			/*
			 * add before insert event
			 */
			if(insertRow){			
				if(false === this.fireEvent('beforeinsertrow', sheet, row, rowSpan, merged, this)){
					return;
				}
				if(!suspendPull){
					if(false === this.fireEvent('beforegoinsertrow', sheet, row, rowSpan, merged, this)){
						return;
					}
				}				
				this.fireEvent('prepareinsertrow', sheet, row, rowSpan, merged, this);
			}else{			
				if(false === this.fireEvent('beforeinsertcell', sheet, row, col, rowSpan, colSpan, moveDir, merged, this)){
					return;
				}
				if(!suspendPull){
					if(false === this.fireEvent('beforegoinsertcell', sheet, row, col, rowSpan, colSpan, moveDir, merged, this)){
						return;
					}
				}
				this.fireEvent('prepareinsertcell', sheet, row, col, rowSpan, colSpan, moveDir, merged, this);
			}
		}else if(!suspendPull){
			if(insertRow){
				if(false === this.fireEvent('beforegoinsertrow', sheet, row, rowSpan, merged, this)){
					return;
				}
			}else{
				if(false === this.fireEvent('beforegoinsertcell', sheet, row, col, rowSpan, colSpan, moveDir, merged, this)){
					return;
				}
			}
		}
		var data = this.getData();
		
		var mincol = col, maxcol = col+colSpan-1;
        var oldP = {}, newP = {}, separateChar = this.separateChar;
		for(var p in data){
            if(data.hasOwnProperty(p)){
                var it = data[p];
                var s = it[0], r = it[1], c = it[2];
                if(s == sheet && r >= row
					&& (insertRow || (mincol <= c && c <= maxcol))){
                    /*
                     * update row index, add span
                     */
                    it[1] += rowSpan;
                    /*
                     * reproduce id
                     */
                    id = [s, it[1], c].join(separateChar);
           
                    newP[id] = it;
                    if(!newP[p]){
                        oldP[p] = true;
                    }
                }
            }
		}
        for(var p in oldP){
            if(oldP.hasOwnProperty(p) && !newP.hasOwnProperty(p)){
                delete(data[p]);
            }
        }
        Ext.apply(data, newP);
    
		if(insertRow){
            this.resetRowHeightCache(sheet);
            if(!suspendPull){
            	this.fireEvent('beforeholdinsertrow', sheet, row, rowSpan, merged, this);
            }
		}else{
			if(!suspendPull){
				this.fireEvent('beforeholdinsertcell', sheet, row, col, rowSpan, colSpan, moveDir, merged, this);
			}
		}
		/*
		 * update the inserted cells
		 */
		if(insertCellCache){
			for(var p in insertCellCache){
				if(insertCellCache.hasOwnProperty(p)){
					var it = insertCellCache[p];
					var sid = it.sheetId, r = it.row, c = it.col, json = it.json;
					this.setCell(sid, r, c, json, undefined, true, 'clear');
				}
			}
		}
		this.syncMaxRowColOfSheet(sheet, insertRow ? 'row' : undefined);
		if(!suspendEvent){	
			if(insertRow){				
				/*
				 * provide a way to call off to fire insertrow, notice the insertrow event will cause the region to render the UI
				 */
				if(false !== this.fireEvent('holdinsertrow', sheet, row, rowSpan, merged, this, insertCellCache)){
					/*
					 * fire insertrow event, notice when this event is fired, the merged cell is not updated yet
					 * after merged cell is updated, there is another event "rowinserted" will fire,
					 * it's a little ugly, but I don't have a better idea yet
					 */			
					this.fireEvent('insertrow', sheet, row, rowSpan, merged, this);
				}				
			}else{				
				/*
				 * provide a way to call off to fire insertcell, notice the insertcell event will cause the region to render the UI
				 */
				if(false !== this.fireEvent('holdinsertcell', sheet, row, col, rowSpan, colSpan, moveDir, merged, this, insertCellCache)){
					/*
					 * fire insertrow event, notice when this event is fired, the merged cell is not updated yet
					 * after merged cell is updated, there is another event "rowinserted" will fire,
					 * it's a little ugly, but I don't have a better idea yet
					 */			
					this.fireEvent('insertcell', sheet, row, col, rowSpan, colSpan, moveDir, merged, this);
				}
			}		
			/*
			 * for merged cells, need update the [minrow, mincol, maxrow, maxcol], cause there is some rows inserted
			 */		
			for(var p in merged){
				var o = merged[p];
				var minr = o.minrow;
				var minc = o.mincol;
				var maxr = o.maxrow+rowSpan;
				var maxc = o.maxcol;
				if(o.inside){														
					for(var r = maxr; r >= minr; r--){
						for(var c = minc; c <= maxc; c++){
							this.setCell(sheet, r, c, {
								'mincol':minc-c,
								'maxcol':maxc-c,
								'minrow':minr-r,
								'maxrow':maxr-r
							});	
						} 
					}
				}else{		
					/*
					 * need check the merged cell after the insert
					 */
					this.setCell(sheet, minr+rowSpan, minc, null, null);					
				}				
			}						
			if(insertRow){
				this.fireEvent('rowinserted', sheet, row, rowSpan, merged, this);
			}else{
				this.fireEvent('cellinserted', sheet, row, col, rowSpan, colSpan, moveDir, merged, this);
			}			
		}
	},
	
	/**
	 * insert some cells at a speicial row/col index, and move the original cells to right or bottom
	 * @param {int} sheet: the sheet id
	 * @param {int} row: the row index, where to insert cells
	 * @param {int} col: the column index, where to insert cells
	 * @param {int} rowSpan: the row span of inserted cells
	 * @param {int} colSpan: the column span of inserted cells
	 * @param {string} moveDir: the direction the original cells to move, could be right or bottom
	 * @param {boolean} suspendEvent: whether suspend the event
	 * @param {object} insertCellCache: the cache for the cells to insert
	 */
	insertCell : function(sheet, row, col, rowSpan, colSpan, moveDir, suspendEvent, insertCellCache){	
		if('right' == moveDir){
			this.insertCellMoveRight(sheet, row, col, rowSpan, colSpan, suspendEvent, insertCellCache);
		}else{
			this.insertCellMoveDown(sheet, row, col, rowSpan, colSpan, suspendEvent, insertCellCache);
		}		
	},
	
	/**
	 * insert some rows at a speicial row index
	 * @param {int} sheet: the sheet id
	 * @param {int} row: the row index, where to insert rows
	 * @param {int} span: how many rows inserted
	 * @param {boolean} suspendEvent: whether suspend the event
	 * @param {object} insertCellCache: the cache for the cells to insert
	 */
	insertRow : function(sheet, row, span, suspendEvent, insertCellCache){	
		this.insertCellMoveDown(sheet, row, 0, span, 0, suspendEvent, insertCellCache);		
	},
	
	/**
	 * insert some columns at a speicial column index
	 * @param {int} sheet: the sheet id
	 * @param {int} col: the col index, where to insert columns
	 * @param {int} span: how many columns inserted
	 * @param {boolean} suspendEvent: whether suspend the event
	 * @param {object} insertCellCache: the cache for the cells to insert
	 */
	insertColumn : function(sheet, col, span, suspendEvent, insertCellCache){
		this.insertCellMoveRight(sheet, 0, col, 0, span, suspendEvent, insertCellCache);		
	},
	
	/*
	 * if a row is hidden then return false, or true
	 * @param {int} sheet: the sheet id
	 * @param {int} row: the row index
	 * @param {Ext.util.MixedCollection} data:if not null then will check the row in data, or will check this.data,
	 * for removed rows, may need pass the removed data to check, in most of time, just leave this parameter empty
	 */
	isVisibleRow : function(sheet, row, data){
		var id = this.getIdBasedData({sheet:sheet, row:row, col:0});		
		var c;
		if(data){
			c = data.key(id);
		}else{
			c = this.getByMapId(id);
		}
		if(c && c.data['json']['hidden']){
			return false;
		}
		return true;
	},
	
	/*
	 * if a column is hidden then return false, or true
	 * @param {int} sheet: the sheet id
	 * @param {int} col: the column index
	 * @param {Ext.util.MixedCollection} data:if not null then will check the column in data, or will check this.data,
	 * for removed columns, may need pass the removed data to check, in most of time, just leave this parameter empty
	 */
	isVisibleColumn : function(sheet, col, data){
		var id = this.getIdBasedData({sheet:sheet, row:0, col:col});
		var c;
		if(data){
			c = data.key(id);
		}else{
			c = this.getByMapId(id);
		}
		if(c && c.data['json']['hidden']){
			return false;
		}
		return true;
	},
	
	/*
	 * count the visibe row from minrow to maxrow
	 * @param {int} sheet: the sheet id
	 * @param {int} minrow: the min row index
	 * @param {int} maxrow: the max row index
	 * @return {int}: the visible row number from minrow to maxrow
	 */
	countVisibleRow : function(sheet, minrow, maxrow){
		var count = 0;
		for(var i = minrow; i <= maxrow; i++){
			if(this.isVisibleRow(sheet, i)){
				count++;
			}
		}
		return count;
	},
	
	/*
	 * count the visibe column from mincol to maxcol
	 * @param {int} sheet: the sheet id
	 * @param {int} mincol: the min column index
	 * @param {int} maxcol: the max column index
	 * @return {int}: the visible column number from mincol to maxcol
	 */
	countVisibleColumn : function(sheet, mincol, maxcol){
		var count = 0;
		for(var i = mincol; i <= maxcol; i++){
			if(this.isVisibleColumn(sheet, i)){
				count++;
			}
		}
		return count;
	},
	
	/*
	 * hide some rows
	 * @param {int} sheet: the sheet id
	 * @param {int} minrow: the min row index start to hide
	 * @param {int} maxrow: the max row index end to hide
	 * @param {boolean} suspendEvent: true to not fire event
	 */
	hideRow : function(sheet, minrow, maxrow, suspendEvent){		
		if(false !== this.fireEvent('beforehiderow', sheet, minrow, maxrow, this)){
			var visibles = [], data = this.getData(), sep = this.separateChar;
			for(var i = minrow; i <= maxrow; i++){
				if(this.isVisibleRow(sheet, i)){
					visibles.push(i);
				}
                var id = [sheet, i, 0].join(sep);
                var cell = data[id];
                if(!cell){
                    cell = {};
                    data[id] = [sheet, i, 0, cell];
                }else{
                    cell = cell[3];
                }
                cell.hidden = true;
                this.syncRowHeightCache(sheet, i);
			}

			if(!suspendEvent){
				this.fireEvent('hiderow', sheet, minrow, maxrow, this);
			}
			return visibles;
		}		
	},
	
	/*
	 * hide some columns
	 * @param {int} sheet: the sheet id
	 * @param {int} mincol: the min column index start to hide
	 * @param {int} maxcol: the max column index end to hide
	 * @param {boolean} suspendEvent: true to not fire event
	 */
	hideColumn : function(sheet, mincol, maxcol, suspendEvent){
		if(false !== this.fireEvent('beforehidecolumn', sheet, mincol, maxcol, this)){
			var visibles = [], data = this.getData(), sep = this.separateChar;
			for(var i = mincol; i <= maxcol; i++){
				if(this.isVisibleColumn(sheet, i)){
					visibles.push(i);
				}
                var id = [sheet, 0, i].join(sep);
                var cell = data[id];
                if(!cell){
                    cell = {};
                    data[id] = [sheet, 0, i, cell];
                }else{
                    cell = cell[3];
                }
                cell.hidden = true;
                this.syncColWidthCache(sheet, i);
			}
			if(!suspendEvent){
				this.fireEvent('hidecolumn', sheet, mincol, maxcol, this);
			}
			return visibles;
		}		
	},
	
	/*
	 * show some rows
	 */
	showRow : function(sheet, minrow, maxrow, suspendEvent){
		if(false !== this.fireEvent('beforeshowrow', sheet, minrow, maxrow, this)){
			var hiddens = [], data = this.getData(), sep = this.separateChar;
			for(var i = minrow; i <= maxrow; i++){
				if(!this.isVisibleRow(sheet, i)){
					hiddens.push(i);
				}
                var id = [sheet, i, 0].join(sep);
                var cell = data[id];
                if(!cell){
                    cell = {};
                    data[id] = [sheet, i, 0, cell];
                }else{
                    cell = cell[3];
                }
                cell.hidden = false;
                this.syncRowHeightCache(sheet, i);
			}
			if(!suspendEvent){
				this.fireEvent('showrow', sheet, minrow, maxrow, this);
			}
			return hiddens;
		}		
	},
	
	/*
	 * show some columns
	 */
	showColumn : function(sheet, mincol, maxcol, suspendEvent){
		if(false !== this.fireEvent('beforeshowcolumn', sheet, mincol, maxcol, this)){
			var hiddens = [], data = this.getData(), sep = this.separateChar;
			for(var i = mincol; i <= maxcol; i++){
				if(!this.isVisibleColumn(sheet, i)){
					hiddens.push(i);
				}
                var id = [sheet, 0, i].join(sep);
                var cell = data[id];
                if(!cell){
                    cell = {};
                    data[id] = [sheet, 0, i, cell];
                }else{
                    cell = cell[3];
                }
                cell.hidden = false;
                this.syncColWidthCache(sheet, i);             
			}
			if(!suspendEvent){
				this.fireEvent('showcolumn', sheet, mincol, maxcol, this);
			}
			return hiddens;
		}		
	},
	
	/*
	 * private
	 * get the config of border for a cell
	 * @param {string} dir: the direction of the border we are handling now, it need be one of [t, b, r, l]
	 * @param {int} width: the border width
	 * @param {string} style: the border style
	 * @param {string} color: the border color
	 * @param {boolean} flag: true to create the border, false to reset the border
	 */
	getBorderConfig : function(dir, width, style, color, flag){
		var o = {};
		var dp = this.defaultProperty;
		if(3 == width){	
			var brw = bbw = blw = btw = 1;
			if('solid' == style){
				brw = 2;
				bbw = 2;
			}
			/*
			 * save the real style as type, and set it to the cell property as bbt, blt, brt, btt
			 */
			var type = style;
			style = 'solid';			
			if('r' == dir){	
				if(flag){
					Ext.apply(o, {
						wrap:true,
						brw:brw,
						brt:type,
						brs:style,
						brc:color,						
						pr:1										
					});
				}else{
					Ext.apply(o, {						
						brw:dp.brw,
						pr:dp.pr,
						brt:false
					});
				}
			}else if('b' == dir){
				if(flag){
					Ext.apply(o, {	
						wrap:true,				
						bbw:bbw,
						bbt:type,
						bbs:style,
						bbc:color,					
						pb:1
					});
				}else{
					Ext.apply(o, {						
						bbw:dp.bbw,
						pb:dp.pb,
						bbt:false
					});	
				}				
			}else if('l' == dir){
				if(flag){
					Ext.apply(o, {
						wrap:true,
						blw:blw,
						blt:type,
						bls:style,
						blc:color,						
						pl:1
					});
				}else{
					Ext.apply(o, {					
						blw:dp.blw,
						pl:dp.pl,
						blt:false,
						blf:0
					});
				}
			}else if('t' == dir){
				if(flag){
					Ext.apply(o, {
						wrap:true,
						btw:btw,
						btt:type,
						bts:style,
						btc:color,						
						pt:1
					});
				}else{
					Ext.apply(o, {						
						btw:dp.btw,
						pt:pt,
						btt:false,
						btf:0
					});
				}
			}
		}else{			
			var brw = dp.brw+width-1, bbw = dp.bbw+width-1;
			var pb = dp.pb-width+1, pr = dp.pr-width+1, pt = dp.pt;
			if('r' == dir){
				if(flag){
					Ext.apply(o, {						
						brc:color,
						brs:style,
						brw:brw,
						brt:false,
						pr:pr					
					});
				}else{
					Ext.apply(o, {						
						brw:dp.brw,
						pr:dp.pr,
						brt:false
					});
				}
			}else if('b' == dir){
				if(flag){
					Ext.apply(o, {						
						bbc:color,
						bbs:style,
						bbw:bbw,
						bbt:false,
						pb:pb
					});
				}else{
					Ext.apply(o, {						
						bbw:dp.bbw,
						pb:dp.pb,
						bbt:false
					});					
				}				
			}else if('l' == dir){
				if(flag){
					Ext.apply(o, {						
						blw:dp.blw,
						pl:dp.pl,
						blc:color,
						bls:style,
						blt:false,
						/*
						 * save the actual width
						 */
						blf:width						
					});
				}else{
					Ext.apply(o, {						
						blw:dp.blw,
						pl:dp.pl,
						blt:false,
						blf:0
					});
				}				
			}else if('t' == dir){
				if(flag){
					Ext.apply(o, {						
						btw:dp.btw,
						pt:pt,
						btc:color,
						bts:style,
						btt:false,
						/*
						 * save the actual width
						 */
						btf:width
					});
				}else{
					Ext.apply(o, {						
						btw:dp.btw,
						pt:pt,
						btt:false,
						btf:0
					});
				}				
			}
		}
		return o;
	},
	
	/*
	 * set border for a cell, it may affect other cells near by
	 * @params {int} sheet: the sheet id
	 * @params {int} row: the row index for the cell
	 * @params {int} col: the column index for the cell
	 * @params {string} dir: the direction of border to set, should be one of ['l', 'r', 't', 'b']
	 * @params {int} width: the width of the border
	 * @params {string} style: the style of the border
	 * @params {string} color: the color of the border
	 * @params {boolean} suspendEvent: the flag to suspend the cellchange event
	 */
	setRangeBorder : function(sheet, row, col, config, suspendEvent){
		var o = {};
		for(var i = 0, len = config.length; i < len; i++){
			var it = config[i];
			Ext.apply(o, this.getBorderConfig(it.dir, it.width, it.style, it.color, it.flag));
		}
		if(0 == row && 0 == col){
			this.setWhole(sheet, o, null, suspendEvent);
		}else if(0 == row){
			this.setColumn(sheet, col, o, null, suspendEvent);
		}else if(0 == col){
			this.setRow(sheet, row, o, null, suspendEvent);
		}else{
			this.setCell(sheet, row, col, o, null, suspendEvent);
		}
	},	
	
	
	
	/*
	 * set column width, we not call setColumn to do this directly, cause there is some kind of padding issue need considerate when set width,
	 * so this function is provide an interface to set the column width to a non-negative value, you don't need care the details
	 * @params {int} sheet: the sheet id
	 * @param {int} col: the column index
	 * @param {int} width: the width of this column 
	 * @param {boolean} suspendCellChange: the flag to hold or fire "cellchange" event
	 * @param {boolean} suspendColChange: the flag to hold or fire "columnchange" event
	 */
	setColumnWidth : function(sheet, col, width, suspendCellChange, suspendColChange){
		if(0 < width){			
			var woff = 0;
			width -= this.cellWidthOffset;
			if(0 > width){
				woff = width;
				width = 0;
			}						
			
			this.setColumn(sheet, col, {			
				width:width,
				woff:woff
			}, null, suspendCellChange, suspendColChange, undefined, true);
		}
	},
	
	/*
	 * set row height, we not call setRow to do this directly, cause there is some kind of padding issue need considerate when set height,
	 * so this function is provide an interface to set the row height to a non-negative value, you don't need care the details
	 * @params {int} sheet: the sheet id
	 * @param {int} row: the row index
	 * @param {int} height: the height of this row 
	 * @param {boolean} suspendCellChange: the flag to hold or fire "cellchange" event
	 * @param {boolean} suspendRowChange: the flag to hold or fire "rowchange" event
	 */
	setRowHeight : function(sheet, row, height, suspendCellChange, suspendRowChange){
		if(0 < height){			
			var hoff = 0;
			height -= this.cellHeightOffset;
			if(0 > height){
				hoff = height;
				height = 0;
			}			
			this.setRow(sheet, row, {			
				height:height,
				hoff:hoff
			}, null, suspendCellChange, suspendRowChange, undefined, true);
		}
	},
	
	/*
	 * set row auto height, we not call setRow to do this directly, cause there is some kind of padding issue need considerate when set height,
	 * so this function is provide an interface to set the row height to a non-negative value, you don't need care the details
	 * @params {int} sheet: the sheet id
	 * @param {int} row: the row index
	 * @param {int} height: the height of this row 
	 * @param {boolean} suspendCellChange: the flag to hold or fire "cellchange" event
	 * @param {boolean} suspendRowChange: the flag to hold or fire "rowchange" event
	 */
	setRowAutoHeight : function(sheet, row, height, suspendCellChange, suspendRowChange){
		if(0 < height){			
			var hoff = 0;
			height -= this.cellHeightOffset;
			if(0 > height){
				hoff = height;
				height = 0;
			}			
			this.setRow(sheet, row, {			
				autoHeight:height,
				hoff:hoff
			}, ['height'], suspendCellChange, suspendRowChange, undefined, true);
		}
	},
	
	/*
	 * transfer the whole data to a [sheet, row, col, property, value] array
	 */
	disassembleData : function(){
		var arr = [];
		this.each(function(rd){
			var data = rd.data;
			var sheet = data.sheet, row = data.row, col = data.col, json = data.json; 
			for(var p in json){
				arr.push([sheet, row, col, p, json[p]]);
			}
		}, this);
		return arr;
	},
	
	/*
	 * walk all non-empty cells in the sheet except the [0, 0] cell
	 * @param {int} sheet: the sheet id	 
	 * @param {function} fn: the callback function, it will be called for every non-empty cell, with rd and this as params
	 * @param {object} scope: the scope of the callback fn
	 */
	walkWhole : function(sheet, fn, scope){
		var ret;
		this.each(function(rd, internalId){
			if(rd.data.sheet == sheet && !(0 === rd.data.row && 0 === rd.data.col)){				
				ret = fn.call(scope, rd, [sheet, 0, 0, 0, 0], this, internalId);
				
				return ret;
			}
		}, this);	
		/*
		 * a trick to create a [0, 0] cell if not exist
		 */
		var id = this.getIdBasedData({sheet:sheet, row:0, col:0});
		var c = this.getByMapId(id);
		if(!c){
			/*
			 * fake an empty rd
			 */
			var rd = {
				data: {
					'sheet': sheet,
					'row': 0,
					'col': 0,
					'json': {}
				}
			};
			return fn.call(scope, rd, [sheet, 0, 0, 0, 0], this, id);
		}else{
            return fn.call(scope, c, [sheet, 0, 0, 0, 0], this, id);
		}
		return ret;
	},
	
	/*
	 * walk all non-empty cells in the row except the [row, 0] cell
	 * @param {int} sheet: the sheet id
	 * @param {int} minRow: the min row
	 * @param {int} maxRow: the max row
	 * @param {int} minCol: the min column
	 * @param {function} fn: the callback function, it will be called for every non-empty cell, with rd and this as params
	 * @param {object} scope: the scope of the callback fn
	 */
	walkRow : function(sheet, minRow, maxRow, minCol, fn, scope, coverFn){
		minCol = minCol || 0;	
		var ret, cols = [];
		this.each(function(rd, internalId){
			var row = rd.data.row, col = rd.data.col;
			if(rd.data.sheet === sheet && 0 !== col && row >= minRow && maxRow >= row && minCol <= col){
				ret = fn.call(scope, rd, [sheet, minRow, 0, maxRow, 0], this, internalId);
				return ret;
			}
		}, this);	
		/*
		 * means stop walking
		 */
		if(false === ret){
			return false;
		}
		if(coverFn){
			/*
			 * for empty cells but with column setting, we need check
			 */
			this.each(function(rd){
				var row = rd.data.row, col = rd.data.col;
				if(rd.data.sheet === sheet && 0 === row){
					if(coverFn.call(scope, rd)){
						cols.push(col);
					}
				}
			}, this);
			
			for(var i = 0, len = cols.length; i < len; i++){
				var col = cols[i];
				for(var j = minRow; j <= maxRow; j++){
					var id = this.getIdBasedData({sheet:sheet, row:j, col:col});
					if(!this.getByMapId(id)){
						/*
						 * fake an empty rd
						 */
						var rd = {
							data: {
								'sheet': sheet,
								'row': j,
								'col': col,
								'json': {}
							}
						};
						if(false === fn.call(scope, rd, [sheet, minRow, 0, maxRow, 0], this, id)){
							return false;
						}
					}
				}
			}
		}
		/*
		 * a trick to create a [row, 0] cell if not exist
		 */
		for(var i = minRow; i <= maxRow; i++){
			var id = this.getIdBasedData({sheet:sheet, row:i, col:0});
			var c = this.getByMapId(id);
			if(!c){
				/*
				 * fake an empty rd
				 */
				var rd = {
					data: {
						'sheet': sheet,
						'row': i,
						'col': 0,
						'json': {}
					}
				};
				if(false === fn.call(scope, rd, [sheet, minRow, 0, maxRow, 0], this, id)){
					return false;
				}
			}else{				
				if(false === fn.call(scope, c, [sheet, minRow, 0, maxRow, 0], this, id)){
					return false;
				}
			}
		}	
		return ret;
	},
	
	/*
	 * walk all non-empty cells in the column except the [0, col] cell
	 * @param {int} sheet: the sheet id
	 * @param {int} minCol: the min col
	 * @param {int} maxCol: the max col
	 * @param {int} minRow: the min row
	 * @param {function} fn: the callback function, it will be called for every non-empty cell, with rd and this as params
	 * @param {object} scope: the scope of the callback fn
	 */
	walkColumn : function(sheet, minCol, maxCol, minRow, fn, scope, coverFn){
		minRow = minRow || 0;
		
		var ret, rows = [];
		this.each(function(rd, internalId){
			var col = rd.data.col, row = rd.data.row;
			if(rd.data.sheet == sheet && 0 !== row && col >= minCol && col <= maxCol && minRow <= row){
				ret = fn.call(scope, rd, [sheet, 0, minCol, 0, maxCol], this, internalId);
				return ret;
			}
		}, this);	
		/*
		 * means stop walking
		 */
		if(false === ret){
			return false;
		}
		if(coverFn){
			/*
			 * for empty cells but with column setting, we need check
			 */
			this.each(function(rd){
				var row = rd.data.row, col = rd.data.col;
				if(rd.data.sheet === sheet && 0 === col){
					if(coverFn.call(scope, rd)){
						rows.push(row);
					}
				}
			}, this);
			
			for(var i = 0, len = rows.length; i < len; i++){
				var row = rows[i];
				for(var j = minCol; j <= maxCol; j++){
					var id = this.getIdBasedData({sheet:sheet, row:row, col:j});
					if(!this.getByMapId(id)){
						/*
						 * fake an empty rd
						 */
						var rd = {
							data: {
								'sheet': sheet,
								'row': row,
								'col': j,
								'json': {}
							}
						};
						if(false === fn.call(scope, rd, [sheet, 0, minCol, 0, maxCol], this, id)){
							return false;
						}
					}
				}
			}
		}
		/*
		 * a trick to create a [row, 0] cell if not exist
		 */
		for(var i = minCol; i <= maxCol; i++){
			var id = this.getIdBasedData({sheet:sheet, row:0, col:i});
			var c = this.getByMapId(id);
			if(!c){				
				/*
				 * fake an empty rd
				 */
				var rd = {
					data: {
						'sheet': sheet,
						'row': 0,
						'col': i,
						'json': {}
					}
				};
				if(false === fn.call(scope, rd, [sheet, 0, minCol, 0, maxCol], this, id)){
					return false;
				}				
			}else{
				if(false === fn.call(scope, c, [sheet, 0, minCol, 0, maxCol], this, id)){
					return false;
				}
			}
		}
		return ret;
	},
	
	/*
	 * walk all non-empty cells in the range passed
	 * @param {array} ranges: the ranges is an array of range items, every range item is 
	 * a 5 length array [sheet, minrow, mincol, maxrow, maxcol] too, such as: [0, 1, 1, 2, 2]
	 * @param {function} fn: the callback function, it will be called for every non-empty cell, with rd and this as params
	 * @param {object} scope: the scope of the callback fn
	 * @param {boolean} skipEmpty: true to skip the empty cells, or create them in cell range
     * @param {boolean} ignore: true then need walkWhole, walkColumn and walkRow
	 */
	walkRange : function(ranges, fn, scope, skipEmpty, coverFn, ignore){
		var sheetLookup = this.getSheetLookup();
		for(var i = 0, len = ranges.length; i < len; i++){
			var span = ranges[i];
			var s = span[0];
			if(0 === span[1] && 0 === span[2] && !ignore){
				/*
				 * for whole sheet range
				 */
				if(false === this.walkWhole(s, fn, scope)){
					return;
				}
			}else if(0 === span[3] && !ignore){
				/*
				 * for column range
				 */				
				if(false === this.walkColumn(s, span[2], span[4], span[1], fn, scope, coverFn)){
					return;
				}							
			}else if(0 === span[4] && !ignore){
				/*
				 * for row range
				 */				
				if(false === this.walkRow(s, span[1], span[3], span[2], fn, scope, coverFn)){
					return;
				}				
			}else{
				for(var r = span[1]; r <= span[3]; r++){
					for(var c = span[2]; c <= span[4]; c++){
						var id = this.getIdBasedData({sheet:s, row:r, col:c});
						var rd = this.getByMapId(id);
						if(!skipEmpty && !rd){
							//rd = this.newRecord(s, r, c);
							/*
							 * fake an empty one
							 */
							rd = {data:{
								'sheet':s,
								'row':r,
								'col':c,
								'json':{}
							}};
						}
						if(rd){
							if(false === fn.call(scope, rd, span, this, id)){
								return;
							}
						}						
					}
				}
			}			
		}
	},
	
	/*
	 * with broken merged cell
	 */
	withBrokenMergedCell : function(coord){
		var withBroken = false;
		this.walkRange(coord, function(rd, span){
			var json = rd.data.json;
			if(this.isMergedCell(rd.data.json, rd.data.sheet, rd.data.row, rd.data.col)){
				var minrow = rd.data.row+json.minrow;
				var maxrow = rd.data.row+json.maxrow;
				var mincol = rd.data.col+json.mincol;
				var maxcol = rd.data.col+json.maxcol;
				withBroken = !(
					(0 == span[1] || span[1] <= minrow) && (0 == span[2] || span[2] <= mincol) && 
					(0 == span[3] || span[3] >= maxrow) && (0 == span[4] || span[4] >= maxcol)
				);
				if(withBroken){					
					return false;
				}				
			}
		}, this, true);
		return withBroken;
	},
	
	
	withBrokenTplCell : function(coord){
		var withBroken = false, tpls = {};
		this.walkRange(coord, function(rd, span){
			var json = rd.data.json;
			if(json.tpl && !tpls[json.tpl]){
				tpls[json.tpl] = true;
				var tpl = Ext.decode(json.tpl);
				var minrow = tpl.span[1];
				var maxrow = tpl.span[3];
				var mincol = tpl.span[2];
				var maxcol = tpl.span[4];
				withBroken = !(
					(0 == span[1] || span[1] <= minrow) && (0 == span[2] || span[2] <= mincol) && 
					(0 == span[3] || span[3] >= maxrow) && (0 == span[4] || span[4] >= maxcol)
				);
				if(withBroken){					
					return false;
				}				
			}
		}, this, true);
		return withBroken;
	},
	
	/*
	 * init sheets, create 3 default sheet in store
	 */
	initSheets : function(){
		this.sheets = [];
		for(var i = 0, len = this.defaultSheetNumber; i < len; i++){
			var name = 'Sheet'+(i+1);
			this.sheets.push({
				id:i,
				name:name,
                loaded: true
			});			
		}		
	},
	
	/*
	 * get sheet object by id
	 */
	getSheetById : function(sheetId){
		var sheets = this.getSheets();
		for(var i = 0, len = sheets.length; i < len; i++){
			var sheet = sheets[i];
			if(sheet.id == sheetId){
				return sheet;
			}
		}
	},
           
    getSheetLookup : function(){
        var sheets = this.getSheets(), lookup = {};
        for(var i = 0, len = sheets.length; i < len; i++){
            var sheet = sheets[i];
            lookup[sheet.id] = sheet;
        }
        return lookup;
    },
           
    /**
     * update a mark map for loaded empty cells
     */
    updateLoadedEmptyCells : function(posLookup, sheetLookup, ranges){
        var separateChar = this.separateChar;
        sheetLookup = sheetLookup || this.getSheetLookup();
        for(var p in posLookup){
            if(posLookup.hasOwnProperty(p)){
                var it = posLookup[p], s = it[0];
                var sheetObj = sheetLookup[s];
                sheetObj.loadedEmptyCells = sheetObj.loadedEmptyCells || {};
                var map = sheetObj.loadedEmptyCells;
                map[p] = true;
            }
        }
        for(var i = 0, len = ranges.length; i < len; i++){
            var span = ranges[i], s = span[0];
            if(0 === span[1] && 0 !== span[2]){
                var sheetObj = sheetLookup[s];
                sheetObj.loadedEmptyCells = sheetObj.loadedEmptyCells || {};
                var map = sheetObj.loadedEmptyCells;
                for(var j = span[2]; j <= span[4]; j++){
                    var id = [s, 0, j].join(separateChar);
                    map[id] = true;
                }
            }else if(0 !== span[1] && 0 === span[2]){
                var sheetObj = sheetLookup[s];
                sheetObj.loadedEmptyCells = sheetObj.loadedEmptyCells || {};
                var map = sheetObj.loadedEmptyCells;
                for(var j = span[1]; j <= span[3]; j++){
                    var id = [s, j, 0].join(separateChar);
                    map[id] = true;
                }
            }
        }
    },
	
	/*
	 * get sheet name based on sheet id
	 */
	getSheetNameById : function(sheetId){
		var sheets = this.getSheets();
		for(var i = 0, len = sheets.length; i < len; i++){
			var sheet = sheets[i];
			if(sheet.id == sheetId){
				return sheet.name;			
			}
		}
	},
	
	/*
	 * get sheet id based on sheet name
	 * @param {string} sheetName: the name of sheet to find the id
	 * @param {boolean} exactMatch: if not true then treat 'sheet1' and "sheet1" as sheet1
	 */
	getSheetIdByName : function(sheetName, exactMatch, checkLastOldName){
        // for case: 'sheet1 ' -> 'sheet1'
        // maybe we'd better check tab name - space should be something
        // TODO		
		var fchar = sheetName.charAt(0), lchar = sheetName.charAt(sheetName.length-1);
		if(('"' === fchar && '"' === lchar) || ("'" === fchar && "'" === lchar)){
			sheetName = sheetName.slice(1, sheetName.length-1);
		}

		sheetName = Ext.String.trim(sheetName.toUpperCase());
		var sheets = this.getSheets();
		for(var i = 0, len = sheets.length; i < len; i++){
			var sheet = sheets[i];
			var name = Ext.String.trim(sheet.name.toUpperCase());
			if(sheetName === name){
				return sheet.id;
			}else if(!exactMatch && ('"'+name+'"' == sheetName || "'"+name+"'" == sheetName)){
				return sheet.id;
			}
			if(checkLastOldName && Ext.isDefined(sheet.lastOldName)){
				name = Ext.String.trim(sheet.lastOldName.toUpperCase());
				if(sheetName === name){
					return sheet.id;
				}else if(!exactMatch && ('"'+name+'"' == sheetName || "'"+name+"'" == sheetName)){
					return sheet.id;
				}
			}
		}
	},
	
	/*
	 * get all sheets in the store
	 */
	getSheets : function(){
		return this.sheets;
	},
	
	/*
	 * sort the span
	 * @param {array} span: the span array
	 * @param {array} keys: the keys array use to sort
	 * @param {string} dir: the sort direction, can be ASC/DESC
	 * @param {string} sortOn: can be row/col
	 * @param {boolean} expand: true to move whole row/col after sort
	 * @param {boolean} allString: true to treat all values as string
	 * @param {boolean} suspendEvent: true to not fire event
	 */
	sortSpan : function(span, keys, dir, sortOn, expand, allString, suspendEvent, suspendPull){
		if(suspendEvent || false !== this.fireEvent('beforesortspan', span, keys, dir, sortOn, expand, allString, this)){
			this.fireEvent('preparesortspan', span, keys, dir, sortOn, expand, allString, this);
			var diff;
			if('row' == sortOn){
				diff = this.sortSpanOnRow(span, keys, dir, expand, allString);
			}else{
				diff = this.sortSpanOnColumn(span, keys, dir, expand, allString);
			}
            if(expand){
                this.resetRowHeightColWidthCache(span[0]);
            }
			if(!suspendEvent){
				this.fireEvent('sortspan', span, keys, dir, sortOn, expand, allString, diff, this);
			}	
			this.fireEvent('aftersortspan', span, keys, dir, sortOn, expand, allString, diff, this);
			this.syncMaxRowColOfSheet(span[0]);
			return diff;
		}		
	},
	
	/*
	 * sort the span on column
	 * @param {array} span: the span array
	 * @param {array} keys: the keys array use to sort
	 * @param {string} dir: the sort direction, can be ASC/DESC
	 * @param {boolean} expand: true to move whole row after sort
	 * @param {boolean} allString: true to treat all values as string
	 */
	sortSpanOnColumn : function(span, keys, dir, expand, allString){

		span = [].concat(span);
		var sheet = span[0], minrow = span[1], mincol = span[2], maxrow = span[3], maxcol = span[4];
		
		/*
		 * for sort key, here we just implement a very simple situation
		 */
		var sortKey = mincol;
		if(keys && 0 < keys.length){
			sortKey = keys[0];
		}
		var values = {}, indexs = [];
		
		var range;
		if(0 == minrow && 0 == mincol){
			/*
			 * the whole sheet
			 */			
		}else if(0 == maxrow || minrow != maxrow){
			/*
			 * columns
			 */		
			
			range = [[sheet, minrow, sortKey, maxrow, sortKey]];					
		}
		if(range){
			var start = false;
			this.walkRange(range, function(rd){
				if(0 !== rd.data.row){
					var o = this.getCellData(rd.data.sheet, rd.data.row, rd.data.col);
					if(false != SCOM.typeOf(o.data)){
						if(false === start){
							start = rd.data.row
						}else if(start > rd.data.row){
							start = rd.data.row;
						}
						values[rd.data.row] = o.data;
						indexs.push(rd.data.row);
					}					
				}				
			}, this, true);
			indexs = this.sortIndexByValue(indexs, values, dir, allString);
			if(false === start){
				start = 1;
			}
			start = 0 == minrow ? start : minrow;					
			/*
			 * arrange rows based on the indexs
			 */
			return this.arrangeRows(start, indexs, expand, sheet, minrow, mincol, maxrow, maxcol);
		}		
	},
	
	/*
	 * sort the span on row
	 * @param {array} span: the span array
	 * @param {array} keys: the keys array use to sort
	 * @param {string} dir: the sort direction, can be ASC/DESC
	 * @param {boolean} expand: true to move whole col after sort
	 * @param {boolean} allString: true to treat all values as string
	 */
	sortSpanOnRow : function(span, keys, dir, expand, allString){
		
	},
	
	/*
	 * _private, sort the indexs array based on values
	 * @param {array} indexs: the indexs array to sort
	 * @param {object} values: the values of indexs
	 * @param {string} dir: the sort direction, can be ASC/DESC
	 * @param {boolean} allString: true to treat all values as string
	 */
	sortIndexByValue : function(indexs, values, dir, allString){
		var fn;
		if('desc' == dir || 'DESC' == dir){
			fn = function(a, b){
				var va = values[a], vb = values[b];			
				if(!allString && SCOM.canbeNumber(va) && SCOM.canbeNumber(vb)){
					var na = Number(va), nb = Number(vb);
					return nb-na;
				}else{
					va = va.toString();
					vb = vb.toString();
					return va > vb ? -1 : (va < vb ? 1 : 0);
				}			
			}
		}else{
			fn = function(a, b){
				var va = values[a], vb = values[b];			
				if(!allString && SCOM.canbeNumber(va) && SCOM.canbeNumber(vb)){
					var na = Number(va), nb = Number(vb);
					return na-nb;
				}else{
					va = va.toString();
					vb = vb.toString();
					return va > vb ? 1 : (va < vb ? -1 : 0);
				}			
			};
		}
		indexs.sort(fn);
		
		return indexs;
	},
	
	/*
	 * arrange the rows based on the sorted array and start at "start" row
	 * @param {int} start: the start row number to arrange
	 * @param {array} sorted: the sorted array to arrange
	 * @param {boolean} expand: true to move the whole row not just the span part
	 * @param {int} sheet: the sheet id of the span
	 * @param {int} minrow: the min row index of the span
	 * @param {int} mincol: the min column index of the span
	 * @param {int} maxrow: the max row index of the span
	 * @param {int} maxcol: the max column index of the span
	 */
	arrangeRows : function(start, sorted, expand, sheet, minrow, mincol, maxrow, maxcol){				
		var data = this.getData();
		/*
		 * create a temp cache to hold these sort changed records
		 */
        var cache = {};
		/*
		 * step 1, first save the moved records in cache, and then changed the taken record's row to moved record's row
		 */		
		var cursor = 0, len = sorted.length, limit = start+len, lookup = {};
		for(var i = 0; i < len; i++){
			var oldNo = sorted[i], newNo = i+start;
			if(oldNo !== newNo){	
				/*
				 * add to lookup for quick look
				 */
				lookup[oldNo] = true;
				/*
				 * first save all oldNo row cells in the cache
				 * and then remove them from data
				 */
				var oldIndexs = this.getRecordIndexs(sheet, oldNo, expand?0:mincol, oldNo, maxcol);				
				for(var j = 0, count = oldIndexs.length; j < count; j++){
					var k = oldIndexs[j];
					var rd = data[k];
					cache[newNo] = cache[newNo] || [];
					/*
					 * save the index and the record
					 */
					cache[newNo].push([k, rd]);
					/*
					 * delete the old map
					 */
					delete(data[k]);
					/*
					 * set this record as pending record, so getRecordIndexs will skip it
					 */
					rd[3].pending = true;
				}														
			}
		}	
		
		/*
		 * diff is an obj to hold the switched row pair, such as: 1:3
		 */
		var diff = {}, separateChar = this.separateChar;
		/*
		 * setp 2, find a place to put the rows not in sorted array
		 */			
		for(var i = 0; i < len; i++){
			var oldNo = sorted[i], newNo = i+start;
			if(oldNo !== newNo && !lookup[newNo]){
				var newIndexs = this.getRecordIndexs(sheet, newNo, expand?0:mincol, newNo, maxcol);
				var no;
				for(; cursor < len; cursor++){
					if(sorted[cursor] >= limit){
						no = sorted[cursor];
						cursor++;
						break;
					}
				}
				no = Number(no);
				/*
				 * save the switch to diff
				 */
				diff[no] = newNo;
				for(var j = 0, count = newIndexs.length; j < count; j++){
					var k = newIndexs[j], it = data[k];
					/*
					 * delete the old map
					 */
					delete(data[k]);
					it[1] = no;
					var newId = [it[0], it[1], it[2]].join(separateChar);

					/*
					 * set the new map
					 */
					data[newId] = it;
				}
			}
		}		
		/*
		 * setp 3, put the rows in cache to the sorted position
		 */
		for(var p in cache){			
			var arr = cache[p];
			for(var i = 0, len = arr.length; i < len; i++){
				var it = arr[i], index = it[0], rd = it[1];
				
				rd[1] = Number(p);
				var newId = [rd[0], rd[1], rd[2]].join(separateChar);

				/*
				 * set the new map
				 */
				data[newId] = rd;
				delete(rd[3].pending);
			}			
		}
		
		/*
		 * save the switch to diff
		 */
		for(var i = 0, len = sorted.length; i < len; i++){
			var j = start+i;
			if(j !== sorted[i]){
				diff[j] = sorted[i];
			}
		}		
		return diff;
	},
	
	/*
	 * change the row index to move the rows
	 * @param {boolean} keyAsSource: true means the index property in diff is source
	 */
	moveRows : function(sheet, diff, mincol, maxcol, keyAsSource, suspendPull){		
		mincol = mincol || 0;
		maxcol = maxcol || 0;
		var data = this.getData();
		/*
		 * use cache to hold the newId for map
		 */
		var cache = {}, separateChar = this.separateChar;
		for(var p in diff){
			var source, dest;
			if(keyAsSource){
				source = Number(p);
				dest = Number(diff[p]);
			}else{
				source = Number(diff[p]);
				dest = Number(p);
			}
			var sourceIndexs = this.getRecordIndexs(sheet, source, mincol, source, maxcol);			
			for(var j = 0, count = sourceIndexs.length; j < count; j++){
				var k = sourceIndexs[j];
				var rd = data[k];
				/*
				 * delete the old map
				 */
				delete(data[k]);
				/*
				 * set this record as pending record, so getRecordIndexs will skip it
				 */
                rd[3].pending = true;
				/*
				 * change the row index to the dest
				 */
				rd[1] = dest;
				var newId = [rd[0], rd[1], rd[2]].join(separateChar);
				cache[newId] = {index:k, rd:rd};							
			}
		}
		for(var p in cache){
			var rd = cache[p].rd;
			delete(rd[3].pending);

			/*
			 * set the new map
			 */
			data[p] = rd;
		}		
		/*
		 * fire moverows event
		 */
		this.fireEvent('moverows', sheet, diff, mincol, maxcol, keyAsSource, this);
		this.syncMaxRowColOfSheet(sheet);
	},
	
	/*
	 * _private
	 */
	getRecordIndexs : function(sheet, minrow, mincol, maxrow, maxcol){		
		/*
		 * keep index of the records
		 */
		var indexs = [];		
		var data = this.getData();
		for(var p in data){
            if(data.hasOwnProperty(p)){
                var it = data[p];
                if(!it[3].pending){
                    /*
                     * skip the pending record
                     */
                    var s = it[0], r = it[1], c = it[2];
                
                    if(s === sheet && 
                		(0 === minrow || (minrow <= r && r <= maxrow)) && (0 === mincol || (mincol <= c && c <= maxcol))){
                        indexs.push(p);
                    }
                }
            }
		}
		return indexs;
	},
	
	/*
	 * get the mixCollection
	 */
	getData : function(){
        if(!this.data){
            this.data = {};
        }
        return this.data;
	},		
	
	/*
	 * set the mixCollection
	 */
	setData : function(data){		
		this.data = data;
	},
        
    /**
     * loop all items
     */
    each : function(callback, scope){
        var data = this.getData();
        for(var p in data){
            if(data.hasOwnProperty(p)){
                var it = data[p];
                var o = {
                    'data': {
                        'sheet': it[0],
                        'row': it[1],
                        'col': it[2],
                        'json': it[3]
                    }
                };
                callback.call(scope, o, p);
            }
        }
    },
           
    queryBy : function(callback, scope){
        var arr = [];
        var data = this.getData();
        for(var p in data){
            if(data.hasOwnProperty(p)){
                var it = data[p];
                var o = {
                    'data': {
                        'sheet': it[0],
                        'row': it[1],
                        'col': it[2],
                        'json': it[3]
                    }
                };
                if(true === callback.call(scope, o)){
                    arr.push(o);
                }
            }
        }
        return arr;
    },
           
    /**
     * loop all items
     */
    eachCal : function(callback, scope){
        var lookup = this.getCalLookup(), data = this.getData(), separateChar = this.separateChar;
        for(var p in lookup){
            if(lookup.hasOwnProperty(p)){
                var it = lookup[p];
                var id = [it[0], it[1], it[2]].join(separateChar);
                if(data.hasOwnProperty(id)){
                    var o = {
                        'data': {
                            'sheet': it[0],
                            'row': it[1],
                            'col': it[2],
                            'json': it[3]
                        }
                    };
                    callback.call(scope, o);
                }
            }
        }
    },
	
	/*
	 * backup and recover the mixCollection
	 */
	backupData : function(){
		var data = this.getData();
        return SCOM.copy(data);
	},
	
	/*
	 * recover the passed data
	 */
	recoverData : function(copy){
		if(this.data){
			Ext.apply(this.data, copy);
		}
	},		
		
	/*
	 * get row/col groups of the passed sheet
	 */
	getGroupsBySheetId : function(sheetId){
		var groups = {};
		if(this.floatings){			
			for(var p in this.floatings){
				if(this.floatings.hasOwnProperty(p)){
					var it = this.floatings[p];
					if(sheetId == it.sheet){
						if('rowGroups' == it.name){
							groups['rowGroups'] = it.json;
						}else if('colGroups' == it.name){
							groups['colGroups'] = it.json;
						}
					}				
					if(groups['rowGroups'] && groups['colGroups']){
						return groups;
					}
				}
			}
		}
		return groups;
	},
	
	/*
	 * get floors of the passed sheet
	 */
	getFloorsBySheetId : function(sheetId){
		var floors = [];
		if(this.floatings){		
			for(var p in this.floatings){
				if(this.floatings.hasOwnProperty(p)){
					var it = this.floatings[p];
					if(sheetId == it.sheet){
						if('rowGroups' != it.name && 'colGroups' != it.name && 'colHiddens' != it.name && 'rowHiddens' != it.name){
							floors.push(Ext.decode(it.json));
						}
					}
				}
			}
		}
		return floors;
	},
	
	getFloorById : function(name, sheetId){
		if(this.floatings){
			var id = name+this.separateChar+sheetId;
			var it = this.floatings[id];
			if(it){
				return Ext.decode(it.json);
			}
			return it;
		}
	},
	
	/*
	 * get floating item by name and sheet
	 */
	getFloatingById : function(name, sheetId){
		if(this.floatings){
			var id = name+this.separateChar+sheetId;
			var it = this.floatings[id];
			if(it){
				return SCOM.copy(it);
			}
			return it;
		}
	},
           
    /*
     * get floating item by name and sheet
     */
    getFileConfigById : function(name, ctype){
        if(this.fileConfig){
            var id = name+this.separateChar+ctype;
            var it = this.fileConfig[id];
            if(it){
                return SCOM.copy(it);
            }
            return it;
        }
    },
        
	
	/*
	 * get condtion by id
	 */
	getConditionById : function(name, sheetId){
		if(this.floatings){
			var id = name+this.separateChar+sheetId;
			var it = this.floatings[id];
			if(it){
				return it.jsonObj || Ext.decode(it.json);
			}			
		}
	},
	
	/**
	 * get condtion by sheet
	 */
	getConditionBySheet : function(sheetId){
		var arr = [];
		if(this.floatings){
			for(var p in this.floatings){
				if(this.floatings.hasOwnProperty(p)){
					var it = this.floatings[p];
					if(it && it.sheet == sheetId && 'cdt' == it.ftype){
						arr.push(it.jsonObj || Ext.decode(it.json));
					}
				}
			}
		}
        return arr;           
	},
           
    getConditionObjsByName : function(name){
        var arr = [];
        if(this.floatings){
            for(var p in this.floatings){
                if(this.floatings.hasOwnProperty(p)){
                    var it = this.floatings[p];
                    if(it && 'cdt' == it.ftype && (!name || it.cdtName === name)){
                        arr.push({
                            cdt: it.jsonObj || Ext.decode(it.json),
                            sheetId: it.sheet
                        });
                    }
                }
            }            
        }
        return arr;
    },
	
	/**
	 * get condtion by sheet
	 */
	getValidationBySheet : function(sheetId){
		var arr = [];
		if(this.floatings){
			
			for(var p in this.floatings){
				if(this.floatings.hasOwnProperty(p)){
					var it = this.floatings[p];
					if(it && it.sheet == sheetId && 'cdt' == it.ftype){
						var json = Ext.decode(it.json);
						if('vd' == json.name){
							var opt = json.opt;
							opt.id = it.name;
							opt.coord = json.rng;
							arr.push(opt);
						}
					}
				}
			}			
			return arr;
		}
	},
	
	/*
	 * get floating by sheet
	 */
	getFloatingBySheet : function(sheetId, ftype){
		var arr = [];
		if(this.floatings){
			for(var p in this.floatings){
				if(this.floatings.hasOwnProperty(p)){
					var it = this.floatings[p];
					if(it && it.sheet == sheetId && ftype == it.ftype){
						arr.push(it);
					}
				}
			}			
			return arr;
		}
	},
	
	/*
	 * walk through floatings
	 */
	eachFloating : function(fn, scope){
		if(this.floatings){
			for(var p in this.floatings){
				if(this.floatings.hasOwnProperty(p)){
					var it = this.floatings[p];					
					if(false === fn.call(scope, it)){
						return;
					}
				}
			}
		}
	},
	
	/*
	 * check a sheet is loaded or not
	 */
	isLoadedSheet : function(sheetId){
		var sheet = this.getSheetById(sheetId);
		if(sheet){
			return sheet.loaded;
		}		
		return false;
	},
	
	isAllCellLoadedInSheet : function(sheetId){
		var sheet = this.getSheetById(sheetId);
		if(sheet){
			return sheet.allCellDataLoaded;
		}		
		return false;
	},
	
	loadMore : function(activeSheetId, startCellId, total, callback, scope, skipCal, message){
        var me = this, data = this.getData();
                
		Ext.Ajax.request({
    		timeout: SCONST['PULLING_TIMEOUT'],
    		url: this.loadMoreUrl,
    		params: {
                fileId: this.fileId,
    			sheetId: activeSheetId,
    			startCellId: startCellId,
    			size: this.limitCellNumAtSingleLoad,
                skipCal: skipCal
    		},
    		success: function(response, options){
                var dataMap = this.getData();
    			var json = Ext.decode(response.responseText);
                var separateChar = this.separateChar;
		        if (true === json.success || 'true' === json.success) {			        			        			            
		            startCellId = json.startCellId;
	    			var me = this,
                        records  = me.reader.read(json.results);
                    var recLen = records.length;
                    if(skipCal){
                         for(var i = 0; i < recLen; i++){
                            var it = records[i];
                            if(!it[3].cal){
                            	var cid = [it[0], it[1], it[2]].join(separateChar);
                                if(!dataMap[cid]){
                                    dataMap[cid] = it;
                                }else{
                                    recLen--;
                                }
                            }
                         }
                    }else{
                        newRecs = records;
                        me.loadRecords(newRecs, { addRecords: true });
                    }
	    			
                    var sheetObj = me.getSheetById(activeSheetId);
                    
                    sheetObj.currentCellCount += recLen;
                    this.fireEvent('loadingmore', activeSheetId, this);
                         
	    			if(startCellId != 0){
	    				/*
	    				 * means need load more
	    				 */
	    				me.loadMore(activeSheetId, startCellId, total, callback, scope, skipCal, message);
	    			}else{
	    				if(callback){
	    					callback.call(scope, true);
	    				}
	    			}
		        }
                
    		},
    		failure: function(response){
            	if(callback){
                	callback.call(scope, false);
                }
            },
    		scope: this
		});
	},
           
    /**
     * load floatings for sheet
     */
    loadFloatingsBySheetId : function(sheetId, callback, scope, startElementId, _floatingsArr){
        var me = this, sheetObj = this.getSheetById(sheetId);
        if(!Ext.isArray(_floatingsArr)){
           _floatingsArr = [];
        }
        Ext.Ajax.request({
            timeout: SCONST['PULLING_TIMEOUT'],
            url: this.loadFloatingsUrl,
            params: {
                fileId: this.fileId,
                sheetId: sheetId,
                startElementId: startElementId,
                size: this.limitCellNumAtSingleLoad
            },
            success: function(response, options){
                var json = Ext.decode(response.responseText);
                            
                if (true === json.success || 'true' === json.success) {
                    startElementId = json.startElementId;
                    var floatings = json.results;
                    _floatingsArr = _floatingsArr.concat(floatings);
                         
                    sheetObj.currentCellCount += floatings.length;
                    me.fireEvent('loadingmore', sheetId, me);
                         
                    if(startElementId != 0){
                        /*
                         * means need load more
                         */
                        me.loadFloatingsBySheetId(sheetId, callback, scope, startElementId, _floatingsArr);
                    }else{
                        if(callback){
                            callback.call(scope, true, _floatingsArr);
                        }
                    }
                }
            },
            failure: function(response){
                if(callback){
                    callback.call(scope, false);
                }
            },
            scope: this
        });
    },
	
	/*
	 * extend load function to add callback to get the message property
	 */
	load : function(options){
        /*
         * a flag for loading file
         */
        this._loadingFlag = true;
		options = options || {};
		
		var me = this;		
		var callback = options.callback, scope = options.scope;
		options.callback = function(operation, successful, response){
            if(!successful){
                if(callback){
                    callback.apply(scope, [me], false);
                }
                return;
            }
            var json = Ext.decode(response.responseText);
			var total = json.total;
            var message = json.message, results = json.results;
           
            this.loadRecords(this.reader.read(results));
           
			var startCellId;
			if(message && Ext.isDefined(message.startCellId)){
				startCellId = message.startCellId;
			}
            var recLen = results ? results.length : 0;
            /*
             * load more cells until all cells loaded
             */
            me.readSheets(message.sheets);
            delete(message.sheets);
            var activeSheetId = me.getActivedSheetId();
            message.loadSheetId = activeSheetId; 
            var sheetObj = me.getSheetById(activeSheetId);
            /*
             * for count
             */
            sheetObj.currentCellCount = recLen;
            sheetObj.currentFloatingCount = 0;
            sheetObj.totalFloatingCount = message.floatingTotal;
            sheetObj.totalCellCount = total;

			if(0 !== startCellId && !SCOM.isEmptyValue(startCellId)) {
                me.loadMore(activeSheetId, startCellId, total, function(){
                    me.loadFloatingsBySheetId(activeSheetId, function(success, floatings){
                        message.floatings = floatings;
                        me.getMessageAfterLoad.apply(me, [message]);
                        if(callback){
                            callback.apply(scope, [me], true);
                        }
                    }, me);
                }, me, undefined, message);
			}else{
                me.loadFloatingsBySheetId(activeSheetId, function(success, floatings){
                    message.floatings = floatings;
                    me.getMessageAfterLoad.apply(me, [message]);                                          
                    if(callback){
                        callback.apply(scope, [me], true);
                    }
                }, me);
			}
		}
        if(false !== this.fireEvent('beforeload', this)){
            /*
             * call backend to load data
             */
            Ext.Ajax.request(Ext.apply(options, {
                url: this.loadUrl
            }));
        }
	},
	
	/*
	 * after load data, read sheets from message
	 */
	readSheets : function(sheets){
		if(Ext.isArray(sheets)){
			this.sheets = SCOM.copy(sheets);			
		}				
	},
           
    /**
     * handle the width and height from 0,0 cell
     */
    prepareDefaultWidthHeightForActiveSheet : function(){
        var cell = this.getCell(this.getActivedSheetId(), 0, 0);
        this.prepareDefaultWidthHeight(cell);
    },
           
    /**
     * handle the width and height from 0,0 cell
     */
    prepareDefaultWidthHeight : function(cell){
        if(!Ext.isDefined(cell.width)){
            cell.width = cell.dw;
        }
        if(!Ext.isDefined(cell.height)){
            cell.height = cell.dh;
        }
        delete(cell.dw);
        delete(cell.dh);
        if(Ext.isNumber(cell.width)){
            this.defaultCellWidth = cell.width;
            this.defaultProperty.width = cell.width;
        }else{
            this.defaultCellWidth = this.originDefaultCellWidth;
            this.defaultProperty.width = this.originDefaultCellWidth;
        }
        if(Ext.isNumber(cell.height)){
            this.defaultCellHeight = cell.height;
            this.defaultProperty.height = cell.height;
        }else{
            this.defaultCellHeight = this.originDefaultCellHeight;
            this.defaultProperty.height = this.originDefaultCellHeight;
        }
    },
           
    getUUStamp : function(){    	
        this.uut++;
        
        return [this.uuid || 1, this.uut];
    },
	
	/*
	 * _private
	 * get the message property after the store is loaded
	 */
	getMessageAfterLoad : function(message){			
		var me = this;
        this.floatings = {};
        this.mergeLookup = {};
        this.cdtLookup = {};
        delete(this._cdtCoord);
				
        me.cachedMessage = message;
        me.fileName = message.fileName;
        me.fileStared = message.fileStared;
        me.fileExname = message.exname;
        me.filePermission = message.permission;
        me.fileOwner = message.owner;
        me.isPublic = message.isPublic;
        me.uuid = message.uuid;
        me.uut = 0;
        me.readSheets(message.sheets);
        me.readFloatings(message.floatings);
        me.readFileConfig(message.fileConfig);

        /*
         * save user info
         */
        me.userInfo = Ext.apply({}, message.user);
        me.checkReferenceString(true);
		
        /*
         * process the default width and height
         */
        this.prepareDefaultWidthHeightForActiveSheet();
        if(this._cdtCoord){
            this.checkLoadCoord(this._cdtCoord, function(){
                if(false !== me.fireEvent('beforeafterload', this)){
                    me.fireEvent('prepareafterload', this);
                    /*
                     * fire afterload event
                     * @notice this will called after load event is fired, so everything is ready
                     */
                    me.afterLoad();
                }
            }, this);
        }
	},
	
	/*
	 * read file config
	 */
	readFileConfig : function(fileConfig){			
		var lookup = {};
		if(fileConfig){
			for(var i = 0, len = fileConfig.length; i < len; i++){
				var it = fileConfig[i];
				var id = it.name+this.separateChar+it.ctype;
                lookup[id] = SCOM.copy(it);
			}
		}
		
		this.fileConfig = lookup;
	},
        
	
	isValidVariable : function(varName){
		var id = varName+this.separateChar+'var';
		if (this.fileConfig) return !this.fileConfig[id];
		else {
			alert("TODO - will coming ... at this moment, only saved file is allowed to bind vaiable.");
			/**
			var lookup = {};
            lookup[id] = SCOM.copy(it);
			
			this.fileConfig = {};
			this.fileConfig.add();
			**/
		};
	},
	    
    readMerges : function(){
        var lookup = this.floatings, megs = this.mergeLookup;
        for(var p in megs){
            if(megs.hasOwnProperty(p)){
                var it = lookup[p], json = it.jsonObj;
                this.presetMerge2Cell(json, it.sheet, p);
            }
        }
    },
           
	/*
	 * read floatings
	 */
	readFloatings : function(floatings){
        var lookup = {}, megs = {}, cdts = {}, coord = [];
        if(floatings){
            for(var i = 0, len = floatings.length; i < len; i++){
                var it = floatings[i];
                var id = [it.name, it.sheet].join(this.separateChar);
                lookup[id] = it;
                if('meg' == it.ftype){
                    var json = Ext.decode(it.json);
                    it.jsonObj = json;
                    megs[id] = true;
                }else if('cdt' == it.ftype){
                    var json = Ext.decode(it.json);
                    json.id = it.name;
                    it.cdtName = json.name;
                    if('vd' !== it.cdtName){
                        var rng = json.rng;
                        for(var k = 0, size = rng.length; k < size; k++){
                            coord.push(rng[k].span);
                        }
                    }
                    it.jsonObj = json;
                    this.presetCdt2Cells(it);
                    cdts[id] = true;
                }else if('row' == it.ftype){
                	var json = Ext.decode(it.json);
                	this.presetRowHiddens(it.sheet, json);
                }else if('col' == it.ftype){
                	var json = Ext.decode(it.json);
                	this.presetColHiddens(it.sheet, json);
                }
            }
        }
        this._cdtCoord = coord;
		this.floatings = lookup;
        this.mergeLookup = megs;
        this.cdtLookup = cdts;
	},
           
    presetTplForCells : function(coord, clearFlag, suspendPull){
        var tpls = {}, separateChar = this.separateChar;
        if(coord){
        	this.walkRange(coord, function(rec){
        		var json = rec.data.json, tpl = json.tpl;
                if(tpl){
                    var tplObj = Ext.decode(tpl);
                    var span = tplObj.span;
                    span[0] = rec.data.sheet;
                    if(span[1] === rec.data.row && span[2] === rec.data.col){
                    	var id = span.join(separateChar);
                        if(!tpls[id]){
                            tpls[id] = {
                                tpl: tplObj,
                                tplStr: tpl
                            }
                        }
                    }                    
                }
        	}, this, true);
        }else{
        	this.each(function(rec){
                var json = rec.data.json, tpl = json.tpl;
                if(tpl){
                    var tplObj = Ext.decode(tpl);
                    var span = tplObj.span;
                    span[0] = rec.data.sheet;
                    var id = span.join(separateChar);
                    if(!tpls[id]){
                        tpls[id] = {
                            tpl: tplObj,
                            tplStr: tpl
                        }
                    }
                }
            }, this);
        }
        
        var arr = [];
        for(var p in tpls){
            if(tpls.hasOwnProperty(p)){
                var it = tpls[p], tpl = it.tpl, span = tpl.span;
                arr.push(span);
                var sheetId = span[0];
                for(var r = span[1]; r <= span[3]; r++){
                    for(var c = span[2]; c <= span[4]; c++){
                    	if(clearFlag){
                    		this.setCell(sheetId, r, c, undefined, ['tpl'], true, undefined, suspendPull);
                    	}else{
                    		this.setCell(sheetId, r, c, {tpl: it.tplStr}, undefined, true, undefined, suspendPull);
                    	}                        
                    }
                }
            }
        }
        return arr;
    },
	
	/**
	 * set the condition to the cell
	 */
	presetCdt2Cells : function(floating){
        var cdt = floating.jsonObj;
		var cdtPro = EnterpriseSheet.sheet.calculate.Condition.prototype;
        var o = cdtPro.presetCdtObj(cdt, this);
        Ext.apply(floating, o);
	},		
	
	clearCdtForCoord : function(coord){
		var deleteCdtStyles = ['cdtVal'].concat(EnterpriseSheet.sheet.calculate.Condition.styles);
        var store = this, timestamp = SCOM.genTimeStamp(), lookup = {};
        store.walkRange(coord, function(rec, walkSpan, store, internalId){
            lookup[internalId] = rec;
        }, this, true);
        for(var p in lookup){
            if(lookup.hasOwnProperty(p)){
                var rec = lookup[p];
                store.setCell(rec.data.sheet, rec.data.row, rec.data.col, {
                    'timestamp': timestamp
                }, deleteCdtStyles, true);
            }
        }
	},
	
	isConditionCell : function(sheetId, row, col){
		var cellCoord = [sheetId, row, col], coordPro = EnterpriseSheet.sheet.calculate.Coordinate.prototype;
		for(var p in this.cdtLookup){
			if(this.floatings.hasOwnProperty(p)){
				var it = this.floatings[p];
                var refs = it.cells;
                if(coordPro.isCellInCoord(cellCoord, refs)){
                    return true;
                }
			}
		}
		return false;
	},
	
	/**
	 * get the related conditions of the passed cell coord
	 */
	getConditionOfCell : function(sheetId, row, col){
		var cellCoord = [sheetId, row, col], coordPro = EnterpriseSheet.sheet.calculate.Coordinate.prototype;
		var conditions = [];
		for(var p in this.cdtLookup){
			if(this.floatings.hasOwnProperty(p)){
				var it = this.floatings[p];
                var jsonObj = it.jsonObj;
                var refs = it.cells;
                if(coordPro.isCellInCoord(cellCoord, refs)){
                    conditions.push(jsonObj);
                }
			}
		}
		
		return conditions;
	},
	
	getCdtFloatingOfCell : function(sheetId, row, col){
		var cellCoord = [sheetId, row, col], coordPro = EnterpriseSheet.sheet.calculate.Coordinate.prototype;
		var conditions = [];
		for(var p in this.cdtLookup){
			if(this.floatings.hasOwnProperty(p)){
				var it = this.floatings[p];
                var jsonObj = it.jsonObj;
                var refs = it.cells;
                if(coordPro.isCellInCoord(cellCoord, refs)){
                    conditions.push(it);
                }
			}
		}
		
		return conditions;
	},
	
	getConditionLookup : function(){
		var conditions = {};
		for(var p in this.cdtLookup){
			if(this.floatings.hasOwnProperty(p)){
				var it = this.floatings[p];
                var jsonObj = it.jsonObj;
                conditions[p] = it;
			}
		}
		return conditions;
	},
	
	/**
	 * preset the merge to the cell
	 */
	presetMerge2Cell : function(merge, sheetId, mergeId){

		var span = [sheetId].concat(merge);
		this.walkRange([span], function(rd){
			var sid = rd.data.sheet, r = rd.data.row, c = rd.data.col;
			var modified = {				
				minrow: merge[0]-r,
				maxrow: merge[2]-r,
				mincol: merge[1]-c,
				maxcol: merge[3]-c,
				abminrow: merge[0],
				abmincol: merge[1],
				abmaxrow: merge[2],
				abmaxcol: merge[3]
			};
			this.setCell(sid, r, c, modified, null, true, undefined, true);
		}, this);
	},
	
	clearMerge2Cell : function(merge, sheetId){

		var span = [sheetId].concat(merge);
		this.walkRange([span], function(rd){
			var sid = rd.data.sheet, r = rd.data.row, c = rd.data.col, json = rd.data.json;
			if(json.abminrow === merge[0] && json.abmincol === merge[1] && json.abmaxrow === merge[2] && json.abmaxcol === merge[3]){
				this.setCell(sid, r, c, undefined, ['minrow', 'maxrow', 'mincol', 'maxcol', 'abminrow', 'abmaxrow', 'abmincol', 'abmaxcol'], true, undefined, true);
			}			
		}, this);
	},
	
	/*
	 * append floatings
	 */
	appendFloatings : function(floatings){		
		
		this.floatings = this.floatings || {};
		for(var i = 0, len = floatings.length; i < len; i++){			
			var it = floatings[i];
			var id = [it.name, it.sheet].join(this.separateChar);
            this.floatings[id] = it;
            if('meg' == it.ftype){
                var json = Ext.decode(it.json);
                it.jsonObj = json;
                this.presetMerge2Cell(json, it.sheet, id);
                this.mergeLookup[id] = true;
            }else if('cdt' == it.ftype){
                var json = Ext.decode(it.json);
                it.cdtName = json.name;
                json.id = it.name;
                it.jsonObj = json;
                this.presetCdt2Cells(it);
                this.cdtLookup[id] = true;
            }
		}
	},
	
	/*
	 * get current login user info
	 */
	getUserInfo : function(){
		return this.userInfo;
	},
	
	afterLoad : function(){
        this.readMerges();
        /*
         * special process for tpl
         */
        this.presetTplForCells();
           
        delete(this._loadingFlag);
		//console.log(Ext.Date.getElapsed(document.startTime));
        this.resetRowHeightColWidthCache(this.getActivedSheetId());
		this.fireEvent('afterload', this);
	},
           
    isLoadingCells : function(){
        return this._loadingFlag;
    },
		
	/*
	 * add a new sheet
	 */
	addSheet : function(tabConfig, callback, scope, loaded){
        tabConfig = tabConfig || {};
        var tabName = tabConfig.name, position = tabConfig.position;
        var sheets = this.sheets;
        
        // in case tabName is not defined ... just get it now ...
        if(this.isExistedSheetName(tabName)){
            Ext.Msg.alert(SLANG['error'], SLANG['tab_name_existed']);
            return 'name_existed';
        }
        
		var sheetId = -1;
		for(var i = 0, len = sheets.length; i < len; i++){
			var id = sheets[i].id;
			if(sheetId < id){
				sheetId = id;
			}
		}
		sheetId++;
        
        delete(tabConfig.position);
		var obj = Ext.apply({
			id: sheetId,
			actived: false,
            loaded: loaded
		}, tabConfig);
        if(Ext.isNumber(position)){
            sheets.splice(position, 0, obj);
        }else{
           sheets.push(obj);
        }
		if(callback){
			callback.call(scope, obj);
		}
		/*
		 * fire event
		 */
		this.fireEvent('addsheet', obj.id, name, this);
	},
	
	/*
	 * delete a sheet
	 */
	deleteSheet : function(sheetId, callback, scope, skipPull, suspendEvent){
		var sheets = this.sheets;
		for(var i = 0, len = sheets.length; i < len; i++){
			var id = sheets[i].id;
			if(sheetId == id){
				sheets.splice(i, 1);
				break;
			}
		}
		var deleted = [], data = this.getData();
        for(var p in data){
            if(data.hasOwnProperty(p)){
                var rd = {data: data[p]};
                if(rd.data.sheet == sheetId){
                    deleted.push(rd);
                    delete(data[p]);
                }
            }
        }
		
		if(callback){
			callback.call(scope, deleted, true);
		}
		if(!suspendEvent){
			/*
			 * fire event
			 */
			this.fireEvent('deletesheet', sheetId, deleted, this, skipPull);
		}		
	},
	
	/*
	 * rename a sheet
	 */
	renameSheet : function(sheetId, newName, callback, scope){
        var sheetTab = this.getSheetById(sheetId);
        if(Ext.isDefined(newName) && this.isExistedSheetName(newName) && sheetTab.name !== newName){
            Ext.Msg.alert(SLANG['error'], SLANG['cannot_rename_existed_tabname']);
            return 'name_existed';
        }
		var sheets = this.sheets;
		for(var i = 0, len = sheets.length; i < len; i++){
			var sheet = sheets[i];
			var id = sheet.id;
			if(sheetId == id){
				sheet.lastOldName = sheet.name;
				sheet.name = newName;				
				break;
			}
		}		
		
		if(callback){
			callback.call(scope);
		}
		/*
		 * fire event
		 */
		this.fireEvent('renamesheet', sheetId, newName, this);
	},
           
    /*
     * set tab color for a sheet
     */
    changeSheetColor : function(sheetId, color, callback, scope){
        var sheets = this.sheets;
        for(var i = 0, len = sheets.length; i < len; i++){
            var sheet = sheets[i];
            var id = sheet.id;
            if(sheetId == id){
                sheet.color = color;
                break;
            }
        }
           
        if(callback){
           callback.call(scope);
        }
        /*
         * fire event
         */
        this.fireEvent('chagesheetcolor', sheetId, color, this);
    },
           
    /**
     * update the config for the passed sheet tab
     */
    updateSheetTab : function(sheetId, config, callback, scope){
        if(!Ext.isDefined(sheetId)){
            sheetId = this.getActivedSheetId();
        }
        var sheetTab = this.getSheetById(sheetId);
        config = config || {};
        var name = config.name;
        if(Ext.isDefined(name) && this.isExistedSheetName(name) && sheetTab.name !== name){
            Ext.Msg.alert(SLANG['error'], SLANG['cannot_rename_existed_tabname']);
            return 'name_existed';
        }
        var sheets = this.sheets;
        for(var i = 0, len = sheets.length; i < len; i++){
            var sheet = sheets[i];
            var id = sheet.id;
            if(sheetId == id){
                Ext.apply(sheet, config);
                break;
            }
        }
           
        if(callback){
            callback.call(scope, sheetId);
        }
        /*
         * fire event
         */
        this.fireEvent('updatesheettab', sheetId, config, this);
    },
	
	/*
	 * load file
	 */
	loadFile : function(config, callback, scope){
		config = config || {};
		if(!SCOM.nullOrUndefined(config.fileId)){
			this.fileId = config.fileId;
		}
		this.load({
			params: {
				fileId: this.fileId,
				startCellId: 0,
				size: this.limitCellNumAtSingleLoad
			},
			callback: function(){
				if(callback){
					callback.apply(scope, arguments);
				}
			},
			scope: this
		});
	},
           
    /**
     * load file by the passed json
     */
    loadJsonFile : function(json, callback, scope){
        json = SCOM.copy(json);
        var me = this;
        Ext.apply(this, {
            fileId: json.fileId,
            fileName: json.fileName || json.name || '',
            fileStared: json.fileStared || json.stared,
            fileExname: json.exname
        });
        /*
         * for other things
         */
        var sheets = json.sheets;
        if(sheets){
            var actived;
            for(var i = 0, len = sheets.length; i < len; i++){
                var it = sheets[i];
                it.loaded = true;
                it.allCellDataLoaded = true;
                if(it.actived){
                    actived = i;
                }
            }
            if(!Ext.isDefined(actived)){
                sheets[0].actived = true;
            }
        }
         
        /*
         * for cells
         */
        var cells = json.cells;
        
        /**
         * When cell is format as: i: 0, j: "{"data":"12"}"x: 3, y: 2
         * We need convert all cell data as CellModel.js format. Otherwise, cell will not be reconginzed.
         * I do not know whether we have better way to process this ...
         */
        if (cells) {
	        for (var i = 0, len = cells.length; i < len; i++) {
	        	var thisCell = cells[i];        	
	        	if (Ext.isDefined(thisCell.x)) {
		        	thisCell.row = thisCell.x;
		        	thisCell.col = thisCell.y;
		        	thisCell.sheet = thisCell.i;
		        	thisCell.json = thisCell.j;
		        	if (thisCell.c) {
		        		thisCell.isCal = thisCell.c;
		        		delete(thisCell.c);
		        	}	        		        	
	        	}
	        	var o = thisCell.json;
	        	if(Ext.isString(o)){
	        		o = Ext.decode(o);	        			               
	        	}
	        	if(Ext.isDefined(o.data)){
                	if(EnterpriseSheet.sheet.calculate.Calculate.prototype.isCalculate(o.data)){
                		o.cal = true;
                	}            	
                }
	        	if(!o.cal){
	        		delete(o.cal);
                	delete(o.arg);
                	delete(o.refs);
                	delete(o.value);
                }    
	        	for(var p in o){
	        		if(o.hasOwnProperty(p) && '_' === p.charAt(0)){
	        			delete(o[p]);
	        		}
	        	}
	        	var arr = [thisCell.sheet, thisCell.row, thisCell.col, o];
	        	cells[i] = arr;
	        }
	        var records  = me.reader.read(cells);
	           
	        me.loadRecords(records, { addRecords: false });
        }               
        
        this.getMessageAfterLoad(json);            
    },
           
    /**
     * this is the function to load more json file 
     * From 
     */
    loadMoreJsonFile : function(json, callback, scope){
        var me = this, dataMap = this.getData();
        var cells = json.cells;    
        var records = me.reader.read(cells);
        var separateChar = this.separateChar;
        var recLen = records.length, sheetCellCount = {};
        for(var i = 0; i < recLen; i++){
            var it = records[i], sheetId = it[0];
            sheetCellCount[sheetId] = sheetCellCount[sheetId] || 0;
            var cid = [it[0], it[1], it[2]].join(separateChar);
            if(!dataMap[cid]){
                dataMap[cid] = it;
            	sheetCellCount[sheetId]++;
            }
        }
        
        for(var p in sheetCellCount){
        	if(sheetCellCount.hasOwnProperty(p)){
        		var sheetObj = this.getSheetById(p);
        		sheetObj.totalCellCount += sheetCellCount[p];
                sheetObj.currentCellCount += sheetCellCount[p];
        	}
        }
        if(callback){
            callback.call(scope);
        }
    },
           
    /**
     * load tab json
     */
    loadTabJsonFile : function(json, callback, scope){
        var me = this, separateChar = this.separateChar, dataMap = this.getData();
        var cells = json.cells;    
        var records = me.reader.read(cells);
        
        var recLen = records.length, newRecs = [], sheetCellCount = {};
        for(var i = 0; i < recLen; i++){
            var it = records[i], sheetId = it[0];
            sheetCellCount[sheetId] = sheetCellCount[sheetId] || 0;
            var cid = [it[0], it[1], it[2]].join(separateChar);
            if(!dataMap[cid]){
                dataMap[cid] = it;
            	sheetCellCount[sheetId]++;
            }
        }
        
        for(var p in sheetCellCount){
        	if(sheetCellCount.hasOwnProperty(p)){
        		var sheetObj = this.getSheetById(p);
        		sheetObj.totalCellCount += sheetCellCount[p];
                sheetObj.currentCellCount += sheetCellCount[p];
        	}
        }
        
        // this is the step to process other things in the tab json ...
        this.floatings = {};
        this.mergeLookup = {};
        this.cdtLookup = {};
		if(json){				
			me.readFloatings(json.floatings);
			me.readFileConfig(json.fileConfig);
			me.userInfo = Ext.apply({}, json.user);
			me.checkReferenceString(true);
		}
        /*
         * process the default width and height
         */
        this.prepareDefaultWidthHeightForActiveSheet();
        if(false !== me.fireEvent('beforeafterload', this)){
            me.fireEvent('prepareafterload', this);
            me.afterLoad();
        }
        
        if(callback){
            callback.call(scope);
        }
    },
           
    getJsonData : function(compress){
        var cells = this.getCellsJson(compress);
        var floatings = this.getFloatingsJson();
        var fileConfig = this.getFileConfigJson();
        var sheets = this.getSheets(), arr = [];
        for(var i = 0, len = sheets.length; i < len; i++){
            var it = sheets[i];
            arr.push({
                id: it.id,
                name: it.name,
                actived: it.actived,
                color: it.color
            });
        }
        var json = {
            sheets: arr,
            cells: cells,
            floatings: floatings,
            fileConfig: fileConfig
        };
        var obj = this.getLoadedFile();
        return Ext.apply(obj, json);
    },
           
    /**
     * save the json file, only if it's not a saved file already
     */
    saveJsonFile : function(config, callback, scope){

        if(!Ext.isDefined(this.getFileId())){
            Ext.applyIf(config, this.getJsonData(true));

            Ext.Ajax.request({
                url: SCONFIG.urls['saveJsonFile'],
                params: {
                    'json': Ext.encode(config)
                },
                success: function(response, options){
                    var json = Ext.decode(response.responseText);
                    var sheetIdMap = json['sheetIdMap'];
                    this.sync2NewSheetIds(sheetIdMap);
                    this.setFileId(json['fileId']);
                    /*
                     * fire event for save json file successfully
                     */
                    this.fireEvent('savejsonfile', sheetIdMap, json['fileId'], this);
                    if(callback){
                        callback.call(scope, json['fileId']);
                    }
                },
                failure: function(){
                             
                },
                scope: this
            });
        }else{
            var params = Ext.apply({
                oldFileId: this.getFileId()
            }, config);
            /*
             * means we need save this file as a new file
             */
            Ext.Ajax.request({
                url: SCONFIG.urls['saveFileAs'],
                params: params,
                success: function(response, options){
                    var json = Ext.decode(response.responseText);
                    var newFileId = json['fileId'] || params.id;
                    this.setFileId(newFileId);
                    /*
                     * fire event for save json file successfully
                     */
                    this.fireEvent('savefileas', newFileId, this);
                    if(callback){
                        callback.call(scope, newFileId);
                    }
                },
                failure: function(){
                            
                },
                scope: this
            });
        }
    },
	
    setFileId : function(fileId){
        this.fileId = fileId;
    },
           
	getFileId : function(){
		return this.fileId;
	},
	
	/*
	 * get the file of current file, if no file is load then return Untitled
	 */
	getLoadedFile : function(){
        return {
           id: this.fileId,
           name: this.fileName,
           stared: this.fileStared,
           exname: this.fileExname,
           permission: this.filePermission,
           owner: this.fileOwner,
           isPublic: this.isPublic
        }
	},
	
	getLoadedFileName : function(){
		var file = this.getLoadedFile();
		if(file){
			return file.name;
		}
	},
	
    isShareableFile : function(){
        var file = this.getLoadedFile();
        if(file && Ext.isDefined(file.id)){
            var permission = 7;
            if(Ext.isDefined(file.permission)){
                permission = file.permission;
            }
            return 7 === permission;
        }
    },
           
    // this is for share file permission, it will be different from
    // public view permission. 
    // For public view, it will be 0, 1, 2 (private, view, edit)
    isViewOnlyFile : function(){
        var file = this.getLoadedFile();
        if(file && Ext.isDefined(file.id)){
            var permission = 7;
            if(Ext.isDefined(file.permission)){
                permission = file.permission;
            }
            return 2 > permission;
        }
    },
           
    isExportableFile : function(){
        var file = this.getLoadedFile();
        if(file && Ext.isDefined(file.id)){
            var permission = 7;
            if(Ext.isDefined(file.permission)){
                permission = file.permission;
            }
            return 2 < permission;
        }
    },             
           
	/*
	 * set floating item
	 */
	setFloatingItem : function(sheetId, name, ftype, json, suspendEvent){
		this.floatings = this.floatings || {};
		var id = name+this.separateChar+sheetId;
		var found = this.floatings[id];
		if(found){
			if(SCOM.nullOrUndefined(json)){
				delete(this.floatings[id]);				
                delete(this.mergeLookup[id]);
                delete(this.cdtLookup[id]);
				if(!suspendEvent){
					this.fireEvent('removefloatingitem', found, this);
				}
			}else{
				found.ftype = ftype;
				found.json = json;
                if('cdt' === ftype){
                    var jsonObj = Ext.decode(json);
                    jsonObj.id = name;
                    found.cdtName = jsonObj.name;
                    found.jsonObj = jsonObj;
                    found.json = Ext.encode(jsonObj);
                    this.presetCdt2Cells(found);                 
                }
				if(!suspendEvent){
					this.fireEvent('updatefloatingitem', found, this);
				}
			}
           
			return found;
		}
		
		if(!SCOM.nullOrUndefined(json)){		
			var it = {
				sheet: sheetId,
				name: name,
				ftype: ftype,
				json: json
			};
            if('cdt' === ftype){
                var jsonObj = Ext.decode(json);
                it.cdtName = jsonObj.name;
                it.jsonObj = jsonObj;
                this.presetCdt2Cells(it);             
                this.cdtLookup[id] = true;
            }else if('meg' === ftype){
                var jsonObj = Ext.decode(json);
                it.jsonObj = jsonObj;
                this.mergeLookup[id] = true;                
            }
			this.floatings[id] = it;
			if(!suspendEvent){
				this.fireEvent('createfloatingitem', it, this);
			}
			return it;
		}		
	},
	
	/*
	 * update row group
	 */
	updateRowGroups : function(sheetId, rowGroups, suspendEvent){
		if(rowGroups){
			rowGroups = SCOM.copy(rowGroups);			
			this.setFloatingItem(sheetId, 'rowGroups', 'rowgroup', Ext.encode(rowGroups), suspendEvent);
		}else{			
			this.setFloatingItem(sheetId, 'rowGroups', 'rowgroup', null, suspendEvent);
		}
		return rowGroups;
	},
	
	/*
	 * update column group
	 */
	updateColumnGroups : function(sheetId, colGroups, suspendEvent){
		if(colGroups){
			colGroups = SCOM.copy(colGroups);
			this.setFloatingItem(sheetId, 'colGroups', 'colgroup', Ext.encode(colGroups), suspendEvent);
		}else{			
			this.setFloatingItem(sheetId, 'colGroups', 'colgroup', null, suspendEvent);
		}
		return colGroups;
	},
	
	/*
	 * update sheet config
	 */
	updateSheetConfig : function(sheetId, config, suspendEvent){		
		if(config){
			/*
			 * save the config to cell(0,0)
			 */
			this.setCell(sheetId, 0, 0, {'config':Ext.encode(config)}, null, suspendEvent);
		}else{
			this.setCell(sheetId, 0, 0, null, ['config'], suspendEvent);
		}		
	},
	
	/*
	 * get the acitved sheet id
	 */
	getActivedSheetId : function(){
		var sheets = this.getSheets();
		for(var i = 0, len = sheets.length; i < len; i++){
			var sheet = sheets[i];
			if(sheet.actived){				
				return sheet.id;
			}
		}
		return sheets[0].id;
	},
	
	/*
	 * set the actived sheet 
	 */
	setActivedSheetId : function(sheetId){
		var sheets = this.getSheets(), found, oldActived, oldActivedSheetId;
		for(var i = 0, len = sheets.length; i < len; i++){
			var sheet = sheets[i];
			if(sheet.actived){
				oldActived = sheet;
				oldActivedSheetId = sheet.id;
				sheet.actived = false;
			}														
		}
		for(var i = 0, len = sheets.length; i < len; i++){
			var sheet = sheets[i];			
			if(sheet.id == sheetId){				
				found = sheet;
				sheet.actived = true;
			}												
		}
         		
        this.prepareDefaultWidthHeightForActiveSheet();
        if(oldActivedSheetId !== sheetId){
        	this.fireEvent('changeactivedsheetid', oldActivedSheetId, sheetId, this);
        }
		return [oldActived, found];
	},
           
    indexOfSheetId : function(sheetId){
        for(var i = 0, len = this.sheets.length; i < len; i++){
            var tab = this.sheets[i];
            if(tab.id === sheetId){
                return i;
            }
        }
    },
	
	/*
	 * change sheet order
	 */
	changeSheetOrder : function(preIndex, curIndex, callback, scope){
		var sheet = this.sheets.splice(preIndex, 1)[0];
		this.sheets.splice(curIndex, 0, sheet);
        if(callback){
            callback.call(scope, true);
        }
	},
	
	/*
	 * change file name
	 */
	changeFileName : function(fileName, callback, scope, suspendEvent){
		this.fileName = fileName;
        if(callback){
            callback.call(scope, true);
        }
        if(!suspendEvent){
        	this.fireEvent('filenamechanged', this.fileName, this);
        }        
	},
	
	/*
	 * change file stared status
	 */
    changeFileStared : function(fileStared, callback, scope, suspendEvent){
		this.fileStared = fileStared;
        if(callback){
            callback.call(scope, true);
        }
        if(!suspendEvent){
        	this.fireEvent('filestaredchanged', this.fileStared, this);
        }
	},
	
	/*
	 * get a copy name of a sheet
	 */
	getCopyName : function(sheetId){
		var sheetName = this.getSheetNameById(sheetId);
		sheetName = 'Copy of '+sheetName;
		var sheets = this.getSheets();
		var checkName = function(name){
			for(var i = 0, len = sheets.length; i < len; i++){
				var sheet = sheets[i];
				if(sheet.name == name){
					return false;
				}
			}
			return true;
		}	
		var index = 1;
		while(!checkName(sheetName)){
			sheetName = sheetName+'('+index+')';
			index++;
		}
		return sheetName;
	},
	
	/*
	 * copy floatings from one sheet to another
	 */
	copyFloatings : function(oldSheetId, newSheetId){
		var floatings = this.floatings, newFloatings = [];
		for(var p in floatings){
			if(floatings.hasOwnProperty(p)){
				var it = floatings[p];
				if(oldSheetId == it.sheet){
					var name = it.name, json = it.json;
					if('meg' === it.ftype){
						name = name.replace(oldSheetId+'$', newSheetId+'$');
					}else{
						json = json.replace('"span":['+oldSheetId+',', '"span":['+newSheetId+',');
					}
					var obj = {
						sheet: newSheetId,
						name: name,
						ftype: it.ftype,
						json: json
					};					
					
					newFloatings.push(obj);
				}
			}
		}
		this.appendFloatings(newFloatings);
	},
	
	/*
	 * copy a sheet
	 */	
	copySheet : function(oldSheetId, newSheetName, callback, scope, newSheetId, skipPull){
        if(this.isExistedSheetName(newSheetName)){
           Ext.Msg.alert(SLANG['error'], SLANG['cannot_rename_existed_tabname']);
           return 'name_existed';
        }
		var sheets = this.sheets;
		var sheetId = newSheetId;
		var oldSheet = this.getSheetById(oldSheetId);
		if(!Ext.isDefined(sheetId)){
			var max = -1;	        
			for(var i = 0, len = sheets.length; i < len; i++){
				var id = sheets[i].id;
				if(max < id){
					max = id;
				}
			}
			sheetId = max+1;
		}		
		var obj = Ext.applyIf({
			actived: false,						
			id: sheetId,
			name: newSheetName										
		}, oldSheet);										
		delete(obj['loadedEmptyCells']);
		this.sheets.push(obj);
		/*
		 * duplicate rec in the store
		 */
		
		this.each(function(rd){
			if(oldSheetId == rd.data.sheet){
				this.newRecord(sheetId, rd.data.row, rd.data.col, rd.data.json);
			}
		}, this);
		/*
		 * copy floatings
		 */
		this.copyFloatings(oldSheetId, sheetId);
		if(callback){
			callback.call(scope, obj, this);
		}
        this.fireEvent('copysheet', sheetId, newSheetName, this);
	},
	
	/*
	 * load sheet, an empty function to let subclass extend
	 */
	loadSheet : function(sheetId, callback, scope){
		if(callback){
			callback.call(scope);
		}
	},
	
	/*
	 * load these unloaded cells in the cache
	 */
	checkLoadCells : function(lookup, callback, scope){
		if(callback){
			callback.call(scope);
		}
		return true;
	},
           
    checkLoadCoord : function(coord, callback, scope){
        if(callback){
            callback.call(scope);
        }
        return true;
    },
	
	/*
	 * find matched cells of the passed str
	 */
	findMatchCells : function(exp, callback, scope, startCellId){
		var reg = SCOM.genRegExp(exp);
		var matchs = [];

		this.each(function(rd){
			var json = rd.data.json, row = rd.data.row, col = rd.data.col;
			if(0 != row && 0 != col){
				var data = json.data;
				reg.lastIndex = 0;
				if(data && reg.test(data)){					
					matchs.push({
						sheet: rd.data.sheet,
						sheetName: this.getSheetNameById(rd.data.sheet),
						row: row,
						col: col,
						cell: this.getColName(col)+row,
						data: data
					});					
				}
			}
		}, this);
		if(callback){
			callback.call(scope, matchs, startCellId);
		}
	},
           
           
	
	/**
	 * set file config item
	 */
	setFileConfig : function(ctype, name, json, suspendEvent, suspendCheck){
		this.fileConfig = this.fileConfig || {};
		var id = name+this.separateChar+ctype;
		var found = this.fileConfig[id];
		if(found){			
			var oldJson = found.json;
			if(SCOM.nullOrUndefined(json)){
				delete(this.fileConfig[id]);
				if(!suspendEvent){
					found = SCOM.copy(found);
					this.fireEvent('removefileconfig', found, this, oldJson);
				}
			}else{				
				found.json = json;
				if(!suspendEvent){
					found = SCOM.copy(found);
					this.fireEvent('updatefileconfig', found, this, oldJson);
				}
			}			
			if(!suspendCheck){
				this.checkReferenceString();
			}			
			return;
		}		
		if(!SCOM.nullOrUndefined(json)){		
			var it = {
				name: name,
				ctype: ctype,
				json: json
			};
			this.fileConfig[id] = it;
			if(!suspendEvent){
				it = SCOM.copy(it);
				this.fireEvent('createfileconfig', it, this);
			}
		}
		if(!suspendCheck){
			this.checkReferenceString();
		}
	},
	
	/**
	 * check whether the reference string is change after 'ref' file config item change
	 */
	checkReferenceString : function(suspendEvent){
		/*
		 * update reference str of file config
		 */
		var oldRefStr = this.configReferenceStr;
		var configs = this.fileConfig || {};
		var curSheetId = this.getActivedSheetId();
		var calPro = EnterpriseSheet.sheet.calculate.Calculate.prototype;
           
        var arr = calPro.prepareRefNamedFunc(configs, curSheetId, this);

        this.configReferenceStr = arr.join('');

		var nameRefs = this.getRefConfigLookup();
		if(oldRefStr != this.configReferenceStr && !suspendEvent){
			var changes = this.compareNameRefChanges(this.oldNameRefs, nameRefs);
			this.fireEvent('refconfigchange', this.configReferenceStr, this, changes, nameRefs);
		}
		this.oldNameRefs = SCOM.copy(nameRefs);
	},
	
	/**
	 * compare the changes of the 2 object passed
	 */
	compareNameRefChanges : function(oldRefs, newRefs){
		oldRefs = oldRefs || {};
		newRefs = newRefs || {};
		var changes = {};
		for(var p in oldRefs){
			if(oldRefs.hasOwnProperty(p)){
				var old = oldRefs[p];
				if(!newRefs.hasOwnProperty(p)){
					changes[p] = 'deleted';
				}else if(newRefs[p].json !== old.json){
					changes[p] = 'changed';
				}
			}
		}
		for(var p in newRefs){
			if(newRefs.hasOwnProperty(p) && !oldRefs.hasOwnProperty(p)){
				changes[p] = 'added';
			}
		}
		return changes;
	},
     
    
	
	/**
	 * prepare the reference file config
	 */
	prepareFileConfigReference : function(){
		return this.configReferenceStr || '';
	},
	
	/*
	 * get all reference name config in the fileConfig
	 */
	getRefConfig : function(){
		var configs = this.fileConfig || {};
		var arr = [];
		for(var p in configs){
			if(configs.hasOwnProperty(p)){
				var it = configs[p];
				if('ref' == it.ctype || 'named_func' == it.ctype){
					arr.push(Ext.apply({}, it));
				}
			}			
		}
		return arr;
	},
	
	getRefConfigLookup : function(){
		var configs = this.fileConfig || {};
		var obj = {};
		for(var p in configs){
			if(configs.hasOwnProperty(p)){
				var it = configs[p];
				if('ref' == it.ctype || 'named_func' == it.ctype){
					obj[it.name] = Ext.apply({}, it);
				}
			}			
		}
		return obj;
	},
	
    getRefConfigByName : function(name){
        var configs = this.fileConfig || {};
        var id = name+this.separateChar+'named_func';
        var rif = name+this.separateChar+'ref';
        var found = configs[id] || configs[rid];
        return found;
    },
           
	/*
	 * check whether the passed sheet is filtered
	 */
	withFilterInSheet : function(sheetId){
		var me = this;
		var flag = false;
		me.each(function(rd){
			if(rd.data.sheet === sheetId){
				var json = rd.data.json;
				if(json.filter){
					flag = true;
					return false;
				}
			}
		});
		return flag;
	},
	
	isDisabledForMe : function(dsd){
		if(dsd){
			if('ed' === dsd){
				return true;
			}else{
				dsd = Ext.decode(dsd);
				var userId = this.getUserInfo().id;
				return -1 === dsd.indexOf(userId);
			}
		}
		return false;
	},
	
	/**
	 * true if the cell is disabled
	 */
	isDisabledCell : function(sheetId, row, col){
		if(!SCOM.nullOrUndefined(sheetId)){
			sheetId = this.getActivedSheetId();
		}
		var cd = this.getCellData(sheetId, row, col);
		
		return this.isDisabledForMe(cd.dsd);		
	},
	
	/**
	 * check the name range reference after insert row
	 */
	checkNameRefForInsertRow : function(sheetId, minrow, rowSpan){
		var configs = this.fileConfig || {};
		var flag = false;
		for(var p in configs){
			if(configs.hasOwnProperty(p)){
				var it = configs[p];
				if('ref' == it.ctype){					
					var coord = Ext.decode(it.json);
					var changed = false;
					for(var i = 0, len = coord.length; i < len; i++){
						var o = coord[i];
						var arr = o.span;
						if(sheetId === arr[0]){							
							if(minrow <= arr[1]){
								arr[1] += rowSpan;
								if(0 !== arr[3]){
									arr[3] += rowSpan;
								}								
								changed = true;
							}else if(minrow <= arr[3]){
								/*
								 * special for something like C1+C3
								 */
								if(arr[1] == arr[3] && !inFun){
									arr[1] += rowSpan;
								}
								arr[3] += rowSpan;
								changed = true;
							}
							flag = flag || changed;							
						}
					}								
					if(changed){
						it.json = Ext.encode(coord);
						this.fireEvent('updatefileconfig', it, this);
					}
				}
			}			
		}
		this.checkReferenceString();
		
		return flag;
	},
	
	/**
	 * check the name range reference after insert row
	 */
	checkNameRefForInsertColumn : function(sheetId, mincol, colSpan){
		var configs = this.fileConfig || {};
		var flag = false;
		for(var p in configs){
			if(configs.hasOwnProperty(p)){
				var it = configs[p];
				if('ref' == it.ctype){					
					var coord = Ext.decode(it.json);
					var changed = false;
					for(var i = 0, len = coord.length; i < len; i++){
						var o = coord[i];
						var arr = o.span;
						if(sheetId === arr[0]){							
							if(mincol <= arr[2]){
								arr[2] += colSpan;
								if(0 !== arr[4]){
									arr[4] += colSpan;
								}								
								changed = true;
							}else if(mincol <= arr[4]){								
								/*
								 * special for something like C1+C3
								 */
								if(arr[2] == arr[4] && !inFun){
									arr[2] += colSpan;
								}
								arr[4] += colSpan;
								changed = true;
							}
							flag = flag || changed;							
						}
					}								
					if(changed){
						it.json = Ext.encode(coord);
						this.fireEvent('updatefileconfig', it, this);
					}
				}
			}			
		}
		this.checkReferenceString();
		
		return flag;
	},
	
	/**
	 * check the name range reference after delete row
	 */
	checkNameRefForDeleteRow : function(sheetId, minrow, maxrow, deletedNameRef){
		var configs = this.fileConfig || {};
		var flag = false;
		var dspan = maxrow-minrow+1;
		for(var p in configs){
			if(configs.hasOwnProperty(p)){
				var it = configs[p];
				if('ref' == it.ctype){					
					var coord = Ext.decode(it.json);
					var changed = false, newCoord = [];
					for(var i = 0, len = coord.length; i < len; i++){
						var o = coord[i];
						var arr = o.span;
						if(sheetId === arr[0]){							
							if(minrow < arr[1]){
								if(maxrow >= arr[1]){
									arr[1] = minrow;
								}else{
									arr[1] -= dspan;
								}
								if(0 !== arr[3]){
									arr[3] -= dspan;
								}								
								changed = true;
							}else if(minrow <= arr[3]){
								if(maxrow > arr[3]){
									arr[3] = minrow-1;
								}else{
									arr[3] -= dspan;
								}
								changed = true;
							}	
							flag = flag || changed;
							if(arr[1] <= arr[3]){
								newCoord.push(o);
							}
						}else{
							newCoord.push(o);
						}
					}						
					if(0 === newCoord.length){
						if(Ext.isObject(deletedNameRef)){
							/*
							 * pass it out through the deletedNameRef
							 */
							deletedNameRef[it.name] = it;
						}
						
						this.setFileConfig('ref', it.name, undefined, undefined, true);						
					}else if(changed){
						it.json = Ext.encode(coord);
						this.fireEvent('updatefileconfig', it, this);
					}
				}
			}			
		}
		this.checkReferenceString();
		
		return flag;
	},
	
	/**
	 * check the name range reference after delete column
	 */
	checkNameRefForDeleteColumn : function(sheetId, mincol, maxcol, deletedNameRef){
		var configs = this.fileConfig || {};
		var flag = false;
		var dspan = maxcol-mincol+1;
		for(var p in configs){
			if(configs.hasOwnProperty(p)){
				var it = configs[p];
				if('ref' == it.ctype){					
					var coord = Ext.decode(it.json);
					var changed = false, newCoord = [];
					for(var i = 0, len = coord.length; i < len; i++){
						var o = coord[i];
						var arr = o.span;
						if(sheetId === arr[0]){							
							if(mincol < arr[2]){
								if(maxcol >= arr[2]){
									arr[2] = mincol;
								}else{
									arr[2] -= dspan;
								}
								if(0 !== arr[4]){
									arr[4] -= dspan;
								}								
								changed = true;
							}else if(mincol <= arr[4]){
								if(maxcol > arr[4]){
									arr[4] = mincol-1;
								}else{
									arr[4] -= dspan;
								}
								changed = true;
							}		
							flag = flag || changed;	
							if(arr[2] <= arr[4]){
								newCoord.push(o);
							}
						}else{
							newCoord.push(o);
						}
					}								
					if(0 === newCoord.length){
						if(Ext.isObject(deletedNameRef)){
							/*
							 * pass it out through the deletedNameRef
							 */
							deletedNameRef[it.name] = it;
						}
						
						this.setFileConfig('ref', it.name, undefined, undefined, true);						
					}else if(changed){
						it.json = Ext.encode(coord);
						this.fireEvent('updatefileconfig', it, this);
					}
				}
			}			
		}
		this.checkReferenceString();
		
		return flag;
	},
	
	checkNameRefForDeleteCell : function(sheetId, minrow, maxrow, mincol, maxcol, moveDir, deletedNameRef){
		var configs = this.fileConfig || {};
		var flag = false;
		var colSpan = maxcol-mincol+1, rowSpan = maxrow-minrow+1;
		for(var p in configs){
			if(configs.hasOwnProperty(p)){
				var it = configs[p];
				if('ref' == it.ctype){					
					var coord = Ext.decode(it.json);
					var changed = false, newCoord = [];
					for(var i = 0, len = coord.length; i < len; i++){
						var o = coord[i];
						var arr = o.span;
						if(sheetId === arr[0]){		
							if('left' === moveDir){
								if(minrow <= arr[1] && maxrow >= arr[3]){
									if(mincol < arr[2]){
										if(maxcol >= arr[2]){
											arr[2] = mincol;
										}else{
											arr[2] -= colSpan;
										}
										if(0 !== arr[4]){
											arr[4] -= colSpan;
										}								
										changed = true;
									}else if(mincol <= arr[4]){
										if(maxcol > arr[4]){
											arr[4] = mincol-1;
										}else{
											arr[4] -= colSpan;
										}
										changed = true;
									}		
									flag = flag || changed;	
									if(arr[2] <= arr[4]){
										newCoord.push(o);
									}
								}else{
									newCoord.push(o);
								}								
							}else{
								if(mincol <= arr[2] && maxcol >= arr[4]){
									if(minrow < arr[1]){
										if(maxrow >= arr[1]){
											arr[1] = minrow;
										}else{
											arr[1] -= rowSpan;
										}
										if(0 !== arr[3]){
											arr[3] -= rowSpan;
										}								
										changed = true;
									}else if(minrow <= arr[3]){
										if(maxrow > arr[3]){
											arr[3] = minrow-1;
										}else{
											arr[3] -= rowSpan;
										}
										changed = true;
									}	
									flag = flag || changed;
									if(arr[1] <= arr[3]){
										newCoord.push(o);
									}
								}else{
									newCoord.push(o);
								}								
							}							
						}else{
							newCoord.push(o);
						}
					}								
					if(0 === newCoord.length){
						if(Ext.isObject(deletedNameRef)){
							/*
							 * pass it out through the deletedNameRef
							 */
							deletedNameRef[it.name] = it;
						}
						
						this.setFileConfig('ref', it.name, undefined, undefined, true);						
					}else if(changed){
						it.json = Ext.encode(coord);
						this.fireEvent('updatefileconfig', it, this);
					}
				}
			}			
		}
		this.checkReferenceString();
		
		return flag;
	},
	
	checkNameRefForInsertCell : function(sheetId, minrow, mincol, rowSpan, colSpan, moveDir){
		var configs = this.fileConfig || {};
		var flag = false;
		var maxrow = minrow+rowSpan-1, maxcol = mincol+colSpan-1;
		for(var p in configs){
			if(configs.hasOwnProperty(p)){
				var it = configs[p];
				if('ref' == it.ctype){					
					var coord = Ext.decode(it.json);
					var changed = false;
					for(var i = 0, len = coord.length; i < len; i++){
						var o = coord[i];
						var arr = o.span;
						if(sheetId === arr[0]){		
							if('right' === moveDir){
								if(minrow <= arr[1] && maxrow >= arr[3]){
									if(mincol <= arr[2]){
										arr[2] += colSpan;
										if(0 !== arr[4]){
											arr[4] += colSpan;
										}								
										changed = true;
									}else if(mincol <= arr[4]){								
										/*
										 * special for something like C1+C3
										 */
										if(arr[2] == arr[4] && !inFun){
											arr[2] += colSpan;
										}
										arr[4] += colSpan;
										changed = true;
									}
									flag = flag || changed;	
								}								
							}else{
								if(mincol <= arr[2] && maxcol >= arr[4]){
									if(minrow <= arr[1]){
										arr[1] += rowSpan;
										if(0 !== arr[3]){
											arr[3] += rowSpan;
										}								
										changed = true;
									}else if(minrow <= arr[3]){
										/*
										 * special for something like C1+C3
										 */
										if(arr[1] == arr[3] && !inFun){
											arr[1] += rowSpan;
										}
										arr[3] += rowSpan;
										changed = true;
									}
									flag = flag || changed;	
								}								
							}							
						}
					}								
					if(changed){
						it.json = Ext.encode(coord);
						this.fireEvent('updatefileconfig', it, this);
					}
				}
			}			
		}
		this.checkReferenceString();
		
		return flag;
	},
      
    /**
     * _private
     */
    getCellsJson : function(shortName){
        var json = [], sheetName = 'sheet', rowName = 'row', colName = 'col', calName = 'cal', jsonName = 'json';
        if(shortName){
            sheetName = 'i';
            rowName = 'x';
            colName = 'y';
            calName = 'c';
            jsonName = 'j';
        }
        var dp = this.defaultProperty;
        var avoidProperty = (['cdt', 'minrow', 'mincol', 'maxrow', 'maxcol', 'abminrow', 'abmincol', 'abmaxrow', 'abmaxcol', 'display'].concat(EnterpriseSheet.sheet.calculate.Condition.styles)).concat(EnterpriseSheet.sheet.calculate.Calculate.calGeneratedStyles);
        this.each(function(rec){
            var data = rec.data;
            var obj = {};
            obj[sheetName] = data.sheet;
            obj[rowName] = data.row;
            obj[colName] = data.col;
            obj[calName] = data.json.cal;
            var cp = Ext.apply({}, data.json);
            for(var i = 0, len = avoidProperty.length; i < len; i++){
                delete(cp[avoidProperty[i]]);
            }
            if(0 < SCOM.countObjMember(cp)){
                obj[jsonName] = Ext.encode(cp);
                json.push(obj);
            }
        }, this);

        return json;
    },
           
    getFloatings : function(){
        return this.floatings;
    },
           
    getMergeFloatings : function(){
        var obj = {};
        for(var p in this.mergeLookup){
            if(this.mergeLookup.hasOwnProperty(p)){
                obj[p] = this.floatings[p];
            }
        }
        return obj;
    },
           
    getFloatingsJson : function(){
        var json = [];
        for(var p in this.floatings){
            if(this.floatings.hasOwnProperty(p)){
                json.push(Ext.apply({}, this.floatings[p]));
            }
        }
        return json;
    },
           
    getFileConfigJson : function(){
        var json = [];
        for(var p in this.fileConfig){
            if(this.fileConfig.hasOwnProperty(p)){
                json.push(Ext.apply({}, this.fileConfig[p]));
            }
        }
        return json;
    },
           
    /**
     * sync sheet ids
     */
    sync2NewSheetIds : function(map){
        for(var i = 0, len = this.sheets.length; i < len; i++){
            var it = this.sheets[i];
            it.id = Number(map[it.id]);
        }
        var recs = [];
        this.each(function(rec){
            var data = rec.data;
            data.sheet = Number(map[data.sheet]);
            delete(data.id);
            recs.push(data);
        }, this);
        var records  = this.reader.read(recs);

        this.loadRecords(records, { addRecords: false });
        
        for(var p in this.floatings){
            if(this.floatings.hasOwnProperty(p)){
                var it = this.floatings[p];
                it.sheet = Number(map[it.sheet]);
            }
        }
    },
           
    /**
     * is existed name
     */
    isExistedSheetName : function(name){
        name = name.toUpperCase();
        var sheets = this.getSheets();
        for(var i = 0, len = sheets.length; i < len; i++){
            var s = sheets[i];
            if(name == s.name.toUpperCase()){
                return true;
            }
        }
        return false;
    },
           
    /**
     * shrink the passed coord to a smaller coord just cover the cells with content
     */
    shrinkCoordWithContent : function(coord){
        for(var i = 0, len = coord.length; i < len; i++){
            var span = coord[i];
            var sheetId = span[0], minRow = span[1], minCol = span[2], maxRow = span[3], maxCol = span[4];
            if(0 === maxRow && 0 === maxCol){
                var contentMaxRow = false, contentMaxCol = false;
                this.each(function(rd){
                    if(rd.data.sheet === sheetId){
                        var row = rd.data.row, col = rd.data.col, json = rd.data.json;
                        if(minRow < row && minCol <= col && json.data){
                            if(false === contentMaxRow || contentMaxRow < row){
                                contentMaxRow = row;
                            }
                            if(false === contentMaxCol || contentMaxCol < col){
                                contentMaxCol = col;
                            }
                        }
                    }
                }, this);
                if(false !== contentMaxRow){
                    span[3] = contentMaxRow;
                    if(0 === span[1]){
                        span[1] = 1;
                    }
                }
                if(false !== contentMaxCol){
                    span[4] = contentMaxCol;
                    if(0 === span[2]){
                        span[2] = 1;
                    }
                }
            }else if(0 === maxRow){
                var contentMaxRow = false;
                this.each(function(rd){
                    if(rd.data.sheet === sheetId){
                        var row = rd.data.row, col = rd.data.col, json = rd.data.json;
                        if(minRow < row && json.data && minCol <= col && col <= maxCol){
                            if(false === contentMaxRow || contentMaxRow < row){
                                contentMaxRow = row;
                            }
                        }
                    }
                }, this);
                if(false !== contentMaxRow){
                    span[3] = contentMaxRow;
                    if(0 === span[1]){
                        span[1] = 1;
                    }
                }
            }else if(0 === maxCol){
                var contentMaxCol = false;
                this.each(function(rd){
                    if(rd.data.sheet === sheetId){
                        var row = rd.data.row, col = rd.data.col, json = rd.data.json;
                        if(minCol < col && json.data && minRow <= row && row <= maxRow){
                            if(false === contentMaxCol || contentMaxCol < col){
                                contentMaxCol = col;
                            }
                        }
                    }
                }, this);
                if(false !== contentMaxCol){
                    span[4] = contentMaxCol;
                    if(0 === span[2]){
                        span[2] = 1;
                    }
                }
            }
        }
        return coord;
    },
           
    isLinkCell : function(cell){
        return (cell.clink || cell.link) ? true : false;
    },
           
    getCellLink : function(cell){
        return cell.clink || cell.link;
    },
           
    getCellFormat : function(cell){
        return cell.cfm || cell.fm;
    },        
           
    /**
     * load data source
     */
    setValueToVariable : function(vnVals, suspendEvent){
        var changedCells = {}, vcells = [], varLookup = {};
    
        this.each(function(rec){
            var sheetId = rec.data.sheet;
            var json = rec.data.json, vname = json.vname;
            if(Ext.isDefined(vname)){
                vcells.push(rec);
                var arr = vname.split('.');
                var found = vnVals[vname];
                
                if(1 < arr.length){
                    var last = arr.pop();
                    var pname = arr.join('.');
                    varLookup[pname] = varLookup[pname] || {
                        names: {},
                        posArr: []
                    };
                    var obj = varLookup[pname];
                    obj.names[last] = found;
                    obj.posArr.push([sheetId, rec.data.row, rec.data.col]);
                }
            }
        }, this);

        for(var p in varLookup){
            if(varLookup.hasOwnProperty(p)){
                var it = varLookup[p], names = it.names, posArr = it.posArr, rowFlag = undefined, colFlag = undefined, sheetId, row, col;
                for(var i = 0, len = posArr.length; i < len; i++){
                    var pos = posArr[i], rid = pos[0]+'-'+pos[1], cid = pos[0]+'-'+pos[2];
                    sheetId = pos[0];
                    row = pos[1];
                    col = pos[2];
                    if(!Ext.isDefined(rowFlag)){
                        rowFlag = rid;
                    }else if(rowFlag !== rid){
                        rowFlag = false;
                    }
                    if(!Ext.isDefined(colFlag)){
                        colFlag = cid;
                    }else if(colFlag !== cid){
                        colFlag = false;
                    }
                }
                if(false !== rowFlag){
                    var max = 0;
                    for(var q in names){
                        if(names.hasOwnProperty(q)){
                            var len = names[q].length;
                            if(max < len){
                                max = len;
                            }
                        }
                    }
                    var i = row+1, minr, maxr;
                    while(true){
                        var cell = this.getCell(sheetId, i, 0);
                        if(cell.vng !== p){
                            break;
                        }else{
                            if(!Ext.isDefined(minr) || minr > i){
                                minr = i;
                            }
                            if(!Ext.isDefined(maxr) || maxr < i){
                                maxr = i;
                            }
                        }
                        i++;
                    }
                    var mergedBroken = false;
                    this.walkRange([[sheetId, row, 0, row, 0]], function(rd){
                        var r = rd.data.row, c = rd.data.col, json = rd.data.json;
                        if(Ext.isDefined(json.minrow) && json.minrow !== json.maxrow){
                            mergedBroken = true;
                        }
                    }, this);
                    if(!mergedBroken){
                        if(Ext.isDefined(minr)){
                            this.removeRow(sheetId, minr, maxr);
                        }
                        this.insertRow(sheetId, row+1, max-1);
                        /*
                         * need special process for merged cell
                         */
                        this.walkRange([[sheetId, row, 0, row, 0]], function(rd){
                            var r = rd.data.row, c = rd.data.col, json = rd.data.json;
                            if(Ext.isDefined(json.minrow)){
                                for(var i = row+1, end = row+max; i < end; i++){
                                    this.setCell(sheetId, i, c, Ext.copyTo({}, json, 'minrow,mincol,maxrow,maxcol,abminrow,abmincol,abmaxrow,abmaxcol'), null, true);
                                }
                            }
                        }, this);
                        for(var i = row+1, end = row+max; i < end; i++){
                            this.setCell(sheetId, i, 0, {'vng': p}, undefined, true);
                        }
                    }
                }
            }
        }
        for(var k = 0, size = vcells.length; k < size; k++){
            var rec = vcells[k];
       
            var sheetId = rec.data.sheet;
            var json = rec.data.json, vname = json.vname;
            var arr = vname.split('.');
            var found = vnVals[vname];
            
            if(Ext.isDefined(found)){
                if(Ext.isArray(found)){
                    for(var i = 0, len = found.length; i < len; i++){
                        this.setCell(sheetId, rec.data.row+i, rec.data.col, {'data': found[i]}, undefined, suspendEvent);
                        var pos = [sheetId, rec.data.row+i, rec.data.col], id = pos.join(this.separateChar);
                        changedCells[id] = pos;
                    }
                }else{
                    this.setCell(sheetId, rec.data.row, rec.data.col, {'data': found}, undefined, suspendEvent);
                    var pos = [sheetId, rec.data.row, rec.data.col], id = pos.join(this.separateChar);
                    changedCells[id] = pos;
                }
            }
        };
        return changedCells;
    },
    
    /**
     * return true if there is disabled cell in the coord
     */
    isCoordContainDisabledCell : function(coord){
    	var flag = false;    	
    	this.walkRange(coord, function(rec){
    		var json = rec.data.json;
    		if(this.isDisabledForMe(json.dsd)){
    			flag = true;
    			return false;
    		}
    	}, this);
    	if(!flag){
    		for(var i = 0, len = coord.length; i < len; i++){
    			var span = coord[i];
    			var cell = this.getCell(span[0], 0, 0);
    			if(this.isDisabledForMe(cell.dsd)){
    				return true;
    			}
    			for(var r = span[1]; r <= span[3]; r++){
    				var cell = this.getCell(span[0], r, 0);
    				if(this.isDisabledForMe(cell.dsd)){
    					return true;
    				}
    			}
    			for(var c = span[2]; c <= span[4]; c++){
    				var cell = this.getCell(span[0], 0, c);
    				if(this.isDisabledForMe(cell.dsd)){
    					return true;
    				}
    			}
    		}
    	}
    	return flag;
    },
    
    getRowHiddens : function(sheetId){
    	var hiddens = [];
    	this.each(function(rec){
    		if(sheetId === rec.data.sheet && 0 === rec.data.col){
    			var hidden = rec.data.json.hidden;
    			if(hidden){
    				hiddens.push(rec.data.row);
    			}
    		}
    	}, this);
    	var hidePairs = SCOM.transferArr2Pairs(hiddens);
    	return hidePairs;
    },
    
    getColHiddens : function(sheetId){
    	var hiddens = [];
    	this.each(function(rec){
    		if(sheetId === rec.data.sheet && 0 === rec.data.row){
    			var hidden = rec.data.json.hidden;
    			if(hidden){
    				hiddens.push(rec.data.col);
    			}
    		}
    	}, this);
    	var hidePairs = SCOM.transferArr2Pairs(hiddens);
    	return hidePairs;
    },
    
    presetRowHiddens : function(sheetId, json){
    	var data = this.getData(), sep = this.separateChar;
    	for(var i = 0, len = json.length; i < len; i++){
            var it = json[i];
            for(var j = it[0]; j <= it[1]; j++){
            	var id = [sheetId, j, 0].join(sep);
            	var found = data[id];
            	if(found){
            		found[3].hidden = true;
            	}else{
            		this.newRecord(sheetId, j, 0, {
            			hidden: true
            		});
            	}
            }
		}
    },
    
    presetColHiddens : function(sheetId, json){
    	var data = this.getData(), sep = this.separateChar;
    	for(var i = 0, len = json.length; i < len; i++){
            var it = json[i];
            for(var j = it[0]; j <= it[1]; j++){
            	var id = [sheetId, 0, j].join(sep);
            	var found = data[id];
            	if(found){
            		found[3].hidden = true;
            	}else{
            		this.newRecord(sheetId, 0, j, {
            			hidden: true
            		});
            	}
            }
		}
    },
    
    /**
     * the difference between presetColHiddens and syncColHiddens is the second one will make the hidden and show of all columns
     */
    syncColHiddens : function(sheetId, json){
    	var data = this.getData(), sep = this.separateChar, lookup = {};
    	for(var i = 0, len = json.length; i < len; i++){
            var it = json[i];
            for(var j = it[0]; j <= it[1]; j++){
            	lookup[j] = true;            	
            }
		}
    	this.each(function(rec){
    		if(rec.data.sheet === sheetId && 0 === rec.data.row){
    			if(!lookup[rec.data.col]){
    				var id = [sheetId, 0, rec.data.col].join(sep);
                	var found = data[id];
                	if(found){
                		delete(found[3].hidden);
                		this.syncColWidthCache(sheetId, rec.data.col);    
                	}
    			}
    		}
    	}, this);
    	for(var j in lookup){
    		if(lookup.hasOwnProperty(j)){
    			var id = [sheetId, 0, j].join(sep);
            	var found = data[id];
            	if(found){
            		found[3].hidden = true;
            	}else{
            		this.newRecord(sheetId, 0, j, {
            			hidden: true
            		});
            	}
            	this.syncColWidthCache(sheetId, j);
    		}
    	}       	    	   
    },
    
    syncRowHiddens : function(sheetId, json){
    	var data = this.getData(), sep = this.separateChar, lookup = {};
    	for(var i = 0, len = json.length; i < len; i++){
            var it = json[i];
            for(var j = it[0]; j <= it[1]; j++){
            	lookup[j] = true;            	
            }
		}
    	this.each(function(rec){
    		if(rec.data.sheet === sheetId && 0 === rec.data.col){
    			if(!lookup[rec.data.row]){
    				var id = [sheetId, rec.data.row, 0].join(sep);
                	var found = data[id];
                	if(found){
                		delete(found[3].hidden);
                		this.syncRowHeightCache(sheetId, rec.data.row);
                	}
    			}
    		}
    	}, this);
    	for(var i in lookup){
    		if(lookup.hasOwnProperty(i)){
    			var id = [sheetId, i, 0].join(sep);
            	var found = data[id];
            	if(found){
            		found[3].hidden = true;
            	}else{
            		this.newRecord(sheetId, i, 0, {
            			hidden: true
            		});
            	}
            	this.syncRowHeightCache(sheetId, i);
    		}
    	}        	
    },
    
    /**
     * save the extraInfo
     */
    saveExtraInfo : function(sheetId, extraInfo, applyWay, callback, scope){
    	var sheet = this.getSheetById(sheetId);
    	if('clear' === applyWay){
    		sheet.extraInfo = Ext.encode(extraInfo);
    	}else{
    		var exInfo = {};
    		if(sheet.extraInfo){
    			exInfo = Ext.decode(sheet.extraInfo);
    		}    		
    		Ext.apply(exInfo, extraInfo);
    		sheet.extraInfo = Ext.encode(exInfo);
    	}    	
    	Ext.Ajax.request({
    		url: SCONFIG.urls['updateExtraInfo'],
    		params: {
    			sheetId: sheetId,
    			extraInfo: sheet.extraInfo
    		},
    		callback: function(options, success, response){
    			if('true' === success || true === success){
    				Ext.Msg.alert(SLANG['hint'], SLANG['change_saved']);
    			}else{
    				Ext.Msg.alert(SLANG['hint'], SLANG['fail2save']);
    			}
    			if(callback){
    				callback.call(scope, success, response);
    			}
    		},
    		scope: this
    	});
    },
    
    getRelatedCdtCoord : function(coords){
        var lookup = {}, store = this;
        var cdts = store.getConditionLookup(), coordPro = EnterpriseSheet.sheet.calculate.Coordinate.prototype;
        store.walkRange(coords, function(rec){
            var sheetId = rec.data.sheet, row = rec.data.row, col = rec.data.col;
            var cellCoord = [sheetId, row, col];
            for(var p in cdts){
    			if(cdts.hasOwnProperty(p) && !lookup.hasOwnProperty(p)){
    				var it = cdts[p], jsonObj = it.jsonObj, refs = it.refs;
    				if('vd' !== jsonObj.name){
	    				if(refs && coordPro.isCellInCoord(cellCoord, refs)){
                            /*
                             * delete the cache of condition, so it will be recal
                             */
                            delete(it.cache);
	    					lookup[p] = {
	    						sheet: sheetId,
	    						id: jsonObj.id
	    					};
	    				}
    				}
    			}
    		}                
        }, this, true);
        
        
        var cdtCoord = [], sep = EnterpriseSheet.sheet.data.reader.CellReader.prototype.separateChar, map = {};
        for(var p in lookup){
            if(lookup.hasOwnProperty(p)){
                var it = lookup[p], id = it.id, sheetId = it.sheet;
                var cdt = store.getConditionById(id, sheetId), name = cdt.name, range = cdt.rng;
                for(var i = 0, len = range.length; i < len; i++){
                    var span = range[i].span, spanId = span.join(sep);
                    if(!map[spanId]){
                        map[spanId] = true;
                        cdtCoord.push(span);
                    }
                }
            }
        }

        return cdtCoord;
    },
    
    getDefinedNameContent : function(name){
    	var item = this.getFileConfigById(name, 'named_func');
    	if(item){    		
    		var json = Ext.decode(item.json);
    		return json.cal;
    	}else{
    		item = this.getFileConfigById(name, 'ref');
    		if(item){
    			return Ext.decode(item.json);
    		}
    	}
    }
});
Ext.define('EnterpriseSheet.sheet.data.PullingStore', {
	/* Begin Definitions */
	
	extend : 'EnterpriseSheet.sheet.data.Store',
	
	/*
	 * the buffer for do the pullling after made some actions
	 */
	pullingBuffer: 500,
	
	/*
	 * the defer time to check again if it's already pulling
	 */
	repullingDefer: 1000,
	
	/*
	 * the limit number of actions to update at one single time
	 * In general, this only happens for first time during inject data
	 * I make it a little bit bigger for save time.
	 */
	limitActionNum: 1000,
	
	//disabledPulling: true,
	
	constructor : function(){
		var avoidProperty = (['hidden', 'plain', 'pending', 'value', 'arg', 'cdt', 'mid', 'minrow', 'mincol', 'maxrow', 'maxcol', 'abminrow', 'abmincol', 'abmaxrow', 'abmaxcol', 'display', 'refs', 'cdtVal', 'lastVal', 'timestamp'].concat(EnterpriseSheet.sheet.calculate.Condition.styles)).concat(EnterpriseSheet.sheet.calculate.Calculate.calGeneratedStyles);
		var o = {};
		for(var i = 0, len = avoidProperty.length; i < len; i++){
			o[avoidProperty[i]] = true;
		}
		this.avoidSaveProperty = o;
		/*
		 * init action queue
		 */
		this.initActionQueue();
		
		this.callParent(arguments);
		
		
		/*
		 * add buffer listener for pullingaction
		 */
		this.on('pullingaction', this.doPulling, this, {buffer: this.pullingBuffer});
		
		this.on({
			scope: this,
			'beforeholdremovecolumn': this.onRemoveColumn,
			'beforeholdinsertcolumn': this.onInsertColumn,
			'beforeholdremoverow': this.onRemoveRow,
			'beforeholdinsertrow': this.onInsertRow,
			'beforeholdremovecell': this.onRemoveCell,
			'beforeholdinsertcell': this.onInsertCell,
			/*
			 * for floating
			 */
			'createfloatingitem': this.createFloatingItem,
			'updatefloatingitem': this.updateFloatingItem,
			'removefloatingitem': this.removeFloatingItem,
			/*
			 * for file config
			 */
			'createfileconfig': this.createFileConfig,
			'updatefileconfig': this.updateFileConfig,
			'removefileconfig': this.removeFileConfig
		});
	},
	/*
	 * init action queue
	 */
	initActionQueue : function(){
		this.actionQueue = [];
	},	
	
	/**
	 * shift action queue, and return the shifted actions
	 */
	shiftActionQueue : function(){
		var len = this.actionQueue.length;
		if(len <= this.limitActionNum){
			var tmp = this.actionQueue;
			this.initActionQueue();
			return tmp;
		}else{
			var tmp = this.actionQueue.splice(0, this.limitActionNum);
			return tmp;
		}
	},
           
    unshiftActionQueue : function(arr){
        this.actionQueue.unshift.apply(this.actionQueue, arr);
    },
	
	/*
	 * do the pulling action
	 */
	doPulling : function(store){
		this.pullingAction();
	},
	
	/**
	 * return true if the pulling action is still processing
	 */
	isPulling : function(){
		return this._pullingFlag;
	},
	
	/**
	 * lock the pulling
	 */
	lockPulling : function(){
		this._pullingFlag = true;
	},
	
	/**
	 * unlock the pulling
	 */
	unlockPulling : function(){
		delete(this._pullingFlag);
	},
	
	/**
	 * check whether the queue is empty or not
	 */
	isEmptyQueue : function(){
		return 0 === this.actionQueue.length || this.isDisabledPulling();
	},
           
    isDisabledPulling : function(){
        return this.disabledPulling || SCOM.nullOrUndefined(this.fileId);
    },
	
	/*
	 * pulling the server for the actions
	 */
	pullingAction : function(callback, scope){
		var me = this;
        if(this.isDisabledPulling()){
            /*
             * clean it up
             */
            this.actionQueue = [];
            if(callback){
                callback.call(scope || me);
            }
            return;
        }
		var isEmpty = this.isEmptyQueue();
		if(this.isPulling()){
			if(!isEmpty){		
				Ext.Function.defer(function(){
					me.pullingAction(callback, scope);
				}, me.repullingDefer, me);
			}
		}else{
			if(!isEmpty){		

				// ok, we need check whether this is public view, if yes do not do anything ...
				if (this.isViewOnlyFile()) { // this is not right, something wrong in here ...
					this.actionQueue = [];
					return;
				}
				
				this.lockPulling();
				
				/*
				 * assemble the actions
				 */
                var pendingActions = this.shiftActionQueue();
				var actions = Ext.encode(pendingActions);
				//console.log(actions)
                var afterPulled = function(){
                    me.checkSeverStatus();
                    me.fireEvent('pull', me);
                    
                    if(callback){
                        callback.call(scope || me);
                    }
                    me.unlockPulling();
                    /*
                     * if the queue is not empty, then pull again
                     */
                    if(!me.isEmptyQueue()){
                        me.fireEvent('pullingaction', me);
                    }else{
                        me.fireEvent('pullover', me);
                    }
                }
                this.fireEvent('beforepull', this);
                Ext.Ajax.request({
                    url: SCONFIG.urls['update'],
                    params: {
                    	fileId: this.fileId,
                        actions: actions
                    },
                    success: function(response, options){
                        var json = Ext.decode(response.responseText), success = json.success;
                        if(true == success || "true" == success){
                            afterPulled();
                        }else{
                            me.serverFailureAction = {
                                action: 'pullAction',
                                pendingActions: pendingActions
                            };
                            me.processServerFailure(response);
                        }
                    },
                    failure: function(response){
                        me.serverFailureAction = {
                            action: 'pullAction',
                            pendingActions: pendingActions
                        };
                        if('disconnected' !== me.processServerFailure(response)){
                            afterPulled();
                        }
                    },
                    scope: scope || me
                });
			}else if(callback){
				callback.call(scope || me);
			}
		}				
	},
	
	/**
	 * add an action to queue
	 */
	addAction2Queue : function(act, suspendAddEvent){
		var len = this.actionQueue.length;
		var skip = false, repeated = false;
		if(0 < len){
			var i = len-1;
			var last = this.actionQueue[i], lastAction = last.action;
			if('removeRow' == lastAction || 'insertRow' == lastAction || 
				'removeColumn' == lastAction || 'insertColumn' == lastAction ||
				'removeCell' == lastAction || 'insertCell' == lastAction ||                   
					'sortSpan' == lastAction || 'moveRows' == lastAction){
				
			}else if('setCell' == act.action){
				if(last.action == act.action && last.sheetId == act.sheetId && last.row == act.row && last.col == act.col){
					this.actionQueue.splice(i, 1);	
					repeated = true;
				}					
			}else if('updateFloatingItem' == act.action){
				if(last.sheetId == act.sheetId && last.name == act.name){
					if(last.action == act.action){
						this.actionQueue.splice(i, 1);	
						repeated = true;
					}else if('createFloatingItem' == last.action && last.json === act.json){
						skip = true;
					}						
				}
			}else if('updateHiddens' == act.action){
				if(last.sheetId == act.sheetId && last.name == act.name){
					if(last.action == act.action){
						this.actionQueue.splice(i, 1);	
						repeated = true;
					}						
				}
			}
		}
		if(!skip){
			this.actionQueue.push(act);
		}
		if(!suspendAddEvent){
			this.fireEvent('afteraddaction', act, {
				skip: skip,
				repeated: repeated
			}, this);
		}		
		
		this.fireEvent('pullingaction', this);
		return skip;
	},
           
	hideRow : function(sheet, minrow, maxrow, suspendEvent, suspendPull){
		var res = this.callParent(arguments);
		if(!suspendPull){
	        this.addAction2Queue({
				action: 'updateHiddens',
				fileId: this.fileId,
				sheetId: sheet,
				name: 'rowHiddens',	
				ftype: 'row',
				json: Ext.encode(this.getRowHiddens(sheet))
			});
		}
        return res;
    },
           
    showRow : function(sheet, minrow, maxrow, suspendEvent, suspendPull){
        var res = this.callParent(arguments);
        if(!suspendPull){
	        this.addAction2Queue({
				action: 'updateHiddens',
				fileId: this.fileId,
				sheetId: sheet,
				name: 'rowHiddens',	
				ftype: 'row',
				json: Ext.encode(this.getRowHiddens(sheet))
			});
        }
        return res;
    },
           
    hideColumn : function(sheet, mincol, maxcol, suspendEvent, suspendPull){
        var res = this.callParent(arguments);
        if(!suspendPull){        
	        this.addAction2Queue({
				action: 'updateHiddens',
				fileId: this.fileId,
				sheetId: sheet,
				name: 'colHiddens',		
				ftype: 'col',
				json: Ext.encode(this.getColHiddens(sheet))
			});
        }
        return res;
    },
           
    showColumn : function(sheet, mincol, maxcol, suspendEvent, suspendPull){
        var res = this.callParent(arguments);
        if(!suspendPull){
	        this.addAction2Queue({
				action: 'updateHiddens',
				fileId: this.fileId,
				sheetId: sheet,
				name: 'colHiddens',	
				ftype: 'col',
				json: Ext.encode(this.getColHiddens(sheet))
			});
        }
        return res;
    },

	/*
	 * override setCell
	 * @notice the last param is using to skip the pulling
	 * @param {boolean} skipPulling: true to skip the pulling the backend
	 */
	setCell : function(sheet, row, col, modified, deleted, suspendEvent, applyWay, skipPulling){		
		sheet = Number(sheet);
		row = Number(row);
		col = Number(col);
        
		var res = this.callParent(arguments);
		
		var origin = res[0] || {}, current = res[1] || {};
        
		var raw = current.data;
		if(SCOM.nullOrUndefined(raw)){
			raw = '';
		}
		if(!skipPulling){
			/*
			 * need check merge property
			 */
			this.checkMergeProperty(sheet, row, col, origin, current, skipPulling);
		}
				
        for(var p in origin){
            if(origin.hasOwnProperty(p) && this.avoidSaveProperty.hasOwnProperty(p)){
                delete(origin[p]);
            }
        }
       
        if(origin.tpl){
            var tpl = Ext.decode(origin.tpl);
            if(tpl.span[1] !== row || tpl.span[2] !== col){
                delete(origin.tpl);
            }
        }
       
		for(var p in current){
			if(current.hasOwnProperty(p) && this.avoidSaveProperty.hasOwnProperty(p)){
				delete(current[p]);
			}								
		}
					
        if(current.tpl){
            var tpl = Ext.decode(current.tpl);
            if(tpl.span[1] !== row || tpl.span[2] !== col){
                delete(current.tpl);
            }
        }
		var originStr = Ext.encode(origin), currentStr = Ext.encode(current);
        if(originStr !== currentStr){
            /*
             * add this action to queue
             */
        	if(!skipPulling){
                this.addAction2Queue({
                    action: 'setCell',
                    sheetId: sheet,
                    row: row,
                    col: col,
                    cal: current.cal || false,
                    data: raw,
                    json: currentStr
                });
                this.fireEvent('setcell2update', origin, current, this, sheet, row, col);
        	}
        	/*
        	 * fire an event for cell change
        	 */
        	this.fireEvent('aftercellchange', modified, deleted, origin, current, this, sheet, row, col);
        }           
			
		return res;
	},

	
	/**
	 * check merge property of the cell
	 */
	checkMergeProperty : function(sheet, row, col, origin, current){
		var sep = this.separateChar, abMinRow, abMinCol, abMaxRow, abMaxCol;
		var isCurMerged = !SCOM.isEmptyValue(current.minrow), isOrgMerged = !SCOM.isEmptyValue(origin.minrow); 
        if(isCurMerged){
            abMinRow = current.minrow+row;
            abMaxRow = current.maxrow+row;
            abMinCol = current.mincol+col;
            abMaxCol = current.maxcol+col;
        }        
		if((isCurMerged || isOrgMerged) && (origin.abminrow !== abMinRow || origin.abmincol !== abMinCol || origin.abmaxrow !== abMaxRow || origin.abmaxcol !== abMaxCol)){
			if(!SCOM.isEmptyValue(origin.abminrow)){
				var minrow = origin.abminrow;
				var mincol = origin.abmincol;
				var maxrow = origin.abmaxrow;
				var maxcol = origin.abmaxcol;
				var oid = [sheet, minrow, mincol, maxrow, maxcol].join(sep);
				this.setFloatingItem(sheet, oid, 'meg');
			}
			if(!SCOM.isEmptyValue(current.minrow)){
				var oid = [sheet, abMinRow, abMinCol, abMaxRow, abMaxCol].join(sep);
				if(!this.getFloatingById(oid, sheet)){
					var merge = [abMinRow, abMinCol, abMaxRow, abMaxCol];				
					this.setFloatingItem(sheet, oid, 'meg', Ext.encode(merge));
				}				
			}					
		}
		if(isCurMerged){
			var json = this.getCell(sheet, row, col);			
			Ext.apply(json, {				
				'abminrow' : abMinRow,
				'abmincol' : abMinCol,
				'abmaxrow' : abMaxRow,
				'abmaxcol' : abMaxCol
			});
		}
	},
	
	/*
	 * override load 
	 */
	load : function(){
		if(0 < this.actionQueue.length){
			var callParent = EnterpriseSheet.sheet.data.PullingStore.superclass.load;
			var args = arguments;
			this.pullingAction(function(){
				callParent.apply(this, args);
			}, this);
		}else{
			return this.callParent(arguments);
		}		
	},
	
	/*
	 * override afterLoad, clear the queue after load
	 */
	afterLoad : function(){
		this.initActionQueue();
		
		return this.callParent(arguments);
	},
	
	/*
	 * when a column in store is removed	
	 */
	onRemoveColumn : function(sheetId, mincol, maxcol, deleted, merged){  			
		/*
		 * add this action to queue
		 */
		this.addAction2Queue({
			action: 'removeColumn',
			fileId: this.fileId,
			sheetId: sheetId,
			mincol: mincol,
			maxcol: maxcol
		});
		this.checkMergedAfterDelete(merged, [sheetId, 0, mincol, 0, maxcol]);
		
		this.addAction2Queue({
			action: 'updateHiddens',
			fileId: this.fileId,
			sheetId: sheetId,
			name: 'colHiddens',		
			ftype: 'col',
			json: Ext.encode(this.getColHiddens(sheetId))
		});
	},
	
	/*
	 * when a column is inserted in store
	 */
	onInsertColumn : function(sheetId, col, colSpan){
		/*
		 * add this action to queue
		 */
		this.addAction2Queue({
			action: 'insertColumn',
			fileId: this.fileId,
			sheetId: sheetId,
			col: col,
			colSpan: colSpan
		});
		
		this.addAction2Queue({
			action: 'updateHiddens',
			fileId: this.fileId,
			sheetId: sheetId,
			name: 'colHiddens',		
			ftype: 'col',
			json: Ext.encode(this.getColHiddens(sheetId))
		});
	},
	
	/*
	 * when a row in store is removed	
	 */
	onRemoveRow : function(sheetId, minrow, maxrow, deleted, merged){  
		
		/*
		 * add this action to queue
		 */
		this.addAction2Queue({
			action: 'removeRow',
			fileId: this.fileId,
			sheetId: sheetId,
			minrow: minrow,
			maxrow: maxrow
		});
		this.checkMergedAfterDelete(merged, [sheetId, minrow, 0, maxrow, 0]);
        
		this.addAction2Queue({
			action: 'updateHiddens',
			fileId: this.fileId,
			sheetId: sheetId,
			name: 'rowHiddens',	
			ftype: 'row',
			json: Ext.encode(this.getRowHiddens(sheetId))
		});
	},
	
	/*
	 * when a row is inserted in store
	 */
	onInsertRow : function(sheetId, row, rowSpan){
		/*
		 * add this action to queue
		 */
		this.addAction2Queue({
			action: 'insertRow',
			fileId: this.fileId,
			sheetId: sheetId,
			row: row,
			rowSpan: rowSpan
		});
		
		this.addAction2Queue({
			action: 'updateHiddens',
			fileId: this.fileId,
			sheetId: sheetId,
			name: 'rowHiddens',	
			ftype: 'row',
			json: Ext.encode(this.getRowHiddens(sheetId))
		});
	},
	
	/*
	 * when cells in store are removed
	 */
	onRemoveCell : function(sheetId, minrow, maxrow, mincol, maxcol, moveDir, deleted, merged){
		
		/*
		 * add this action to queue
		 */
		this.addAction2Queue({
			action: 'removeCell',
			fileId: this.fileId,
			sheetId: sheetId,
			minrow: minrow,
			maxrow: maxrow,
			mincol: mincol,
			maxcol: maxcol,
			moveDir: moveDir
		});
		this.checkMergedAfterDelete(merged, [sheetId, minrow, mincol, maxrow, maxcol]);
	},
	
	/**
	 * check the merge cell change after delete
	 */
	checkMergedAfterDelete : function(merged, span){
		var sep = this.separateChar;
		var deleted = [], sheetId = span[0];
		for(var p in merged){
			if(merged.hasOwnProperty(p)){
				var it = merged[p];
				if((0 === span[3] || (span[1] <= it.minrow && span[3] >= it.minrow && span[1] <= it.maxrow && span[3] >= it.maxrow))
					&& (0 === span[4] || (span[2] <= it.mincol && span[4] >= it.mincol && span[2] <= it.maxcol && span[4] >= it.maxcol))){
					deleted.push([sheetId, it.minrow, it.mincol, it.maxrow, it.maxcol].join(sep));
				}
			}
		}
		for(var i = 0, len = deleted.length; i < len; i++){
			this.setFloatingItem(sheetId, deleted[i], 'meg');
		}
	},
	
	/*
	 * when cells are inserted in store
	 */
	onInsertCell : function(sheetId, row, col, rowSpan, colSpan, moveDir){
		/*
		 * add this action to queue
		 */
		this.addAction2Queue({
			action: 'insertCell',
			fileId: this.fileId,
			sheetId: sheetId,
			row: row,
			rowSpan: rowSpan,
			col: col,
			colSpan: colSpan,
			moveDir: moveDir
		});
	},
	
	/*
	 * override sortSpan
	 */
	sortSpan : function(span, keys, dir, sortOn, expand, allString, suspendEvent, suspendPull){
		sortOn = sortOn || 'col';
		var diff = this.callParent(arguments);
		
		if(diff && !suspendPull){
			/*
			 * add this action to queue
			 */
			this.addAction2Queue({
				action: 'sortSpan',
				fileId: this.fileId,
				span: span,
				diff: diff,
				sortOn: sortOn,
				expand: expand,
				allString: allString
			});
			var sheetId = span[0];
			this.addAction2Queue({
				action: 'updateHiddens',
				fileId: this.fileId,
				sheetId: sheetId,
				name: 'rowHiddens',	
				ftype: 'row',
				json: Ext.encode(this.getRowHiddens(sheetId))
			});
		}
		return diff;
	},
	
	/*
	 * override moveRows
	 */
	moveRows : function(sheetId, diff, mincol, maxcol, keyAsSource, suspendPull){
		this.callParent(arguments);
		if(!suspendPull){
			/*
			 * add this action to queue
			 */
			this.addAction2Queue({
				action: 'moveRows',
				fileId: this.fileId,
				sheetId: sheetId,
				diff: diff,
				mincol: mincol,
				maxcol: maxcol,
				keyAsSource: keyAsSource
			});
			
			this.addAction2Queue({
				action: 'updateHiddens',
				fileId: this.fileId,
				sheetId: sheetId,
				name: 'rowHiddens',	
				ftype: 'row',
				json: Ext.encode(this.getRowHiddens(sheetId))
			});
		}
	},
	
	/*
	 * create a floating item
	 */
	createFloatingItem : function(floatingItem){
		/*
		 * add this action to queue
		 */
		this.addAction2Queue({
			action: 'createFloatingItem',
			fileId: this.fileId,
			sheetId: floatingItem.sheet,
			name: floatingItem.name,	
			ftype: floatingItem.ftype,
			json: floatingItem.json
		});
	},
	
	/*
	 * update a floating item
	 */
	updateFloatingItem : function(floatingItem){
		/*
		 * add this action to queue
		 */
		this.addAction2Queue({
			action: 'updateFloatingItem',
			fileId: this.fileId,
			sheetId: floatingItem.sheet,			
			name: floatingItem.name,	
			ftype: floatingItem.ftype,
			json: floatingItem.json
		});
	},
	
	/*
	 * remove a floating item
	 */
	removeFloatingItem : function(floatingItem){
		/*
		 * add this action to queue
		 */
		this.addAction2Queue({
			action: 'removeFloatingItem',
			fileId: this.fileId,
			sheetId: floatingItem.sheet,
			name: floatingItem.name,
			ftype: floatingItem.ftype
		});
	},
	
	/*
	 * set the actived sheet id
	 */
	setActivedSheetId : function(sheetId){
		var ret = this.callParent(arguments);
		var oldActivedId, activedId;
		if(ret[0]){
			oldActivedId = ret[0].id;
		}
		if(ret[1]){
			activedId = ret[1].id;
		}
		/*
		 * add this action to queue
		 */
		var obj = {
			action: 'setActivedSheet',		
			fileId: this.fileId,
			activedSheetId: activedId
		};
		if(oldActivedId){
			obj['preActivedSheetId'] = oldActivedId;
		}
		this.addAction2Queue(obj);
		return ret;
	},
	
	/*
	 * add a new sheet
	 */
	addSheet : function(tabConfig, callback, scope, skipPull){
        tabConfig = tabConfig || {};
        var tabName = tabConfig.name, position = tabConfig.position;

        // in case tabName is not defined ... just get it now ...
        if (tabName == undefined || tabName == null) {
        	var len = this.sheets.length;
            tabName = SLANG['sheet'] + len;
            while(this.isExistedSheetName(tabName)){
                len++;
                tabName = SLANG['sheet']+len;
            }
            tabConfig.name = tabName;
        } else if(this.isExistedSheetName(tabName)){
            Ext.Msg.alert(SLANG['error'], SLANG['tab_name_existed']);
            return 'name_existed';
        }
        var callParent = EnterpriseSheet.sheet.data.PullingStore.superclass.addSheet;
        var args = arguments;
        if(this.disabledPulling || !Ext.isDefined(this.fileId) || skipPull){
            callParent.apply(this, [tabConfig, callback, scope, true]);
            return;
        }
		/*
		 * lock to stop pulling first
		 */
		this.lockPulling();
		Ext.Ajax.request({
			url: SCONFIG.urls.createSheet,
			params: Ext.apply({
				fileId: this.fileId,
				position: this.sheets.length
			}, tabConfig),
			success: function(response, options){				
				var json = Ext.decode(response.responseText);
				var sheetId = json.id;
				if(true == json.success || "true" == json.success){
					var obj = Ext.applyIf({
						id: sheetId,
						actived: false
					}, tabConfig);
                    if(Ext.isNumber(position)){
                         this.sheets.splice(position, 0, obj);
                    }else{
                         this.sheets.push(obj);
                    }
					if(callback){
						callback.call(scope, obj);
					}
					/*
					 * fire event
					 */
					this.fireEvent('addsheet', sheetId, name, this);
				}else{
                    this.serverFailureAction = {
                        action: 'addSheet',
                        tabConfig: tabConfig,
                        callback: callback,
                        scope: scope
                    };
                    this.processServerFailure(response);

					Ext.Msg.alert(SLANG['hint'], json.info);
				}
                this.checkSeverStatus();
			},
			failure: function(response){
                this.serverFailureAction = {
                    action: 'addSheet',
                    tabConfig: tabConfig,
                    callback: callback,
                    scope: scope
                };
                this.processServerFailure(response);
			},
			callback: function(){
				/*
				 * unlock
				 */
				this.unlockPulling();
			},
			scope: this
		});
	},
	
	/*
	 * extend deleteSheet, call backend first
	 */
	deleteSheet : function(sheetId, callback, scope, skipPull, suspendEvent){
		if(!suspendEvent){
			this.fireEvent('beforedeletesheet', sheetId, this);
		}		
		
		var callParent = EnterpriseSheet.sheet.data.PullingStore.superclass.deleteSheet;
		var args = arguments;
        if(this.disabledPulling || !Ext.isDefined(this.fileId) || skipPull){
           callParent.apply(this, args);
           return;
        }
		/*
		 * lock to stop pulling first
		 */
		this.lockPulling();
		
		Ext.Ajax.request({
			url: SCONFIG.urls.deleteSheet,
			params: {
				fileId: this.fileId,
				sheetId: sheetId
			},
			success: function(response, options){
				var json = Ext.decode(response.responseText);
				if(true === json.success || "true" === json.success){
					callParent.apply(this, args);
				}else{
                    this.serverFailureAction = {
                        action: 'deleteSheet',
                        sheetId: sheetId,
                        callback: callback,
                        scope: scope
                    };
                    this.processServerFailure(response);
                    if(callback){
                        callback.call(scope, null, false);
                    }
					Ext.Msg.alert(SLANG['hint'], json.info);
				}
                this.checkSeverStatus();                         
			},
			failure: function(response){
                this.serverFailureAction = {
                    action: 'deleteSheet',
                    sheetId: sheetId,
                    callback: callback,
                    scope: scope
                };
                this.processServerFailure(response);
                if(callback){
                    callback.call(scope, null, false);
                }
			},
			callback: function(){
				/*
				 * unlock
				 */
				this.unlockPulling();
			},
			scope: this
		});
	},
	
	/*
	 * extend renameSheet, call backend first
	 */
	renameSheet : function(sheetId, newName, callback, scope, skipPull){
        var sheetTab = this.getSheetById(sheetId);
        if(Ext.isDefined(newName) && this.isExistedSheetName(newName) && newName !== sheetTab.name){
            Ext.Msg.alert(SLANG['error'], SLANG['cannot_rename_existed_tabname']);
            return 'name_existed';
        }
           
		var callParent = EnterpriseSheet.sheet.data.PullingStore.superclass.renameSheet;
		var args = arguments;
        if(this.disabledPulling || !Ext.isDefined(this.fileId) || skipPull){
           callParent.apply(this, args);
           return;
        }
		/*
		 * lock to stop pulling first
		 */
		this.lockPulling();
		
		Ext.Ajax.request({
			url: SCONFIG.urls.renameSheet,
			params: {
				fileId: this.fileId,
				sheetId: sheetId,
				name: newName
			},
			success: function(response, options){
				var json = Ext.decode(response.responseText);
				if(json.success){
					callParent.apply(this, args);
				}else{
                    this.serverFailureAction = {
                        action: 'renameSheet',
                        sheetId: sheetId,
                        newName: newName,
                        callback: callback,
                        scope: scope
                    };
                    this.processServerFailure(response);
					Ext.Msg.alert(SLANG['hint'], json.info);
				}
                this.checkSeverStatus();
			},
			failure: function(response){
                this.serverFailureAction = {
                    action: 'renameSheet',
                    sheetId: sheetId,
                    newName: newName,
                    callback: callback,
                    scope: scope
                };
                this.processServerFailure(response);
			},
			callback: function(){
				/*
				 * unlock
				 */
				this.unlockPulling();
			},
			scope: this
		});
	},
           
    /*
     * extend changeSheetColor, call backend first
     */
    changeSheetColor : function(sheetId, color, callback, scope, skipPull){
        var callParent = EnterpriseSheet.sheet.data.PullingStore.superclass.changeSheetColor;
        var args = arguments;
        if(this.disabledPulling || !Ext.isDefined(this.fileId) || skipPull){
            callParent.apply(this, args);
            return;
        }
        /*
         * lock to stop pulling first
         */
        this.lockPulling();
           
        Ext.Ajax.request({
            url: SCONFIG.urls.changeSheetColor,
            params: {
                fileId: this.fileId,
                sheetId: sheetId,
                color: color
            },
            success: function(response, options){
                var json = Ext.decode(response.responseText);
                if(json.success){
                    callParent.apply(this, args);
                }else{
                    this.serverFailureAction = {
                        action: 'changeSheetColor',
                        sheetId: sheetId,
                        color: color,
                        callback: callback,
                        scope: scope
                    };
                    this.processServerFailure(response);
                    Ext.Msg.alert(SLANG['hint'], json.info);
                }
                this.checkSeverStatus();
            },
            failure: function(response){
                this.serverFailureAction = {
                    action: 'changeSheetColor',
                    sheetId: sheetId,
                    color: color,
                    callback: callback,
                    scope: scope
                };
                this.processServerFailure(response);
            },
            callback: function(){
                /*
                 * unlock
                 */
                this.unlockPulling();
            },
            scope: this
        });
    },
           
    /**
     * update the config for the passed sheet tab
     */
    updateSheetTab : function(sheetId, config, callback, scope, skipPull){
        if(!Ext.isDefined(sheetId)){
           sheetId = this.getActivedSheetId();
        }
        var sheetTab = this.getSheetById(sheetId);
        config = config || {};
        var name = config.name;
        if(Ext.isDefined(name) && this.isExistedSheetName(name) && name !== sheetTab.name){
            Ext.Msg.alert(SLANG['error'], SLANG['cannot_rename_existed_tabname']);
            return 'name_existed';
        }
           
        var callParent = EnterpriseSheet.sheet.data.PullingStore.superclass.updateSheetTab;
        var args = arguments;
        if(this.disabledPulling || !Ext.isDefined(this.fileId) || skipPull){
            callParent.apply(this, args);
            return;
        }
        /*
         * lock to stop pulling first
         */
        this.lockPulling();
           
        Ext.Ajax.request({
            url: SCONFIG.urls.updateSheetTab,
            params: Ext.applyIf({
                fileId: this.fileId,
                sheetId: sheetId
            }, config),
            success: function(response, options){
                var json = Ext.decode(response.responseText);
                if(json.success){
                    callParent.apply(this, args);
                }else{
                    this.serverFailureAction = {
                        action: 'updateSheetTab',
                        sheetId: sheetId,
                        config: config,
                        callback: callback,
                        scope: scope
                    };
                    this.processServerFailure(response);
                    Ext.Msg.alert(SLANG['hint'], json.info);
                }
                this.checkSeverStatus();
            },
            failure: function(response){
                this.serverFailureAction = {
                    action: 'updateSheetTab',
                    sheetId: sheetId,
                    config: config,
                    callback: callback,
                    scope: scope
                };
                this.processServerFailure(response);
            },
            callback: function(){
                /*
                 * unlock
                 */
                this.unlockPulling();
            },
            scope: this
        });
    },

	
	/*
	 * extend changeSheetOrder, call backend first
	 */
	changeSheetOrder : function(preIndex, curIndex, callback, scope, skipPull){
		var sheet = this.getSheets()[preIndex];
		var callParent = EnterpriseSheet.sheet.data.PullingStore.superclass.changeSheetOrder;
		var args = arguments;
        if(this.disabledPulling || !Ext.isDefined(this.fileId) || skipPull){
           callParent.apply(this, args);
           return;
        }
		/*
		 * lock to stop pulling first
		 */
		this.lockPulling();
		
		Ext.Ajax.request({
			url: SCONFIG.urls.changeSheetOrder,
			params: {
				fileId: this.fileId,
				sheetId: sheet.id,
				prePos: preIndex,
				curPos: curIndex
			},
			success: function(response, options){
				var json = Ext.decode(response.responseText);
				if(json.success){
					callParent.apply(this, args);
				}else{
                    this.serverFailureAction = {
                        action: 'changeSheetOrder',
                        preIndex: preIndex,
                        curIndex: curIndex,
                        callback: callback,
                        scope: scope
                    };
                    this.processServerFailure(response);
					Ext.Msg.alert(SLANG['hint'], json.info);
                    if(callback){
                        callback.call(scope, false);
                    }
				}
                this.checkSeverStatus();
			},
			failure: function(response){
                this.serverFailureAction = {
                    action: 'changeSheetOrder',
                    preIndex: preIndex,
                    curIndex: curIndex,
                    callback: callback,
                    scope: scope
                };
                this.processServerFailure(response);
                if(callback){
                    callback.call(scope, false);
                }
			},
			callback: function(){
				/*
				 * unlock
				 */
				this.unlockPulling();
			},
			scope: this
		});	
	},
	
	/*
	 * change file name
	 */
	changeFileName : function(fileName, callback, scope, suspendEvent, skipPull){
		var callParent = EnterpriseSheet.sheet.data.PullingStore.superclass.changeFileName;
        var args = arguments;
		if(this.disabledPulling || !Ext.isDefined(this.fileId) || skipPull){
            this.callParent(arguments);
            return;
        }
		/*
		 * lock to stop pulling first
		 */
		this.lockPulling();
		
		Ext.Ajax.request({
			url: SCONFIG.urls.changeFileName,
			params: {
				id: this.fileId,
				name: fileName
			},
			success: function(response, options){
				var json = Ext.decode(response.responseText);
                var success = ("true" == json.success || true === json.success);
				if(!success){
                    this.serverFailureAction = {
                        action: 'changeFileName',
                        fileName: fileName,
                        callback: callback,
                        scope: scope
                    };
                    this.processServerFailure(response);
					Ext.Msg.alert(SLANG['hint'], json.info);
                    if(callback){
                        callback.call(scope, success);
                    }
                }else{
					callParent.apply(this, args);
                }
                
                this.checkSeverStatus();
			},
			failure: function(response){
                this.serverFailureAction = {
                    action: 'changeFileName',
                    fileName: fileName,
                    callback: callback,
                    scope: scope
                };
                this.processServerFailure(response);
                if(callback){
                    callback.call(scope, false);
                }
			},
			callback: function(){
				/*
				 * unlock
				 */
				this.unlockPulling();
			},
			scope: this
		});	
	},
	
	/*
	 * change file stared status
	 */
	changeFileStared : function(fileStared, callback, scope, suspendEvent, skipPull){
        var callParent = EnterpriseSheet.sheet.data.PullingStore.superclass.changeFileStared;
        var args = arguments;
        if(this.disabledPulling || !Ext.isDefined(this.fileId) || skipPull){
            this.callParent(arguments);
            return;
        }
		/*
		 * lock to stop pulling first
		 */
		this.lockPulling();
		
		Ext.Ajax.request({
			url: SCONFIG.urls.changeFileStared,
			params: {
				fileId: this.fileId,
				fileStared: fileStared
			},
			success: function(response, options){
				var json = Ext.decode(response.responseText);
                var success = ("true" == json.success || true === json.success);
				if(!success){
                    this.serverFailureAction = {
                        action: 'changeFileStared',
                        fileStared: fileStared,
                        callback: callback,
                        scope: scope
                    };
                    this.processServerFailure(response);
					Ext.Msg.alert(SLANG['hint'], json.info);
                    if(callback){
                         callback.call(scope, success);
                    }
                }else{
					callParent.apply(this, args);
                }
                
                this.checkSeverStatus();
			},
			failure: function(response){
                this.serverFailureAction = {
                    action: 'changeFileStared',
                    fileStared: fileStared,
                    callback: callback,
                    scope: scope
                };
                this.processServerFailure(response);
                if(callback){
                    callback.call(scope, false);
                }
			},
			callback: function(){
				/*
				 * unlock
				 */
				this.unlockPulling();
			},
			scope: this
		});	
	},
	
	/*
	 * copy a sheet
	 */	
	copySheet : function(oldSheetId, newSheetName, callback, scope, newSheetId, skipPull){
        if(this.isExistedSheetName(newSheetName)){
            Ext.Msg.alert(SLANG['error'], SLANG['cannot_rename_existed_tabname']);
            return 'name_existed';
        }
        var callParent = EnterpriseSheet.sheet.data.PullingStore.superclass.copySheet;
        var args = arguments;
        if(this.disabledPulling || !Ext.isDefined(this.fileId) || skipPull){
           callParent.apply(this, args);
           return;
        }
           
		/*
		 * lock to stop pulling first
		 */
		this.lockPulling();
		
		Ext.Ajax.request({
			url: SCONFIG.urls.copySheet,
			params: {
				fileId: this.fileId,
				oldSheetId: oldSheetId,
				newSheetName: newSheetName,
				pos: this.sheets.length
			},
			success: function(response, options){
				var json = Ext.decode(response.responseText);
				if(json.success){
					var sheetId = Number(json.id);
                    var oldSheet = this.getSheetById(oldSheetId);
					var obj = Ext.applyIf({
						actived: false,						
						id: sheetId,
						name: newSheetName										
					}, oldSheet);										
					delete(obj['loadedEmptyCells']);
					this.sheets.push(obj);
					/*
					 * duplicate rec in the store
					 */
					
					this.each(function(rd){
						if(oldSheetId == rd.data.sheet){
							this.newRecord(sheetId, rd.data.row, rd.data.col, rd.data.json);
						}
					}, this);
					/*
					 * copy floatings
					 */
					this.copyFloatings(oldSheetId, sheetId);
					if(callback){
						callback.call(scope, obj, this);
					}
                    this.fireEvent('copysheet', sheetId, newSheetName, this);
				}else{
                    this.serverFailureAction = {
                        action: 'copySheet',
                        oldSheetId: oldSheetId,
                        newSheetName: newSheetName,
                        callback: callback,
                        scope: scope
                    };
                    this.processServerFailure(response);

					Ext.Msg.alert(SLANG['hint'], json.info);
				}
                this.checkSeverStatus();
			},
			failure: function(response){
                this.serverFailureAction = {
                    action: 'copySheet',
                    oldSheetId: oldSheetId,
                    newSheetName: newSheetName,
                    callback: callback,
                    scope: scope
                };
                this.processServerFailure(response);
			},
			callback: function(){
				/*
				 * unlock
				 */
				this.unlockPulling();
			},
			scope: this
		});	
	},
	
	/*
	 * create file config
	 */
	createFileConfig : function(config){
		/*
		 * add this action to queue
		 */
		this.addAction2Queue({
			action: 'createFileConfig',
			fileId: this.fileId,
			ctype: config.ctype,
			name: config.name,			
			json: config.json
		});
	},
	
	/*
	 * update a file config
	 */
	updateFileConfig : function(config){
		/*
		 * add this action to queue
		 */
		this.addAction2Queue({
			action: 'updateFileConfig',
			fileId: this.fileId,
			ctype: config.ctype,
			name: config.name,			
			json: config.json
		});
	},
	
	/*
	 * remove a file config
	 */
	removeFileConfig : function(config){
		/*
		 * add this action to queue
		 */
		this.addAction2Queue({
			action: 'removeFileConfig',
			fileId: this.fileId,
			ctype: config.ctype,
			name: config.name
		});
	},
           
    /**
     * process server failure
     */
    processServerFailure : function(response){
        var status = response.status, serverFailure = this.serverFailureAction;

        if(response.request && response.request.options){
           serverFailure.params = response.request.options.params;
        }
        
        if(300 <= status || 0 == status){
            if('pullAction' == serverFailure.action){
                /*
                 * means it could be a connection problem, we need check the connection later, and request again if resume
                 */
                this.unshiftActionQueue(serverFailure.pendingActions);
            }
            /*
             * fire event
             */
            this.fireEvent('disconnectserver', this);
            if('disconnected' !== this.serverStatus){
                this.serverStatus = 'disconnected';
            }
            Ext.Function.defer(function(){
                this.reconnectServer();
            }, SCONST['RECONNECT_SERVER_INTERVAL'], this);
            return 'disconnected';
        }else{
            var json = Ext.decode(response.responseText);
            if('relogin' === json.success){
                if('pullAction' == serverFailure.action){
                    /*
                     * means it could be a connection problem, we need check the connection later, and request again if resume
                     */
                    this.unshiftActionQueue(serverFailure.pendingActions);
                }
                return;
            }
            if(!this.errorReportWin){
                this.errorReportWin = Ext.create('EnterpriseSheet.sheet.pop.ErrorReportWin', {
                    reportCallback : {
                        fn: this.reportServerError,
                        scope: this
                    }
                });
            }
            this.errorReportWin.show();            
        }
    },
    
    /**
     * try to reconnect the server
     */
    reconnectServer : function(){
        if(this.serverFailureAction){
            var serverFailure = this.serverFailureAction, actionName = serverFailure.action;
            if('pullAction' == actionName){
                //SCONFIG.urls['update'] = SCONFIG.baseDir+'sheetCell/updateBatchCells'
                this.unlockPulling();
                this.pullingAction();
            }else if('addSheet' == actionName){
                this.addSheet(serverFailure.tabConfig, serverFailure.callback, serverFailure.scope);
            }else if('deleteSheet' == actionName){
                this.deleteSheet(serverFailure.sheetId, serverFailure.callback, serverFailure.scope);
            }else if('renameSheet' == actionName){
                this.renameSheet(serverFailure.sheetId, serverFailure.newName, serverFailure.callback, serverFailure.scope);
            }else if('changeSheetColor' == actionName){
                this.changeSheetColor(serverFailure.sheetId, serverFailure.color, serverFailure.callback, serverFailure.scope);
            }else if('copySheet' == actionName){
                this.copySheet(serverFailure.oldSheetId, serverFailure.newSheetName, serverFailure.callback, serverFailure.scope);
            }else if('updateSheetTab' == actionName){
                this.updateSheetTab(serverFailure.sheetId, serverFailure.config, serverFailure.callback, serverFailure.scope);
           }else if('changeSheetOrder' == actionName){
                this.changeSheetOrder(serverFailure.preIndex, serverFailure.curIndex, serverFailure.callback, serverFailure.scope);
           }else if('changeFileName' == actionName){
                this.changeFileName(serverFailure.fileName, serverFailure.callback, serverFailure.scope);
            }else if('changeFileStared' == actionName){
                this.changeFileStared(serverFailure.fileStared, serverFailure.callback, serverFailure.scope);
            }
        }
    },
           
    checkSeverStatus : function(){
        if('disconnected' === this.serverStatus){
            delete(this.serverStatus);
            delete(this.serverFailureAction);
            this.fireEvent('connectserver', this);
        }
    },
           
    reportServerError : function(comment){
        this.fireEvent('reportservererror', this.serverFailureAction, comment, this);
    }
});
Ext.define('EnterpriseSheet.sheet.data.RangeStore', {
	/* Begin Definitions */
	
	extend : 'Ext.data.Store',	
	
	/*
	 * the position of where the series, could be row or col
	 */
	seriesPosition: 'row',
	
	useAbs : false,
	
	constructor : function(config){
		Ext.apply(this, config);
		this.storeId = 'rs-'+Ext.id();
		/*
		 * generate fields and data
		 */
		this.generateFieldsData();				
		
		this.callParent(arguments);
		
		
		var store = this.sheet.getStore();
		
		this.mon(store, {
			scope: this,
			'valuechange': this.syncValueChange,
			'aftersortspan': this.afterSortSpan,
			'moverows': this.onMoveRows
		});
		this.mon(this.sheet, {
			scope: this,
			'holdremoverow': this.onRemoveRow,
			'holdremovecolumn': this.onRemoveColumn,
			'holdremovecell': this.onRemoveCell,
			'holdinsertcolumn': this.onInsertColumn,
			'holdinsertrow': this.onInsertRow,			
			'holdinsertcell': this.onInsertCell
		});
		this.mon(store, 'valuechange', this.onValueChange, this, {buffer: 50});
		/*
		 * buffer the regenerate action
		 */
		this.on('regeneratedata', this.regenerateData, this, {buffer: 100});
        this.checkLoad();
	},
           
    checkLoad : function(){
        var store = this.sheet.getStore();
        var coord = [];
        if(this.categories){
            coord = coord.concat(this.categories);
        }
        if(this.labels){
            coord = coord.concat(this.labels);
        }
        if(this.series){
            coord = coord.concat(this.series);
        }
		store.checkLoadCoord(coord, function(){
            this.fireEvent('regeneratedata', this);
        }, this);
    },
	
	/*
	 * get the source config for this range store
	 */
	getSourceConfig : function(){
		var curSheetId = this.sheet.getSheetId();
		
		var series = SCOM.copy(this.series);
		for(var i = 0, len = series.length; i < len; i++){
			var it = series[i];
			if(it[0] == curSheetId){
				it[0] = '';
			}
		}
		var categories = SCOM.copy(this.categories);
		if(categories){
			for(var i = 0, len = categories.length; i < len; i++){
				var it = categories[i];
				if(it[0] == curSheetId){
					it[0] = '';
				}
			}
		}		
		var labels = SCOM.copy(this.labels);
		if(labels){
			for(var i = 0, len = labels.length; i < len; i++){
				var it = labels[i];
				if(it[0] == curSheetId){
					it[0] = '';
				}
			}
		}		
		
		return {
			series: series,
			categories: categories,
			labels: labels,
			usAbs: this.useAbs,
			cacheFields: SCOM.copy(this.cacheFields)
		}
	},
	
	/*
	 * generate fields based on coord span
	 */
	generateFieldsData : function(){		
		if(!this.series && this.coord){
			/*
			 * parse range data to generate categories, labels and series
			 */
			this.parseRangeData();
		}else{
            if(!this.cacheFields){
                this.cacheFields = [{
                    name: 'category'
                }];
                for(var i = 0, len = this.series.length; i < len; i++){
                    this.cacheFields.push({
                        name: ('row' === this.seriesPosition ? SLANG['row'] : SLANG['column'])+(i+1)
                    });
                }
            }
            var flag;
            for(var i = 0, len = this.cacheFields.length; i < len; i++){
                if('category' === this.cacheFields[i].name){
                    flag = true;
                    break;
                }
            }
            if(!flag){
                this.cacheFields = [{name:'category'}].concat(this.cacheFields);
            }
			for(var i = 0, len = this.cacheFields.length; i < len; i++){
				var title = this.cacheFields[i].title;
				if(title){
					this.cacheFields[i].name = title;
				}
			}
			this.fields = SCOM.copy(this.cacheFields);
		}				

		/*
		 * generate data
		 */			
		this.inlineData = this.getDataFromSeries();				
	},		
	
	/*
	 * get category by index
	 */
	getCategoryByIndex : function(index){
		if(this.categories && index < this.categories.length){
			var span = this.categories[index];
			var cd = this.sheet.getCellData(span[0], span[1], span[2]);
			return SCOM.getPureText(cd.data);
		}
	},
	
	/*
	 * get label by index
	 */
	getLabelByIndex : function(index){
		if(this.labels && index < this.labels.length){
			var span = this.labels[index];
			var cd = this.sheet.getCellData(span[0], span[1], span[2]);
			
			return SCOM.getPureText(cd.data);
		}
	},
	
	getSeriesPosition : function(){
		return this.seriesPosition;
	},
	
	/*
	 * generate series based on the passed range
	 */
	generateSeries : function(sheetId, minRow, minCol, maxRow, maxCol){
		var series = [];
		if('row' == this.seriesPosition){
			for(var i = minRow; i <= maxRow; i++){
				series.push([sheetId, i, minCol, i, maxCol]);
			}
			/*
			 * generate fields
			 */
			var fields = [{
				'name': 'category'
			}];
			for(var i = minRow; i <= maxRow; i++){
				fields.push({
					'name': this.getCategoryByIndex(i-minRow) || SLANG['row']+i
				});
			}

			if(this.model && Ext.isFunction(this.model.setFields)){
				this.model.setFields(fields);
			}else{
				this.fields = fields;
			}
			
			/*
			 * save other ref
			 */
			this.cacheFields = [].concat(fields);
			
		}else{
			for(var i = minCol; i <= maxCol; i++){
				series.push([sheetId, minRow, i, maxRow, i]);
			}
			/*
			 * generate fields
			 */
			var fields = [{
				'name': 'category'
			}];
			for(var i = minCol; i <= maxCol; i++){
				fields.push({
					'name': this.getCategoryByIndex(i-minCol) || SLANG['column']+i
				});
			}

			if(this.model && Ext.isFunction(this.model.setFields)){
				this.model.setFields(fields);
			}else{
				this.fields = fields;
			}			
			/*
			 * save other ref
			 */
			this.cacheFields = [].concat(fields);
		}
		this.series = series;
	},
	
	/*
	 * generate categories and labels
	 */
	generateCategoriesAndLabels : function(span, rowFlag, colFlag){		
		var sheetId = span[0], minRow = span[1], minCol = span[2], maxRow = span[3], maxCol = span[4];
		var categories = [], labels = [];
        delete(this.categories);
        delete(this.labels);
		if('row' == this.seriesPosition){
			if(colFlag){
				/*
				 * get the coord of category and labels
				 */
				for(var i = (rowFlag ? minRow+1 : minRow); i <= maxRow; i++){
					categories.push([sheetId, i, minCol, i, minCol]);
				}
				this.categories = categories;
			}			
			if(rowFlag){
				for(var i = (colFlag ? minCol+1 : minCol); i <= maxCol; i++){
					labels.push([sheetId, minRow, i, minRow, i]);
				}
				this.labels = labels;
			}			
		}else{
			if(rowFlag){
				/*
				 * get the coord of category and labels
				 */
				for(var i = (colFlag ? minCol+1 : minCol); i <= maxCol; i++){
					categories.push([sheetId, minRow, i, minRow, i]);
				}
				this.categories = categories;
			}			
			if(colFlag){
				for(var i = (rowFlag ? minRow+1 : minRow); i <= maxRow; i++){
					labels.push([sheetId, i, minCol, i, minCol]);
				}
				this.labels = labels;
			}			 
		}
	},
	
	/*
	 * generate series and category
	 */
	parseRangeData : function(config){
		var span = this.coord[0];
		var sheetId = span[0], minRow = span[1], minCol = span[2], maxRow = span[3], maxCol = span[4];
		/*
		 * decide the series position
		 */
		if(!this.seriesPosition){
			
			if(minRow == maxRow){
				this.seriesPosition = 'row';
			}else if(minCol == maxCol){
				this.seriesPosition = 'col';
			}
		}
		
		var sheet = this.sheet, store = sheet.getStore();
        var rowFlag = false, colFlag = false;
        if(config){
            if(Ext.isDefined(config.firstRowLabel)){
                this.firstRowLabel = config.firstRowLabel;
            }
            if(Ext.isDefined(config.firstColLabel)){
                this.firstColLabel = config.firstColLabel;
            }
        }
        if(Ext.isDefined(this.firstRowLabel) || Ext.isDefined(this.firstColLabel)){
            rowFlag = this.firstRowLabel;
            if(rowFlag){
                minRow++;
            }
            colFlag = this.firstColLabel;
            if(colFlag){
                minCol++;
            }
        }else{
            /*
             * check the corner, see whether it's empty
             */
            var corner = store.getCell(sheetId, minRow, minCol);

            if(SCOM.nullOrUndefined(corner.data)){
                rowFlag = true;
                colFlag = true;
                minRow++;
                minCol++;
            }else{
                var nonNumFlag = true;
                for(var i = minRow; i <= maxRow; i++){
                    var cd = sheet.getCellValue(sheetId, i, minCol);
                    if(SCOM.canbeNumber(cd.data)){
                        nonNumFlag = false;
                        break;
                    }
                }
                if(nonNumFlag){
                    colFlag = true;
                    minCol++;
                }
                nonNumFlag = true;
                for(var i = minCol; i <= maxCol; i++){
                    var cd = sheet.getCellValue(sheetId, minRow, i);
                    if(SCOM.canbeNumber(cd.data)){
                        nonNumFlag = false;
                        break;
                    }
                }
                if(nonNumFlag){
                    rowFlag = true;
                    minRow++;
                }
            }
            this.firstRowLabel = rowFlag || false;
            this.firstColLabel = colFlag || false;
        }
		this.generateCategoriesAndLabels(span, rowFlag, colFlag);
		/*
		 * generate the series
		 */
		this.generateSeries(sheetId, minRow, minCol, maxRow, maxCol);		
	},
	
	/*
	 * generate data from series
	 */
	getDataFromSeries : function(){
		var sheet = this.sheet;
		var fields = this.cacheFields;
		/*
		 * generate data
		 */
		var data = [], series = this.series;
		var len = series.length;
		if('row' == this.seriesPosition){
			/*
			 * locate the longest span series
			 */
			var index, max = -1, span;
			for(var i = 0; i < len; i++){
				span = series[i];
				var offset = span[4]-span[2];
				if(offset > max){
					max = offset;
					index = i;
				}
			}
			if(SCOM.nullOrUndefined(index)){
				return;
			}
			var span = series[index];
			var min = span[2];
			max = span[4];
			for(var j = min; j <= max; j++){
				var index = j-min;
				var category = this.getLabelByIndex(index) || index+1;
				category = category.toString();
				var obj = {'category': category};
				for(var i = 0; i < len; i++){
					span = series[i];
					var col = j-min+span[2];
					var num = 0;
					if(col <= span[4]){
						var cd = sheet.getCellValue(span[0], span[1], col);
						num = Number(cd.data);
						num = Ext.isNumber(num) ? num : 0;
					}					
					/*
					 * the data part should be number
					 */
					if(true == this.useAbs){						
						if(0 > num){
							num = -num;
						}
					}
					obj[fields[i+1].name] = num;
				}
				data.push(obj);
			}					
		}else{
			/*
			 * locate the longest span series
			 */
			var index, max = -1, span;
			for(var i = 0; i < len; i++){
				span = series[i];
				var offset = span[3]-span[1];
				if(offset > max){
					max = offset;
					index = i;
				}
			}
			if(SCOM.nullOrUndefined(index)){
				return;
			}
			var span = series[index];
			var min = span[1];
			max = span[3];
			for(var j = min; j <= max; j++){
				var index = j-min;
				var category = this.getLabelByIndex(index) || index+1;
				category = category.toString();
				var obj = {'category': category};
				for(var i = 0; i < len; i++){
					span = series[i];
					var row = j-min+span[1];
					var num = 0;
					if(row <= span[3]){
						var cd = sheet.getCellValue(span[0], row, span[2]);
						num = Number(cd.data);
						num = Ext.isNumber(num) ? num : 0;
					}					
					/*
					 * the data part should be number
					 */
					if(this.useAbs){
						if(0 > num){
							num = -num;
						}
					}
					obj[fields[i+1].name] = num;
				}
				data.push(obj);
			}
		}
		
		return data;
	},
	
	/**
	 * need sync the data when any cell's value changed
	 */
	onValueChange : function(sheetId, row, col, modified, deleted, origin, current, store){
		
		var coord = [];
		if(this.categories){
			coord = coord.concat(this.categories);
		}
		if(this.labels){
			coord = coord.concat(this.labels);
		}
		if(this.series){
			coord = coord.concat(this.series);
		}
		//console.log(Ext.encode(coord))
		var sheet = this.sheet;
		var store = sheet.getStore();
		store.walkRange(coord, function(rd){
			var s = rd.data.sheet, r = rd.data.row, c = rd.data.col, json = rd.data.json;
			if(sheet.isCalculateCell(json)){
				sheet.processCalCdtData(s, r, c);
			}
		}, sheet);
	},
	
	/**
	 * need sync the data when any cell's value changed
	 */
	syncValueChange : function(sheet, row, col, modified, deleted, origin, current, store){		
		if(this.categories){
			for(var i = 0, len = this.categories.length; i < len; i++){
				var span = this.categories[i];
				if(sheet == span[0] && span[1] <= row && span[3] >= row && span[2] <= col && span[4] >= col){
					/*
					 * update the category
					 */
					this.cacheFields[i+1]['title'] = this.getCategoryByIndex(i);
					/*
					 * fire event to let the chart change the series title
					 */
					this.fireEvent('fieldtitlechange', this.cacheFields, this);
					
					this.fireEvent('regeneratedata', this);
					return;
				}
			}
		}
		if(this.labels){
			for(var i = 0, len = this.labels.length; i < len; i++){
				var span = this.labels[i];
				if(sheet == span[0] && span[1] <= row && span[3] >= row && span[2] <= col && span[4] >= col){
					this.fireEvent('regeneratedata', this);
					return;
				}
			}
		}
		if(this.series){
			for(var i = 0, len = this.series.length; i < len; i++){
				var span = this.series[i];
				if(sheet == span[0] && span[1] <= row && span[3] >= row && span[2] <= col && span[4] >= col){
					this.fireEvent('regeneratedata', this);
					return;
				}
			}
		}			
	},
	
	/*
	 * when sort span, we just simply regenerate the store
	 */
	afterSortSpan : function(span, keys, dir, sortOn, expand, allString, diff){
		this.regenerateAll();
	},
	
	/*
	 * when rows are moved, we just regenerate the store
	 */
	onMoveRows : function(sheetId, diff, mincol, maxcol, flag){
		this.regenerateAll();
	},
	
	/*
	 * re-generate and load data
	 */
	regenerateData : function(){		
		if(this.series){
			var data = this.getDataFromSeries();			
			this.loadData(data);
		}else{
			this.removeAll();
		}				
	},
	
	/*
	 * regenerate all data
	 */
	regenerateAll : function(){
		if(this.categories){
			var cacheFields = [this.cacheFields[0]];
			for(var i = 0, len = this.categories.length; i < len; i++){
				/*
				 * update the category
				 */
				var j = i+1;
				this.cacheFields[j]['title'] = this.getCategoryByIndex(i);
				cacheFields.push(this.cacheFields[j]);								
			}
			/*
			 * fire event to let the chart change the series title
			 */
			this.cacheFields = cacheFields;
			this.fireEvent('fieldtitlechange', this.cacheFields, this);
			this.fireEvent('regeneratedata', this);
			return;
		}
		this.fireEvent('regeneratedata', this);
		return;
	},
	
	/*
	 * get coord span
	 */
	getCoordSpan : function(){
		return [].concat(this.coord);
	},	
	
	/*
	 * get the coord reference based on series
	 */
	getCoordReference : function(){
		var arr = SCOM.copy(this.series);
		if(this.categories){
			var categories = [];
			for(var i = 0, len = this.categories.length; i < len; i++){
				categories.push({
					span: [].concat(this.categories[i]),
					cls: 'ss-rm-nodot'
				});
			}
			arr = arr.concat(categories);
		}
		if(this.labels){
			var labels = [];
			for(var i = 0, len = this.labels.length; i < len; i++){
				labels.push({
					span: [].concat(this.labels[i]),
					cls: 'ss-rm-nodot'
				});
			}
			arr = arr.concat(labels);
		}
		
		return arr;
	},
		
    
           
	/*
	 * monitor reference move
	 * @param {boolean} flag: true to add listeners, or remove listeners
	 */
	monitorMoveReference : function(flag){
		var sheet = this.sheet;
		if(flag){
			this.mon(sheet, {
				scope: this,
				'endmovereference': this.endMoveReference,
				'beforemovingreference': this.beforeMovingReference
			});
		}else{			
			this.mun(sheet, {
				scope: this,
				'endmovereference': this.endMoveReference,
				'beforemovingreference': this.beforeMovingReference
			});
		}
	},
	
	/*
	 * end move reference
	 */
	endMoveReference : function(draggingCoordSpan, rm){	
		/*
		 * get the current sheetId
		 */
		var sheetId = this.sheet.getSheetId();
		var fields = this.cacheFields;
		var originSpan = [].concat(draggingCoordSpan.span);
		/*
		 * fill the current sheet id if it's empty
		 */
		if(SCOM.nullOrUndefined(originSpan[0])){
			originSpan[0] = sheetId;
		}
		var currentSpan = [].concat(draggingCoordSpan.currentSpan);
		currentSpan[0] = originSpan[0];
		
		var oid = originSpan.join('$');
		
		/*
		 * check categories
		 */
		if(this.categories){
			for(var i = 0, len = this.categories.length; i < len; i++){
				var span = this.categories[i];
				var id = span.join('$');
				if(id == oid){				
					this.categories[i] = [].concat(currentSpan);
					fields[i+1]['title'] = this.getCategoryByIndex(i);
					/*
					 * fire event to let the chart change the series title
					 */
					this.fireEvent('fieldtitlechange', this.cacheFields, this);
					break;
				}
			}
		}		
		/*
		 * check labels
		 */
		if(this.labels){
			for(var i = 0, len = this.labels.length; i < len; i++){
				var span = this.labels[i];
				var id = span.join('$');
				if(id == oid){				
					this.labels[i] = [].concat(currentSpan);					
					break;
				}
			}
		}
		/*
		 * check series
		 */
		for(var i = 0, len = this.series.length; i < len; i++){
			var span = this.series[i];
			var id = span.join('$');
			
			if(id == oid){				
				this.series[i] = [].concat(currentSpan);
				if('row' == this.seriesPosition){
					fields[i+1]['title'] = this.getCategoryByIndex(i) || SLANG['row']+currentSpan[1];
				}else{
					fields[i+1]['title'] = this.getCategoryByIndex(i) || SLANG['column']+currentSpan[2];
				}	
				/*
				 * fire event to let the chart change the series title
				 */
				this.fireEvent('fieldtitlechange', this.cacheFields, this);
				break;
			}
		}
		this.fireEvent('regeneratedata', this);
		/*
		 * fire related coord change event
		 */
		this.fireEvent('relatedcoordchange', this);
		/*
		 * fire an event through this.sheet
		 */
		this.sheet.fireEvent('rangestorecoordchagne', this, this.sheet);				
	},
	
	/*
	 * before moving the reference, limit the moving direction
	 */
	beforeMovingReference : function(startPos, endPos){
		if('row' == this.seriesPosition){
			endPos.row = startPos.row;
		}else{
			endPos.col = startPos.col;
		}
	},
	
	/*
	 * check series range is a rect or not
	 */
	isSeriesRect : function(series){		
		var count = 0;
		series = series || this.series;
		var pos = this.getMinMaxPos(series);
		var minRow = pos[0], minCol = pos[1], maxRow = pos[2], maxCol = pos[3];
		for(var i = 0, len = series.length; i < len; i++){
			var it = series[i];
			count += ((it[3]-it[1]+1)*(it[4]-it[2]+1));			
		}
		
		var take = (maxRow-minRow+1)*(maxCol-minCol+1);
		
		if(count == take){
			return true;
		}
		return false;
	},
           
    getCoverCoord : function(){
        var arr = [].concat(this.series);
        if(this.categories){
            arr = arr.concat(this.categories);
        }
        if(this.labels){
            arr = arr.concat(this.labels);
        }
        var pos = this.getMinMaxPos(arr);
        return [[this.coord[0][0]].concat(pos)];
    },
           
    isRectangleCoord : function(){
        var cover = this.getCoverCoord();
        var minRow = cover[1], minCol = cover[2], maxRow = cover[3], maxCol = cover[4];
        var flags = {};
        for(var i = minRow; i <= maxRow; i++){
            for(var j = minCol; j <= maxCol; j++){
                flags[i+'-'+j] = false;
            }
        }
        var arr = [].concat(this.series);
        if(this.categories){
            arr = arr.concat(this.categories);
        }
        if(this.labels){
            arr = arr.concat(this.labels);
        }
        for(var i = 0, len = arr.length; i < len; i++){
            var it = arr[i];
            for(var r = it[1]; r <= it[3]; r++){
                for(var c = it[2]; c <= it[4]; c++){
                    flags[r+'-'+c] = true;
                }
            }
        }

        for(var p in flags){
            if(flags.hasOwnProperty(p) && false === flags[p]){
                return false;
            }
        }
        return true;
    },
	
	getMinMaxPos : function(arr){
		var minRow = false, minCol = false, maxRow = false, maxCol = false;
		for(var i = 0, len = arr.length; i < len; i++){
			var it = arr[i];			
			if(false === minRow){
				minRow = it[1];
			}else if(minRow > it[1]){
				minRow = it[1];
			}
			if(false === minCol){
				minCol = it[2];
			}else if(minCol > it[2]){
				minCol = it[2];
			}
			if(false === maxRow){
				maxRow = it[3];
			}else if(maxRow < it[3]){
				maxRow = it[3];
			}
			if(false === maxCol){
				maxCol = it[4];
			}else if(maxCol < it[4]){
				maxCol = it[4];
			}
		}
		return [minRow, minCol, maxRow, maxCol];
	},
	
	/*
	 * change series position
	 */
	changeSeriesPosition : function(seriesPosition, suspendEvent){
		if(this.seriesPosition != seriesPosition){
			this.seriesPosition = seriesPosition;
           
			this.coord = this.getCoverCoord();
			this.parseRangeData();
			if(!suspendEvent){
				/*
				 * fire event to let the chart change the series title
				 */
				this.fireEvent('fieldtitlechange', this.cacheFields, this);
			}			
			/*
			 * regenerate data
			 */
			this.regenerateData();
			
			if(!suspendEvent){
				/*
				 * fire an event through this.sheet
				 */
				this.sheet.fireEvent('rangestorecoordchagne', this, this.sheet);
			}
		}		
	},
           
    refreshAsLabelChange : function(firstRowLabel, firstColLabel){
        this.coord = this.getCoverCoord();
        this.parseRangeData({
            firstRowLabel: firstRowLabel,
            firstColLabel: firstColLabel
        });
           
        /*
         * fire event to let the chart change the series title
         */
        this.fireEvent('fieldtitlechange', this.cacheFields, this);
        /*
         * regenerate data
         */
        this.regenerateData();
           
        /*
         * fire an event through this.sheet
         */
        this.sheet.fireEvent('rangestorecoordchagne', this, this.sheet);
    },
	
	/*
	 * when columns are removed
	 */
	onRemoveColumn : function(sheetId, mincol, maxcol, deleted, merged){
		var old = {
			series: SCOM.copy(this.series),
			categories: SCOM.copy(this.categories),
			labels: SCOM.copy(this.labels)
		};
		var changed = false;
		var colSpan = maxcol-mincol+1;
		if('row' == this.seriesPosition){
			var series = this.series, remains = [];
			for(var i = 0, len = series.length; i < len; i++){
				var it = series[i];
				var startCol = it[2], endCol = it[4];
				if(it[0] == sheetId){
					if(!(startCol >= mincol && endCol <= maxcol)){
						if(startCol <= mincol && endCol >= maxcol){
							it[4] -= colSpan;
							changed = true;
						}else if(startCol <= mincol && mincol <= endCol){
							it[4] = mincol-1;
							changed = true;
						}else if(startCol <= maxcol && maxcol <= endCol){
							it[2] = mincol;
							it[4] -= colSpan;
							changed = true;
						}else if(maxcol <= startCol){
							it[2] -= colSpan;
							it[4] -= colSpan;
							changed = true;
						}
						remains.push(it);							
					}
				}else{
					remains.push(it);		
				}				
			}
			if(0 < remains.length){
				this.series = remains;
			}else{
				delete(this.series);
			}
			if(this.categories){
				var categories = [];
				for(var i = 0, len = this.categories.length; i < len; i++){
					var it = this.categories[i];
					if(it[0] == sheetId){
						var col = it[2];
						if(col < mincol){
							categories.push(it);						
						}else if(col > maxcol){
							it[2] -= colSpan;
							it[4] -= colSpan;
							categories.push(it);
							changed = true;
						}
					}else{
						categories.push(it);
					}					
				}
				if(0 < categories.length){
					this.categories = categories;
				}else{
					delete(this.categories);
				}
			}
			if(this.labels){
				var labels = [];
				for(var i = 0, len = this.labels.length; i < len; i++){
					var it = this.labels[i];
					if(it[0] == sheetId){
						var col = it[2];
						if(col < mincol){
							labels.push(it);						
						}else if(col > maxcol){
							it[2] -= colSpan;
							it[4] -= colSpan;
							labels.push(it);
							changed = true;
						}
					}else{
						labels.push(it);
					}					
				}
				if(0 < labels.length){
					this.labels = labels;
				}else{
					delete(this.labels);
				}
			}
			/*
			 * regenerate all the data
			 */
			this.regenerateAll();
		}else{
			var series = this.series, remains = [], categories = [];
			for(var i = 0, len = series.length; i < len; i++){
				var it = series[i];
				if(it[0] == sheetId){
					var col = it[2];
					if(col < mincol){
						remains.push(it);					
					}else if(col > maxcol){
						it[2] -= colSpan;
						it[4] -= colSpan;
						remains.push(it);
						changed = true;
					}
				}else{
					remains.push(it);
				}				
			}
			if(0 < remains.length){
				this.series = remains;
			}else{
				delete(this.series);
			}
			if(this.categories){
				for(var i = 0, len = this.categories.length; i < len; i++){
					var it = this.categories[i];
					if(it[0] == sheetId){
						var col = it[2];
						if(col < mincol){
							categories.push(it);						
						}else if(col > maxcol){
							it[2] -= colSpan;
							it[4] -= colSpan;
							categories.push(it);
							changed = true;
						}
					}else{
						categories.push(it);
					}
				}
				if(0 < categories.length){
					this.categories = categories;
				}else{
					delete(this.categories);
				}
			}
			
			if(this.labels){
				var labels = [];
				for(var i = 0, len = this.labels.length; i < len; i++){
					var it = this.labels[i];
					if(it[0] == sheetId){
						var col = it[2];
						if(col < mincol){
							labels.push(it);
						}else if(col > maxcol){
							it[2] -= colSpan;
							it[4] -= colSpan;
							labels.push(it);
							changed = true;
						}
					}else{
						labels.push(it);
					}
				}
				if(0 < labels.length){
					this.labels = labels;
				}else{
					delete(this.labels);
				}
			}
			
			/*
			 * regenerate all the data
			 */
			this.regenerateAll();			
		}
		if(changed){
			var sid = this.storeId;
			var cur = {
				series: SCOM.copy(this.series),
				categories: SCOM.copy(this.categories),
				labels: SCOM.copy(this.labels)
			};
			this.sheet.rangeStoreRef[sid] = {
				rangeStore: this,
				oldConfig: old,
				newConfig: cur
			};
			/*
			 * fire an event through this.sheet
			 */
			this.sheet.fireEvent('rangestorecoordchagne', this, this.sheet);
		}
	},
	
	/*
	 * when rows are removed
	 */
	onRemoveRow : function(sheetId, minrow, maxrow, deleted, merged){
		var old = {
			series: SCOM.copy(this.series),
			categories: SCOM.copy(this.categories),
			labels: SCOM.copy(this.labels)
		};
		var changed = false;
		var rowSpan = maxrow-minrow+1;
		if('row' != this.seriesPosition){
			var series = this.series, remains = [];
			for(var i = 0, len = series.length; i < len; i++){
				var it = series[i];
				if(it[0] == sheetId){
					var startRow = it[1], endRow = it[3];
					if(!(startRow >= minrow && endRow <= maxrow)){
						if(startRow <= minrow && endRow >= maxrow){
							it[3] -= rowSpan;
							changed = true;
						}else if(startRow <= minrow && minrow <= endRow){
							it[3] = minrow-1;
							changed = true;
						}else if(startRow <= maxrow && maxrow <= endRow){
							it[1] = minrow;
							it[3] -= rowSpan;
							changed = true;
						}else if(maxrow <= startRow){
							it[1] -= rowSpan;
							it[3] -= rowSpan;
							changed = true;
						}
						remains.push(it);					
					}
				}else{
					remains.push(it);		
				}				
			}
			if(0 < remains.length){
				this.series = remains;
			}else{
				delete(this.series);
			}

			if(this.categories){
				var categories = [];
				for(var i = 0, len = this.categories.length; i < len; i++){
					var it = this.categories[i];
					if(it[0] == sheetId){
						var row = it[1];
						if(row < minrow){
							categories.push(it);
						}else if(row > maxrow){
							it[1] -= rowSpan;
							it[3] -= rowSpan;
							categories.push(it);
							changed = true;
						}
					}else{
						categories.push(it);
					}
				}
				if(0 < categories.length){
					this.categories = categories;
				}else{
					delete(this.categories);
				}
			}			
			
			if(this.labels){
				var labels = [];
				for(var i = 0, len = this.labels.length; i < len; i++){
					var it = this.labels[i];
					if(it[0] == sheetId){
						var row = it[1];
						if(row < minrow){
							labels.push(it);
						}else if(row > maxrow){
							it[1] -= rowSpan;
							it[3] -= rowSpan;
							labels.push(it);
							changed = true;
						}
					}else{
						labels.push(it);
					}
				}
				if(0 < labels.length){
					this.labels = labels;
				}else{
					delete(this.labels);
				}
			}
			
			/*
			 * regenerate all the data
			 */
			this.regenerateAll();
		}else{
			var series = this.series, remains = [], categories = [];
			for(var i = 0, len = series.length; i < len; i++){
				var it = series[i];
				if(it[0] == sheetId){
					var row = it[1];
					if(row < minrow){
						remains.push(it);
					}else if(row > maxrow){
						it[1] -= rowSpan;
						it[3] -= rowSpan;
						remains.push(it);
						changed = true;
					}
				}else{
					remains.push(it);
				}
			}
			if(0 < remains.length){
				this.series = remains;
			}else{
				delete(this.series);
			}
			if(this.categories){
				for(var i = 0, len = this.categories.length; i < len; i++){
					var it = this.categories[i];
					if(it[0] == sheetId){
						var row = it[1];
						if(row < minrow){
							categories.push(it);
						}else if(row > maxrow){
							it[1] -= rowSpan;
							it[3] -= rowSpan;
							categories.push(it);
							changed = true;
						}
					}else{
						categories.push(it);
					}
				}
				if(0 < categories.length){
					this.categories = categories;
				}else{
					delete(this.categories);
				}
			}
			if(this.labels){
				var labels = [];
				for(var i = 0, len = this.labels.length; i < len; i++){
					var it = this.labels[i];
					if(it[0] == sheetId){
						var row = it[1];
						if(row < minrow){
							labels.push(it);
						}else if(row > maxrow){
							it[1] -= rowSpan;
							it[3] -= rowSpan;
							labels.push(it);
							changed = true;
						}
					}else{
						labels.push(it);
					}
				}
				if(0 < labels.length){
					this.labels = labels;
				}else{
					delete(this.labels);
				}
			}
			/*
			 * regenerate all the data
			 */
			this.regenerateAll();
		}
		if(changed){
			var sid = this.storeId;
			var cur = {
				series: SCOM.copy(this.series),
				categories: SCOM.copy(this.categories),
				labels: SCOM.copy(this.labels)
			};
			this.sheet.rangeStoreRef[sid] = {
				rangeStore: this,
				oldConfig: old,
				newConfig: cur
			};
			/*
			 * fire an event through this.sheet
			 */
			this.sheet.fireEvent('rangestorecoordchagne', this, this.sheet);
		}
	},
	
	resetRangeConfig : function(config){
		this.series = config.series;
		this.categories = config.categories;
		this.labels = config.labels;
		/*
		 * regenerate all the data
		 */
		this.regenerateAll();
		/*
		 * fire an event through this.sheet
		 */
		this.sheet.fireEvent('rangestorecoordchagne', this, this.sheet);
	},
	
	/*
	 * when columns are inserted
	 */
	onInsertColumn : function(sheetId, col, colSpan){	
		var old = {
			series: SCOM.copy(this.series),
			categories: SCOM.copy(this.categories),
			labels: SCOM.copy(this.labels)
		};
		var changed = false;
		if('row' == this.seriesPosition){
			var series = this.series, inside = false;
			for(var i = 0, len = series.length; i < len; i++){
				var it = series[i];
				if(it[0] == sheetId){
					var startCol = it[2], endCol = it[4];
					if(col < startCol){
						it[2] += colSpan;
						it[4] += colSpan;	
						changed = true;
					}else if(col <= endCol){
						it[4] += colSpan;
						inside = true;
						changed = true;
					}	
				}
			}		
			if(this.categories){
				for(var i = 0, len = this.categories.length; i < len; i++){
					var it = this.categories[i];
					if(it[0] == sheetId){
						var startCol = it[2], endCol = it[4];
						if(col <= startCol){
							it[2] += colSpan;
							it[4] += colSpan;	
							changed = true;
						}				
					}
				}	
			}
			if(this.labels){
				if(inside){
					var labels = this.labels, index = false;
					for(var i = 0, len = labels.length; i < len; i++){
						var it = labels[i];
						if(it[0] == sheetId){
							var startCol = it[2], endCol = it[4];
							if(col <= startCol){
								it[2] += colSpan;
								it[4] += colSpan;
								if(false === index){							
									index = i;
								}
								changed = true;
							}	
						}
					}
					if(false === index){
						var last = labels[labels.length-1];
						if(last[0] == sheetId){
							for(var i = 0; i < colSpan; i++){
								var j = col+i;
								labels.push([last[0], last[1], j, last[3], j]);
								changed = true;
							}
						}						
					}else{						
						var last = labels[index];
						if(last[0] == sheetId){
							for(var i = 0; i < colSpan; i++){
								var j = col+colSpan-1-i;
								labels.splice(index, 0, [last[0], last[1], j, last[3], j]);
								changed = true;
							}
						}
					}					
				}else{
					for(var i = 0, len = this.labels.length; i < len; i++){
						var it = this.labels[i];
						if(it[0] == sheetId){
							var startCol = it[2], endCol = it[4];
							if(col < startCol){
								it[2] += colSpan;
								it[4] += colSpan;		
								changed = true;
							}
						}									
					}
				}
			}
			/*
			 * regenerate all the data
			 */
			this.regenerateAll();
		}else{
			var series = this.series;
			for(var i = 0, len = series.length; i < len; i++){
				var it = series[i];
				if(it[0] == sheetId){
					var startCol = it[2];
					if(col <= startCol){
						it[2] += colSpan;
						it[4] += colSpan;
						changed = true;
					}
				}
			}			
			if(this.categories){
				for(var i = 0, len = this.categories.length; i < len; i++){
					var it = this.categories[i];
					if(it[0] == sheetId){
						var startCol = it[2];
						if(col <= startCol){
							it[2] += colSpan;
							it[4] += colSpan;
							changed = true;
						}
					}
				}				
			}
			if(this.labels){
				for(var i = 0, len = this.labels.length; i < len; i++){
					var it = this.labels[i];
					if(it[0] == sheetId){
						var startCol = it[2];
						if(col <= startCol){
							it[2] += colSpan;
							it[4] += colSpan;
							changed = true;
						}
					}
				}				
			}
			
			/*
			 * regenerate all the data
			 */
			this.regenerateAll();
		}
		if(changed){
			var sid = this.storeId;
			var cur = {
				series: SCOM.copy(this.series),
				categories: SCOM.copy(this.categories),
				labels: SCOM.copy(this.labels)
			};
			this.sheet.rangeStoreRef[sid] = {
				rangeStore: this,
				oldConfig: old,
				newConfig: cur
			};
			/*
			 * fire an event through this.sheet
			 */
			this.sheet.fireEvent('rangestorecoordchagne', this, this.sheet);
		}
	},
	
	/*
	 * when rows are inserted
	 */
	onInsertRow : function(sheetId, row, rowSpan){				
		var old = {
			series: SCOM.copy(this.series),
			categories: SCOM.copy(this.categories),
			labels: SCOM.copy(this.labels)
		};		
		var changed = false;
		if('row' !== this.seriesPosition){
			var series = this.series, inside = false;
			for(var i = 0, len = series.length; i < len; i++){
				var it = series[i];
				if(it[0] == sheetId){
					var startRow = it[1], endRow = it[3];
					if(row < startRow){
						it[1] += rowSpan;
						it[3] += rowSpan;	
						changed = true;
					}else if(row <= endRow){
						it[3] += rowSpan;
						inside = true;
						changed = true;
					}
				}
			}
			
			if(this.categories){
				for(var i = 0, len = this.categories.length; i < len; i++){
					var it = this.categories[i];
					if(it[0] == sheetId){
						var startRow = it[1], endRow = it[3];
						if(row <= startRow){
							it[1] += rowSpan;
							it[3] += rowSpan;
							changed = true;
						}	
					}
				}
			}
			
			if(this.labels){
				if(inside){
					var labels = this.labels, index = false;
					for(var i = 0, len = labels.length; i < len; i++){
						var it = labels[i];
						if(it[0] == sheetId){
							var startRow = it[1], endRow = it[3];
							if(row <= startRow){
								it[1] += rowSpan;
								it[3] += rowSpan;
								if(false === index){							
									index = i;
								}
								changed = true;
							}	
						}
					}
					if(false === index){
						var last = labels[labels.length-1];
						if(last[0] == sheetId){
							for(var i = 0; i < rowSpan; i++){
								var j = row+i;
								labels.push([last[0], j, last[2], j, last[4]]);
								changed = true;
							}
						}
					}else{						
						var last = labels[index];
						if(last[0] == sheetId){
							for(var i = 0; i < rowSpan; i++){
								var j = row+rowSpan-1-i;
								labels.splice(index, 0, [last[0], j, last[2], j, last[4]]);
								changed = true;
							}
						}
					}					
				}else{
					for(var i = 0, len = this.labels.length; i < len; i++){
						var it = this.labels[i];
						if(it[0] == sheetId){
							var startRow = it[1], endRow = it[3];
							if(row < startRow){
								it[1] += rowSpan;
								it[3] += rowSpan;			
								changed = true;
							}	
						}
					}
				}
			}			
			/*
			 * regenerate all the data
			 */
			this.regenerateAll();
		}else{
			var series = this.series;
			for(var i = 0, len = series.length; i < len; i++){
				var it = series[i];
				if(it[0] == sheetId){
					var startRow = it[1];
					if(row <= startRow){
						it[1] += rowSpan;
						it[3] += rowSpan;
						changed = true;
					}
				}
			}			
			if(this.categories){
				for(var i = 0, len = this.categories.length; i < len; i++){
					var it = this.categories[i];
					if(it[0] == sheetId){
						var startRow = it[1];
						if(row <= startRow){
							it[1] += rowSpan;
							it[3] += rowSpan;
							changed = true;
						}
					}
				}				
			}
			if(this.labels){
				for(var i = 0, len = this.labels.length; i < len; i++){
					var it = this.labels[i];
					if(it[0] == sheetId){
						var startRow = it[1];
						if(row <= startRow){
							it[1] += rowSpan;
							it[3] += rowSpan;
							changed = true;
						}
					}
				}				
			}
			
			/*
			 * regenerate all the data
			 */
			this.regenerateAll();
		}
		if(changed){
			var sid = this.storeId;
			var cur = {
				series: SCOM.copy(this.series),
				categories: SCOM.copy(this.categories),
				labels: SCOM.copy(this.labels)
			};
			this.sheet.rangeStoreRef[sid] = {
				rangeStore: this,
				oldConfig: old,
				newConfig: cur
			};
			/*
			 * fire an event through this.sheet
			 */
			this.sheet.fireEvent('rangestorecoordchagne', this, this.sheet);
		}
	},
	
	onRemoveCell : function(sheetId, minrow, maxrow, mincol, maxcol, moveDir, deleted, merged){		
		var old = {
			series: SCOM.copy(this.series),
			categories: SCOM.copy(this.categories),
			labels: SCOM.copy(this.labels)
		};
		
		var changed = false;
		var rowSpan = maxrow-minrow+1, colSpan = maxcol-mincol+1;
		if('left' === moveDir){			
			if('row' == this.seriesPosition){
				var series = this.series, remains = [];
				for(var i = 0, len = series.length; i < len; i++){
					var it = series[i];
					var startCol = it[2], endCol = it[4];
					if(it[0] == sheetId){
						if(minrow <= it[1] && it[3]<= maxrow){
							if(!(startCol >= mincol && endCol <= maxcol)){
								if(startCol <= mincol && endCol >= maxcol){
									it[4] -= colSpan;
									changed = true;
								}else if(startCol <= mincol && mincol <= endCol){
									it[4] = mincol-1;
									changed = true;
								}else if(startCol <= maxcol && maxcol <= endCol){
									it[2] = mincol;
									it[4] -= colSpan;
									changed = true;
								}else if(maxcol <= startCol){
									it[2] -= colSpan;
									it[4] -= colSpan;
									changed = true;
								}
								remains.push(it);							
							}
						}else{
							remains.push(it);
						}						
					}else{
						remains.push(it);		
					}				
				}
				if(0 < remains.length){
					this.series = remains;
				}else{
					delete(this.series);
				}
				if(this.categories){
					var categories = [];
					for(var i = 0, len = this.categories.length; i < len; i++){
						var it = this.categories[i];
						if(it[0] == sheetId){
							if(minrow <= it[1] && it[3]<= maxrow){
								var col = it[2];
								if(col < mincol){
									categories.push(it);						
								}else if(col > maxcol){
									it[2] -= colSpan;
									it[4] -= colSpan;
									categories.push(it);
									changed = true;
								}
							}else{
								categories.push(it);
							}
						}else{
							categories.push(it);
						}					
					}
					if(0 < categories.length){
						this.categories = categories;
					}else{
						delete(this.categories);
					}
				}
				if(this.labels){
					var labels = [];
					for(var i = 0, len = this.labels.length; i < len; i++){
						var it = this.labels[i];
						if(it[0] == sheetId){
							if(minrow <= it[1] && it[3]<= maxrow){
								var col = it[2];
								if(col < mincol){
									labels.push(it);						
								}else if(col > maxcol){
									it[2] -= colSpan;
									it[4] -= colSpan;
									labels.push(it);
									changed = true;
								}
							}else{
								labels.push(it);
							}
						}else{
							labels.push(it);
						}					
					}
					if(0 < labels.length){
						this.labels = labels;
					}else{
						delete(this.labels);
					}
				}
				/*
				 * regenerate all the data
				 */
				this.regenerateAll();
			}else{
				var series = this.series, remains = [], categories = [];
				for(var i = 0, len = series.length; i < len; i++){
					var it = series[i];
					if(it[0] == sheetId){
						if(minrow <= it[1] && it[3]<= maxrow){
							var col = it[2];
							if(col < mincol){
								remains.push(it);					
							}else if(col > maxcol){
								it[2] -= colSpan;
								it[4] -= colSpan;
								remains.push(it);
								changed = true;
							}
						}else{
							remains.push(it);
						}
					}else{
						remains.push(it);
					}				
				}
				if(0 < remains.length){
					this.series = remains;
				}else{
					delete(this.series);
				}
				if(this.categories){
					for(var i = 0, len = this.categories.length; i < len; i++){
						var it = this.categories[i];
						if(it[0] == sheetId){
							if(minrow <= it[1] && it[3]<= maxrow){
								var col = it[2];
								if(col < mincol){
									categories.push(it);						
								}else if(col > maxcol){
									it[2] -= colSpan;
									it[4] -= colSpan;
									categories.push(it);
									changed = true;
								}
							}else{
								categories.push(it);
							}							
						}else{
							categories.push(it);
						}
					}
					if(0 < categories.length){
						this.categories = categories;
					}else{
						delete(this.categories);
					}
				}
				
				if(this.labels){
					var labels = [];
					for(var i = 0, len = this.labels.length; i < len; i++){
						var it = this.labels[i];
						if(it[0] == sheetId){
							if(minrow <= it[1] && it[3]<= maxrow){
								var col = it[2];
								if(col < mincol){
									labels.push(it);
								}else if(col > maxcol){
									it[2] -= colSpan;
									it[4] -= colSpan;
									labels.push(it);
									changed = true;
								}
							}else{
								labels.push(it);
							}
							
						}else{
							labels.push(it);
						}
					}
					if(0 < labels.length){
						this.labels = labels;
					}else{
						delete(this.labels);
					}
				}
				
				/*
				 * regenerate all the data
				 */
				this.regenerateAll();			
			}			
		}else{
			if('row' != this.seriesPosition){
				var series = this.series, remains = [];
				for(var i = 0, len = series.length; i < len; i++){
					var it = series[i];
					if(it[0] == sheetId){
						var startRow = it[1], endRow = it[3];
						if(mincol <= it[2] && it[4] <= maxcol){
							if(!(startRow >= minrow && endRow <= maxrow)){
								if(startRow <= minrow && endRow >= maxrow){
									it[3] -= rowSpan;
									changed = true;
								}else if(startRow <= minrow && minrow <= endRow){
									it[3] = minrow-1;
									changed = true;
								}else if(startRow <= maxrow && maxrow <= endRow){
									it[1] = minrow;
									it[3] -= rowSpan;
									changed = true;
								}else if(maxrow <= startRow){
									it[1] -= rowSpan;
									it[3] -= rowSpan;
									changed = true;
								}
								remains.push(it);					
							}
						}else{
							remains.push(it);
						}						
					}else{
						remains.push(it);		
					}				
				}
				if(0 < remains.length){
					this.series = remains;
				}else{
					delete(this.series);
				}

				if(this.categories){
					var categories = [];
					for(var i = 0, len = this.categories.length; i < len; i++){
						var it = this.categories[i];
						if(it[0] == sheetId){
							var row = it[1];
							if(mincol <= it[2] && it[4] <= maxcol){
								if(row < minrow){
									categories.push(it);
								}else if(row > maxrow){
									it[1] -= rowSpan;
									it[3] -= rowSpan;
									categories.push(it);
									changed = true;
								}
							}else{
								categories.push(it);
							}							
						}else{
							categories.push(it);
						}
					}
					if(0 < categories.length){
						this.categories = categories;
					}else{
						delete(this.categories);
					}
				}			
				
				if(this.labels){
					var labels = [];
					for(var i = 0, len = this.labels.length; i < len; i++){
						var it = this.labels[i];
						if(it[0] == sheetId){
							var row = it[1];
							if(mincol <= it[2] && it[4] <= maxcol){
								if(row < minrow){
									labels.push(it);
								}else if(row > maxrow){
									it[1] -= rowSpan;
									it[3] -= rowSpan;
									labels.push(it);
									changed = true;
								}
							}else{
								labels.push(it);
							}
							
						}else{
							labels.push(it);
						}
					}
					if(0 < labels.length){
						this.labels = labels;
					}else{
						delete(this.labels);
					}
				}
				
				/*
				 * regenerate all the data
				 */
				this.regenerateAll();
			}else{
				var series = this.series, remains = [], categories = [];
				for(var i = 0, len = series.length; i < len; i++){
					var it = series[i];
					if(it[0] == sheetId){
						var row = it[1];
						if(mincol <= it[2] && it[4] <= maxcol){
							if(row < minrow){
								remains.push(it);
							}else if(row > maxrow){
								it[1] -= rowSpan;
								it[3] -= rowSpan;
								remains.push(it);
								changed = true;
							}
						}else{
							remains.push(it);
						}
						
					}else{
						remains.push(it);
					}
				}
				if(0 < remains.length){
					this.series = remains;
				}else{
					delete(this.series);
				}
				if(this.categories){
					for(var i = 0, len = this.categories.length; i < len; i++){
						var it = this.categories[i];
						if(it[0] == sheetId){
							var row = it[1];
							if(mincol <= it[2] && it[4] <= maxcol){
								if(row < minrow){
									categories.push(it);
								}else if(row > maxrow){
									it[1] -= rowSpan;
									it[3] -= rowSpan;
									categories.push(it);
									changed = true;
								}
							}else{
								categories.push(it);
							}
						}else{
							categories.push(it);
						}
					}
					if(0 < categories.length){
						this.categories = categories;
					}else{
						delete(this.categories);
					}
				}
				if(this.labels){
					var labels = [];
					for(var i = 0, len = this.labels.length; i < len; i++){
						var it = this.labels[i];
						if(it[0] == sheetId){
							var row = it[1];
							if(mincol <= it[2] && it[4] <= maxcol){
								if(row < minrow){
									labels.push(it);
								}else if(row > maxrow){
									it[1] -= rowSpan;
									it[3] -= rowSpan;
									labels.push(it);
									changed = true;
								}
							}else{
								labels.push(it);
							}
						}else{
							labels.push(it);
						}
					}
					if(0 < labels.length){
						this.labels = labels;
					}else{
						delete(this.labels);
					}
				}
				/*
				 * regenerate all the data
				 */
				this.regenerateAll();
			}
		}
		if(changed){
			var sid = this.storeId;
			var cur = {
				series: SCOM.copy(this.series),
				categories: SCOM.copy(this.categories),
				labels: SCOM.copy(this.labels)
			};
			this.sheet.rangeStoreRef[sid] = {
				rangeStore: this,
				oldConfig: old,
				newConfig: cur
			};
			/*
			 * fire an event through this.sheet
			 */
			this.sheet.fireEvent('rangestorecoordchagne', this, this.sheet);
		}
	},
	
	onInsertCell : function(sheetId, row, col, rowSpan, colSpan, moveDir, merged){		
		var old = {
			series: SCOM.copy(this.series),
			categories: SCOM.copy(this.categories),
			labels: SCOM.copy(this.labels)
		};
		
		var changed = false;
		var minrow = row, maxrow = row+rowSpan-1, mincol = col, maxcol = col+colSpan-1;
		
		if('right' === moveDir){
			if('row' == this.seriesPosition){
				var series = this.series, inside = false;
				for(var i = 0, len = series.length; i < len; i++){
					var it = series[i];
					if(it[0] == sheetId){
						if(minrow <= it[1] && it[3] <= maxrow){
							var startCol = it[2], endCol = it[4];
							if(col < startCol){
								it[2] += colSpan;
								it[4] += colSpan;	
								changed = true;
							}else if(col <= endCol){
								it[4] += colSpan;
								inside = true;
								changed = true;
							}
						}						
					}
				}		
				if(this.categories){
					for(var i = 0, len = this.categories.length; i < len; i++){
						var it = this.categories[i];
						if(it[0] == sheetId){
							if(minrow <= it[1] && it[3] <= maxrow){
								var startCol = it[2], endCol = it[4];
								if(col <= startCol){
									it[2] += colSpan;
									it[4] += colSpan;	
									changed = true;
								}				
							}
						}
					}	
				}
				if(this.labels){
					if(inside){
						var labels = this.labels, index = false;
						for(var i = 0, len = labels.length; i < len; i++){
							var it = labels[i];
							if(it[0] == sheetId){
								if(minrow <= it[1] && it[3] <= maxrow){
									var startCol = it[2], endCol = it[4];
									if(col <= startCol){
										it[2] += colSpan;
										it[4] += colSpan;
										if(false === index){							
											index = i;
										}
										changed = true;
									}	
								}
							}
						}
						if(false === index){
							var last = labels[labels.length-1];
							if(last[0] == sheetId){
								if(minrow <= last[1] && last[3] <= maxrow){
									for(var i = 0; i < colSpan; i++){
										var j = col+i;
										labels.push([last[0], last[1], j, last[3], j]);
										changed = true;
									}
								}
							}						
						}else{						
							var last = labels[index];
							if(last[0] == sheetId){
								if(minrow <= last[1] && last[3] <= maxrow){
									for(var i = 0; i < colSpan; i++){
										var j = col+colSpan-1-i;
										labels.splice(index, 0, [last[0], last[1], j, last[3], j]);
										changed = true;
									}
								}
							}
						}					
					}else{
						for(var i = 0, len = this.labels.length; i < len; i++){
							var it = this.labels[i];
							if(it[0] == sheetId){
								if(minrow <= it[1] && it[3] <= maxrow){
									var startCol = it[2], endCol = it[4];
									if(col < startCol){
										it[2] += colSpan;
										it[4] += colSpan;		
										changed = true;
									}
								}
							}									
						}
					}
				}
				/*
				 * regenerate all the data
				 */
				this.regenerateAll();
			}else{
				var series = this.series;
				for(var i = 0, len = series.length; i < len; i++){
					var it = series[i];
					if(it[0] == sheetId){
						if(minrow <= it[1] && it[3] <= maxrow){
							var startCol = it[2];
							if(col <= startCol){
								it[2] += colSpan;
								it[4] += colSpan;
								changed = true;
							}
						}
					}
				}			
				if(this.categories){
					for(var i = 0, len = this.categories.length; i < len; i++){
						var it = this.categories[i];
						if(it[0] == sheetId){
							if(minrow <= it[1] && it[3] <= maxrow){
								var startCol = it[2];
								if(col <= startCol){
									it[2] += colSpan;
									it[4] += colSpan;
									changed = true;
								}
							}
						}
					}				
				}
				if(this.labels){
					for(var i = 0, len = this.labels.length; i < len; i++){
						var it = this.labels[i];
						if(it[0] == sheetId){
							if(minrow <= it[1] && it[3] <= maxrow){
								var startCol = it[2];
								if(col <= startCol){
									it[2] += colSpan;
									it[4] += colSpan;
									changed = true;
								}
							}
						}
					}				
				}
				
				/*
				 * regenerate all the data
				 */
				this.regenerateAll();
			}
		}else{
			if('row' !== this.seriesPosition){
				var series = this.series, inside = false;
				for(var i = 0, len = series.length; i < len; i++){
					var it = series[i];
					if(it[0] == sheetId){
						if(mincol <= it[2] && it[4] <= maxcol){
							var startRow = it[1], endRow = it[3];
							if(row < startRow){
								it[1] += rowSpan;
								it[3] += rowSpan;	
								changed = true;
							}else if(row <= endRow){
								it[3] += rowSpan;
								inside = true;
								changed = true;
							}
						}					
					}
				}
				
				if(this.categories){
					for(var i = 0, len = this.categories.length; i < len; i++){
						var it = this.categories[i];
						if(it[0] == sheetId){
							if(mincol <= it[2] && it[4] <= maxcol){
								var startRow = it[1], endRow = it[3];
								if(row <= startRow){
									it[1] += rowSpan;
									it[3] += rowSpan;
									changed = true;
								}	
							}
						}
					}
				}
				
				if(this.labels){
					if(inside){
						var labels = this.labels, index = false;
						for(var i = 0, len = labels.length; i < len; i++){
							var it = labels[i];
							if(it[0] == sheetId){
								if(mincol <= it[2] && it[4] <= maxcol){
									var startRow = it[1], endRow = it[3];
									if(row <= startRow){
										it[1] += rowSpan;
										it[3] += rowSpan;
										if(false === index){							
											index = i;
										}
										changed = true;
									}	
								}
							}
						}
						if(false === index){
							var last = labels[labels.length-1];
							if(last[0] == sheetId){
								if(mincol <= last[2] && last[4] <= maxcol){
									for(var i = 0; i < rowSpan; i++){
										var j = row+i;
										labels.push([last[0], j, last[2], j, last[4]]);
										changed = true;
									}
								}
							}
						}else{						
							var last = labels[index];
							if(last[0] == sheetId){
								if(mincol <= last[2] && last[4] <= maxcol){
									for(var i = 0; i < rowSpan; i++){
										var j = row+rowSpan-1-i;
										labels.splice(index, 0, [last[0], j, last[2], j, last[4]]);
										changed = true;
									}
								}
							}
						}					
					}else{
						for(var i = 0, len = this.labels.length; i < len; i++){
							var it = this.labels[i];
							if(it[0] == sheetId){
								if(mincol <= it[2] && it[4] <= maxcol){
									var startRow = it[1], endRow = it[3];
									if(row < startRow){
										it[1] += rowSpan;
										it[3] += rowSpan;			
										changed = true;
									}	
								}
							}
						}
					}
				}			
				/*
				 * regenerate all the data
				 */
				this.regenerateAll();
			}else{
				var series = this.series;
				for(var i = 0, len = series.length; i < len; i++){
					var it = series[i];
					if(it[0] == sheetId){
						if(mincol <= it[2] && it[4] <= maxcol){
							var startRow = it[1];
							if(row <= startRow){
								it[1] += rowSpan;
								it[3] += rowSpan;
								changed = true;
							}
						}					
					}
				}			
				if(this.categories){
					for(var i = 0, len = this.categories.length; i < len; i++){
						var it = this.categories[i];
						if(it[0] == sheetId){
							if(mincol <= it[2] && it[4] <= maxcol){
								var startRow = it[1];
								if(row <= startRow){
									it[1] += rowSpan;
									it[3] += rowSpan;
									changed = true;
								}
							}
						}
					}				
				}
				if(this.labels){
					for(var i = 0, len = this.labels.length; i < len; i++){
						var it = this.labels[i];
						if(it[0] == sheetId){
							if(mincol <= it[2] && it[4] <= maxcol){
								var startRow = it[1];
								if(row <= startRow){
									it[1] += rowSpan;
									it[3] += rowSpan;
									changed = true;
								}
							}
						}
					}				
				}
				
				/*
				 * regenerate all the data
				 */
				this.regenerateAll();
			}
		}		
		if(changed){
			var sid = this.storeId;
			var cur = {
				series: SCOM.copy(this.series),
				categories: SCOM.copy(this.categories),
				labels: SCOM.copy(this.labels)
			};
			this.sheet.rangeStoreRef[sid] = {
				rangeStore: this,
				oldConfig: old,
				newConfig: cur
			};
			/*
			 * fire an event through this.sheet
			 */
			this.sheet.fireEvent('rangestorecoordchagne', this, this.sheet);
		}
	}
});
Ext.define('EnterpriseSheet.sheet.data.SheetStore', {
	/* Begin Definitions */
	
	extend : 'EnterpriseSheet.sheet.data.PullingStore',
	
	pageSize : 1000,
           
    loadSheetUrl: SCONFIG.urls['loadSheet'],
           
    loadRangeUrl: SCONFIG.urls['loadRange2'],
	
	constructor : function(){
		
		this.callParent(arguments);
		
	},
	
	/*
	 * extend readSheets
	 */
	readSheets : function(sheets){		
		
		this.callParent(arguments);
		
		for(var i = 0, len = this.sheets.length; i < len; i++){
			var it = this.sheets[i];
			if(it.actived){
				it['loaded'] = true;
			}
		}
	},	
	
	/**
	 * a function to let the extender class to do something before loadMore
	 */
	updateSheetObjAfterLoadSheet : function(sheetObj, json, sheetId){
		
	},
	
	/*
	 * load sheet
	 */
	loadSheet : function(sheetId, callback, scope, notActiveTabFlag){
		/*
		 * first check whether this sheet is already loaded
		 */
		var loaded = this.isLoadedSheet(sheetId), allCellLoaded = this.isAllCellLoadedInSheet(sheetId);
		var me = this;
		if(loaded){
            this.resetRowHeightColWidthCache(sheetId);
			if(callback){
				callback.call(scope, true);
			}
		}else if(allCellLoaded){
			 /*
	         * append floatings
	         */
            me.loadFloatingsBySheetId(sheetId, function(success, floatings){
                if(floatings && 0 < floatings.length){
                    me.appendFloatings(floatings);
                }
                me.checkSeverStatus();
                me.resetRowHeightColWidthCache(sheetId);
                /*
	        	 * set flag of loaded
	        	 */
                var sheetObj = me.getSheetById(sheetId);
	        	sheetObj.loaded = true;
                if(callback){
                    callback.call(scope, true);
                }
            }, me);
		}else{		
			
			Ext.Ajax.request({				
				url: this.loadSheetUrl,
				params: {
                    fileId: this.fileId,
					sheetId: sheetId,
					size: this.limitCellNumAtSingleLoad,
                    notActiveTabFlag: notActiveTabFlag || false,
                    throttleOfBigFile: this.throttleOfBigFile
				},
				success: function(response, options){
					var json = Ext.decode(response.responseText);					
					var separateChar = this.separateChar, dataMap = this.getData(),
		             	records  = me.reader.read(json.results),
		             	startCellId = json.startCellId;
					
			        if (true === json.success || 'true' === json.success) {
                        var newRecs = [], recLen = records.length;
                        for(var i = 0; i < recLen; i++){
                            var it = records[i];
                            if(!it[3].cal){
                                var cid = [it[0], it[1], it[2]].join(separateChar);
                                if(!dataMap[cid]){
                                    dataMap[cid] = it;
                                }
                             }
                        }
			        	/*
			        	 * set flag of loaded
			        	 */
                        var sheetObj = me.getSheetById(sheetId);
			        	sheetObj.loaded = true;
                        /*
                         * update the totalCount
                         */
                        sheetObj.currentFloatingCount = 0;
                        sheetObj.totalFloatingCount = json.floatingTotal;
                        sheetObj.totalCellCount = json.total;
                        sheetObj.currentCellCount = recLen;     
                        me.updateSheetObjAfterLoadSheet(sheetObj, json, sheetId);

			            if(startCellId != 0 && !SCOM.isEmptyValue(startCellId)){
		    				/*
		    				 * means need load more
		    				 */
		    				me.loadMore(sheetId, startCellId, me.limitCellNumAtSingleLoad, function(){
                                /*
		    			         * append floatings
		    			         */
                                me.loadFloatingsBySheetId(sheetId, function(success, floatings){
                                    if(floatings && 0 < floatings.length){
                                        me.appendFloatings(floatings);
                                    }
                                    /*
                                     * special process for tpl
                                     */
                                    this.presetTplForCells();
                                    if(callback){
                                        callback.call(scope, true);
                                    }
                                }, me);
		    				}, me, true, json);
		    				return;
		    			}	            
                    }else{
                        this.serverFailureAction = {
                            action: 'loadSheet',
                            sheetId: sheetId,
                            callback: callback,
                            scope: scope
                        };
                        this.processServerFailure(response);
                    }
			        
			        /*
			         * append floatings
			         */
                    me.loadFloatingsBySheetId(sheetId, function(success, floatings){
                        if(floatings && 0 < floatings.length){
                            me.appendFloatings(floatings);
                        }
                        /*
                         * special process for tpl
                         */
                        this.presetTplForCells();
                        me.checkSeverStatus();
                        me.resetRowHeightColWidthCache(sheetId);
                        if(callback){
                            callback.call(scope, true);
                        }
                    }, me);
				},
				failure: function(response, options){
                    this.serverFailureAction = {
                        action: 'loadSheet',
                        sheetId: sheetId,
                        callback: callback,
                        scope: scope
                    };
                    this.processServerFailure(response);
                    this.resetRowHeightColWidthCache(sheetId);                             
                    if(callback){
                        callback.call(scope, false);
                    }
				},
				scope: this
			});
		}
	},
    
    /**
     * check whether this cell is loaded
     */
    isLoadedCell : function(sheetId, row, col, sheet){

        var sep = this.separateChar;
        sheet = sheet || this.getSheetById(sheetId);
        
        var data = this.getData();
        if(!sheet.allCellDataLoaded){
            var loadedEmptyCells = sheet.loadedEmptyCells || {};
            var p = [sheetId, row, col].join(sep);
            if(!data[p]){
                if(loadedEmptyCells[p]){
                    return true;
                }else if(0 !== row && 0 !== col){
                    var a = [sheetId, 0, 0].join(sep);
                    if(!loadedEmptyCells[a]){
                        var r = [sheetId, row, 0].join(sep);
                        if(!loadedEmptyCells[r]){
                            var c = [sheetId, 0, col].join(sep);
                            if(!loadedEmptyCells[c]){
                                return this.checkIsLoadedCell(sheetId, row, col, sheet) || false;
                            }
                        }
                    }
                }else{
                    return false;
                }
            }if(0 === row || 0 === col){
                /*
                 * special process for row or column cell
                 */
                if(loadedEmptyCells[p]){
                    return true;
                }
                return false;
            }
        }
        return true;
    },
           
    checkIsLoadedCell : function(){
           
    },
    
    getMergedRanges : function(cells){
    	var sep = EnterpriseSheet.sheet.calculate.Coordinate.prototype.separator;
    	var tabs = {};
    	for(var p in cells){
    		if(cells.hasOwnProperty(p)){
    			var it = cells[p], s = it[0], r = it[1], c = it[2];
    			tabs[s] = tabs[s] || {
    				minr: r,
    				maxr: r,
    				minc: c,
    				maxc: c
    			};
    			var tab = tabs[s];
    			if(tab.minr > r){
    				tab.minr = r;
    			}
    			if(tab.maxr < r){
    				tab.maxr = r;
    			}
    			if(tab.minc > c){
    				tab.minc = c;
    			}
    			if(tab.maxc < c){
    				tab.maxc = c;
    			}
    		}
    	}
    	var flags = {};
    	for(var s in tabs){
    		if(tabs.hasOwnProperty(s)){
                var tab = tabs[s], minr = tab.minr, minc = tab.minc, maxr = tab.maxr, maxc = tab.maxc, index = 0;
                for(var j = minc; j <= maxc; j++){
                    for(var i = minr; i <= maxr; i++){
    					var p = [s, i, j].join(sep);
    					if(cells[p]){
	    					if(minr < i){
	    						up = [s, i-1, j].join(sep);
                                flags[p] = flags[up];
	    					}
	    					if(!Ext.isDefined(flags[p])){
	    						flags[p] = index;
	    						index++;
	    					}
    					}
    				}
    			}
    		}
    	}
    	var ranges = {};
    	for(var p in flags){
    		if(flags.hasOwnProperty(p)){
    			var index = flags[p], pos = cells[p], s = pos[0], r = pos[1], c = pos[2];
    			ranges[s] = ranges[s] || {};
    			var it = ranges[s];
    			it[index] = it[index] || {
    				sheet: s,
    				minr: r,
    				minc: c,
    				maxr: r,
    				maxc: c
    			};
    			var range = it[index];
    			if(range.minr > r){
    				range.minr = r;
    			}
    			if(range.maxr < r){
    				range.maxr = r;
    			}
    			if(range.minc > c){
    				range.minc = c;
    			}
    			if(range.maxc < c){
    				range.maxc = c;
    			}
    		}
    	}
    	var arr = [];
    	for(var p in ranges){
    		if(ranges.hasOwnProperty(p)){
    			var it = ranges[p];
    			for(var q in it){
    				if(it.hasOwnProperty(q)){
    					var range = it[q];
    					arr.push([range.sheet, range.minr, range.minc, range.maxr, range.maxc]);
    				}
    			}    			
    		}
    	}
    	return arr;
    },
           
    getCoverRangesByCell : function(cells){
        var tabs = {};
        for(var p in cells){
            if(cells.hasOwnProperty(p)){
                var it = cells[p], s = it[0], r = it[1], c = it[2];
                tabs[s] = tabs[s] || {
                    minr: r,
                    maxr: r,
                    minc: c,
                    maxc: c
                };
                var tab = tabs[s];
                if(tab.minr > r){
                    tab.minr = r;
                }
                if(0 === r || (tab.maxr < r && 0 !== tab.maxr)){
                    tab.maxr = r;
                }
                if(tab.minc > c){
                    tab.minc = c;
                }
                if(0 === c || (tab.maxc < c && 0 !== tab.maxc)){
                    tab.maxc = c;
                }
            }
        }
        var arr = [];
        for(var p in tabs){
            if(tabs.hasOwnProperty(p)){
                var it = tabs[p];
                arr.push([Number(p), it.minr, it.minc, it.maxr, it.maxc]);
            }
        }
        return arr;
    },
           
    getCoverRangesBySheet : function(ranges){
        var lookup = {};
        for(var i = 0, len = ranges.length; i < len; i++){
            var it = ranges[i];
            var sheet = it[0];
            lookup[sheet] = lookup[sheet] || {};
            var o = lookup[sheet], minr = o.minr, minc = o.minc, maxr = o.maxr, maxc = o.maxc;
            if(!Ext.isNumber(minr) || minr > it[1] || 0 === it[1]){
                if(0 !== minr){
                    minr = it[1];
                }
            }
            if(!Ext.isNumber(minc) || minc > it[2] || 0 === it[2]){
                if(0 !== minc){
                    minc = it[2];
                }
            }
            if(!Ext.isNumber(maxr) || maxr < it[3] || 0 === it[3]){
                if(0 !== maxr){
                    maxr = it[3];
                }
            }
            if(!Ext.isNumber(maxc) || maxc < it[4] || 0 === it[4]){
                if(0 !== maxc){
                    maxc = it[4];
                }
            }
            o.minr = minr;
            o.minc = minc;
            o.maxr = maxr;
            o.maxc = maxc;
        }
        var arr = [];
        for(var p in lookup){
            if(lookup.hasOwnProperty(p)){
                var it = lookup[p];
                arr.push([Number(p), it.minr, it.minc, it.maxr, it.maxc]);
            }
        }
        return arr;
    },
           
    /**
     * load cells by range
     */
    loadCellsByRange : function(ranges, callback, scope){
        var me = this, sheetsLookup = this.getSheetLookup(), dataMap = this.getData(), separateChar = this.separateChar;
        var loadedTabIds = [];
        for(var i = 0, len = ranges.length; i < len; i++){
            var it = ranges[i];
            if(0 === it[1] && 0 === it[2] && 0 === it[3] && 0 === it[4]){
                loadedTabIds.push(it[0]);
            }
        }
        var rangeStr = Ext.encode(ranges);
       
        this._loadingFlag = true;
        var nextCellId = 0;
        var loadFn = function(){
        	if(!Ext.isDefined(me.fileId)){
        		delete(me._loadingFlag);
                if(callback){
                    callback.call(scope);
                }
        	}else{
        		Ext.Ajax.request({
                    url: me.loadRangeUrl,
                    params: {
                        range: rangeStr,
                        limit: me.limitCellNumAtSingleLoad,
                        nextCellId: nextCellId
                    },
                    success: function(response, options){
                        var json = Ext.decode(response.responseText);
                        var records  = me.reader.read(json.results);
                        if (true === json.success || 'true' === json.success) {
                            var count = 0;
                            for(var i = 0, len = records.length; i < len; i++){
                                var it = records[i];
                                if(!it[3].cal){
                                    var id = [it[0], it[1], it[2]].join(separateChar);
                                    if(!dataMap[id]){
                                        dataMap[id] = it;
                                        count++;
                                    }
                                }
                            }
                            me.totalCount += count;
                        }
                        if(json.nextCellId){
                            nextCellId = json.nextCellId;
                            loadFn();
                        }else{
                            for(var k = 0, size = loadedTabIds.length; k < size; k++){
                                var tabId = loadedTabIds[k];
                                sheetsLookup[tabId].allCellDataLoaded = true;
                            }
                            delete(me._loadingFlag);
                            if(callback){
                                callback.call(scope);
                            }
                            me.fireEvent('loadingrange', [ranges], me);
                        }
                    },
                    failure: function(response, options){
                        delete(me._loadingFlag);
                        Ext.Msg.alert(SLANG['hint'], SLANG['intelnet_error']);
                    },
                    scope: me
                });
        	}            
        }
        if(false === me.fireEvent('beforeloadingrange', [ranges], me)){
            return false;
        }
        me.fireEvent('prepareloadingrange', [ranges], me);
        loadFn();
    },
	
	/*
	 * load these unloaded cells in the cache
	 */
	checkLoadCells : function(lookup, callback, scope, mergeRangeFlag){

        var unloadeds = [], cache = this.getSheetLookup(), unloadedLookup = {};
		for(var p in lookup){
			if(lookup.hasOwnProperty(p)){
                var it = lookup[p];
				var pos = it.pos || it;
                var sheetId = pos[0];

                if(!this.isLoadedCell(sheetId, pos[1], pos[2], cache[sheetId])){
                    unloadedLookup[p] = pos;
                }
			}
		}
        var sep = EnterpriseSheet.sheet.calculate.Coordinate.prototype.separator, tmp = {};
        for(var p in unloadedLookup){
            if(unloadedLookup.hasOwnProperty(p)){
                var pos = unloadedLookup[p];
                var s = pos[0], r = pos[1], c = pos[2];
                if(0 === r && 0 === c){
                    tmp[p] = pos;
                }else if(0 === r || 0 === c){
                    var allId = [s, 0, 0].join(sep);
                    if(!unloadedLookup[allId]){
                        tmp[p] = pos;
                    }
                }else{
                    var allId = [s, 0, 0].join(sep);
                    if(!unloadedLookup[allId]){
                        var rowId = [s, r, 0].join(sep);
                        if(!unloadedLookup[rowId]){
                            var colId = [s, 0, c].join(sep);
                            if(!unloadedLookup[colId]){
                                tmp[p] = pos;
                            }
                        }
                    }
                }
            }
        }
        var ranges;
        if(mergeRangeFlag){
           ranges = this.getCoverRangesByCell(tmp);
        }else{
           ranges = this.getMergedRanges(tmp);
        }
        // console.log(ranges)

		var len = ranges.length;
		if(0 < len){
            this.loadCellsByRange(ranges, function(){
                /*
                 * sometimes the request cell is empty in backend, we just create an empty cell in store, so won't load it again next time
                 */
                this.updateLoadedEmptyCells(tmp, cache, ranges);
                                  
                if(callback){
                    callback.call(scope, true, unloadedLookup);
                }
            }, this);
			return false;
		}else if(callback){
			callback.call(scope);
		}
		return true;
	},
           
    /*
     * load these unloaded cells in the coord
     */
    checkLoadCoord : function(coord, callback, scope, mergeRangeFlag){
        var me = this;
        var coordPro = EnterpriseSheet.sheet.calculate.Coordinate.prototype;

        var ranges = [], sheetIds = [], sheetIdLookup = {}, cache = this.getSheetLookup();
        for(var i = 0, len = coord.length; i < len; i++){
            var span = coord[i];
            if(span){
	            var sheetId = span[0];
	            if(!sheetIdLookup[sheetId]){
	                var it = [].concat(span), flag = 0;
	                if(500 <= it[3]-it[1]){
	                    it[1] = 0;
	                    it[3] = 0;
	                    flag++;
	                }
	                if(100 <= it[4]-it[2]){
	                    it[2] = 0;
	                    it[4] = 0;
	                    flag++;
	                }
	                if(2 === flag){
	                    sheetIds.push(sheetId);
	                    sheetIdLookup[sheetId] = true;
	                }else{
	                    ranges.push(it);
	                }
	            }
            }
        }
        var needLoadSheetLen = sheetIds.length;
        if(0 < needLoadSheetLen){
            var index = 0;
            var loadFn = function(){
                me.loadSheet(sheetIds[index], function(){
                    index++;
                    if(index < needLoadSheetLen){
                        loadFn();
                    }else{
                        var cells = coordPro.transferCoord2CellLookup(ranges);
                        me.checkLoadCells(cells, callback, scope, mergeRangeFlag);
                    }
                }, me, true);
            }
            loadFn();
        }else{
            var cells = coordPro.transferCoord2CellLookup(ranges);
            this.checkLoadCells(cells, callback, scope, mergeRangeFlag);
        }
    },
	
	/*
	 * extend, find matched cells of the passed str
	 */
	findMatchCells : function(exp, callback, scope, startCellId){
		var me = this;
		var callParent = EnterpriseSheet.sheet.data.SheetStore.superclass.findMatchCells;
		var args = arguments;
		
		var sheets = this.getSheets(), loaded = true;
		for(var i = 0, len = sheets.length; i < len; i++){
			var it = sheets[i];
			if(!it.allCellDataLoaded){
				loaded = false;
				break;
			}
		}
		if(loaded || !Ext.isDefined(this.fileId)){
			/*
			 * if all sheets are loaded then call parent
			 */
			callParent.apply(me, [exp, callback, scope]);
		}else{
			
			exp = exp.toString();
			// update, remove % - backend add this
			var query = exp.replace(/\*/gi, '');
			if (query.length < 2) {
				Ext.Msg.alert(SLANG['hint'], SLANG['enter2char']);
				return;
			}
            var loadFn = function(){
                Ext.Ajax.request({
                    url: SCONFIG.urls['findCells2'],
                    params: {
                        fileId: this.fileId,
                        query: query,
                        limit: this.limitCellNumAtSingleLoad,
                        start: startCellId
                    },
                    success: function(response, options){
                        var json = Ext.decode(response.responseText);
                        
                        var me = this,
                        records  = me.reader.read(json.results);
                            
                        if (true === json.success || 'true' === json.success) {
                            me.totalCount += json.total;
                            // @ 2015 03 07. If I added this line. We have one bug during
                            // search item includes formula format. See Bug 2016
                            me.loadRecords(records, { addRecords: true, notOverwrite: true});
                        }
                        var matchs = [], sheetLookup = this.getSheetLookup(), colLookup = {};
                        for(var i = 0, len = records.length; i < len; i++){
                        	var it = records[i];
                        	var colName = colLookup[it[2]];
                        	if(!colName){
                        		colName = this.getColName(it[2]);
                        		colLookup[it[2]] = colName;
                        	}
                        	matchs.push({
        						sheet: it[0],
        						sheetName: sheetLookup[it[0]],
        						row: it[1],
        						col: it[2],
        						cell: colName+it[1],
        						data: it[3].data
        					});		
                        }   
                        if(callback){
                			callback.call(scope, matchs, json.nextCellId);
                		}                        
                    },
                    failure: function(response, options){
                        Ext.Msg.alert(SLANG['hint'], SLANG['intelnet_error']);
                    },
                    scope: this
                });
            }
            loadFn.call(this);
		}
	},
           
    /**
     * try to reconnect the server
     */
    reconnectServer : function(){
        this.callParent(arguments);
        if(this.serverFailureAction){
            var serverFailure = this.serverFailureAction, actionName = serverFailure.action;
            if('loadSheet' == actionName){
                this.loadSheet(serverFailure.sheetId, serverFailure.callback, serverFailure.scope);
            }
        }
    }
});
Ext.define('EnterpriseSheet.sheet.data.RollingStore', {
	/* Begin Definitions */
	
	extend : 'EnterpriseSheet.sheet.data.SheetStore',		
	
	requires : [	    	    	    
	    'EnterpriseSheet.common.measure.PixelMeasure'
	],

    rowBlockCount: 100,
           
    colBlockCount: 30,
	/**
	 * a buffer to hold all  
	 */
	loadCellRangeBuffer : 100,
	
	throttleOfBigFile : 10000,
           
    loadUrl : SCONFIG.urls['loadSheetInfo2'],
           
    loadMoreUrl: SCONFIG.urls['loadCellOnDemand4'],
           
    loadSheetUrl: SCONFIG.urls['loadSheet5'],
           
    loadRangeUrl: SCONFIG.urls['loadRange3'],
           
    loadRangeStyleUrl: SCONFIG.urls['loadRange3'],
	    	
	constructor : function(){
		
		this.callParent(arguments);
		
		
		
        this.on('loadcellrange', this.loadCellRange, this, {buffer: this.loadCellRangeBuffer});
	},
	
    /*
     * load file
     */
    loadFile : function(config, callback, scope){
        config = config || {};
        if(!SCOM.nullOrUndefined(config.fileId)){
            this.fileId = config.fileId;
        }
        this.load({
            params: {
                fileId: this.fileId,
                startCellId: 0,
                size: this.limitCellNumAtSingleLoad,
                throttleOfBigFile: this.throttleOfBigFile
            },
            callback: function(){
                if(callback){
                    callback.apply(scope, arguments);
                }
            },
            scope: this
        });
    },
    
    updateSheetObjAfterLoadSheet : function(sheetObj, json, sheetId){
		if('tab' === json.loadWay){
			sheetObj.allCellDataLoaded = true;
			json.loadSheetId = sheetId;
		}
	},
	
    loadMore : function(activeSheetId, startCellId, total, callback, scope, skipCal, message){
    	if('doc' === message.loadWay){
    		this.loadMoreUrl = SCONFIG.urls['loadCellOnDemand5'];
    	}else if('tab' === message.loadWay){
    		if(activeSheetId === message.loadSheetId){
    			this.loadMoreUrl = SCONFIG.urls['loadCellOnDemand3'];
    		}else{
    			this.loadMoreUrl = SCONFIG.urls['loadCellOnDemand4'];
    		}
    	}else{
    		this.loadMoreUrl = SCONFIG.urls['loadCellOnDemand4'];
    	}
    	this.callParent(arguments);
    },
         
    isSpansLoaded : function(spans){
    	var separateChar = this.separateChar, sheetId = this.getActivedSheetId();
        if(this.isAllCellLoadedInSheet(sheetId)){        	
        	return true;
        }
        var tab = this.getSheetById(sheetId);
        var maxRow = tab.maxRow, maxCol = tab.maxCol;
        tab.loadedBlocks = tab.loadedBlocks || {};
        var loadedBlocks = tab.loadedBlocks, unlodedBlocks = {};
        for(var i = 0, len = spans.length; i < len; i++){
            var span = spans[i];
            if(0 < span[1] && 0 < span[2] && span[1] <= maxRow && span[2] <= maxCol){
                var minr = Math.floor((span[1]-1)/this.rowBlockCount),
                maxr = Math.floor((span[3]-1)/this.rowBlockCount),
                minc = Math.floor((span[2]-1)/this.colBlockCount),
                maxc = Math.floor((span[4]-1)/this.colBlockCount);
           
                for(var r = minr; r <= maxr; r++){
                	for(var c = minc; c <= maxc; c++){
                		var id = [r, c].join(separateChar);
                        if(!loadedBlocks[id]){
                            return false;
                        }
                	}
                }                
            }
        }
        return true;
    },
    	
	/**
	 * check and load if the cells in range is not loaded
	 */
	checkLoadRange : function(spans, callback, scope){
        var separateChar = this.separateChar, sheetId = this.getActivedSheetId();
        if(this.isAllCellLoadedInSheet(sheetId)){
        	if(callback){
        		callback.call(scope);
        	}
        	return;
        }
        var tab = this.getSheetById(sheetId);
        var maxRow = tab.maxRow, maxCol = tab.maxCol;
        tab.loadedBlocks = tab.loadedBlocks || {};
        var loadedBlocks = tab.loadedBlocks, unlodedBlocks = {};
        for(var i = 0, len = spans.length; i < len; i++){
            var span = spans[i];
            if(0 < span[1] && 0 < span[2] && span[1] <= maxRow && span[2] <= maxCol){
                var minr = Math.floor((span[1]-1)/this.rowBlockCount),
                maxr = Math.floor((span[3]-1)/this.rowBlockCount),
                minc = Math.floor((span[2]-1)/this.colBlockCount),
                maxc = Math.floor((span[4]-1)/this.colBlockCount);
           
                for(var r = minr; r <= maxr; r++){
                	for(var c = minc; c <= maxc; c++){
                		var id = [r, c].join(separateChar);
                        if(!loadedBlocks[id]){
                            loadedBlocks[id] = 'loading';
                            unlodedBlocks[id] = [r, c];
                        }
                	}
                }                
            }
        }
        
        var coord = [];
        for(var p in unlodedBlocks){
            if(unlodedBlocks.hasOwnProperty(p)){
                var it = unlodedBlocks[p], r = it[0], c = it[1];
                var minr = r*this.rowBlockCount+1, maxr = minr+this.rowBlockCount-1,
                    minc = c*this.colBlockCount+1, maxc = minc+this.colBlockCount-1;
                coord.push([sheetId, minr, minc, maxr, maxc]);
            }
        }
        if(0 < coord.length){
            this.loadCellRange(coord, function(){
                for(var p in unlodedBlocks){
                    if(p.hasOwnProperty(p)){
                        loadedBlocks[p] = true;
                    }
                }
                if(callback){
                    callback.call(scope);
                }
            }, this);
        }else{
            if(callback){
                callback.call(scope);
            }
        }
	},
           
	/**
	 * load the cell range from server
	 */
	loadCellRange : function(coord, callback, scope){
        var sheetId = this.getActivedSheetId(), nextCellId = 0, separateChar = this.separateChar;
        var dataMap = this.getData();
        if(false === this.fireEvent('beforeloadrange', coord, this)){
            return;
        }
        var me = this;
        var loadFn = function(){
            me.fireEvent('prepareloadrange', coord, me);
            Ext.Ajax.request({
                url: me.loadRangeStyleUrl,
                params: {
                    'nextCellId': nextCellId,
                    'range': Ext.encode(coord),
                    'limit': me.limitCellNumAtSingleLoad
                },
                success : function(response, options){
                    var json = Ext.decode(response.responseText);
                    nextCellId = json.nextCellId;
                    if (true === json.success || 'true' === json.success) {
                        var results = json.results;
                        for(var i = 0, len = results.length; i < len; i++){
                            var it = results[i];
                            var id = [it[0], it[1], it[2]].join(separateChar);
                            var found = dataMap[id];
                            if(found){
                                var empty = SCOM.isEmptyValue(found[3].data);
                                found[3] = Ext.apply(Ext.decode(it[3]), found[3]);
                                if(empty){
                                    /*
                                     * need delete the cdtVal if the data is empty
                                     */
                                    delete(found[3]['cdtVal']);
                                }
                            }else{
                                it = me.reader.readSingle(it);
                                dataMap[id] = it;
                            }
                        }
                    }
                    if(nextCellId){
                        loadFn();
                    }else{
                        /*
                         * special process for tpl
                         */
                        this.presetTplForCells();
                        if(callback){
                            callback.call(scope);
                        }
                        me.fireEvent('afterloadrange', coord, me);
                    }
                },
                scope: me
            });
        }
        loadFn();
	},
           
    checkIsLoadedCell : function(sheetId, row, col, sheet){
        sheet = sheet || this.getSheetById(sheetId);
        if(sheet.loadedBlocks){
            var r = Math.floor((row-1)/this.rowBlockCount),
                c = Math.floor((col-1)/this.colBlockCount);
            var id = [r, c].join(this.separateChar);
        
            if(sheet.loadedBlocks[id]){
                return true;
            }
        }
    }
});
Ext.define('EnterpriseSheet.sheet.menu.CustomFormatMenu', {
	
	/* Begin Definitions */
	
	extend : 'Ext.menu.Menu',
           
    requires: [
        'EnterpriseSheet.sheet.data.CustomStore',
        'EnterpriseSheet.common.Helper'
    ],
	
	/* End Definitions */
			
	offset: SCONFIG.js_standalone ? 8 : 9,
	
	initComponent : function(){
        this.store = Ext.create('EnterpriseSheet.sheet.data.CustomStore', {});
           
		this.defaults = {
			scope: this,
			handler: this.onClickFormatItem
		};
		
		this.items = [{	
			text: SCONST.NUMBER_CUSTOM_FORMAT['num1']
		}, {							
			text: SCONST.NUMBER_CUSTOM_FORMAT['num2']
		}, {							
			text: SCONST.NUMBER_CUSTOM_FORMAT['num3']
		}, {							
			text: SCONST.NUMBER_CUSTOM_FORMAT['num4']
		}, {							
			text: SCONST.NUMBER_CUSTOM_FORMAT['num5']
		}, {							
			text: SCONST.NUMBER_CUSTOM_FORMAT['num6']
		}, {							
			text: SCONST.NUMBER_CUSTOM_FORMAT['num7']
		}, {							
			text: SCONST.NUMBER_CUSTOM_FORMAT['num8']
		},{
			text: SLANG['customFormat'],
			hidden: SCONFIG.js_standalone,
			name: 'createCustom',
			iconCls: 'icon-add'
		}];
		
		this.callParent(arguments);
		
		this.store.on('beforeload', this.onBeforeStoreLoad, this);
        this.store.on('load', this.onStoreLoad, this);
        
		this.on('beforeshow', function(){
			if(!this.storeLoaded){
				this.store.load();
				this.storeLoaded = true;
			}			
		}, this);
	},
	
	onBeforeStoreLoad : function(){
		var dels = [];
		this.items.each(function(item){
			if(item.fromStore){
				dels.push(item);
			}
		}, this);
		for(var i = 0, len = dels.length; i < len; i++){
			this.remove(dels[i]);
		}
	},
	
	onStoreLoad : function(store, recs, success){
		if(success){
			for(var i = 0, len = recs.length; i < len; i++){
				var it = recs[i];
				this.add(Ext.applyIf({
					fromStore: true
				}, it.data));
			}
			if(this.parentItem){
				this.showBy(this.parentItem, this.parentItem.menuAlign);				
			}
		}		
	},
    
    /*
	 * bind the sheet for handler use
	 */
	bindSheet : function(sheet){
		this.sheet = sheet;
	},
    
    /*
     * handler for select, it will change the text format of selection
     */
    selectTextFormat : function(format){    	
    	var sheet = this.sheet;
    	if(sheet){ 
    		// check whether this format is end with %
    		if (HELPER.endWith(format, '%')) sheet.setPercentFormatForSelection(format);
    		else sheet.setNumberFormatForSelection(format);
    	}
    },
    
    onClickFormatItem : function(item){
    	if (item.name) {
    		if (item.name == "createCustom") {
	    		// popup window ...
	    		this.customWin = Ext.create("EnterpriseSheet.sheet.pop.NumberCustomWin", {});
	    		this.customWin.bindSheet(this.sheet);
	    		this.customWin.popup();
    		} else {
    			this.sheet.setTextFormatForSelection(item.name);
    		}   		
    	} else 
    	    this.selectTextFormat(item.text);
    },
    
    itemsHandler: function(item, evt) {
		this.selectTextFormat(item.text);
    }
});
Ext.define('EnterpriseSheet.sheet.menu.CellStyleMenu', {
	
	/* Begin Definitions */
	
	extend: 'Ext.menu.Menu',	
	
	requires: [
	    'EnterpriseSheet.common.CONST',
	    'EnterpriseSheet.sheet.model.CellTplModel', 
	    'Ext.data.Store'
	],
	
	/* End Definitions */
	
	plain : true,
	
	scrollOffset : 18,
	
	initComponent : function(){ 
		/*
		 * define stores
		 */
		var preferStore = new Ext.data.Store({		    		    
		    model: 'EnterpriseSheet.sheet.model.CellTplModel'		   
		});
		
		var modelStore = new Ext.data.Store({		    		    
		    model: 'EnterpriseSheet.sheet.model.CellTplModel'		   
		});
		
		var titleStore = new Ext.data.Store({		    		    
		    model: 'EnterpriseSheet.sheet.model.CellTplModel'		   
		});
		
		var subjectStore = new Ext.data.Store({		    		    
		    model: 'EnterpriseSheet.sheet.model.CellTplModel'		   
		});
		
		var numberStore = new Ext.data.Store({		    		    
		    model: 'EnterpriseSheet.sheet.model.CellTplModel'		   
		});
		
		var tpl = new Ext.XTemplate(
			'<tpl for=".">',
				'<div class="thumb-wrap">',
					'<div class="thumb cell-style" style="{style}">{text}</div>',
				'</div>',
			'</tpl>',
			'<div class="x-clear"></div>'
		);
		
		for(var i = 0, len = CELLTPL_DATA.length; i < len; i++){
			var it = CELLTPL_DATA[i];
			if('prefer' == it['type']){
				var r = preferStore.createModel(it);						
				preferStore.add(r);
			}else if('model' == it['type']){
				var r = modelStore.createModel(it);						
				modelStore.add(r);
			}else if('title' == it['type']){
				var r = titleStore.createModel(it);						
				titleStore.add(r);
			}else if('subject' == it['type']){
				var r = subjectStore.createModel(it);						
				subjectStore.add(r);
			}else if('number' == it['type']){
				var r = numberStore.createModel(it);						
				numberStore.add(r);
			}			
		}
		
		/*
		 * define views
		 */
		this.preferView = new Ext.view.View({
			cls: 'images-view',
		    store: preferStore,
		    tpl: tpl,
		    autoHeight:true,
		    singleSelect: true,
		    trackOver: true,
		    overItemCls:'x-view-over',
		    itemSelector:'div.thumb-wrap'
		});		
		
		this.modelView = new Ext.view.View({
			cls: 'images-view',
		    store: modelStore,
		    tpl: tpl,
		    autoHeight:true,
		    singleSelect: true,
		    trackOver: true,
		    overItemCls:'x-view-over',
		    itemSelector:'div.thumb-wrap'
		});
		
		this.titleView = new Ext.view.View({
			cls: 'images-view',
		    store: titleStore,
		    tpl: tpl,
		    autoHeight:true,
		    singleSelect: true,
		    trackOver: true,
		    overItemCls:'x-view-over',
		    itemSelector:'div.thumb-wrap'
		}); 
		
		this.subjectView = new Ext.view.View({
			cls: 'images-view',
		    store: subjectStore,
		    tpl: tpl,
		    autoHeight:true,
		    singleSelect: true,
		    trackOver: true,
		    overItemCls:'x-view-over',
		    itemSelector:'div.thumb-wrap'
		}); 
		
		this.numberView = new Ext.view.View({
			cls: 'images-view',
		    store: numberStore,
		    tpl: tpl,
		    autoHeight:true,
		    singleSelect: true,
		    trackOver: true,
		    overItemCls:'x-view-over',
		    itemSelector:'div.thumb-wrap'
		});
		
		this.items = [{
			xtype:'container',
			style:'background:rgb(250,250,250);',
			width:480,
			height:430,
			autoScroll:true,
			items:[{
				xtype:'box',
				cls:'tpl-title',
				html:SLANG['bad_good_ok']
			}, this.preferView, {
				xtype:'box',
				cls:'tpl-title',
				html:SLANG['data_modal']
			}, this.modelView, {
				xtype:'box',
				cls:'tpl-title',
				html:SLANG['title']
			}, this.titleView, {
				xtype:'box',
				cls:'tpl-title',
				html:SLANG['subject_text']
			}, this.subjectView, {
				xtype:'box',
				cls:'tpl-title',
				html:SLANG['number_format']
			}, this.numberView],
			listeners: {
				'afterrender' : function(ct){
					var el = ct.getEl(); 
					var me = this;
					me.mon(el, 'mousewheel', function(e){
						var delta = e.getWheelDelta();
						el.dom.scrollTop += -delta*me.scrollOffset;
					})
				},
				scope: this
			}
		}, {
			iconCls:'icon-cell-tpl',
			text:SLANG['new_cell_tpl']
		}];
		
		this.callParent();				
				
		this.mon(this.preferView, 'itemclick', this._onClickItem, this);
		this.mon(this.modelView, 'itemclick', this._onClickItem, this);
		this.mon(this.titleView, 'itemclick', this._onClickItem, this);
		this.mon(this.subjectView, 'itemclick', this._onClickItem, this);
		this.mon(this.numberView, 'itemclick', this._onClickItem, this);
	},
	
	/*
	 * bind the sheet for handler use
	 */
	bindSheet : function(sheet){
		this.sheet = sheet;		
	},
		
	_onClickItem : function(dv, rec){				
		var property = rec.data.property, fn = rec.data.fn;
		if(property || fn){			
			this.setPropertyForSelection(property, fn);
		}
		this.hide();	
	},
	
	/*
	 * set tpl for selection in sheet
	 */
	setPropertyForSelection : function(property, fn){
		var sheet = this.sheet, store = sheet.getStore();
		var sm = sheet.getSelectionModel();
		
		var coord = sm.selection2Coord();    		
		var range = new EnterpriseSheet.sheet.range.Range({
    		sheet:sheet,
    		coord:coord
    	});		
		
		if(false !== sheet.fireEvent('beforeborderchange', range, sheet)){
			sheet.fireEvent('prepareborderchange', range, sheet);
			var dp = {				
				bgc:'',
				fz:'',
				fw:'',
				fs:'',			
				color:''
			};						
			property = Ext.apply(dp, property);
			sheet.setPropertyForSelection(property, null, true, true);
			if(fn){
				fn(sheet);
			}
			range.refresh();
			sheet.fireEvent('borderchange', range, sheet);
		}					
	}
}, function(){
	/**********************************************
	 * template datas 
	 *********************************************/

	CELLTPL_DATA = [{
		'text':SLANG['regular'],		
		'tip':SLANG['regular'],
		'type':'prefer',
		'style':'background:white;'
	}, {
		'text':SLANG['bad'],		
		'tip':SLANG[''],
		'type':'prefer',
		'style':'background:pink;color:rgb(156,0,6);',
		'property':{
			bgc:'pink',					
			color:'rgb(156,0,6)'
		}
	}, {
		'text':SLANG['good'],		
		'tip':SLANG[''],
		'type':'prefer',
		'style':'background:rgb(198,239,206);color:rgb(0,97,0);',
		'property':{
			bgc:'rgb(198,239,206)',			
			color:'rgb(0,97,0)'
		}
	}, {
		'text':SLANG['ok'],		
		'tip':SLANG[''],
		'type':'prefer',
		'style':'background:rgb(255,235,156);color:rgb(156,101,0);',
		'property':{
			bgc:'rgb(255,235,156)',			
			color:'rgb(156,101,0)'
		}
	},
	/*********************
	 * model
	 *********************/
	{
		'text':SLANG['calculate'],		
		'tip':SLANG['calculate'],
		'type':'model',
		'style':'background:rgb(242,242,242);border:1px solid gray;',
		'property':{
			bgc:'rgb(242,242,242)'			
		},
		fn: function(sheet){			
			sheet.setRangeBorder('all', 'gray', 1, 'solid', true, true);
		}
	}, {
		'text':SLANG['check_cell'],		
		'tip':SLANG['check_cell'],
		'type':'model',
		'style':'background:rgb(165,165,165);border:3px double;padding-top:1px;padding-bottom:1px;color:white;',
		'property':{
			bgc:'rgb(165,165,165)',			
			color:'white'
		},
		fn: function(sheet){			
			sheet.setRangeBorder('all', 'black', 3, 'double', true, true);
		}
	}, {
		'text':SLANG['explain_text'],		
		'tip':SLANG['explain_text'],
		'type':'model',
		'style':'background:white;color:rgb(127,127,127);font-style:italic;',
		'property':{
			bgc:'',			
			color:'rgb(127,127,127)',
			fs:'italic'
		}
	}, {
		'text':SLANG['warning_text'],		
		'tip':SLANG['warning_text'],
		'type':'model',
		'style':'background:white;color:red;',
		'property':{
			bgc:'',			
			color:'red'
		}
	}, {
		'text':SLANG['link_cell'],		
		'tip':SLANG['link_cell'],
		'type':'model',
		'style':'background:white;color:orange;border-bottom:3px double orange;',
		'property':{
			bgc:'',			
			color:'orange'
		},
		fn: function(sheet){			
			sheet.setRangeBorder('bottom', 'orange', 3, 'double', true, true);
		}
	}, {
		'text':SLANG['output'],		
		'tip':SLANG['output'],
		'type':'model',
		'style':'background:rgb(242,242,242);border:1px solid;',
		'property':{
			bgc:'rgb(242,242,242)'
		},
		fn: function(sheet){			
			sheet.setRangeBorder('all', 'black', 1, 'solid', true, true);
		}
	}, {
		'text':SLANG['input'],		
		'tip':SLANG['input'],
		'type':'model',
		'style':'background:rgb(255,204,153);color:rgb(63,63,118);border:1px solid gray;',
		'property':{
			bgc:'rgb(255,204,153)',
			color:'rgb(63,63,118)'
		},
		fn: function(sheet){			
			sheet.setRangeBorder('all', 'gray', 1, 'solid', true, true);
		}
	}, {
		'text':SLANG['comment'],		
		'tip':SLANG['comment'],
		'type':'model',
		'style':'background:rgb(255,255,204);border:1px solid silver;',
		'property':{
			bgc:'rgb(255,255,204)'
		},
		fn: function(sheet){			
			sheet.setRangeBorder('all', 'silver', 1, 'solid', true, true);
		}
	},
	/*********************
	 * title
	 *********************/
	{
		'text':SLANG['title'],		
		'tip':SLANG['title'],
		'type':'title',
		'style':'background:white;color:rgb(31,73,125);font-size:18px;',
		'property':{
			color:'rgb(31,73,125)',
			fz:'18'
		}
	}, {
		'text':SLANG['title']+'1',		
		'tip':SLANG['title']+'1',
		'type':'title',
		'style':'background:white;color:rgb(31,73,125);font-size:15px;border-bottom:3px solid rgb(79,129,189);',
		'property':{
			color:'rgb(31,73,125)',
			fz:15
		},
		fn: function(sheet){			
			sheet.setRangeBorder('bottom', 'rgb(79,129,189)', 3, 'solid', true, true);
		}
	}, {
		'text':SLANG['title']+'2',		
		'tip':SLANG['title']+'2',
		'type':'title',
		'style':'background:white;color:rgb(31,73,125);font-size:13px;border-bottom:3px solid rgb(168,192,222);',
		'property':{
			color:'rgb(31,73,125)',
			fz:13
		},
		fn: function(sheet){			
			sheet.setRangeBorder('bottom', 'rgb(168,192,222)', 3, 'solid', true, true);
		}
	}, {
		'text':SLANG['title']+'3',		
		'tip':SLANG['title']+'3',
		'type':'title',
		'style':'background:white;color:rgb(31,73,125);font-size:11px;border-bottom:2px solid rgb(149,179,215);',
		'property':{
			color:'rgb(31,73,125)',
			fz:11
		},
		fn: function(sheet){			
			sheet.setRangeBorder('bottom', 'rgb(149,179,215)', 2, 'solid', true, true);
		}
	}, {
		'text':SLANG['title']+'4',		
		'tip':SLANG['title']+'4',
		'type':'title',
		'style':'background:white;color:rgb(31,73,125);font-size:11px;',
		'property':{
			color:'rgb(31,73,125)',
			fz:11
		}
	}, {
		'text':SLANG['summary'],		
		'tip':SLANG['summary'],
		'type':'title',
		'style':'background:white;border-top:1px solid rgb(79,129,189);border-bottom:3px double rgb(79,129,189);',		
		fn: function(sheet){			
			sheet.setRangeBorder('top', 'rgb(79,129,189)', 1, 'solid', true, true);
			sheet.setRangeBorder('bottom', 'rgb(79,129,189)', 3, 'double', true, true);
		} 
	}, 
	/*********************
	 * subject
	 *********************/
	{
		'text':'20% '+SLANG['strong'],		
		'tip':'20% '+SLANG['strong'],
		'type':'subject',
		'style':'background:rgb(219,229,241);',
		'property':{
			bgc:'rgb(219,229,241)'
		}
	}, {
		'text':'20% '+SLANG['strong'],		
		'tip':'20% '+SLANG['strong'],
		'type':'subject',
		'style':'background:rgb(242,221,220);',
		'property':{
			bgc:'rgb(242,221,220)'
		}
	}, {
		'text':'20% '+SLANG['strong'],		
		'tip':'20% '+SLANG['strong'],
		'type':'subject',
		'style':'background:rgb(234,241,221);',
		'property':{
			bgc:'rgb(234,241,221)'
		}
	}, {
		'text':'20% '+SLANG['strong'],		
		'tip':'20% '+SLANG['strong'],
		'type':'subject',
		'style':'background:rgb(229,224,236);',
		'property':{
			bgc:'rgb(229,224,236)'
		}
	}, {
		'text':'20% '+SLANG['strong'],		
		'tip':'20% '+SLANG['strong'],
		'type':'subject',
		'style':'background:rgb(219,238,243);',
		'property':{
			bgc:'rgb(219,238,243)'
		}
	}, {
		'text':'20% '+SLANG['strong'],		
		'tip':'20% '+SLANG['strong'],
		'type':'subject',
		'style':'background:rgb(253,233,217);',
		'property':{
			bgc:'rgb(253,233,217)'
		}
	}, {
		'text':'40% '+SLANG['strong'],		
		'tip':'40% '+SLANG['strong'],
		'type':'subject',
		'style':'background:rgb(184,204,228);',
		'property':{
			bgc:'rgb(184,204,228)'
		}
	}, {
		'text':'40% '+SLANG['strong'],		
		'tip':'40% '+SLANG['strong'],
		'type':'subject',
		'style':'background:rgb(230,185,184);',
		'property':{
			bgc:'rgb(230,185,184)'
		}
	}, {
		'text':'40% '+SLANG['strong'],		
		'tip':'40% '+SLANG['strong'],
		'type':'subject',
		'style':'background:rgb(215,228,188);',
		'property':{
			bgc:'rgb(215,228,188)'
		}
	}, {
		'text':'40% '+SLANG['strong'],		
		'tip':'40% '+SLANG['strong'],
		'type':'subject',
		'style':'background:rgb(204,192,218);',
		'property':{
			bgc:'rgb(204,192,218)'
		}
	}, {
		'text':'40% '+SLANG['strong'],		
		'tip':'40% '+SLANG['strong'],
		'type':'subject',
		'style':'background:rgb(182,221,232);',
		'property':{
			bgc:'rgb(182,221,232)'
		}
	}, {
		'text':'40% '+SLANG['strong'],		
		'tip':'40% '+SLANG['strong'],
		'type':'subject',
		'style':'background:rgb(252,213,180);',
		'property':{
			bgc:'rgb(252,213,180)'
		}
	}, {
		'text':'60% '+SLANG['strong'],		
		'tip':'60% '+SLANG['strong'],
		'type':'subject',
		'style':'background:rgb(149,179,215);color:white;',
		'property':{
			bgc:'rgb(149,179,215)',
			color:'white'				
		}
	}, {
		'text':'60% '+SLANG['strong'],		
		'tip':'60% '+SLANG['strong'],
		'type':'subject',
		'style':'background:rgb(217,151,149);color:white;',
		'property':{
			bgc:'rgb(217,151,149)',
			color:'white'
		}
	}, {
		'text':'60% '+SLANG['strong'],		
		'tip':'60% '+SLANG['strong'],
		'type':'subject',
		'style':'background:rgb(194,214,154);color:white;',
		'property':{
			bgc:'rgb(194,214,154)',
			color:'white'
		}
	}, {
		'text':'60% '+SLANG['strong'],		
		'tip':'60% '+SLANG['strong'],
		'type':'subject',
		'style':'background:rgb(178,161,199);color:white;',
		'property':{
			bgc:'rgb(178,161,199)',
			color:'white'
		}
	}, {
		'text':'60% '+SLANG['strong'],		
		'tip':'60% '+SLANG['strong'],
		'type':'subject',
		'style':'background:rgb(147,205,221);color:white;',
		'property':{
			bgc:'rgb(147,205,221)',
			color:'white'
		}
	}, {
		'text':'60% '+SLANG['strong'],		
		'tip':'60% '+SLANG['strong'],
		'type':'subject',
		'style':'background:rgb(250,192,144);color:white;',
		'property':{
			bgc:'rgb(250,192,144)',
			color:'white'
		}
	}, {
		'text':SLANG['strong'],		
		'tip':SLANG['strong'],
		'type':'subject',
		'style':'background:rgb(79,129,189);color:white;',
		'property':{
			bgc:'rgb(79,129,189)',
			color:'white'
		}
	}, {
		'text':SLANG['strong'],		
		'tip':SLANG['strong'],
		'type':'subject',
		'style':'background:rgb(192,80,77);color:white;',
		'property':{
			bgc:'rgb(192,80,77)',
			color:'white'
		}
	}, {
		'text':SLANG['strong'],		
		'tip':SLANG['strong'],
		'type':'subject',
		'style':'background:rgb(155,187,89);color:white;',
		'property':{
			bgc:'rgb(155,187,89)',
			color:'white'
		}
	}, {
		'text':SLANG['strong'],		
		'tip':SLANG['strong'],
		'type':'subject',
		'style':'background:rgb(128,100,162);color:white;',
		'property':{
			bgc:'rgb(128,100,162)',
			color:'white'
		}
	}, {
		'text':SLANG['strong'],		
		'tip':SLANG['strong'],
		'type':'subject',
		'style':'background:rgb(75,172,198);color:white;',
		'property':{
			bgc:'rgb(75,172,198)',
			color:'white'
		}
	}, {
		'text':SLANG['strong'],		
		'tip':SLANG['strong'],
		'type':'subject',
		'style':'background:rgb(247,150,70);color:white;',
		'property':{
			bgc:'rgb(247,150,70)',
			color:'white'
		}
	},
	/*********************
	 * number
	 *********************/
	{
		'text':SLANG['percent']+'[%]',		
		'tip':SLANG['percent'],
		'type':'number',
		'style':'background:white;',
		'property':{			
			fm: SCONST.FORMAT_PERCENT
		}
	}, {
		'text':SLANG['currency'],		
		'tip':SLANG['currency'],
		'type':'number',
		'style':'background:white;',
		'property':{			
			fm: SCONST.FORMAT_CURRENCY
		}
	}, {
		'text':SLANG['comma'],		
		'tip':SLANG['comma'],
		'type':'number',
		'style':'background:white;',
		'property':{			
			fm: SCONST.FORMAT_COMMA
		}
	}];
});
Ext.define('EnterpriseSheet.sheet.menu.ConditionMenu', {
	
	/* Begin Definitions */
	
	extend: 'EnterpriseSheet.common.menu.ScaleMenu',		
	
	/* End Definitions */
	
	scale : 'large',
	
	initComponent : function(){
		
		this.colors = {
			'red':[255,0,0],
			'green':[0,255,0],
			'blue':[0,0,255],
			'orange':[255,128,0],
			'native':[0,128,255],
			'pink':[255,0,128],
			'white':[255,255,255],
			'yellow':[255,255,0]
		};
		
		this.gradColors = {
			'red':[248,105,107],
			'green':[90,190,123],
			'blue':[90,138,198],								
			'white':[255,255,255],
			'yellow':[255,235,132]	
		};
		
		this.colorTpl = new Ext.XTemplate(
			'rgb({0},{1},{2})'
		).compile();
				
		this.items = [{
			xtype: 'scaleitem',
			scale: 'large',
			iconCls:'icon-compare-highlight32',
			text:SLANG['condition_highlight_cell'],
			menu:new EnterpriseSheet.common.menu.ScaleMenu({
				scale:'large',
				minWidth: 200,
				items:[{							
					xtype: 'scaleitem',
					scale: 'large',
					iconCls:'icon-condition-greater32',
					text:SLANG['greater_than']+'...',
					handler:this.onConditionGreater,
					scope:this
				}, {
					xtype: 'scaleitem',
					scale: 'large',
					iconCls:'icon-condition-less32',
					text:SLANG['less_than']+'...',
					handler:this.onConditionLess,
					scope:this
				}, {
					xtype: 'scaleitem',
					scale: 'large',
					iconCls:'icon-condition-equal32',
					text:SLANG['equal']+'...',
					handler:this.onConditionEqual,
					scope:this
				}, {
					xtype: 'scaleitem',
					scale: 'large',
					iconCls:'icon-condition-between32',
					text:SLANG['between']+'...',
					handler:this.onConditionBetween,
					scope:this
				}, '-', {
					xtype: 'scaleitem',
					scale: 'large',
					iconCls:'icon-condition-include32',
					text:SLANG['include']+'...',
					handler:this.onConditionInclude,
					scope:this
				}, {
					xtype: 'scaleitem',
					scale: 'large',
					iconCls:'icon-condition-date32',
					text:SLANG['date_ocurring_at']+'...',
					handler:this.onConditionDate,
					scope:this
				}, {
					xtype: 'scaleitem',
					scale: 'large',
					iconCls:'icon-condition-repeat32',
					text:SLANG['repeat_value']+'...',
					handler:this.onConditionRepeat,
					scope:this
				}, '-', {
					text:SLANG['other_condition']+'...',
					handler:this.onOtherCondition,
					scope:this
				}]
			})
		}, {				
			xtype: 'scaleitem',
			scale: 'large',
			iconCls:'icon-calculate-highlight32',
			text:SLANG['calculate_highlight_cell'],
			menu:new EnterpriseSheet.common.menu.ScaleMenu({
				scale:'large',
				minWidth: 200,
				items:[{		
					xtype: 'scaleitem',
					scale: 'large',
					iconCls:'icon-condition-max32',
					text:SLANG['top_10_value']+'...',
					handler:this.onConditionMax,
					scope:this
				}, {
					xtype: 'scaleitem',
					scale: 'large',
					iconCls:'icon-condition-top32',
					text:SLANG['top_10%']+'...',
					handler:this.onConditionTop,
					scope:this
				}, {
					xtype: 'scaleitem',
					scale: 'large',
					iconCls:'icon-condition-min32',
					text:SLANG['bottom_10_value']+'...',
					handler:this.onConditionMin,
					scope:this
				}, {
					xtype: 'scaleitem',
					scale: 'large',
					iconCls:'icon-condition-bottom32',
					text:SLANG['bottom_10%']+'...',
					handler:this.onConditionBottom,
					scope:this
				}, '-', {
					xtype: 'scaleitem',
					scale: 'large',
					iconCls:'icon-condition-above32',
					text:SLANG['above_average']+'...',
					handler:this.onConditionAbove,
					scope:this
				}, {
					xtype: 'scaleitem',
					scale: 'large',
					iconCls:'icon-condition-below32',
					text:SLANG['below_average']+'...',
					handler:this.onConditionBelow,
					scope:this
				}, '-', {
					text:SLANG['other_condition']+'...',
					handler:this.onOtherCondition,
					scope:this
				}]
			})
		}, '-', {		
			xtype: 'scaleitem',
			scale: 'large',
			iconCls:'icon-red-bar32',
			text:SLANG['colorbar'],	
			handler:this.onColorBar,
			scope:this,
			menu:new Ext.menu.Menu({
				plain:true,
				items:[{	
					title:SLANG['pure_color_fill'],
					xtype:'buttongroup',			
					frame:false,
					height: 90,
					layout: {
				        type: 'table',
				        columns: 3,
				        tableAttrs: {
				            style: {
				                width: '100%'				                
				            }
				        }
				    },
					defaults:{
						scale:'large',
						style:'padding:2px;',
						handler:this.onColorBar,
						scope:this
					},
					items:[{						
						iconCls:'icon-blue-bar32',
						color:'blue'
					}, {						
						iconCls:'icon-green-bar32',
						color:'green'
					}, {						
						iconCls:'icon-red-bar32',
						color:'red'
					}, {						
						iconCls:'icon-native-bar32',
						color:'native'
					}, {						
						iconCls:'icon-orange-bar32',
						color:'orange'
					}, {						
						iconCls:'icon-pink-bar32',
						color:'pink'
					}]
				}, '-', {
					text:SLANG['other_condition']+'...',
					handler:this.onOtherCondition,
					scope:this
				}]
			})
		}, {		
			xtype: 'scaleitem',
			scale: 'large',
			iconCls:'icon-colorchange32',
			text:SLANG['color_scales'],
			handler:this.onColorChange,
			scope:this,
			menu:new Ext.menu.Menu({
				plain:true,
				items:[{						
					xtype:'buttongroup',
					frame:false,
					height: 120,
					layout: {
				        type: 'table',
				        columns: 4,
				        tableAttrs: {
				            style: {
				                width: '100%'
				            }
				        }
				    },
					defaults:{
						scale:'large',
						style:'padding:2px;',
						handler:this.onColorChange,
						scope:this
					},
					items:[{						
						iconCls:'icon-grad-green2orange2red32',
						start:'green',
						stop:'yellow',
						end:'red'
					}, {											
						iconCls:'icon-grad-red2orange2green32',
						start:'red',
						stop:'yellow',
						end:'green'
					}, {						
						iconCls:'icon-grad-blue2orange2red32',
						start:'blue',
						stop:'yellow',
						end:'red'
					}, {											
						iconCls:'icon-grad-red2orange2blue32',
						start:'red',
						stop:'yellow',
						end:'blue'
					}, {											
						iconCls:'icon-grad-green2yellow32',
						start:'green',						
						end:'yellow'
					}, {						
						iconCls:'icon-grad-yellow2green32',
						start:'yellow',						
						end:'green'
					}, {						
						iconCls:'icon-grad-orange2red32',
						start:'yellow',						
						end:'red'
					}, {						
						iconCls:'icon-grad-red2orange32',
						start:'red',						
						end:'yellow'
					}, {						
						iconCls:'icon-grad-white2pink32',
						start:'white',						
						end:'red'
					}, {						
						iconCls:'icon-grad-pink2white32',
						start:'red',						
						end:'white'
					}, {						
						iconCls:'icon-grad-white2green32',
						start:'white',						
						end:'green'
					}, {						
						iconCls:'icon-grad-green2white32',
						start:'green',						
						end:'white'
					}]
				}, '-', {
					text:SLANG['other_condition']+'...',
					handler:this.onOtherCondition,
					scope:this
				}]
			})
		}, '-', {			
			xtype: 'scaleitem',
			scale: 'large',
			iconCls:'icon-clear-condition32',
			text:SLANG['clear_condition'],
			menu:[{
				text:SLANG['clear_selecttion_condition'],
				handler:this.onClearSelectionCondition,
				scope:this
			}, {
				text:SLANG['clear_sheet_condition'],
				handler:this.onClearSheetCondition,
				scope:this
			}]
		}, {
			xtype: 'scaleitem',
			scale: 'large',
			iconCls:'icon-manage-condition32',
			text:SLANG['condition_management']+'...',
			handler:this.onManageCondition,
			scope:this
		}];
		
		this.callParent();		
	},
	
	/*
	 * bind the sheet for handler use
	 */
	bindSheet : function(sheet){
		this.sheet = sheet;
	},
	
	/*
	 * highlight the cells in the selection, if it fit the condition,
	 * this condition is about greater than some value, it requires number
	 */
	onConditionGreater : function(){		
		/*
		 * get the average value
		 */
		var avg = this.sheet.getAverageOfSelection(3);
		var sheetId = this.sheet.getSheetId();
		SPOP.showConditionBool({
			/*
			 * pass the ref of sheet, it need
			 */
			sheet:this.sheet,
			title:SLANG['greater_than'],
			label:SLANG['set_style_for_greater'],
			value:avg,
			applyCallback:{
				fn:function(o){					
					var opt = {
						'type':'greater',
						'base':o.base,
						'style':o.style
					};
					this.sheet.setConditionForSelection('boolstyle', opt, sheetId);
				},
				scope:this
			}
		});			
	},
	
	/*
	 * highlight the cells in the selection, if it fit the condition,
	 * this condition is about less than some value, it requires number
	 */
	onConditionLess : function(){
		/*
		 * get the average value
		 */
		var avg = this.sheet.getAverageOfSelection(3);		
		SPOP.showConditionBool({
			/*
			 * pass the ref of sheet, it need
			 */
			sheet:this.sheet,
			title:SLANG['less_than'],
			label:SLANG['set_style_for_less'],
			value:avg,
			applyCallback:{
				fn:function(o){					
					var opt = {
						'type':'less',
						'base':o.base,
						'style':o.style
					};
					this.sheet.setConditionForSelection('boolstyle', opt);
				},
				scope:this
			}
		});			
	},
	
	/*
	 * highlight the cells in the selection, if it fit the condition,
	 * this condition is about equal some value, it requires number
	 */
	onConditionEqual : function(){
		/*
		 * get the average value
		 */
		var avg = this.sheet.getAverageOfSelection(3);		
		SPOP.showConditionBool({
			/*
			 * pass the ref of sheet, it need
			 */
			sheet:this.sheet,
			title:SLANG['equal'],
			label:SLANG['set_style_for_equal'],
			value:avg,
			applyCallback:{
				fn:function(o){					
					var opt = {
						'type':'equal',
						'base':o.base,
						'style':o.style
					};
					this.sheet.setConditionForSelection('boolstyle', opt);
				},
				scope:this
			}
		});			
	},
	
	/*
	 * highlight the cells in the selection, if it fit the condition,
	 * this condition is about between min and max value, it requires number
	 */
	onConditionBetween : function(){		
		SPOP.showConditionBetween({
			/*
			 * pass the ref of sheet, it need
			 */
			sheet:this.sheet,
			title:SLANG['between'],
			label:SLANG['set_style_for_between'],			
			applyCallback:{
				fn:function(o){					
					var opt = {
						'type':'between',
						'base':o.base,
						'style':o.style
					};
					this.sheet.setConditionForSelection('boolstyle', opt);
				},
				scope:this
			}
		});			
	},
	
	/*
	 * highlight the cells in the selection, if it fit the condition,
	 * this condition is about include some value
	 */
	onConditionInclude : function(){
		/*
		 * get the average value
		 */
		var avg = this.sheet.getAverageOfSelection(3);		
		SPOP.showConditionBool({
			/*
			 * pass the ref of sheet, it need
			 */
			sheet:this.sheet,
			title:SLANG['include'],
			label:SLANG['set_style_for_include'],
			value:avg,
			applyCallback:{
				fn:function(o){					
					var opt = {
						'type':'include',
						'base':o.base,
						'style':o.style
					};
					this.sheet.setConditionForSelection('boolstyle', opt);
				},
				scope:this
			}
		});			
	},
	
	/*
	 * highlight the cells in the selection, if it fit the condition,
	 * this condition is about the repeat value
	 */
	onConditionRepeat : function(){
		/*
		 * get the average value
		 */		
		SPOP.showConditionRepeat({
			/*
			 * pass the ref of sheet, it need
			 */
			sheet:this.sheet,
			title:SLANG['repeat_value'],
			label:SLANG['set_style_for_cell'],			
			applyCallback:{
				fn:function(o){					
					var opt = {
						'type':'repeat',
						'base':o.base,
						'style':o.style
					};
					this.sheet.setConditionForSelection('boolstyle', opt);
				},
				scope:this
			}
		});			
	},
	
	/*
	 * highlight the cells in the selection, if it fit the condition,
	 * this condition is about the repeat value
	 */
	onConditionDate : function(){
			
		SPOP.showConditionDate({
			/*
			 * pass the ref of sheet, it need
			 */
			sheet:this.sheet,
			title:SLANG['date_ocurring_at'],
			label:SLANG['set_style_date_ocurring_at'],			
			applyCallback:{
				fn:function(o){					
					var opt = {
						'type':'date',
						'base':o.base,
						'style':o.style
					};
					this.sheet.setConditionForSelection('boolstyle', opt);
				},
				scope:this
			}
		});			
	},
	
	/*
	 * highlight the cells in the selection, if it fit the condition,
	 * this condition is above the average value
	 */
	onConditionAbove : function(){
			
		SPOP.showConditionAverage({
			/*
			 * pass the ref of sheet, it need
			 */
			sheet:this.sheet,
			title:SLANG['above_average'],
			label:SLANG['set_style_above_average'],			
			applyCallback:{
				fn:function(o){					
					var opt = {
						'type':'average',	
						'base':SCONST.ABOVE_AVERAGE,
						'style':o.style
					};
					this.sheet.setConditionForSelection('boolstyle', opt);
				},
				scope:this
			}
		});			
	},
	
	/*
	 * highlight the cells in the selection, if it fit the condition,
	 * this condition is below the average value
	 */
	onConditionBelow : function(){
			
		SPOP.showConditionAverage({
			/*
			 * pass the ref of sheet, it need
			 */
			sheet:this.sheet,
			title:SLANG['below_average'],
			label:SLANG['set_style_below_average'],			
			applyCallback:{
				fn:function(o){					
					var opt = {
						'type':'average',	
						'base':SCONST.BELOW_AVERAGE,			
						'style':o.style
					};
					this.sheet.setConditionForSelection('boolstyle', opt);
				},
				scope:this
			}
		});			
	},
	
	/*
	 * highlight the cells in the selection, if it fit the condition,
	 * this condition is one of the 10 maximum values
	 */
	onConditionMax : function(){
			
		SPOP.showConditionPosition({
			/*
			 * pass the ref of sheet, it need
			 */
			sheet:this.sheet,
			title:SLANG['top_10_value'],
			label:SLANG['set_style_max_value'],	
			setAsTxt:SLANG['set_as'],
			applyCallback:{
				fn:function(o){					
					var opt = {
						'type':'max',	
						'base':o.base,			
						'style':o.style
					};
					this.sheet.setConditionForSelection('boolstyle', opt);
				},
				scope:this
			}
		});			
	},
	
	/*
	 * highlight the cells in the selection, if it fit the condition,
	 * this condition is one of the top 10% values
	 */
	onConditionTop : function(){
			
		SPOP.showConditionPosition({
			/*
			 * pass the ref of sheet, it need
			 */
			sheet:this.sheet,
			title:SLANG['top_10%'],
			label:SLANG['set_style_top_value'],	
			setAsTxt:SLANG['percent_set_as'],
			maxValue:100,
			applyCallback:{
				fn:function(o){					
					var opt = {
						'type':'top',	
						'base':o.base,			
						'style':o.style
					};
					this.sheet.setConditionForSelection('boolstyle', opt);
				},
				scope:this
			}
		});			
	},
	
	/*
	 * highlight the cells in the selection, if it fit the condition,
	 * this condition is one of the 10 minimum values
	 */
	onConditionMin : function(){
			
		SPOP.showConditionPosition({
			/*
			 * pass the ref of sheet, it need
			 */
			sheet:this.sheet,
			title:SLANG['bottom_10_value'],
			label:SLANG['set_style_min_value'],	
			setAsTxt:SLANG['set_as'],
			applyCallback:{
				fn:function(o){					
					var opt = {
						'type':'min',	
						'base':o.base,			
						'style':o.style
					};
					this.sheet.setConditionForSelection('boolstyle', opt);
				},
				scope:this
			}
		});			
	},
	
	/*
	 * highlight the cells in the selection, if it fit the condition,
	 * this condition is one of the bottom 10% values
	 */
	onConditionBottom : function(){
			
		SPOP.showConditionPosition({
			/*
			 * pass the ref of sheet, it need
			 */
			sheet:this.sheet,
			title:SLANG['bottom_10%'],
			label:SLANG['set_style_bottom_value'],	
			setAsTxt:SLANG['percent_set_as'],
			maxValue:100,
			applyCallback:{
				fn:function(o){					
					var opt = {
						'type':'bottom',	
						'base':o.base,			
						'style':o.style
					};
					this.sheet.setConditionForSelection('boolstyle', opt);
				},
				scope:this
			}
		});			
	},
	
	/*
	 * show color bar for selection range
	 */
	onColorBar : function(btn){
		var opt = {
			'pos':'red',
			'neg':'green'
		};
		if(btn){
			var color = this.colors[btn.color];
			if(color){
				opt = {
					'pos':this.colorTpl.apply(color),
					'neg':this.colorTpl.apply([255-color[0],255-color[1],255-color[2]])
				};
			}
		}
		this.sheet.setConditionForSelection('colorbar', opt);
		this.hide();
	},
	
	/*
	 * show changing background color for selection range
	 */
	onColorChange : function(btn){
		var opt = {
			'start':this.gradColors['green'],
			'end':this.gradColors['red']
		};
		if(btn){
			var start = this.gradColors[btn.start];
			var stop = this.gradColors[btn.stop];
			var end = this.gradColors[btn.end];
			if(start){
				opt = opt || {};
				opt['start'] = start;
			}
			if(stop){
				opt = opt || {};
				opt['stop'] = stop;
			}
			if(end){
				opt = opt || {};
				opt['end'] = end;
			}			
		}
		this.sheet.setConditionForSelection('colorgrad', opt);
		this.hide();
	},
	
	/*
	 * clear the condition for selection range
	 */
	onClearSelectionCondition : function(){
		this.sheet.clearConditionForSelection();
	},
	
	/*
	 * clear the condition for the whole sheet
	 */
	onClearSheetCondition : function(){
		this.sheet.clearConditonForSheet();
	},
	
	/*
	 * manage the conditions of selection range,
	 * it will pop up a window and list all conditions of selection range
	 */
	onManageCondition : function(){
		SPOP.showConditionManage({
			/*
			 * pass the ref of sheet, it need
			 */
			sheet:this.sheet			
		});
	}
});
Ext.define('EnterpriseSheet.sheet.menu.ContextMenu', {

	/* Begin Definitions */

	extend : 'Ext.menu.Menu',

	/* End Definitions */

	minWidth : 200,

	// width : 200,
    
    /*
     * use this to define your customized menu items
     */
	
    itemsInMenu: [ // {text: 'My customized item',handler: function() { alert("ok"); } },
        "freeze", "split", "-", "cut", "copy", "paste", "-", "insert", "insertCopied", "delete", "clean", "-",
        "hideRow", "showRow", "rowHeight", "hideColumn", "showColumn", "columnWidth", "-",
        "insertComment", "markRange", "insertVariable", "-", "addGroup", "cancelGroup",
        "hyperlink", "validate", "setHeaderTitle", "hideTitle", "showTitle"
    ],

	init : function(sheet) {
		if (this.sheet) {
			return;
		}
		this.sheet = sheet;

		this.mon(sheet, {
			scope : this,
			'cellcontextmenu' : this.onCellContextMenu,
			'copy2clip': this.onCopy2Clip,
			'changing': this.onSheetChange
		});
	},

	initComponent : function() {

		this.items = [];

		this.freezeItem = new Ext.menu.Item(SABOX.get('doFreeze', {
			iconCls : 'icon-freeze',
			text : SLANG['freeze_sheet'],
			/*
			 * define a toggle to change the item text, it will called by the
			 * action
			 */
			toggle : function(pressed, suspendEvent) {
				if (!pressed) {
					this.setText(SLANG['freeze_sheet']);
				} else {
					this.setText(SLANG['cancel_freeze']);
				}
			},
            sender: this
		}));

		this.splitItem = new Ext.menu.Item(SABOX.get('doSplit', {
			iconCls : 'icon-split',
			text : SLANG['split_sheet'],
			/*
			 * define a toggle to change the item text, it will called by the
			 * action
			 */
			toggle : function(pressed, suspendEvent) {
				if (!pressed) {
					this.setText(SLANG['split_sheet']);
				} else {
					this.setText(SLANG['cancel_split']);
				}
			},
            sender: this
		}));
		
		this.cutItem = new Ext.menu.Item(				
			SABOX.get('cut', {						
				iconCls: 'icon-cut',				
				text: SLANG['cut'],
	            sender: this
			})
		);
				
		this.copyItem = new Ext.menu.Item(
			SABOX.get('copy', {									
				iconCls:'icon-copy',
				text: SLANG['copy'],
	            sender: this
			})	
		);
			
		this.pasteItem = new Ext.menu.Item(
			SABOX.get('paste', {				
				iconCls:'icon-paste',
				text: SLANG['paste'],
	            sender: this
			})				
		);
			
		this.insertItem = new Ext.menu.Item(SABOX.get('insertRange', {
			iconCls: 'icon-insert-col',
			text : SLANG['insert'] + '..',
            sender: this
		}));

		this.deleteItem = new Ext.menu.Item(SABOX.get('deleteRange', {
			iconCls: 'icon-delete',
			text : SLANG['delete'] + '..',
            sender: this
		}));

		this.hideRowItem = new Ext.menu.Item(SABOX.get('hideRow', {
			text : SLANG['hide_row'],
            sender: this
		}));

		this.hideColumnItem = new Ext.menu.Item(SABOX.get('hideColumn', {
			text : SLANG['hide_column'],
            sender: this
		}));

		this.showRowItem = new Ext.menu.Item(SABOX.get('showRow', {
			iconCls: 'icon-cancel',
			text : SLANG['cancel_hide_row'],
            sender: this
		}));

		this.showColumnItem = new Ext.menu.Item(SABOX.get('showColumn', {
			iconCls: 'icon-cancel',
			text : SLANG['cancel_hide_column'],
            sender: this
		}));

		this.columnWidthItem = new Ext.menu.Item(SABOX.get('columnWidth', {
			iconCls : 'icon-column-width',
			text : SLANG['column_width'],
            sender: this
		}));

		this.rowHeightItem = new Ext.menu.Item(SABOX.get('rowHeight', {
			iconCls : 'icon-row-height',
			text : SLANG['row_height'],
            sender: this
		}));

		this.cleanItem = new Ext.menu.Item({
			iconCls : 'icon-clean-range',
			text : SLANG['clean_content'],
            sender: this
		});
		
		this.insertCopiedItem = new Ext.menu.Item(SABOX.get('insertCopied', {			
			hidden: true,
			text: SLANG['insert_copied'],
            sender: this
		}));
		
		this.insertCommentItem = new Ext.menu.Item(SABOX.get('insertComment', {
			iconCls : 'icon-insert-comment',
			text : SLANG['insert_comment'],
            sender: this
		}));

		this.markRangeItem = new Ext.menu.Item(SABOX.get('markRange', {
			//iconCls : 'icon-star',
			text : SLANG['mark_range'] + '..',
            sender: this
		}));

		this.insertVariableItem = new Ext.menu.Item(SABOX.get('insertVariable', {
			iconCls : 'icon-var-add',
			text : SLANG['add_variable'],
            sender: this
		}));

		this.hyperlinkItem = new Ext.menu.Item(SABOX.get('insertHyperlink', {
			iconCls : 'icon-link',
			text : SLANG['hyperlink'] + '...(Ctrl+K)',
            sender: this
		}));

		this.addGroupItem = new Ext.menu.Item(SABOX.get('addGroup', {
			text : SLANG['add_group'],
            sender: this
		}));

		this.cancelGroupItem = new Ext.menu.Item(SABOX.get('cancelGroup', {
			iconCls: 'icon-cancel',
			text : SLANG['cancel_group'],
            sender: this
		}));

		this.validateItem = new Ext.menu.Item(SABOX.get('validation', {
			text: SLANG['validation']+'..',
            sender: this
		}));
           
        this.setHeaderTitleItem = new Ext.menu.Item(SABOX.get('setHeaderTitle', {
            text: SLANG['set_header_title'],
            sender: this
        }));
		
        this.hideTitleItem = new Ext.menu.Item({
            text: SLANG['hide_title'],
            handler: this.hideTitle,
            scope: this
        });
        
        this.showTitleItem = new Ext.menu.Item({
            text: SLANG['show_title'],
            handler: this.showTitle,
            scope: this
        });
        
		var deafultList = this.itemsInMenu;
        for (var i=0, len = deafultList.length; i < len; i++) {
			var item = deafultList[i];
			if (Ext.isObject(item)) {
				// do extra things ...
				this.items.push(item);
			} else {
                if (item == "-"){
                    this.items.push('-');
                }else {
                    if(this[item+'Item']){
                        this.items.push(this[item+'Item']);
                    }
                }
			}
		}
		
		//if (this.items.length == 0) this.items.push("");

		this.callParent();
	},
	
	/**
	 * when copy something to clip 
	 */
	onCopy2Clip : function(range){
		this.clipRange = range;
		var coord = range.getCoord();
		var span = coord[0];
		if(0 === span[3] && 0 === span[4]){
			this.clipRangeType = 'sheet';
		}else if(0 === span[3]){
			this.clipRangeType = 'col';
		}else if(0 === span[4]){
			this.clipRangeType = 'row';
		}else{
			this.clipRangeType = 'cell';
		}
	},
	
	/**
	 * on sheet change
	 */
	onSheetChange : function(){
		delete(this.clipRange);
	},
	
	onCellContextMenu : function(row, col, region, e) {
        if(this.sheet.isReadOnly()){
            return;
        }
		var xy = e.getXY();
		var sm = region.getSelectionModel(), store = region.getStore();
		if (!sm.isSelected(row, col)) {
			sm.selectRange({
				row : row,
				col : col
			});
			sm.setFocusCell(row, col);
		}
		this.setHeaderTitleItem.hide();
		this.hideTitleItem.hide();
		this.showTitleItem.hide();
		var span = sm.selection2Span();
		if (0 == row && 0 != col) {
			this.hideRowItem.hide();
			this.showRowItem.hide();
			this.rowHeightItem.hide();
			this.hideColumnItem.show();
			this.showColumnItem.show();
			this.columnWidthItem.show();
			var f1, f2; 
			for(var i = span[2]; i <= span[4]; i++){
				var cell = store.getCell(span[0], 0, i);
				if(cell.hideTitle){
					f1 = true;
				}else{
					f2 = true;
				}				
				if(f1 && f2){
					break;
				}
			}
			if(f2){
				this.hideTitleItem.show();
			}else{
				this.hideTitleItem.hide();
			}
			if(f1){
				this.showTitleItem.show();
			}else{
				this.showTitleItem.hide();
			}
			if (0 < span[4] - span[2]) {
				this.addGroupItem.show();
			} else {
				this.addGroupItem.hide();
			}
			if (this.sheet.isSelectedGroup('col')) {
				this.cancelGroupItem.show();
			} else {
				this.cancelGroupItem.hide();
			}
			if(this.clipRange && 'col' == this.clipRangeType){
				this.insertCopiedItem.show();
			}else{
				this.insertCopiedItem.hide();
			}
		} else if (0 == col && 0 != row) {
			this.hideRowItem.show();
			this.showRowItem.show();
			this.rowHeightItem.show();
			this.hideColumnItem.hide();
			this.showColumnItem.hide();
			this.columnWidthItem.hide();
			if (0 < span[3] - span[1]) {
				this.addGroupItem.show();
			} else {
				this.addGroupItem.hide();
			}
			if (this.sheet.isSelectedGroup('row')) {
				this.cancelGroupItem.show();
			} else {
				this.cancelGroupItem.hide();
			}
			if(this.clipRange && 'row' == this.clipRangeType){
				this.insertCopiedItem.show();
			}else{
				this.insertCopiedItem.hide();
			}
		} else {
			this.hideRowItem.hide();
			this.showRowItem.hide();
			this.rowHeightItem.show();
			this.hideColumnItem.hide();
			this.showColumnItem.hide();
			this.columnWidthItem.show();
			this.addGroupItem.hide();
			this.cancelGroupItem.hide();			
			this.setHeaderTitleItem.show();
			if(this.clipRange && 'cell' == this.clipRangeType){
				this.insertCopiedItem.show();
			}else{
				this.insertCopiedItem.hide();
			}
		}
		this.splitItem.toggle(this.sheet.isSplited(), true);
		this.freezeItem.toggle(this.sheet.isFreezed(), true);
				
		this.showAt(xy);
	},
	
	hideTitle : function(){
		var sm = this.sheet.getSelectionModel();
		var mm = sm.getMinMaxPos();
		this.sheet.setColumnTitleVisible(false, mm.mincol, mm.maxcol);
	},
	
	showTitle : function(){
		var sm = this.sheet.getSelectionModel();
		var mm = sm.getMinMaxPos();
		this.sheet.setColumnTitleVisible(true, mm.mincol, mm.maxcol);
	}
});
Ext.define('EnterpriseSheet.sheet.menu.TableStyleMenu', {
	
	/* Begin Definitions */
	
	extend: 'Ext.menu.Menu',	
	
	requires: [
	   	'EnterpriseSheet.common.CONST',
	   	'EnterpriseSheet.sheet.model.TableTplModel', 
	   	'Ext.data.Store',
	   	'EnterpriseSheet.sheet.tpl.TableTemplate'
	],
	
	/* End Definitions */
	
	plain : true,
	
	scrollOffset : 18,
	
	initComponent : function(){ 
				
		var lightStore = new Ext.data.Store({		    		    
		    model: 'EnterpriseSheet.sheet.model.TableTplModel'		   
		});
		
		var mediumStore = new Ext.data.Store({		    		    
			model: 'EnterpriseSheet.sheet.model.TableTplModel'		   
		});
		
		var darkStore = new Ext.data.Store({		    		    
			model: 'EnterpriseSheet.sheet.model.TableTplModel'		   
		});
		var tpls = EnterpriseSheet.sheet.tpl.TableTemplate.prototype.tableTplData;
		for(var i = 0, len = tpls.length; i < len; i++){
			var it = tpls[i];
			if('light' == it['type']){
				var r = lightStore.createModel(it);						
				lightStore.add(r);
			}else if('medium' == it['type']){
				var r = mediumStore.createModel(it);						
				mediumStore.add(r);							
			}else{
				var r = darkStore.createModel(it);						
				darkStore.add(r);							
			}			
		}
		
		var tpl = new Ext.XTemplate(
			'<tpl for=".">',
				'<div class="thumb-wrap">',
					'<div class="thumb"><img src="{url}"></div>',
				'</div>',
			'</tpl>',
			'<div class="x-clear"></div>'
		);

		this.lightView = new Ext.view.View({
			cls: 'images-view',
	        store: lightStore,
	        tpl: tpl,
	        autoHeight: true,
	        singleSelect: true,
	        trackOver: true,
	        overItemCls:'x-view-over',
	        itemSelector:'div.thumb-wrap'
	    });				
		
		this.mediumView = new Ext.view.View({
			cls: 'images-view',
	        store: mediumStore,
	        tpl: tpl,
	        autoHeight:true,
	        singleSelect: true,
	        trackOver: true,
	        overItemCls:'x-view-over',
	        itemSelector:'div.thumb-wrap'
	    });
		
		this.darkView = new Ext.view.View({
			cls: 'images-view',
	        store: darkStore,
	        tpl: tpl,
	        autoHeight:true,
	        singleSelect: true,
	        trackOver: true,
	        overItemCls:'x-view-over',
	        itemSelector:'div.thumb-wrap'
	    });
		
		this.items = [{
			xtype:'container',
			style:'background:white;',
			width:515,
			height:450,
			autoScroll:true,
			items:[{
				xtype:'component',
				cls:'tpl-title',
				html:SLANG['light_color']
			}, this.lightView, {
				xtype:'component',
				cls:'tpl-title',
				html:SLANG['dark_color']
			}, this.mediumView, {
				xtype:'component',
				cls:'tpl-title',
				html:SLANG['deep_dark_color']
			}, this.darkView],
			listeners: {
				'afterrender' : function(ct){
					var el = ct.getEl(); 
					var me = this;
					me.mon(el, 'mousewheel', function(e){
						var delta = e.getWheelDelta();
						el.dom.scrollTop += -delta*me.scrollOffset;
					})
				},
				scope: this
			}
		}, {
			iconCls:'icon-customer-tpl',
			text:SLANG['new_customer_tpl']
		}, '-', {			
			text:SLANG['clear_table_tpl'],
			handler : this.clearTableTpl,
			scope: this
		}];
		
		this.callParent();		
		
		this.mon(this.lightView, 'itemclick', this._onClickItem, this);
		this.mon(this.mediumView, 'itemclick', this._onClickItem, this);
		this.mon(this.darkView, 'itemclick', this._onClickItem, this);
	},
	
	/*
	 * bind the sheet for handler use
	 */
	bindSheet : function(sheet){
		this.sheet = sheet;		
	},
	
	/*
	 * set tpl for selection in sheet
	 */
	setTplForSelection : function(tpl){
		var sm = this.sheet.getSelectionModel();
		var span = sm.selection2Span();
		var tableTpl = this.sheet.getTableTpl();
		if(tableTpl){
			tableTpl.setTplForSpan(span, tpl);					
		}		
	},
	
	/*
	 * clear the table tpl for selection
	 */
	clearTableTpl : function(){
		var sm = this.sheet.getSelectionModel();
		var span = sm.selection2Span();
		var tableTpl = this.sheet.getTableTpl();
		if(tableTpl){
			tableTpl.clearTplForSpan(span);
		}		
	},
	
	_onClickItem : function(dv, rec){		
		var tpl = rec.data.tpl;		
		if(tpl){
			this.setTplForSelection({'id': rec.data.id});
		}
		this.hide();	
	}
});
Ext.define('EnterpriseSheet.sheet.menu.TextFormatMenu', {
	
	/* Begin Definitions */
	
	extend: 'EnterpriseSheet.common.menu.ScaleMenu',		
	
	/* End Definitions */
	
	scale : 'large',
	
	initComponent : function(){
		
		this.defaults = {
			scope: this,
			handler: this.onClickFormatItem
		};
		
		this.items = [{							
			xtype: 'scaleitem',
			scale: 'large',
			iconCls:'icon-regular32',
			name: 'regular',
			text:SLANG['regular']
		}, {							
			xtype: 'scaleitem',
			scale: 'large',
			iconCls:'icon-number32',
			name: SCONST.FORMAT_NUMBER,
			text: SLANG['number']
		}, {							
			xtype: 'scaleitem',
			scale: 'large',
			iconCls:'icon-money32',
			name: SCONST.FORMAT_CURRENCY,
			text: SLANG['currency']
		}, {							
			xtype: 'scaleitem',
			scale: 'large',
			iconCls:'icon-comma32',
			name: SCONST.FORMAT_COMMA,
			text:SLANG['comma']
		}, {							
			xtype: 'scaleitem',
			scale: 'large',
			iconCls:'icon-date32',
			name: 'date',
			text:SLANG['date']
		}, {							
			xtype: 'scaleitem',
			scale: 'large',
			iconCls:'icon-time32',
			name: 'time',
			text:SLANG['time']
		}, {							
			xtype: 'scaleitem',
			scale: 'large',
			iconCls:'icon-percent32',
			name: SCONST.FORMAT_PERCENT,
			text: SLANG['percentage']
		}, {							
			xtype: 'scaleitem',
			scale: 'large',
			iconCls:'icon-fraction32',
			name: SCONST.FORMAT_FRACTION,
			text:SLANG['fraction']
		}, {							
			xtype: 'scaleitem',
			scale: 'large',
			iconCls:'icon-science32',
			name: SCONST.FORMAT_SCIENCE,
			text:SLANG['science']
		}, {							
			xtype: 'scaleitem',
			scale: 'large',
			iconCls:'icon-text32',
			name: 'text',
			text:SLANG['text']
		}];
		
		this.callParent(arguments);
	},
	
	/*
     * preview the different formats for focus data
     */
    previewTextFormat : function(data){
    	if(data){
    		this.items.each(function(it){
    			var preview = SFORMAT.transferFormat({data:data}, it.name).data;
    			it.setText(SLANG[it.name]+'<br><span style="padding-left:20px;">'+preview+'</span>');
    		}, this);
    	}else{
    		this.items.each(function(it){    			
    			it.setText(SLANG[it.name]);
    		}, this);
    	}
    },
    
    /*
	 * bind the sheet for handler use
	 */
	bindSheet : function(sheet){
		this.sheet = sheet;
	},
    
    /*
     * handler for select, it will change the text format of selection
     */
    selectTextFormat : function(format){    	
    	var sheet = this.sheet;
    	if(sheet){  
    		if (format == SCONST.FORMAT_PERCENT) sheet.setPercentFormatForSelection(SCONST.DEFAULT_PERCENT_FORMAT);
    		else sheet.setTextFormatForSelection(format);
    	}
    },
    
    onClickFormatItem : function(item){
    	this.selectTextFormat(item.name);
    }
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.floating.Floating', {
	
	/* Begin Definitions */
		
	extend : 'Ext.util.Observable',
	
	requires: [
	    'EnterpriseSheet.common.Common',
	    'Ext.ComponentManager',
	    'Ext.container.Container',
	    //'Ext.draw.Component',
	    'Ext.util.ComponentDragger',
	    'Ext.resizer.Resizer',
	    'Ext.ComponentManager'
	],
	
	/* End Definitions */
	
	defaultType : 'container',
	
	ddGroup : 'sf-group',				
	
	constructor : function(config){
		config = Ext.apply({}, config);
		config.cls = config.cls || '';
		config.cls = 'ss-floating '+config.cls;
		/*
		 * add z-index
		 */
		config.style = config.style || '';
		config.style = 'z-index:'+SCONST['FLOAT_Z_INDEX']+';'+config.style;
		
		if(false == SCOM.typeOf(config.ddConfig)){
			config.ddConfig = {
				scroll: false,
				moveOnly: true
			};
		}
		if(false == SCOM.typeOf(config.resizeConfig)){
			config.resizeConfig = {
				handles: 'all',
				pinned: true				
			};
		}		
		
		if((!config.xtype && 'drawcomponent' == this.defaultType)
			|| ('drawcomponent' == config.xtype)){
			/*
			 * special handle for draw component
			 */
			delete(config.xtype);
			//this.comp = new Ext.draw.Component(config);
		}else{
			this.comp = new Ext.ComponentMgr.create(config, this.defaultType);
		}		
		
		this.callParent();			
				
		
		this.comp.on({
			scope:this,
			'afterrender':this._afterRender
		});
	},
	
	_afterRender : function(comp){
		
		if(comp.ddConfig){
			this.initDD();
		}
		
		if(comp.resizeConfig){
			this.initResize();
		}
		
		var el = comp.getEl();
		var evts = {
			'mousedown': 'elmousedown',
			'mouseup': 'elmouseup',
			'mousemove': 'elmousemove',
			'click': 'elclick',
			'contextmenu': 'elcontextmenu',
			'dblclick': 'eldblclick'
			
		}
		var me = this;
		for(var p in evts){
			var evt = evts[p];
			this.mon(el, p, function(e){
				me.fireEvent(this.evt, e, me);
			}, {evt: evt});
		}		
		/*
		 * create a focus el for key down event
		 */
		if(Ext.isIE){
			this.focusEl = Ext.core.DomHelper.append(Ext.getBody(), '<a class="ss-focus" href="#"></a>', true);
		}else{
			this.focusEl = Ext.core.DomHelper.append(Ext.getBody(), '<input class="ss-focus" />', true);
		}		
		if(this.comp.withTool){
			this.initTool();
		}
		evts = {
			'focus': 'focus',
			'blur': 'blur',
			'keydown': 'keydown',
			'keypress': 'keypress',
			'keyup': 'keyup'
		};
		for(var p in evts){
			var evt = evts[p];
			this.mon(this.focusEl, p, function(e){
				me.fireEvent(this.evt, e, me);
			}, {evt: evt});
		}			
		
		this.mon(el, 'mousedown', function(){
			this.focusEl.focus();
		}, this);
		
		this.mon(this.focusEl, {
			scope: this,
			'focus': function(e){		
				if(el){
					el.addCls('ss-floating-top');
				}				
			},
			'blur': function(e){
				if(el){
					el.removeCls('ss-floating-top');
				}
			}
		})
	},
	
	/*
	 * get the component in this floating
	 */
	getComp : function(){
		return this.comp;
	},	
	
	/*
	 * init a small toolbar at the top-right corner
	 */
	initTool : function(){
		var el = this.comp.getEl();
		this.toolEl = Ext.core.DomHelper.append(el, ['<div class="ss-floor-tool">',
		    '<div class="ss-floor-setting"></div>',
		'</div>'].join(''), true);
		this.mon(this.toolEl, {
			scope: this,
			'click': function(e){
				var target = e.getTarget();
				var tgEl = Ext.get(target);
				if(tgEl.hasCls('ss-floor-setting')){					
					this.fireEvent('showfloorsetting', tgEl, this);
				}
			}
		});
	},
	
	/*
	 * init DD for this component
	 */
	initDD : function(){		
		var comp = this.comp;
		var pnode = Ext.get(comp.el.dom.parentNode);
		var me = this,
        ddConfig = {
			el: comp.getDragEl(),
            constrainTo: pnode,
            constrain: true            
        };
	    
	    this.dd = Ext.create('Ext.util.ComponentDragger', comp, ddConfig);	    	   
	    
	    /*
	     * backward for 4.0.7
	     */
	    if(Ext.getVersion('core').isLessThan('4.0.9')){	    	
	    	this.dd.onStart = function(e){
		    	var me = this,
	            comp = me.comp;

		        // Cache the start [X, Y] array
		        this.startPosition = comp.getPosition();
		        /************************
	    		 * adjust the position
	    		 ***********************/    		                 
	    		this.startPosition[0] -= pnode.getLeft();
	    		this.startPosition[1] -= pnode.getTop();
		        // If client Component has a ghost method to show a lightweight version of itself
		        // then use that as a drag proxy unless configured to liveDrag.
		        if (comp.ghost && !comp.liveDrag) {
		             me.proxy = comp.ghost();
		             me.dragTarget = me.proxy.header.el;
		        }
		
		        // Set the constrainTo Region before we start dragging.
		        if (me.constrain || me.constrainDelegate) {
		            me.constrainTo = me.calculateConstrainRegion();
		        }
		    };
	    }	    
	    this.dd.on({
	    	scope: this,
	    	'mousedown' : function(dd, e){
	    		var tgEl = Ext.get(e.getTarget());
	    		/*
				 * for chart element, avoid the exception
				 */
				if(Ext.supports.ClassList && !tgEl.dom.classList){
					return;
				}
				if(tgEl.hasCls('x-resizable-handle')){
					return false;
				}
	    	},	    	
	    	'drag' : function(dd, e){
	    		me.fireEvent('moving', me, e);
	    	},
	    	'dragend' : function(dd, e){
	    		me.fireEvent('moved', me, e);
	    	}
	    });	    
	},
	
	/*
	 * init resize for this component
	 */
	initResize : function(){		
		var comp = this.comp;
		var el = comp.getEl();			
		this.resizer = new Ext.resizer.Resizer(el.id, comp.resizeConfig);
		this.resizer.on({
			scope:this,
			'resize':function(resizer, width, height, e){									
				comp.setSize(width, height);
				this.fireEvent('resizing', this, width, height, e);
				this.fireEvent('resized', this, width, height, e);
			},
			'resizedrag': function(resizer, width, height, e){		
				this.fireEvent('resizing', this, width, height, e);
			}
		});
	},
	
	/*
	 * get the position of this floating in this region
	 */
	getXYInRegion : function(){
		var comp = this.comp;
		var el = comp.getEl();
		if(el){
			var pel = Ext.get(el.dom.parentNode);
			var x = el.getLeft()-pel.getLeft(), y = el.getTop()-pel.getTop();
			return [x, y];
		}
	},
	
	setXYInRegion : function(xy){
		var comp = this.comp;
		var el = comp.getEl();
		if(el){
			el.setLeft(xy[0]);
			el.setTop(xy[1]);
		}
	},
	
	/*
	 * show and hide
	 */
	show : function(){
		this.comp.show();
	},
	
	hide : function(){
		this.comp.hide();
	}
});
Ext.define('EnterpriseSheet.sheet.floating.Floor', {
	
	/* Begin Definitions */
		
	extend : 'Ext.util.Observable',
	
	requires : [
	    'Ext.menu.Menu', 
	    'EnterpriseSheet.sheet.floating.Floating'
	],
	
	/* End Definitions */
	
	constructor : function(config, suspendPulling){
        config = config || {};
        var sheetId = config.sheetId;
        delete(config.sheetId);
		Ext.apply(this, config);
		
		/*
		 * process floor id
		 */
		if(config.floorId){
			this.id = config.floorId;
			delete(config.floorId);
		}else if(config.floatingConfig && !SCOM.nullOrUndefined(config.floatingConfig.floorId)) {
			this.id = config.floatingConfig.floorId;
			delete(config.floatingConfig.floorId);				
		}
		if(config.floatingConfig){
			if(config.localKit){
				config.floatingConfig.style = config.floatingConfig.style || '';
				config.floatingConfig.style = 'cursor:pointer;'+config.floatingConfig.style;
			}
			delete(config.floatingConfig.id);
		}		
		
		/*
		 * create the id if need
		 */
		this.getId();
		/*
		 * create contextmenu
		 */
		this.initContextMenu();
		
		this.callParent();		
		
		this.createFloating();
		
		if(this.sheet){
			/*
			 * register to the sheet
			 */
			this.sheet.registerFloor(this, suspendPulling, sheetId);
		}
		
		this.on({
			scope:this,
			'moving':function(floating, e){
				if(this.sheet && (this.sheet.isFreezed() || this.sheet.isSplited())){
					this.sysnFloatingPos(floating);
				}					
			},
			'moved': function(){
				/*
				 * fire event for floor change
				 */
				this.sheet.fireEvent('floormove', this);
			},
			'resizing':function(floating, width, height, e){	
				if(this.sheet && (this.sheet.isFreezed() || this.sheet.isSplited())){
					this.sysnFloatingPos(floating);
					this.sysnFloatingSize(floating);
				}				
			},
			'resized': function(){
				/*
				 * fire event for floor change
				 */
				this.sheet.fireEvent('floorresize', this);
			}
		});
		
		if(this.sheet){
			this.mon(this.sheet, {
				scope: this,
				'freezechange': this.onSheetLayoutChange,
				'splitchange': this.onSheetLayoutChange,
                'changereadonly': this.onChangeReadOnly
			})			
		}
		
		/*
		 * add listeners for all comps
		 */
		this.addListenerForFloatings('elcontextmenu', this.onContextMenu, this);
		this.addListenerForFloatings('focus', this.onFocus, this);		
		this.addListenerForFloatings('keydown', this.onKeyDown, this);
		this.addListenerForFloatings('blur', this.onBlur, this);
	},
	
	/*
	 * create the context menu
	 */
	initContextMenu : function(){
		this.contextMenu = new Ext.menu.Menu({
			items: [{
				text: SLANG['delete'],
				handler: function(){
					this.destroy();
				},
				scope: this
			}]
		});
	},
	
	/*
	 * add some keydown action
	 */
	onKeyDown : function(e){
		e.stopEvent();
		var key = e.getKey();
		if(46 == key || 8 == key){//delete
			this.destroy();
		}
	},
	
	/*
	 * show context menu
	 */
	onContextMenu : function(e){
        if(this.sheet && this.sheet.isReadOnly()){
           return;
        }
		if(this.contextMenu){
			this.contextMenu.showAt(e.getXY());
		}		
	},
	
	/*
	 * focus on the floating
	 */
	onFocus : function(e){
        if(this.sheet && this.sheet.isReadOnly()){
            return;
        }
		for(var p in this.lookup){
			var comp = this.lookup[p].comp;
			var el = comp.getEl();
			if(el){
				el.addCls('x-resizable-pinned');
				el.setStyle('z-index', SCONST['ACTIVE_FLOAT_Z_INDEX']);
			}
		}					
		this.pinned = true;		
	},
	
	/*
	 * when the focus blur, we will remove the resizable-pinned
	 */
	onBlur : function(){
		if(this.pinned){
			var rm = this.sheet.getReferenceModel();
			rm.disableSelect();
			for(var p in this.lookup){
				var comp = this.lookup[p].comp;
				var el = comp.getEl();
				if(el){
					el.removeCls('x-resizable-pinned');
					el.setStyle('z-index', SCONST['FLOAT_Z_INDEX']);
				}
			}
			delete(this.pinned);			
		}
	},
	
	/*
	 * sync the floating from different region when the sheet freeze change or split change
	 */
	onSheetLayoutChange : function(){
		if(this.sheet.isFreezed() || this.sheet.isSplited()){
			var floating = this.lookup['cregion'];
			for(var p in this.lookup){
				var ft = this.lookup[p];
				var region = this.sheet[p];
				if(region && region.isVisible() && !ft.comp.rendered){
					region.render2RegionBody(ft.comp);
				}else if(Ext.isFunction(ft.comp.doLayout)){
					ft.comp.doLayout();
				}else if(Ext.isFunction(ft.comp.updateLayout)){
					ft.comp.updateLayout();
				}
			}
			this.sysnFloatingPos(floating);
			this.sysnFloatingSize(floating, true);
		}
	},
	
    isLocalKit : function(){
        return this.localKit;
    },
	
	/*
	 * get the id of this floor
	 */
	getId : function(){
		/*
		 * create a random Id if don't have
		 */
		if(SCOM.nullOrUndefined(this.id)){
			this.id = Ext.id()+'-'+SCOM.genTimeStamp();			
		}		
		if(SCOM.nullOrUndefined(this.name)){
			this.name = this.id;
			if(this.sheet){
				this.id += '-'+this.sheet.getSheetId();
			}
		}
		return this.id;
	},
	
	getName : function(){
		return this.name;
	},
	
	/*
	 * create floating component in different regions of the sheet
	 */
	createFloating : function(){		
		if(this.sheet){
			this.lookup = {};			
			this.sheet.walkFloorRegions(function(region, name){
				/*
				 * clone the floating config, avoid ref conflict
				 */
				var config = SCOM.copy(this.floatingConfig);
				var floating = new EnterpriseSheet.sheet.floating.Floating(config);
				/*
				 * render the floating in region
				 */
				if(region.isVisible()){
					region.render2RegionBody(floating.comp);
				}				
				/*
				 * relay events from floatings
				 */
				this.relayEvents(floating, ['moving', 'resizing', 'moved', 'resized']);
				/*
				 * save the comp to lookup
				 */
				this.lookup[name] = floating;
			}, this);
            this.onChangeReadOnly(this.sheet.isReadOnly(), this.sheet);
		}
	},
	
	/*
	 * add listener for all components of this floor
	 */
	addListenerForFloatings : function(){
		for(var p in this.lookup){
			var floating = this.lookup[p];
			floating.on.apply(floating, arguments);
		}
	},
	
	/*
	 * when one floating is moving, need sysn all floatings' position
	 */
	sysnFloatingPos : function(floating){				
		var xy = floating.getXYInRegion();
		for(var p in this.lookup){
			var f = this.lookup[p];
			if(f != floating){				
				f.setXYInRegion(xy);
			}
		}		
	},
	
	/*
	 * when one floating is resizing, need sysn all floatings' size
	 */
	sysnFloatingSize : function(floating){		
		var size = floating.comp.getSize();		
		for(var p in this.lookup){
			var f = this.lookup[p];
			if(f != floating){
				f.comp.setSize(size.width, size.height);
			}
		}		
	},
	
	/*
	 * set the xy of all floatings
	 */
	setXY : function(xy){
		for(var p in this.lookup){
			var f = this.lookup[p];
			f.setXYInRegion(xy);
		}
	},
		
	/*
	 * show and hide
	 */
	show : function(){
		for(var p in this.lookup){
			var f = this.lookup[p];
			f.show();
		}
	},
	
	hide : function(){
		for(var p in this.lookup){
			var f = this.lookup[p];
			f.hide();
		}
	},
	
	/*
	 * get position and size
	 */
	getPositionSize : function(){
		for(var p in this.lookup){
			var comp = this.lookup[p].comp;	
			var el = comp.getEl();
			if(el){
				var pEl = el.parent();
				var left = el.getLeft()-pEl.getLeft();
				var top = el.getTop()-pEl.getTop();
				return {
					x: left,
					y: top,
					width: el.getWidth(),
					height: el.getHeight()
				};
			}			
		}
	},
	
	/*
	 * add cls for floating comp
	 */
	addCls : function(cls){
		for(var p in this.lookup){
			var comp = this.lookup[p].comp;	
			var el = comp.getEl();
			if(el){
				el.addCls(cls);
			}else{
				comp.cls = cls;
			}			
		}
	},
           
    setIconCls : function(cls){
        for(var p in this.lookup){
            var comp = this.lookup[p].comp;
            var el = comp.getEl();
            if(el){
                comp.setIconCls(cls);
            }else{
                comp.iconCls = cls;
            }
        }
    },
	
	removeCls : function(cls){
		for(var p in this.lookup){
			var comp = this.lookup[p].comp;	
			var el = comp.getEl();
			if(el){
				el.removeCls(cls);
			}else if(comp.cls){
				comp.cls = comp.cls.replace(cls, '');
			}			
		}
	},
	
	/**
	 * loop each floatings
	 */
	eachFloating : function(callback, scope){
		for(var p in this.lookup){
			if(this.lookup.hasOwnProperty(p)){
				var comp = this.lookup[p].comp;	
				callback.call(scope, comp);
			}
		}
	},
	
	/*
	 * destroy this floor and comp 
	 */
	destroy : function(suspendUpdate, suspendEvent){
		/*
		 * unregister first
		 */
		this.sheet.unregisterFloor(this, suspendUpdate);
		for(var p in this.lookup){
			var f = this.lookup[p];
			var el = f.comp.getEl();
			if(el){
				el.clearListeners();				
			}			
			f.comp.destroy();			
			if(f.focusEl){
				Ext.removeNode(f.focusEl.dom);
			}
		}
		this.clearListeners();
		if(!suspendEvent){
			/*
			 * fire delete chart event
			 */
			this.sheet.fireEvent('deletefloor', this, this.sheet);
		}
	},
           
    onChangeReadOnly : function(readOnly, sheet){
        if(readOnly){
            for(var p in this.lookup){
                var f = this.lookup[p];
                if(f.dd){
                    f.dd.disable();
                    f.resizer.disable();
                }
            }
        }else{
            for(var p in this.lookup){
                var f = this.lookup[p];
                if(f.dd){
                    f.dd.enable();
                    f.resizer.enable();
                }
            }
        }
    }
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 *
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 *
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.range.Range', {
	
	/* Begin Definitions */
	requires: ['EnterpriseSheet.sheet.calculate.Condition'],	
	
	/* End Definitions */
	
	constructor : function(config){
		Ext.apply(this, config);
		var sheetId = this.sheet.getSheetId();
		var type = SCOM.typeOf(this.coord);
		if('string' == type){
			this.coord = this.parseCoorString(this.coord);
			var store = this.sheet.getStore();		
			for(var i = 0, len = this.coord.length; i < len; i++){
				if('string' == SCOM.typeOf(this.coord[i][0])){
					/*
					 * change the sheet name to sheet id
					 */
					this.coord[i][0] = store.getSheetIdByName(this.coord[i][0]);
				}
			}
		}else if('array' == type){
			var len = this.coord.length;
			if(0 < len){
				if('array' == SCOM.typeOf(this.coord[0])){
					var coord = [];
					for(var i = 0; i < len; i++){
						coord.push(EnterpriseSheet.sheet.calculate.Coordinate.prototype.normalizeCoord(this.coord[i], sheetId));
					}
					this.coord = coord;
				}else{
					this.coord = [EnterpriseSheet.sheet.calculate.Coordinate.prototype.normalizeCoord(this.coord, sheetId)];
				}
			}
		}else if('object' == type){
			this.coord = [
			    [this.sheet.getSheetId(), this.coord.minrow, this.coord.mincol, this.coord.maxrow, this.coord.maxcol]
			];
		}	
		this.callParent();		
	},
	
	parseCoorString : function(coordStr){
		try{
			var coord = EnterpriseSheet.sheet.calculate.Coordinate.prototype.string2Coord(coordStr);
			var arr = [];
			for(var i = 0, len = coord.length; i < len; i++){
				arr.push(coord[i].span);
			}
			this.coord = arr;
		}catch(e){
			this.coord = null;
		}
	}
	/*
	 * add methods in prototype
	 */
}, function(){
	Ext.apply(EnterpriseSheet.sheet.range.Range.prototype, {	
		/*
		 * set condition for assigned range
		 * @param {object} ranges: the ranges to set the condition 
		 * @param {string} condition: the condition name
		 * @param {object} option: the option object for this condition		 
		 * @param {boolean} suspendRefresh: true to not refresh the condition cells
		 */
		setCondition : function(condition, option, suspendRefresh, suspendEvent, cdtId){
			var coord = this.getCoord();
			/*
			 * if the range is not in single sheet then can not set condition
			 */
			if(!this.isInSingleSheet()){
				Ext.Msg.alert(SLANG['hint'], SLANG['set_condition_only_single_sheet']);
				return;
			}
			var ss = this.sheet;
			var store = ss.getStore();
            
			/*
			 * get the sheet Id
			 */
			var sheetId = this.coord[0][0];
			if(SCOM.nullOrUndefined(sheetId) || '' == sheetId){
				sheetId = ss.getSheetId();
			}
			/*
			 * fire before range change event, so listener can cancel the change by return false
			 */
			if(suspendEvent || false !== ss.fireEvent('beforeconditionchange', this, ss)){
				/*
				 * use a timestamp as a id
				 */
				var id = cdtId || Ext.id()+'-'+SCOM.genTimeStamp();
				var oldCdts = {};
				oldCdts[id] = {
					sheet: sheetId,
					name: id
				};
                var cdtCoord = ss.getRelatedCdtCoord(coord);
                
				if(!suspendEvent){
					ss.fireEvent('prepareconditionchange', this, ss, oldCdts, cdtCoord);
				}		
				
				var args = {						
					'name':condition,
					'rng': this.getCoordInAbsolute()						
				}; 
				
				if(option){
					args.opt = option;
				}	
				var argstr = Ext.encode(args);
				args.id = id;
				var found;
				store.eachFloating(function(it){
					if(it.sheet == sheetId && it.json == argstr){
						found = it;
						return false;
					}
				});
				/*
				 * set floating if not existed
				 */
				if(!found){					
					store.setFloatingItem(sheetId, id, 'cdt', Ext.encode(args));
					found = {name: id};
				}
				
				if(!suspendRefresh){		
					var cdtCoord = ss.processRelatedCdt(this.coord);
					
					ss.refreshRange(cdtCoord.concat(this.coord));	
				}
				if(!suspendEvent){
					ss.fireEvent('conditionchange', this, ss, oldCdts, cdtCoord);
				}
				return id;
			}
		},
		
		/*
		 * clear the condition for the cells in the selection range
		 * @param {int} sheetId: the sheetId of the sheet we want to set the condition for
		 */
		clearCondition : function(suspendRefresh, suspendEvent){	
			var ss = this.sheet;
			
			var coord = this.getCoord();
			/*
			 * fire event
			 */
			if(false !== ss.fireEvent('beforeconditionchange', this, ss)){
				var oldCdts = ss.getCdtsFromCoord(coord);
                var cdtCoord = ss.getRelatedCdtCoord(coord);
                
				ss.fireEvent('prepareconditionchange', this, ss, oldCdts, cdtCoord);

				ss.splitCdt(coord, oldCdts);
                ss.clearCdtValueForCoord(cdtCoord);
	    		if(!suspendRefresh){
	    			/*
		    		 * refresh the range
		    		 */
		    		ss.refreshRange(cdtCoord.concat(coord));
	    		}
	    		
	    		ss.fireEvent('conditionchange', this, ss, oldCdts, cdtCoord);
			}
		},
				
		/*
		 * set the property or remove property for the selection range, and refresh the UI to show
		 * @param {object} modified: the property set which need modified for selection range
		 * @param {array} deleted: the array of propertys which need removed from selection range
		 * @param {boolean} suspendRefresh: a flag to suspend the refresh action for ss
		 */
		setProperty : function(modified, deleted, suspendRefresh, suspendEvent, walkThrough){
			var ss = this.sheet;		
			var store = ss.getStore();
			var changedHeights = {}, cdtCoord;
			if((modified && modified['dcfg']) || (deleted && -1 !== deleted.indexOf('dcfg'))){
				cdtCoord = [];
				for(var i = 0, len = this.coord.length; i < len; i++){
					var span = this.coord[i];
					for(var j = span[2]; j <= span[4]; j++){
						cdtCoord.push([span[0], span[1], j, span[3], j]);
					}
				}
			}
			var deleteDsdFlag;
			if((deleted && -1 !== deleted.indexOf('dsd')) || (modified && ('' === modified['dsd'] || false === modified['dsd']))){
				deleteDsdFlag = true;
			}
			/*
			 * fire before range change event, so listener can cancel the change by return false
			 */
			if(suspendEvent || false !== ss.fireEvent('beforerangechange', this, modified, deleted, ss)){
				if(!suspendEvent){
					ss.fireEvent('preparerangechange', this, modified, deleted, changedHeights, cdtCoord, ss);
				}
                if(walkThrough){
                    store.walkRange(this.coord, function(rec){
                    	var pro = store.getCellProperty(rec.data.sheet, rec.data.row, rec.data.col);
                    	if(deleteDsdFlag || !store.isDisabledForMe(pro.dsd)){
                    		store.setCell(rec.data.sheet, rec.data.row, rec.data.col, modified, deleted, true);
                    	}
                    }, this);
                }else{
                    for(var i = 0, len = this.coord.length; i < len; i++){
                        var span = this.coord[i];
                        var sheetId = span[0];
                        if(0 == span[3] && 0 == span[4]){
                        	var cell = store.getCell(sheetId, 0, 0);
                        	if(deleteDsdFlag || !store.isDisabledForMe(cell.dsd)){
                        		store.setWhole(sheetId, modified, deleted, true);
                        	}
                        }else if(0 == span[3]){
                            for(var col = span[2]; col <= span[4]; col++){
                            	var cell = store.getCell(sheetId, 0, col);
                            	if(deleteDsdFlag || !store.isDisabledForMe(cell.dsd)){
                            		store.setColumn(sheetId, col, modified, deleted, true, true);
                            	}
                            }
                        }else if(0 == span[4]){
                            for(var row = span[1]; row <= span[3]; row++){
                            	var cell = store.getCell(sheetId, row, 0);
                            	if(deleteDsdFlag || !store.isDisabledForMe(cell.dsd)){
                            		store.setRow(sheetId, row, modified, deleted, true, true);
                            	}
                            }
                        }else{
                            for(var row = span[1]; row <= span[3]; row++){
                                for(var col = span[2]; col <= span[4]; col++){
                                	var cell = store.getCellProperty(sheetId, row, col);
                                	if(deleteDsdFlag || !store.isDisabledForMe(cell.dsd)){
                                		store.setCell(sheetId, row, col, modified, deleted, true);
                                	}
                                }
                            }
                        }
                    }
                }
				/*
				 * check autoheight, if we change fz or ws, it could affect the autoheight of row
				 */
				Ext.apply(changedHeights, this.checkAutoHeightForChange(modified, deleted, suspendRefresh, true));
				
				if(!suspendRefresh){
					this.refresh();					
				}			
				if(!suspendEvent){					
					ss.fireEvent('rangechange', this, modified, deleted, ss);
				}				
			}		
		},
		
		getRelatedRowsForAutoHeight : function(modified, deleted, checkNoWrap){
			return this.sheet.getRelatedRowsForAutoHeight(this.coord, modified, deleted, checkNoWrap);
		},
		
		/**
		 * check the autoHeight when some special properties are changed
		 */
		checkAutoHeightForChange : function(modified, deleted, suspendRefresh, checkNoWrap){
			var store = this.sheet.getStore();
			var relatedRows = this.getRelatedRowsForAutoHeight(modified, deleted, checkNoWrap);
			return this.sheet.checkAutoHeightForRows(relatedRows, suspendRefresh);
		},
		
		/*
		 * set the itchk to true for the passed cell and set other cells in this range to false, and refresh the UI to show
		 * @param {int} osheetId: the sheet id of the cell which will be set itchk to true
		 * @param {int} orow: the row index of the cell which will be set itchk to true
		 * @param {int} ocol: the column index of the cell which will be set itchk to true
		 * @param {boolean} suspendRefresh: a flag to suspend the refresh action for ss
		 * @param {boolean} suspendEvent: a flag to suspend the rangechange event
		 */
		toggleItemCheck : function(osheetId, orow, ocol, suspendRefresh, suspendEvent){				
			var ss = this.sheet;		
			var modified = {'itchk': false}, deleted = null;
			/*
			 * fire before range change event, so listener can cancel the change by return false
			 */
			if(suspendEvent || false !== ss.fireEvent('beforerangechange', this, modified, deleted, ss)){
				if(!suspendEvent){
					ss.fireEvent('preparerangechange', this, modified, deleted, ss);
				}
				var store = ss.getStore();
				var cell = ss.getCellProperty(osheetId, orow, ocol);
				var itemName = cell.itn;
				if(itemName){
					for(var i = 0, len = this.coord.length; i < len; i++){
						var span = this.coord[i];
						var sheetId = span[0];
						if(0 == span[3] && 0 == span[4]){
							var o = ss.getCellProperty(sheetId, 0, 0);
							if(itemName == o.itn){
								store.setWhole(sheetId, modified, deleted, true);
							}
						}else if(0 == span[3]){
							for(var col = span[2]; col <= span[4]; col++){
								var o = ss.getCellProperty(sheetId, 0, col);
								if(itemName == o.itn){
									store.setColumn(sheetId, col, modified, deleted, true, true);
								}
							}											
						}else if(0 == span[4]){
							for(var row = span[1]; row <= span[3]; row++){
								var o = ss.getCellProperty(sheetId, row, 0);
								if(itemName == o.itn){
									store.setRow(sheetId, row, modified, deleted, true, true);
								}
							}				
						}else{
							for(var row = span[1]; row <= span[3]; row++){
								for(var col = span[2]; col <= span[4]; col++){
									var o = ss.getCellProperty(sheetId, row, col);
									if(itemName == o.itn){
										store.setCell(sheetId, row, col, modified, deleted, true);
									}
								}
							}
						}
					}
				}
				store.setCell(osheetId, orow, ocol, {'itchk': true}, null, true);
					
				if(!suspendRefresh){
					this.refresh();					
				}			
				if(!suspendEvent){					
					ss.fireEvent('rangechange', this, modified, deleted, ss);
				}				
			}		
		},
		
		/*
	     * move decimal point position for the data in selection
	     * @param {int} offset: the decimal digital number
	     */
	    moveDecimalPoint : function(digital, suspendRefresh, suspendEvent){
	    	this.setProperty({'dpd': digital}, null, suspendRefresh, suspendEvent);	    	    
	    },	
		
		/*
		 * walk for the selection range, and refresh the UI to show
		 * @param {object} modified: the property set which need modified for selection range
		 * @param {array} deleted: the array of propertys which need removed from selection range
		 * @param {boolean} suspendRefresh: a flag to suspend the refresh action for ss
		 */
		walk : function(fn, scope, suspendRefresh, suspendEvent){
			var ss = this.sheet;			
			/*
			 * fire before range change event, so listener can cancel the change by return false
			 */
			if(suspendEvent || false !== ss.fireEvent('beforerangechange', this, null, null, ss)){
				if(!suspendEvent){
					ss.fireEvent('preparerangechange', this, null, null, ss);
				}
				var store = ss.getStore();
				store.walkRange(this.coord, function(rd){
					if(fn){
						fn.call(scope, rd);
					}
				}, this);	
				if(!suspendRefresh){
					this.refresh();					
				}			
				if(!suspendEvent){
					ss.fireEvent('rangechange', this, null, null, ss);
				}				
			}		
		},
		
		/*
		 * this function provide a interface to set a border for the selection range
		 * @param {string} dir: the direction of the border, should be one of ['l', 'r', 't', 'b']
		 * @param {string} color: the color of the border
		 * @param {int} width: the width of the border
		 * @param {string} style: the style of the broder
		 * @param {boolean} suspendRefresh: a flag to suspend the refresh action for ss
		 */
		setRangeBorder : function(dir, color, width, style, suspendRefresh, suspendEvent){			
			var ss = this.sheet;	
			/*
			 * fire before range change event, so listener can cancel the change by return false
			 */
			if(suspendEvent || false !== ss.fireEvent('beforeborderchange', this, ss)){				
				if(!suspendEvent){
					ss.fireEvent('prepareborderchange', this, ss);
				}
				var store = ss.getStore();
				for(var i = 0, len = this.coord.length; i < len; i++){
					var coord = this.coord[i];
					var sheetId = coord[0], minrow = coord[1], mincol = coord[2], maxrow = coord[3], maxcol = coord[4];
					var pos = {sheetId:sheetId, minrow:minrow, mincol:mincol, maxrow:maxrow, maxcol:maxcol};
					/*
					 * for different border width, need adjust padding or margin
					 */
					if(0 == mincol && 0 == minrow){
						/*
						 * for select all
						 */		
						if('all' == dir){
							this.setAllBorder(pos, width, style, color);
						}
					}else if(0 == mincol){
						/*
						 * for select row
						 */
						if('all' == dir){
							this.setAllBorder(pos, width, style, color);
						}else if('top' == dir){
							this.setTopBorder(pos, width, style, color);
						}else if('bottom' == dir){
							this.setBottomBorder(pos, width, style, color);
						}else if('outside' == dir || 'topbottom' == dir){
							this.setTopBorder(pos, width, style, color);
							this.setBottomBorder(pos, width, style, color);
						}
					}else if(0 == minrow){
						/*
						 * for select column
						 */
						if('all' == dir){
							this.setAllBorder(pos, width, style, color);
						}else if('left' == dir){
							this.setLeftBorder(pos, width, style, color);
						}else if('right' == dir){
							this.setRightBorder(pos, width, style, color);
						}else if('outside' == dir){
							this.setLeftBorder(pos, width, style, color);
							this.setRightBorder(pos, width, style, color);
						}
					}else{
						/*
						 * for cell selection
						 */
						if('all' == dir){
							this.setAllBorder(pos, width, style, color);
						}else if('left' == dir){
							this.setLeftBorder(pos, width, style, color);				
						}else if('right' == dir){
							this.setRightBorder(pos, width, style, color);				
						}else if('top' == dir){
							this.setTopBorder(pos, width, style, color);
						}else if('bottom' == dir){
							this.setBottomBorder(pos, width, style, color);
						}else if('outside' == dir){
							this.setLeftBorder(pos, width, style, color);				
							this.setRightBorder(pos, width, style, color);	
							this.setTopBorder(pos, width, style, color);
							this.setBottomBorder(pos, width, style, color);
						}else if('topbottom' == dir){
							this.setTopBorder(pos, width, style, color);
							this.setBottomBorder(pos, width, style, color);
						}
					}			
				}	
				if(!suspendRefresh){
					/*
					 * if not suspend, then refresh the range
					 */
					this.refresh();
				}
				if(!suspendEvent){
					ss.fireEvent('borderchange', this, ss);
				}				
			}
		},
		
		/*
		 * set the left border for cells contained in span
		 */ 
		setLeftBorder : function(span, width, style, color){			
			var sheetId = span.sheetId;
			var store = this.sheet.getStore();
			var mincol = span.mincol, maxcol = span.maxcol, minrow = span.minrow, maxrow = span.maxrow;
			for(var i = minrow; i <= maxrow; i++){						
				store.setRangeBorder(sheetId, i, mincol, [{
					dir:'l',
					width:width,
					style:style,
					color:color,
					/*
					 * true to set the left border, or it will clean the left border
					 */
					flag:true
				}], true);				
			}	
			
			if(1 < mincol){
				var col = mincol-1;
				for(var i = minrow; i <= maxrow; i++){	
					store.setRangeBorder(sheetId, i, col, [{
						dir:'r',
						width:width,
						style:style,
						color:color					
					}], true);
				}
			}
		},
		
		/*
		 * set the right border for cells contained in span
		 */ 
		setRightBorder : function(span, width, style, color){			
			var sheetId = span.sheetId;
			var store = this.sheet.getStore();
			var mincol = span.mincol, maxcol = span.maxcol, minrow = span.minrow, maxrow = span.maxrow;
			var col = maxcol+1;
			for(var i = minrow; i <= maxrow; i++){
				store.setRangeBorder(sheetId, i, maxcol, [{
					dir:'r',
					width:width,
					style:style,
					color:color,
					/*
					 * true to set the right border, or it will clean the right border
					 */
					flag:true
				}], true);
				
				store.setRangeBorder(sheetId, i, col, [{
					dir:'l',
					width:width,
					style:style,
					color:color
				}], true);							
			}		
		},
		
		/*
		 * set the top border for cells contained in span
		 */ 
		setTopBorder : function(span, width, style, color){			
			var sheetId = span.sheetId;
			var store = this.sheet.getStore();
			var mincol = span.mincol, maxcol = span.maxcol, minrow = span.minrow, maxrow = span.maxrow;
			for(var j = mincol; j <= maxcol; j++){
				store.setRangeBorder(sheetId, minrow, j, [{
					dir:'t',
					width:width,
					style:style,
					color:color,
					/*
					 * true to set the top border, or it will clean the top border
					 */
					flag:true
				}], true);				
			}	
			
			if(1 < minrow){
				row = minrow-1;
				for(var j = mincol; j <= maxcol; j++){
					store.setRangeBorder(sheetId, row, j, [{
						dir:'b',
						width:width,
						style:style,
						color:color
					}], true);		
				}
			}
		},
		
		/*
		 * set the bottom border for cells contained in span
		 */ 
		setBottomBorder : function(span, width, style, color){			
			var sheetId = span.sheetId;
			var store = this.sheet.getStore();
			var mincol = span.mincol, maxcol = span.maxcol, minrow = span.minrow, maxrow = span.maxrow;
			var row = maxrow+1;
			for(var j = mincol; j <= maxcol; j++){
				store.setRangeBorder(sheetId, maxrow, j, [{
					dir:'b',
					width:width,
					style:style,
					color:color,
					/*
					 * true to set the bottom border, or it will clean the bottom border
					 */
					flag:true
				}], true);
				
				store.setRangeBorder(sheetId, row, j, [{
					dir:'t',
					width:width,
					style:style,
					color:color
				}], true);
			}		
		},
		
		/*
		 * set the all border for cells contained in span
		 */ 
		setAllBorder : function(span, width, style, color){			
			var sheetId = span.sheetId;
			var store = this.sheet.getStore();
			var mincol = span.mincol, maxcol = span.maxcol, minrow = span.minrow, maxrow = span.maxrow;		
			for(var i = minrow; i <= maxrow; i++){
				for(var j = mincol; j <= maxcol; j++){
					store.setRangeBorder(sheetId, i, j, [{
						dir:'l',
						width:width,
						style:style,
						color:color,
						flag:true
					}, {
						dir:'t',
						width:width,
						style:style,
						color:color,
						flag:true
					}, {
						dir:'r',
						width:width,
						style:style,
						color:color,
						flag:true
					}, {
						dir:'b',
						width:width,
						style:style,
						color:color,
						flag:true
					}], true);							
				}
			}
			
			if(0 != minrow){
				var row = maxrow+1;
				for(var j = mincol; j <= maxcol; j++){
					store.setRangeBorder(sheetId, row, j, [{
						dir:'t',
						width:width,
						style:style,
						color:color
					}], true);						
				}
				if(1 < minrow){
					var row = minrow-1;
					for(var j = mincol; j <= maxcol; j++){
						store.setRangeBorder(sheetId, row, j, [{
							dir:'b',
							width:width,
							style:style,
							color:color
						}], true);						
					}				
				}
			}		
			if(0 != mincol){
				var col = maxcol+1;
				for(var i = minrow; i <= maxrow; i++){
					store.setRangeBorder(sheetId, i, col, [{
						dir:'l',
						width:width,
						style:style,
						color:color
					}], true);							
				}
				if(1 < mincol){
					var col = mincol-1;
					for(var i = minrow; i <= maxrow; i++){
						store.setRangeBorder(sheetId, i, col, [{
							dir:'r',
							width:width,
							style:style,
							color:color
						}], true);							
					}				
				}
			}		
		},					
		
		/*
		 * refresh the elements in this range
		 * @param {boolean} refreshCalCdt: true to reculate calcualte and condition cells in sheet
		 */
		refresh : function(refreshCalCdt, refreshAll, concatCoord){
			var coord = SCOM.copy(this.coord);
			if(concatCoord){
				coord = coord.concat(concatCoord);
			}
			
			/*
			 * special process for merged cell, we will refresh all cells in the merged range
			 */
			var store = this.sheet.getStore();
			for(var i = 0, len = coord.length; i < len; i++){
				var span = coord[i];
				if(span[1] == span[3] && span[2] == span[4]){
					var cd = store.getCellData(span[0], span[1], span[2]);
					if(store.isMergedCell(cd, span[0], span[1], span[2])){
						span[1] += cd.minrow;
						span[2] += cd.mincol;
						span[3] += cd.maxrow;
						span[4] += cd.maxcol;
					}
				}				
			}
			
			if(refreshCalCdt){
                this.sheet.refreshCalCdt(refreshCalCdt, undefined, undefined, coord, function(calCoord){
                    if(calCoord){
                        coord = coord.concat(calCoord);
                    }
                    this.sheet.refreshRange(refreshAll ? null : coord);
                }, this);
            }else{
                this.sheet.refreshRange(refreshAll ? null : coord);
            }
		},
		
		/**
		 * return true if there is merged cell in this range
		 */
		includeMergedCell : function(){
			var store = this.sheet.getStore();
			var coord = this.coord;
			var flag = false;
			store.walkRange(coord, function(rd){
				if(store.isMergedCell(rd.data.json, rd.data.sheet, rd.data.row, rd.data.col)){
					flag = true;
					return false;
				}
			}, this, true);
			
			return flag;
		},
		
		/**
		 * return true if it's cell coord range
		 */
		isCellRange : function(){
			var store = this.sheet.getStore();
			var coord = this.coord;
			for(var i = 0, len = coord.length; i < len; i++){
				var span = coord[i];
				if(0 == span[3] || 0 == span[4]){
					return false;
				}
			}
			return true;
		},
		
		/*
		 * get the coord array
		 */
		getCoord : function(){			
			return SCOM.copy(this.coord);
		},
		
		setCoord : function(coord){
			this.coord = SCOM.copy(coord);
		},
		
		getCoordInAbsolute : function(coord, asArr){
			var arr = [];
			coord = coord || this.coord;
			for(var i = 0, len = coord.length; i < len; i++){
				var span = SCOM.copy(coord[i]);
				if(asArr){
					arr.push(span);
				}else{
					arr.push({
						span: span,
						type:SCONST.ABSOLUTE_COORD
					});
				}
			}
			return arr;
		},
		
		/*
		 * transfer the absolute coord to relative coord
		 */
		absolute2Relative : function(coord, sheetId, row, col){
			var arr = [];
			for(var i = 0, len = coord.length; i < len; i++){
				var span = coord[i];
				span = EnterpriseSheet.sheet.calculate.Coordinate.prototype.absoluteSpan2Relative(sheetId, row, col, span);			
				arr.push({
					span:span,
					type:SCONST.RELATIVE_COORD
				});
			}
			return arr;
		},
		
		/*
		 * extend to margin
		 */
		extend2Margin : function(coord){
			var borders = [];
			for(var i = 0, len = coord.length; i < len; i++){
				var span = coord[i];
				if(1 < span[1]){
					borders.push([span[0], span[1]-1, span[2], span[1]-1, span[4]]);
				}
				if(1 < span[2]){
					borders.push([span[0], span[1], span[2]-1, span[3], span[2]-1]);
				}
				borders.push([span[0], span[3]+1, span[2], span[3]+1, span[4]]);
				borders.push([span[0], span[1], span[4]+1, span[3], span[4]+1]);
			}
			coord = coord.concat(borders);
			return coord;
		},
		
		/**
		 * escape from the default property
		 */
		escapeDefaultProperty : function(sheetId, row, col){
			var sheet = this.sheet, store = sheet.getStore();
			var dp = store.defaultProperty;
			var cellPro = store.getCellProperty(sheetId, row, col);
			
			var obj = {};
			for(var p in cellPro){
				if(cellPro.hasOwnProperty(p) && dp.hasOwnProperty(p)){
					obj[p] = dp[p];
				}
			}
			return obj;
		},
		
		/**
		 * clean the content and style of the range
		 * @param {boolean} suspendEvent: true to not fire Event
		 */
		clean : function(suspendEvent, avoidRange, suspendRefresh, skipDisabled){
			if(false !== skipDisabled){
				skipDisabled = true;
			}
			var me = this;
			var ss = this.sheet;
			var fn = function(originCdts, reCalCells, changedHeights){
				var store = ss.getStore();  
				var coord = this.coord;
				for(var k = 0, size = coord.length; k < size; k++){
					var span = coord[k], sheetId = span[0];
					var cell = store.getCell(sheetId, 0, 0), dsd = cell.dsd;	
					if(skipDisabled && store.isDisabledForMe(dsd)){
						continue;
					}
					if(0 == span[3] && 0 == span[4]){
						/*
						 * clear the whole sheet
						 */
						if(!avoidRange || !avoidRange.isIncluded(sheetId, 0, 0)){
							store.each(function(rd){
								if(rd.data.sheet == sheetId){
									var row = rd.data.row, col = rd.data.col;
									if(0 != row || 0 != col){
										if(!avoidRange || !avoidRange.isIncluded(sheetId, row, col)){
											var json = rd.data.json, dsd = json.dsd;
											if(!store.isDisabledForMe(dsd) && skipDisabled){
												var pro = store.getCellProperty(sheetId, row, col);
												dsd = pro.dsd;
											}
											if(!skipDisabled || !store.isDisabledForMe(dsd)){
												var countMemeber = SCOM.countObjMember(json);
												if(0 < countMemeber){										
													if(json['tpl']){					
														if(1 != countMemeber){
															store.setCell(sheetId, row, col, {'tpl': json['tpl']}, null, true, 'clear');
														}													
													}else{
														store.setCell(sheetId, row, col, null, null, true, 'clear');
													}
												}
											}
										}
									}
								}
							}, store);		
							var cell = store.getCell(sheetId, 0, 0);
							if(!skipDisabled || !store.isDisabledForMe(cell.dsd)){
								store.setCell(sheetId, 0, 0, Ext.copyTo({}, store.getCell(sheetId, 0, 0), store.avoidMembers), null, true, 'clear');
							}
						}
					}else if(0 == span[3]){
						/*
						 * clear columns
						 */
						for(var j = span[2]; j <= span[4]; j++){
							if(!avoidRange || !avoidRange.isIncluded(sheetId, 0, j)){
								var rows = [];
								store.each(function(rd){
									if(rd.data.sheet == sheetId){
										var row = rd.data.row, col = rd.data.col;
										if(j == col && 0 != row){
											if(!avoidRange || !avoidRange.isIncluded(sheetId, row, col)){
												var needDefault = false;
												var rowJson = store.getCell(sheetId, row, 0), dsd = rowJson.dsd;
												if(!skipDisabled || !store.isDisabledForMe(dsd)){
													var countMemeber = SCOM.countObjMember(rowJson);
													if(1 < countMemeber || (1 == countMemeber && !rowJson.hasOwnProperty('tpl'))){
														needDefault = true;
													}
													var json = rd.data.json;
													dsd = dsd || json.dsd;
													if(!store.isDisabledForMe(dsd) && skipDisabled){
														var pro = store.getCellProperty(sheetId, row, col);
														dsd = pro.dsd;
													}
													if(!skipDisabled || !store.isDisabledForMe(dsd)){
														if(needDefault){
															var property = {};
															if(json && json['tpl']){
																property['tpl'] = json['tpl'];
															}
															store.setCell(sheetId, row, col, Ext.apply(property, me.escapeDefaultProperty(sheetId, row, col)), null, true, 'clear');
														}else{
															countMemeber = SCOM.countObjMember(json);
															if(0 < countMemeber){										
																if(json['tpl']){					
																	if(1 != countMemeber){
																		store.setCell(sheetId, row, col, {'tpl': json['tpl']}, null, true, 'clear');
																	}													
																}else{
																	store.setCell(sheetId, row, col, null, null, true, 'clear');
																}
															}
														}
													}
												}
											}
										}else if(0 == col && 0 != row){
											rows.push(rd);
										}										
									}
								}, store);		
								/*
								 * for cover the row setting
								 */			 
								for(var i = 0, len = rows.length; i < len; i++){
									var r = rows[i];
									var row = r.data.row;
									var id = store.getIdBasedData({sheet:sheetId, row:row, col:j});
									if(!store.getByMapId(id)){
										var json = store.getCell(sheetId, row, 0), dsd = json.dsd;
										if(!store.isDisabledForMe(dsd) && skipDisabled){
											var pro = store.getCell(sheetId, 0, j);
											dsd = pro.dsd;
										}
										if(!skipDisabled || !store.isDisabledForMe(dsd)){											
											var countMemeber = SCOM.countObjMember(json);
											if(0 < countMemeber){
												if(!json['tpl'] || 1 != countMemeber){
													/*
													 * need use a new obj for every new record
													 */	
													store.setCell(sheetId, row, j, Ext.apply({}, me.escapeDefaultProperty(sheetId, row, j)), null, true, 'clear');
												}
											}											
										}
									}
								}
								var json = store.getCell(sheetId, 0, j);
								if(!skipDisabled || !store.isDisabledForMe(json.dsd)){
									var countMemeber = SCOM.countObjMember(json);
									if(0 < countMemeber){										
										if(json['tpl']){					
											if(1 != countMemeber){
												store.setCell(sheetId, 0, j, Ext.copyTo({}, json, ['tpl']), null, true, 'clear');
											}													
										}else{
											store.setCell(sheetId, 0, j, null, null, true, 'clear');
										}
									}								
								}
							}
						}
					}else if(0 == span[4]){
						/*
						 * clear rows
						 */
						for(var i = span[1]; i <= span[3]; i++){
							if(!avoidRange || !avoidRange.isIncluded(sheetId, i, 0)){			
								var cols = [];
								store.each(function(rd){
									if(rd.data.sheet == sheetId){
										var row = rd.data.row, col = rd.data.col;
										if(i == row && 0 != col){
											if(!avoidRange || !avoidRange.isIncluded(sheetId, row, col)){
												var needDefault = false;
												var colJson = store.getCell(sheetId, 0, col), dsd = colJson.dsd;
												if(!skipDisabled || !store.isDisabledForMe(dsd)){
													countMemeber = SCOM.countObjMember(colJson);
													if(1 < countMemeber || (1 == countMemeber && !colJson.hasOwnProperty('tpl'))){
														needDefault = true;
													}
													var json = rd.data.json;
													dsd = dsd || json.dsd;
													if(!store.isDisabledForMe(dsd) && skipDisabled){
														var pro = store.getCellProperty(sheetId, row, col);
														dsd = pro.dsd;
													}
													if(!skipDisabled || !store.isDisabledForMe(dsd)){
														if(needDefault){
															var property = {};
															if(json && json['tpl']){
																property['tpl'] = json['tpl'];
															}
															store.setCell(sheetId, row, col, Ext.apply(property, me.escapeDefaultProperty(sheetId, row, col)), null, true, 'clear');
														}else{
															countMemeber = SCOM.countObjMember(json);
															if(0 < countMemeber){										
																if(json['tpl']){					
																	if(1 != countMemeber){
																		store.setCell(sheetId, row, col, {'tpl': json['tpl']}, null, true, 'clear');
																	}													
																}else{
																	store.setCell(sheetId, row, col, null, null, true, 'clear');
																}
															}
														}
													}
												}
											}
										}else if(0 == row && 0 != col){
											cols.push(rd);
										}										
									}
								}, store);		
								/*
								 * for cover the column setting
								 */			 
								for(var j = 0, len = cols.length; j < len; j++){
									var c = cols[j];
									var col = c.data.col;
									var id = store.getIdBasedData({sheet:sheetId, row:i, col:col});
									if(!store.getByMapId(id)){
										var json = store.getCell(sheetId, 0, col), dsd = json.dsd;
										if(!store.isDisabledForMe(dsd) && skipDisabled){
											var cell = store.getCell(sheetId, i, 0);
											dsd = cell.dsd;
										}
										if(!skipDisabled || !store.isDisabledForMe(dsd)){										
											var countMemeber = SCOM.countObjMember(json);
											if(0 < countMemeber){
												if(!json['tpl'] || 1 != countMemeber){
													/*
													 * need use a new obj for every new record
													 */	
													store.setCell(sheetId, i, col, Ext.apply({}, me.escapeDefaultProperty(sheetId, i, col)), null, true, 'clear');
												}
											}											
										}
									}
								}
								var json = store.getCell(sheetId, i, 0);
								if(!skipDisabled || !store.isDisabledForMe(json.dsd)){
									var countMemeber = SCOM.countObjMember(json);
									if(0 < countMemeber){										
										if(json['tpl']){					
											if(1 != countMemeber){
												store.setCell(sheetId, i, 0, Ext.copyTo({}, json, ['tpl']), null, true, 'clear');
											}													
										}else{
											store.setCell(sheetId, i, 0, null, null, true, 'clear');
										}
									}								
								}
							}
						}
					}else{											
						for(var i = span[1]; i <= span[3]; i++){
							for(var j = span[2]; j <= span[4]; j++){
								if(!avoidRange || !avoidRange.isIncluded(sheetId, i, j)){
									var needDefault = false;
									var rowJson = store.getCell(sheetId, i, 0);
									var dsd = rowJson.dsd;
									if(!skipDisabled || !store.isDisabledForMe(dsd)){
										var colJson = store.getCell(sheetId, 0, j);
										dsd = dsd || colJson.dsd;		
										if(!skipDisabled || !store.isDisabledForMe(dsd)){
											var countMemeber = SCOM.countObjMember(rowJson);
											if(1 < countMemeber || (1 == countMemeber && !rowJson.hasOwnProperty('tpl'))){
												needDefault = true;
											}else{																						
												countMemeber = SCOM.countObjMember(colJson);
												if(1 < countMemeber || (1 == countMemeber && !colJson.hasOwnProperty('tpl'))){
													needDefault = true;
												}											
											}
											var id = store.getIdBasedData({sheet:sheetId, row:i, col:j});
											var rd = store.getByMapId(id);
											var json = rd ? rd.data.json : {};
											dsd = dsd || json.dsd;
											if(!skipDisabled || !store.isDisabledForMe(dsd)){
												if(needDefault){
													var property = {};
													if(json && json['tpl']){
														property['tpl'] = json['tpl'];
													}
													store.setCell(sheetId, i, j, Ext.apply(property, me.escapeDefaultProperty(sheetId, i, j)), null, true, 'clear');
												}else{										
													if(rd){											
														countMemeber = SCOM.countObjMember(json);
														if(0 < countMemeber){										
															if(json['tpl']){					
																if(1 != countMemeber){
																	store.setCell(sheetId, i, j, Ext.copyTo({}, json, ['tpl']), null, true, 'clear');
																}													
															}else{
																store.setCell(sheetId, i, j, null, null, true, 'clear');
															}
														}										
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
				ss.splitCdt(this.getCoord(), originCdts);
				
				if(!suspendRefresh){
					/*
					 * check autoHeight for ralted range
					 */
					if(this.isCellCoord()){
						Ext.apply(changedHeights, ss.checkAutoHeightForCoord(undefined, this.coord, false, true));
					}
					this.refresh(reCalCells);
				}				
			}
			var coordPro = EnterpriseSheet.sheet.calculate.Coordinate.prototype;
			if(!suspendEvent){
				/*
				 * fire before clean range event, so listener can cancel the change by return false
				 */		
				if(false !== ss.fireEvent('beforecleanrange', this, null, ss)){
					var originCdts = ss.getCdtsFromCoord(this.coord);
					//ss.startTime = new Date()
					var reCalCells = ss.getRecalculateCellsByCoord(this.coord);
					Ext.apply(reCalCells, coordPro.transferCoord2CellLookup(ss.getRelatedCdtCoord(this.coord)));
					var changedHeights = {};
					ss.fireEvent('preparecleanrange', this, null, ss, originCdts, reCalCells, changedHeights);
					fn.call(this, originCdts, reCalCells, changedHeights);
					
					ss.fireEvent('cleanrange', this, null, ss, originCdts, reCalCells);
				}
			}else{
				var originCdts = ss.getCdtsFromCoord(this.coord); 
				var reCalCells = ss.getRecalculateCellsByCoord(this.coord);
				Ext.apply(reCalCells, coordPro.transferCoord2CellLookup(ss.getRelatedCdtCoord(this.coord)));
				fn.call(this, originCdts, reCalCells);
			}	
		},
		
		/*
		 * clean style of the range
		 * @param {boolean} suspendEvent: true to not fire Event
		 */
		cleanStyle : function(suspendEvent, avoidRange, suspendRefresh, skipDisabled){
			if(false !== skipDisabled){
				skipDisabled = true;
			}
			var me = this;
			var ss = this.sheet;
			var fn = function(){
				var store = ss.getStore();
				var keepProperties = ['data', 'display', 'cal', 'arg', 'value', 'timestamp', 'afrow', 'afcol', 'aerow', 'aecol', 'cdt', 'tpl', 'width', 'woff', 'height', 'hoff'].concat(EnterpriseSheet.sheet.calculate.Condition.styles);
				var coord = this.coord;
				for(var k = 0, size = coord.length; k < size; k++){
					var span = coord[k], sheetId = span[0];
					var cell = store.getCell(sheetId, 0, 0), dsd = cell.dsd;	
					if(skipDisabled && store.isDisabledForMe(dsd)){
						continue;
					}
					if(0 == span[3] && 0 == span[4]){
						/*
						 * clear the whole sheet
						 */
						if(!avoidRange || !avoidRange.isIncluded(sheetId, 0, 0)){
							store.each(function(rd){
								if(rd.data.sheet == sheetId){
									var row = rd.data.row, col = rd.data.col;
									if(0 != row || 0 != col){
										if(!avoidRange || !avoidRange.isIncluded(sheetId, row, col)){
											var json = rd.data.json, dsd = json.dsd;
											if(!store.isDisabledForMe(dsd)){
												var pro = store.getCellProperty(sheetId, row, col);
												dsd = pro.dsd;
											}
											if(!skipDisabled || !store.isDisabledForMe(dsd)){
												var md = Ext.copyTo({}, json, keepProperties);
												store.setCell(sheetId, row, col, md, null, true, 'clear');
											}
										}
									}
								}
							}, store);		
							var cell = store.getCell(sheetId, 0, 0);
							if(!skipDisabled || !store.isDisabledForMe(cell.dsd)){
								store.setCell(sheetId, 0, 0, Ext.copyTo({}, store.getCell(sheetId, 0, 0), keepProperties.concat(store.avoidMembers)), null, true, 'clear');
							}
						}
					}else if(0 == span[3]){
						/*
						 * clear columns
						 */
						for(var j = span[2]; j <= span[4]; j++){
							if(!avoidRange || !avoidRange.isIncluded(sheetId, 0, j)){
								var rows = [];
								store.each(function(rd){
									if(rd.data.sheet == sheetId){
										var row = rd.data.row, col = rd.data.col;
										if(j == col && 0 != row){
											if(!avoidRange || !avoidRange.isIncluded(sheetId, row, col)){
												var rowJson = store.getCell(sheetId, row, 0), dsd = rowJson.dsd;
												if(!skipDisabled || !store.isDisabledForMe(dsd)){
													var needDefault = store.withStyleProperty(rowJson);
													var json = rd.data.json;
													if(!dsd && skipDisabled){
														var pro = store.getCellProperty(sheetId, row, col);
														dsd = pro.dsd;
													}													
													if(!skipDisabled || !store.isDisabledForMe(dsd)){
														var property = {};
														if(json){
															Ext.copyTo(property, json, keepProperties);
														}
														if(needDefault){
															Ext.apply(property, me.escapeDefaultProperty(sheetId, row, col));
														}
														store.setCell(sheetId, row, col, property, null, true, 'clear');
													}
												}
											}
										}else if(0 == col && 0 != row){
											rows.push(rd);
										}										
									}
								}, store);		
								/*
								 * for cover the row setting
								 */			 
								for(var i = 0, len = rows.length; i < len; i++){
									var r = rows[i];
									var row = r.data.row;
									var id = store.getIdBasedData({sheet:sheetId, row:row, col:j});
									if(!store.getByMapId(id)){
										var json = store.getCell(sheetId, row, 0), dsd = json.dsd;
										if(!store.isDisabledForMe(dsd) && skipDisabled){
											var cell = store.getCell(sheetId, 0, j);
											dsd = cell.dsd;
										}
										if(!skipDisabled || !store.isDisabledForMe(dsd)){
											if(store.withStyleProperty(json)){
												/*
												 * need use a new obj for every new record
												 */	
												store.setCell(sheetId, row, j, Ext.apply({}, me.escapeDefaultProperty(sheetId, row, j)), null, true, 'clear');
											}
										}
									}
								}
								var json = store.getCell(sheetId, 0, j);
								if(!skipDisabled || !store.isDisabledForMe(json.dsd)){
									if(store.withStyleProperty(json)){			
										var property = Ext.copyTo({}, json, keepProperties);
										store.setCell(sheetId, 0, j, property, null, true, 'clear');
									}							
								}
							}
						}
					}else if(0 == span[4]){
						/*
						 * clear rows
						 */
						for(var i = span[1]; i <= span[3]; i++){
							if(!avoidRange || !avoidRange.isIncluded(sheetId, i, 0)){	
								var cols = [];
								store.each(function(rd){
									if(rd.data.sheet == sheetId){
										var row = rd.data.row, col = rd.data.col;
										if(i == row && 0 != col){
											if(!avoidRange || !avoidRange.isIncluded(sheetId, row, col)){												
												var colJson = store.getCell(sheetId, 0, col), dsd = colJson.dsd;
												if(!skipDisabled || !store.isDisabledForMe(dsd)){
													var needDefault = store.withStyleProperty(colJson);								
													var json = rd.data.json, dsd = json.dsd;
													if(!store.isDisabledForMe(dsd) && skipDisabled){
														var pro = store.getCellProperty(sheetId, row, col);
														dsd = pro.dsd;
													}
													if(!skipDisabled || !store.isDisabledForMe(dsd)){
														var property = {};
														if(json){
															Ext.copyTo(property, json, keepProperties);
														}
														if(needDefault){
															Ext.apply(property, me.escapeDefaultProperty(sheetId, row, col));
														}
														store.setCell(sheetId, row, col, property, null, true, 'clear');
													}
												}
											}
										}else if(0 == row && 0 != col){
											cols.push(rd);
										}										
									}
								}, store);		
								/*
								 * for cover the column setting
								 */			 
								for(var j = 0, len = cols.length; j < len; j++){
									var c = cols[j];
									var col = c.data.col;
									var id = store.getIdBasedData({sheet:sheetId, row:i, col:col});
									if(!store.getByMapId(id)){
										var json = store.getCell(sheetId, 0, col), dsd = json.dsd;
										if(!store.isDisabledForMe(dsd) && skipDisabled){
											var cell = store.getCell(sheetId, i, 0);
											dsd = cell.dsd;
										}
										if(!skipDisabled || !store.isDisabledForMe(dsd)){
											if(store.withStyleProperty(json)){
												/*
												 * need use a new obj for every new record
												 */	
												store.setCell(sheetId, i, col, Ext.apply({}, me.escapeDefaultProperty(sheetId, i, col)), null, true, 'clear');
											}
										}
									}
								}
								var json = store.getCell(sheetId, i, 0), dsd = json.dsd;
								if(!skipDisabled || !store.isDisabledForMe(dsd)){
									if(store.withStyleProperty(json)){			
										var property = Ext.copyTo({}, json, keepProperties);
										store.setCell(sheetId, i, 0, property, null, true, 'clear');
									}							
								}
							}
						}
					}else{
						for(var i = span[1]; i <= span[3]; i++){
							for(var j = span[2]; j <= span[4]; j++){
								if(!avoidRange || !avoidRange.isIncluded(sheetId, i, j)){
									var rowJson = store.getCell(sheetId, i, 0), dsd = rowJson.dsd;
									if(!skipDisabled || !store.isDisabledForMe(dsd)){
										var needDefault = store.withStyleProperty(rowJson);
										var colJson = store.getCell(sheetId, 0, j);
										dsd = dsd || colJson.dsd;
										if(!skipDisabled || !store.isDisabledForMe(dsd)){
											if(!needDefault){											
												needDefault = store.withStyleProperty(colJson);
											}
											var id = store.getIdBasedData({sheet:sheetId, row:i, col:j});
											var rd = store.getByMapId(id);
											var json = rd ? rd.data.json : null;
											var property = {};
											if(json){
												dsd = dsd || json.dsd;
												Ext.copyTo(property, json, keepProperties);
											}
											if(!skipDisabled || !store.isDisabledForMe(dsd)){
												if(needDefault){
													Ext.apply(property, me.escapeDefaultProperty(sheetId, i, j));
												}
												store.setCell(sheetId, i, j, property, null, true, 'clear');
											}
										}
									}
								}
							}
						}
					}
				}
				/*
				 * check autoHeight for ralted range
				 */
				if(this.isCellCoord()){
					ss.checkAutoHeightForCoord(undefined, this.coord, false, true);
				}
				if(!suspendRefresh){
					this.refresh();
				}				
			}
			if(!suspendEvent){
				/*
				 * fire before clean range event, so listener can cancel the change by return false
				 */		
				if(false !== ss.fireEvent('beforecleanrange', this, 'style', ss)){
					ss.fireEvent('preparecleanrange', this, 'style', ss);
					fn.call(this);
					ss.fireEvent('cleanrange', this, 'style', ss);
				}
			}else{
				fn.call(this);
			}		
		},
		
		
		/*
		 * clean the content of the range
		 * @param {boolean} suspendEvent: true to not fire Event
		 */
		cleanContent : function(suspendEvent, avoidRange, suspendRefresh){
			var ss = this.sheet;
			var fn = function(reCalCells, changedHeights){
				var store = ss.getStore();
				var deleted = EnterpriseSheet.sheet.calculate.Calculate.prototype.contentRelatedProperty.concat(EnterpriseSheet.sheet.calculate.Condition.stylesWithoutMini);
				store.walkRange(this.coord, function(rd){
					if(rd.data.row || rd.data.col){
						if(!SCOM.isEmptyObj(rd.data.json) && !store.isDisabledCell(rd.data.sheet, rd.data.row, rd.data.col) ){
							if(!avoidRange || !avoidRange.isIncluded(rd.data.sheet, rd.data.row, rd.data.col)){								
								store.setCell(rd.data.sheet, rd.data.row, rd.data.col, null, deleted, true);
							}
						}
					}
				}, this);		
				/*
				 * check autoHeight for ralted range
				 */
				if(this.isCellCoord()){
					Ext.apply(changedHeights, ss.checkAutoHeightForCoord(undefined, this.coord, false, true));
				}
				
				if(!suspendRefresh){
					this.refresh(reCalCells);
				}				
			}
			var coordPro = EnterpriseSheet.sheet.calculate.Coordinate.prototype;
			if(!suspendEvent){
				/*
				 * fire before clean range event, so listener can cancel the change by return false
				 */
				if(false !== ss.fireEvent('beforecleanrange', this, 'content', ss)){
					var originCdts = ss.getCdtsFromCoord(this.coord);				
					var reCalCells = ss.getRecalculateCellsByCoord(this.coord);
					Ext.apply(reCalCells, coordPro.transferCoord2CellLookup(ss.getRelatedCdtCoord(this.coord)));              
					var changedHeights = {};
					ss.fireEvent('preparecleanrange', this, 'content', ss, undefined, reCalCells, changedHeights);
					fn.call(this, reCalCells, changedHeights);
					ss.fireEvent('cleanrange', this, 'content', ss, undefined, reCalCells);
				}
			}else{
				var originCdts = ss.getCdtsFromCoord(this.coord);				
				var reCalCells = ss.getRecalculateCellsByCoord(this.coord);
				Ext.apply(reCalCells, coordPro.transferCoord2CellLookup(ss.getRelatedCdtCoord(this.coord))); 
				fn.call(this, reCalCells);
			}
		},
		
		/*
		 * check whether it's in single sheet
		 */
		isInSingleSheet : function(){
			var sheet = null;
			for(var i = 0, len = this.coord.length; i < len; i++){
				var span = this.coord[i];
				if(null === sheet){
					sheet = span[0];
				}else if(sheet != span[0]){
					return false;
				}
			}
			return true;
		},
		
		/*
		 * get min pos of the range, for example if it's [[0, 5, 3, 6, 8], [0, 6, 8, 7, 10]] then the min pos is 5, 3
		 */
		getMinPos : function(){
			var minrow = null, mincol = null;
			for(var i = 0, len = this.coord.length; i < len; i++){
				var span = this.coord[i];
				if(null === minrow){
					minrow = span[1];
				}else if(minrow > span[1]){
					minrow = span[1];
				}
				if(null === mincol){
					mincol = span[2];
				}else if(mincol > span[2]){
					mincol = span[2];
				}			
			}
			return {
				row:minrow,
				col:mincol
			};
		},
		
		/*
		 * get max pos of the range, for example if it's [[0, 5, 3, 6, 8], [0, 6, 8, 7, 10]] then the min pos is 7, 10
		 */
		getMaxPos : function(){
			var maxrow = null, maxcol = null;
			for(var i = 0, len = this.coord.length; i < len; i++){
				var span = this.coord[i];
				if(null === maxrow){
					maxrow = span[3];
				}else if(maxrow < span[3]){
					maxrow = span[3];
				}
				if(null === maxcol){
					maxcol = span[4];
				}else if(maxcol < span[4]){
					maxcol = span[4];
				}			
			}
			return {
				row:maxrow,
				col:maxcol
			};
		},
		
		/*
		 * move coord
		 * @param {int} sheetId: the new sheet id, if null/undefined, then use the old one
		 * @param {int} rowOffset: the row offset to move for every span
		 * @param {int} colOffset: the col offset to move for every span
		 */
		moveCoord : function(sheetId, rowOffset, colOffset){
			for(var i = 0, len = this.coord.length; i < len; i++){
				var span = this.coord[i];
				if(false !== sheetId){
					span[0] = sheetId;
				}			
				span[1] = span[1]+rowOffset;
				span[2] = span[2]+colOffset;
				span[3] = span[3]+rowOffset;
				span[4] = span[4]+colOffset;
			}
		},
		
		/*
		 * reverse coord
		 */
		reverseCoord : function(){
			for(var i = 0, len = this.coord.length; i < len; i++){
				var span = this.coord[i];
				var tmp = span[3]-span[1];
				span[3] = span[1]+span[4]-span[2];
				span[4] = span[2]+tmp;
			}
		},
		
		/*
		 * selet the first span of the range
		 */
		select : function(){
			if(0 < this.coord.length){
				var span = this.coord[0];
				if(span[0] == this.sheet.getSheetId()){
					this.sheet.getSelectionModel().selectRange({
						row:span[1],
						col:span[2]
					}, {
						row:span[3],
						col:span[4]
					});
				}
			}
		},
		
		/*
		 * create an new EnterpriseSheet.sheet.range.Range instance with the same coord as this one
		 */
		clone : function(){
			return new EnterpriseSheet.sheet.range.Range({
				sheet:this.sheet,
				coord:this.getCoord()
			});
		},
		
		/*
		 * merge coord
		 * @param {array} coord: the coord array to merge
		 * @param {boolean} suspendRefresh: true to not refresh the range
		 */
		mergeCoord : function(coord, suspendRefresh){
			this.coord = this.coord || []; 
			for(var i = 0, len = coord.length; i < len; i++){
				this.coord.push([].concat(coord[i]));
			}
			if(!suspendRefresh){
				this.refresh();
			}
		},
		
		/*
		 * check the passed row and col index is included in this range or not
		 */
		isIncluded : function(sheet, row, col, coord){
			coord = coord || this.coord;
			for(var i = 0, len = coord.length; i < len; i++){
				var it = coord[i];
				var span = it.span ? it.span : it;
				if(sheet == span[0] && 
					((row <= span[3] || 0 === span[3]) && row >= span[1]) && 
					((col <= span[4] || 0 === span[4]) && col >= span[2])
				){
					return true;
				}
			}
			return false;
		},
		
		/*
		 * find the span included the cell
		 */
		findIncludedSpan : function(sheet, row, col, coord){
			coord = coord || this.coord;
			for(var i = 0, len = coord.length; i < len; i++){
				var it = coord[i];
				var span = it.span ? it.span : it;
				if(sheet == span[0] && 
					((row <= span[3] || 0 === span[3]) && row >= span[1]) && 
					((col <= span[4] || 0 === span[4]) && col >= span[2])
				){
					return {
						span: span,
						index: i
					}
				}
			}
		},
              
        isCoordIncludeSpan : function(coord, span){
            for(var i = 0, len = coord.length; i < len; i++){
                var it = coord[i];
                if(it[0] === span[0] && it[1] <= span[1] && it[2] <= span[2] && (0 === it[3] || it[3] >= span[3]) && (0 === it[4] || it[4] >= span[4])){
                    return true;
                }
            }
            return false;
        },
              
        isCoordAIncludeCoordB : function(a, b){
            var pro = EnterpriseSheet.sheet.range.Range.prototype;
            for(var i = 0, len = b.length; i < len; i++){
                var span = b[i];
                if(!pro.isCoordIncludeSpan(a, span)){
                    return false;
                }
            }
            return true;
        },
		
		/**
		 * check the passed coord is a cell range coord or not
		 * @param {array} coord: an coordinate array, if null then use this.coord
		 * @return {boolean} : true means it's a cell range coord
		 */
		isCellCoord : function(coord){
			coord = coord || this.coord;
			for(var i = 0, len = coord.length; i < len; i++){
				var span = coord[i];
				if(0 !== span[3] && 0 !== span[4]){
					return true;
				}
			}
			return false;
		},
		
		/**
		 * expand the passed span to the around cell with content
		 */
		expandSpanWithContent : function(span, sheet){
			var sheetId = span[0], minrow = span[1], mincol = span[2], maxrow = span[3], maxcol = span[4];
			var store = sheet.getStore();
			if(0 === maxrow && 0 === maxcol){
				/*
				 * whole sheet
				 */
				store.each(function(rd){
					var row = rd.data.row, col = rd.data.col;
					if(rd.data.sheet === sheetId && 0 !== row && 0 !== col){
						var data = rd.data.json.data;
						if(!SCOM.nullOrUndefined(data) && '' !== data){
							if(row < minrow || 0 === minrow){
								minrow = row;
							}
							if(row > maxrow || 0 === maxrow){
								maxrow = row;
							}
							if(col < mincol || 0 === mincol){
								mincol = col;
							}
							if(col > maxcol || 0 === maxcol){
								maxcol = col;
							}
						}
					}
				});
				return [sheetId, minrow, mincol, maxrow, maxcol];
			}else if(0 === maxrow){
				/*
				 * column selection
				 */
				store.walkRange([span], function(rd){
					var row = rd.data.row, col = rd.data.col;
					if(rd.data.sheet === sheetId && 0 !== row && 0 !== col){
						var data = rd.data.json.data;
						if(!SCOM.nullOrUndefined(data) && '' !== data){
							if(row < minrow || 0 === minrow){
								minrow = row;
							}
							if(col < mincol){
								mincol = col;
							}
							if(col > maxcol){
								maxcol = col;
							}
						}
					}
				});
				return [sheetId, minrow, mincol, maxrow, maxcol];
			}else if(0 === maxcol){
				/*
				 * row selection
				 */
				store.walkRange([span], function(rd){
					var row = rd.data.row, col = rd.data.col;
					if(rd.data.sheet === sheetId && 0 !== row && 0 !== col){
						var data = rd.data.json.data;
						if(!SCOM.nullOrUndefined(data) && '' !== data){
							if(col < mincol || 0 === mincol){
								mincol = col;
							}
							if(col > maxcol || 0 === maxcol){
								maxcol = col;
							}
							if(row < minrow){
								minrow = row;
							}
							if(row > maxrow){
								maxrow = row;
							}
						}
					}
				});
				if(span[1] === span[3]){
					maxrow = 0;
				}
				return [sheetId, minrow, mincol, maxrow, maxcol];
			}else{
				/*
				 * cell selection
				 */
				if(minrow === maxrow){
					//return this.expandCell2Around(sheetId, minrow, mincol, sheet);
                    return [sheetId, minrow, mincol, 0, maxcol];
				}else{
					return span;
				}
			}
		},
		
		/**
		 * expand a cell to around
		 */
		expandCell2Around : function(sheetId, row, col, sheet){
			var separateChar = EnterpriseSheet.sheet.data.reader.CellReader.prototype.separateChar;
			var store = sheet.getStore();
			var minrow = row, maxrow = row, mincol = col, maxcol = col;
			var arr = [sheetId, row, col];
			var id = arr.join(separateChar);
			var lookup = {
				id: arr
			}, visited = {
				id: true
			};
			var extend = function(){				
				for(var p in lookup){
					if(lookup.hasOwnProperty(p)){
						var it = lookup[p];
						var s = it[0], r = it[1], c = it[2];
						var sr = r, er = r+1, sc = c, ec = c+1;
						if(1 < r){
							sr--;
						}
						if(1 < c){
							sc--;
						}
						for(var i = sr; i <= er; i++){
							for(var j = sc; j <= ec; j++){
								var arr = [s, i, j];
								var id = arr.join(separateChar);
								if(!visited[id]){
									visited[id] = true;
									var cell = store.getCell(s, i, j);
									var merged = store.isMergedCell(cell, s, i, j), wminrow, wmincol, wmaxrow, wmaxcol;
									if(merged){
										wminrow = i+cell.minrow;
										wmincol = j+cell.mincol;
										wmaxrow = i+cell.maxrow;
										wmaxcol = j+cell.maxcol;
										cell = store.getCell(s, wminrow, wmincol);
									}
									
									if(!SCOM.nullOrUndefined(cell.data) && '' !== cell.data){
										lookup[id] = arr;										
										/*
										 * process merged cell differently
										 */
										if(merged){											
											for(var x = wminrow; x <= wmaxrow; x++){
												for(var y = wmincol; y <= wmaxcol; y++){
													var tmp = [s, x, y];
													var wid = tmp.join(separateChar);
													if(!visited[wid]){														
														lookup[wid] = tmp;														
													}
												}
											}
										}
										if(i < minrow){
											minrow = i;
										}
										if(i > maxrow){
											maxrow = i;
										}
										if(j < mincol){
											mincol = j;
										}
										if(j > maxcol){
											maxcol = j;
										}
									}
								}
							}
						}
						delete(lookup[p]);
						break;
					}
				}
				if(!SCOM.isEmptyObj(lookup)){
					extend();
				}
			}
			extend();
			return [sheetId, minrow, mincol, maxrow, maxcol];
		}
	});
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.range.RangeField', {
	
	/* Begin Definitions */
		
	extend : 'Ext.form.field.Trigger',
	
	requires : ['EnterpriseSheet.sheet.calculate.Coordinate'],
	
	alias: 'widget.rangefield',
	
	withSheetName: true,
	
	/* End Definitions */
	
	triggerCls : 'ss-rng-trigger',
	
	initComponent : function(){
		if(this.normalModeLink){
			this.enableKeyEvents = true;
		}
		
		this.callParent();		
		
		if(this.sheet){
			this.mon(this.sheet, {
				scope:this,
				'referencechange':this.onReferenceChange,
				'movingreference': this.movingReference,
				'endmovereference': this.endMoveReference
				//'beforeswitchsheet': this.beforeSwitchSheet,
				//'switchsheet': this.onSwitchSheet
			});
		}	
		this.on({
			scope:this,
			'focus':this._onFocus,
			'keydown': this._onKeydown
		});
	},
	
	_onKeydown : function(field, e){
		
		var key = e.getKey();
		if((e.ESC == key || e.ENTER == key) && this.normalModeLink){
			var win = this.getMiniRangeBox();
			win.hide();
			this.normalModeLink.fireEvent('normalmode', win, this.normalModeLink);
			if(this.normalModeLink instanceof EnterpriseSheet.sheet.range.RangeField){
				this.normalModeLink.setValue(this.getValue());
			}
		}
	},
	
	_onFocus : function(){	
		var sheet = this.sheet;		
		/*
		 * we use prototype to save the focusId, which is use to check
		 * whether need update value when receive referencchange event
		 */
		EnterpriseSheet.sheet.range.RangeField.prototype.focusId = this.getEl().id;
		var v = this.getValue();
		if(EnterpriseSheet.sheet.calculate.Calculate.prototype.isCalculate(v)){			
			if(sheet){
				var coord = this.getCoord();	
				var rm = sheet.getReferenceModel();
				if(coord && coord.length){					
					rm.setReference(coord, false, true);				
				}			
			}
		}		
	},
	
	/*
	 * update the value when reference change
	 */
	onReferenceChange : function(region, rm){		
		if(!this._sheetSwitching){
			var el = this.getEl();
			
			if(el.isVisible(true) && EnterpriseSheet.sheet.range.RangeField.prototype.focusId == el.id){
				var ref = rm.getReference(true);	
				
				this.setValue(ref);
			}
		}		
	},	
	
	/*
	 *  moving reference
	 */
	movingReference : function(draggingCoordSpan, rm){
		var coord = [draggingCoordSpan.currentSpan];	
		
		this.setValue(coord);
	},
	
	endMoveReference : function(draggingCoordSpan, rm){
		//var coord = [draggingCoordSpan.currentSpan];
		//this.setValue(coord);		
		var ref = rm.getReference();
		this.setValue(ref);
	},
		
		
	/*
	 * transfer the string to coord and return
	 */
    getCoord : function(){
    	var store = this.sheet.getStore();
    	var v = this.getValue();
    	if(Ext.isString(v)){    		 
    		var tmp = v;
    		if(EnterpriseSheet.sheet.calculate.Calculate.prototype.isCalculate(v)){
    			try{
        			v = v.slice(1);
        			var oldStr = v;
    	    		v = EnterpriseSheet.sheet.calculate.Coordinate.prototype.string2Coord(v);
    	    		if(0 < v.length){
    	    			var str = EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String(v, undefined, '' !== v[0][0]);
        	    		
        	    		if(oldStr === str){
	        	    		for(var i = 0, len = v.length; i < len; i++){
	        	    			var it = v[i], span = it.span;
	        	    			if('' !== span[0] && 'string' == SCOM.typeOf(span[0])){
	        	    				span[0] = store.getSheetIdByName(span[0]);
	        	    			}	    			
	        	    		}
        	    		}else{
        	    			return;
        	    		}
    	    		}else{
    	    			return;
    	    		}    	    			  
        		}catch(e){
        			return;
        		}
    		}    		
    	}    	
    	return v;
    },
    
    /*
     * override set value
     */
    setValue : function(refs){       	
    	if(Ext.isArray(refs)){    				
			
			refs = this.sheet.coord2StringWithSheetName(refs, undefined, this.withSheetName);
			
			if(refs){
				refs = '='+refs;
			}		
    	}    	
    	
    	this.callParent([refs]);
    },
    
    /**
     * click on the trigger
     */
    onTriggerClick : function(){
    	if(!this.normalModeLink){
    		var win = this.getMiniRangeBox(undefined, this);        	
        	this.fireEvent('minimode', win, this);
        	win.show();
        	win.items.get(0).setValue(this.getValue());
    	}else{
    		var win = this.getMiniRangeBox();
        	win.hide();
        	this.normalModeLink.fireEvent('normalmode', win, this.normalModeLink);
        	if(this.normalModeLink instanceof EnterpriseSheet.sheet.range.RangeField){
        		this.normalModeLink.setValue(win.items.get(0).getValue());
        	}
    	}
    },
    
    /**
     * before switch sheet
     */
    beforeSwitchSheet : function(){
    	this._sheetSwitching = true;
    },
    
    /**
     * after swtich sheet
     */
    onSwitchSheet : function(){
    	this._sheetSwitching = false;
    }
}, function(){
	Ext.apply(EnterpriseSheet.sheet.range.RangeField.prototype, {
		/**
	     * get mini reference box
	     */
	    getMiniRangeBox : function(sheet, normalModeLink){
	    	sheet = sheet || this.sheet;
	    	var win = Ext.getCmp('ss-mini-reference-box');
	    	if(!win){
	    		win = new Ext.window.Window({
	    			id: 'ss-mini-reference-box',
	    			title: SLANG['drag_select_reference'],
	    			autoHeight: true,
	    			width: 300,
	    			resizable: false,
	    			bodyStyle: 'padding:5px;',
	    			closable: false,
	    			layout: 'anchor',
	    			items: [{
	    				xtype: 'rangefield',
	    				normalModeLink: normalModeLink || this,
	    				value: this.getValue(),
	    				withSheetName: this.withSheetName,
	    				sheet: sheet,
	    				anchor: '100%'
	    			}],
	    			getRangeField: function(){
	    				return win.items.get(0);
	    			},
	    			listeners: {
	    				'show': {
	    					fn: function(){
	    						/*
	    						 * disable the selectionModel and editor
	    						 */
	    						sheet.disableSelect();
	    						sheet.disableEdit();			
	    						/*
	    						 * enable reference model, clear the reference selection, and set it to single select mode 
	    						 */
	    						sheet.enableRefer(true, this.singleSelect, this.simpleSelect);
	    						win.items.get(0).focus(true, 100);;
	    					},
	    					scope: this
	    				},
	    				'hide': {
	    					fn: function(){
	    						sheet.enableSelect();
	    						sheet.enableEdit();
	    						/*
	    						 * disable reference model, clear the reference selection, and cancel the single select mode 
	    						 */
	    						sheet.disableRefer(true);
	    					},
	    					scope: this
	    				}
	    			}
	    		});
	    	}else if(normalModeLink){
	    		win.getRangeField().normalModeLink = normalModeLink;
	    	}
	    	return win;
	    }
	}); 
});
Ext.define('EnterpriseSheet.sheet.action.ClipBoard', {
	
	/* Begin Definitions */
	
	requires : [
	    'Ext.button.Button',	    
	    'Ext.container.ButtonGroup',
	    'EnterpriseSheet.sheet.range.Range',
	    'EnterpriseSheet.sheet.floating.Floor'
	],	
	
	/* End Definitions */
	
	/*
	 * the maximum stack length
	 */
	maxStackLength : 1,
	
	autoHideKitTime : 100000,
	
	constructor : function(config){
		Ext.apply(this, config);
		
		this.kitOffset = this.kitOffset || [5, 5];
		
		this.stack = [];	
		
		this.lastSSID = SCONST['SSID']+'$'+SCOM.genTimeStamp();
		
		this.initClipMenu();	
		
		/*
		 * init clip template
		 */
		this.initClipTpl();
		
		this.callParent();		
		
	},
	
	/*
	 * a xtemplate for generate clip html
	 */
	initClipTpl : function(){
		this.clipTpl = new Ext.XTemplate([		    
		    '<table name="{ssid}"><tbody>',
		    	'<tpl for="rows">',
		    		'<tr>',
		    			'<tpl for=".">',
		    				'<td>{data}</td>',
		    			'</tpl>',
		    		'</tr>',
		    	'</tpl>',
		    '</tbody></table>'		   
		].join(''), {
			compiled: true
		});
	},
	
	init : function(sheet){
		if(this.sheet){
			return;
		}
		this.sheet = sheet;
		sheet.on({
			scope:this,
			'changing': this.onChanging
		});	
		sheet.on('beforestartedit', this.hideClipKit, this);	
		/*
		 * listener the keypress evt 
		 */				
		sheet.on('keydown', this.onKeyDown, this);
        sheet.on('changereadonly', this.onChangeReadOnly, this);
	},
	
	/*
	 * when sheet change
	 */
	onChanging : function(){
		delete(this.clipRange);
		this.hideClipKit();
	},
	
	/*
	 * generate html for OS clipboard
	 */
	generateHTMLForClip : function(coord){
		var rows = [], span = coord[0];
		var minrow = span[1], mincol = span[2];
		var sheet = this.sheet, store = sheet.getStore();
		store.walkRange([span], function(rd){
			var row = rd.data.row, col = rd.data.col, sheetId = rd.data.sheet, json = rd.data.json;
			var roff = row-minrow, coff = col-mincol, flag = false;
			if(Ext.isDefined(json.minrow)){
				flag = (0 === json.minrow && 0 === json.mincol);
			}
			var cell = json;
			if(flag){
				cell = store.getCellData(sheetId, row, col);			
				if(!sheet.isCalculateCell(sheetId, row, col, cell)){
					cell = SFORMAT.transferFormat(cell, cell.fm);
				}
			}
			
			var len = rows.length;
			if(roff > len-1){
				var offset = roff-len+1;
				for(var i = 0; i < offset; i++){
					rows.push([]);
				}
			}
			var tr = rows[roff];
			var clen = tr.length;
			if(coff > clen-1){
				var offset = coff-clen+1;
				for(var i = 0; i < offset; i++){
					tr.push({});
				}
			}
			var data = cell.data;
			if(SCOM.nullOrUndefined(data)){
				data = '';
			}
			tr[coff].data = data;
		}, this);
		if(0 < rows.length){
			this.lastSSID = SCONST['SSID']+'$'+SCOM.genTimeStamp();
			var html = this.clipTpl.apply({
				ssid: this.lastSSID,
				rows: rows
			});			
			return html;
		}
		return '';
	},
	
	/*
	 * parse the str in clip area, try to transfer it to a row*col matrix for paste into the sheet
	 */
	parseFromClip : function(clip){
		var clipStr = clip.innerHTML;		
		if(clipStr && -1 != clipStr.indexOf(this.lastSSID)){
			/*
			 * if it's copy from enterprisesheet, then return nothing, because we already push the data into stack
			 */
			return false;
		}

		clip = Ext.get(clip);
		var sheet = this.sheet, sm = sheet.getSelectionModel(), store = sheet.getStore();
		var sheetId = sheet.getSheetId();
		var table = clip.down('table');
		var focusCell = sm.getFocusCell();
		var focusRow = focusCell.row, focusCol = focusCell.col;
		var rowLen, colLen = 0, lookup = [];
		if(table){
			var trs = Ext.DomQuery.jsSelect('tr', table.dom);
			rowLen = trs.length;
			for(var i = 0; i < rowLen; i++){
				var tr = trs[i];
				var tds = Ext.DomQuery.jsSelect('td', tr);
				var len = tds.length;
				if(colLen < len){
					colLen = len;
				}
				var cols = [];
				for(var j = 0; j < len; j++){
					var td = tds[j];
					var html = td.innerHTML;
					var data = '';
					if(html){
						data = SCOM.getInnerText(td);
					}
					cols.push(data);
				}
				lookup.push(cols);
			}
		}else{
			var colIndex = 0, arr = [];
			var parseTxt = function(str){
				var rows = str.split('\n');
				for(var j = 0, size = rows.length; j < size; j++){
					var it = rows[j];
					var cols = it.split('\t');
					colIndex += cols.length;
					if(colIndex > colLen){
						colLen = colIndex;
					}
					arr = arr.concat(cols);
					lookup.push(arr);
					arr = [];
					colIndex = 0;
				}
			}
			
			for(var i = 0, len = clip.dom.childNodes.length; i < len; i++){
				var child = clip.dom.childNodes[i];
				var nodeType = child.nodeType;
				
				if(3 == nodeType){
					var txt = child.nodeValue;
					if(txt){
						txt = Ext.String.trim(txt);
						if(txt){
							parseTxt(txt);
						}
					}
				}else if(1 == nodeType){
					var tagName = child.tagName.toUpperCase();
					if('P' == tagName || 'DIV' == tagName){
						colIndex = 0;
						arr = [];
						var txt = SCOM.getInnerText(child);
						if(txt){
							txt = Ext.String.trim(txt);
							if(txt){
								parseTxt(txt);
							}
						}
					}else if('BR' == tagName){
						colIndex = 0;
						arr = [];
					}else{
						var txt = SCOM.getInnerText(child);
						if(txt){
							txt = Ext.String.trim(txt);
							if(txt){
								parseTxt(txt);
							}
						}
					}
				}
			}
			rowLen = lookup.length;
		}
		var coord = [[sheetId, focusRow, focusCol, focusRow+rowLen-1, focusCol+colLen-1]];
		var range = new EnterpriseSheet.sheet.range.Range({
			sheet: sheet,
			coord: coord
		});
		var flag = false;
		for(var i = 0; i < rowLen; i++){
			var row = lookup[i];
			for(var j = 0, len = row.length; j < len; j++){				
				var rowIndex = focusRow+i, colIndex = focusCol+j;
				var pro = store.getCellProperty(sheetId, rowIndex, colIndex);
				if(store.isDisabledForMe(pro.dsd)){
					flag = true;
					break;
				}
			}
		}
		var nextFn = function(){
			if(false !== sheet.fireEvent('beforepaste', range, sheet)){
				var changedHeights = {};
				/*
				 * get the cells need recalculated
				 */
				var reCalCells = sheet.getRecalculateCellsByCoord(coord);
				sheet.fireEvent('preparepaste', range, sheet, undefined, reCalCells, changedHeights);
				
				for(var i = 0; i < rowLen; i++){
					var row = lookup[i];
					for(var j = 0, len = row.length; j < len; j++){
						var data = row[j];
						if(SCOM.nullOrUndefined(data)){
							data = '';
						}
						var rowIndex = focusRow+i, colIndex = focusCol+j;
						var pro = store.getCellProperty(sheetId, rowIndex, colIndex);
						if(!store.isDisabledForMe(pro.dsd)){
							data = SCOM.skipBlankForCommaOrPercent(data);
							var o = {data:data};
							if(!SCOM.isEmptyValue(data)){
								Ext.apply(o, SFORMAT.decideFormat(data));
							}
							sheet.setCell(sheetId, rowIndex, colIndex, o, null, true);
						}
					}
				}
				/*
				 * check autoHeight for ralted range
				 */
				Ext.apply(changedHeights, sheet.checkAutoHeightForCoord(null, coord, false, true));
				
				/*
				 * extend the recalculated cells
				 */
				Ext.applyIf(reCalCells, sheet.getCalCdtCellsFromCoord(coord));
				/*
				 * need refresh the calculate and condition cells too
				 */
				sheet.refreshRange(coord, reCalCells);
				/*
				 * try to select the range
				 */
				range.select();		
				sheet.refreshFocus();
				/*
				 * fire paste event
				 */
				sheet.fireEvent('paste', range, sheet, lookup, undefined, reCalCells);
			}
		}
		if(flag){
			Ext.Msg.show({
				title: SLANG['hint'], 
				msg: SLANG['confirm_process_action_on_disabled_cell'],
				buttons: Ext.Msg.YESNO,
				fn: function(bid){
					if('yes' === bid){
						return;
					}else{
						nextFn.call(this);
					}
				},
				scope: this
			});
		}else{
			nextFn.call(this);
		}
		return true;
	},
	
	getFocusEl : function(){
		var editor = this.sheet.getEditor();
		return editor.getEditorEl();
	},
	
	/*
	 * detect ctrl+c/ctrl+x/ctrl+v 
	 */	
	onKeyDown : function(e){		
		var key = e.getKey();		
		if(e.ctrlKey){			
			var clipRange = false, flag;
			var sm = this.sheet.getSelectionModel();
			var coord = sm.selection2Coord();
			if(99 == key || 67 == key){//press c
				flag = 'copy';				
			}else if(88 == key){//press x
				flag = 'cut';				
			}else if(86 == key){//press v
				var clipArea = this.getFocusEl().dom;
				SCOM.selectAll(clipArea);
				Ext.Function.defer(function(){			
					
					if(!this.parseFromClip(clipArea)){
						this.paste(undefined, SCONFIG['DEFAULT_PASTE_TYPE']);
					}
					clipArea.innerHTML = '';
				}, this.sheet.focusDelayTime, this);
			}	
			if(flag){
				/*
				 * put data to OS clipboard through the focus div element
				 */
				var clipEl = this.getFocusEl();
				
				var clipArea = clipEl.dom;				
				var html = this.generateHTMLForClip(coord);
				
				if(SCOM.nullOrUndefined(html)){
					html = '';
				}
				
				clipArea.innerHTML = html;
				SCOM.selectAll(clipArea);	
				
				Ext.Function.defer(function(){					
					clipArea.innerHTML = '';
					if('cut' === flag){
						this.cut();
					}else{
						this.copy();
					}
				}, this.sheet.focusDelayTime, this);
			}
		}
	},
	
	/*
	 * copy the selection to the clipboard, actually just save the range not 
	 * the real data
	 */
	copy : function(coord, clearFlag){
		var sheet = this.sheet;
		if(!coord){
			var sm = sheet.getSelectionModel();
			var coord = sm.selection2Coord();			
		}		
		
		//var rm = sheet.getReferenceModel()
		//rm.setReference([{span: span, colorIndex: 1}], true, false, 'ss-copy-ref');
		//rm.show();		
		var range = new EnterpriseSheet.sheet.range.Range({
			sheet:sheet,
			coord:coord
		});
		if(this.stack.length > this.maxStackLength){
			this.stack.splice(0, this.stack.length-this.maxStackLength);
		}
		/*
		 * save into the stack for retrace the history
		 */
		this.stack.push(range);
		this.clipRange = range;
		/*
		 * remove the clearFlag
		 */
		delete(this.clearFlag);
		/*
		 * fire a copy event through sheet
		 */
		sheet.fireEvent('copy2clip', range, sheet, this);
		
        this.clearFlag = clearFlag;
		return range;
	},
	

	/*
	 * cut the data to clipboard, it will be the same as copy, but it will clean the origin data after paste
	 */
	cut : function(){
		var res = this.copy(undefined, true);

		return res;
	},		

	
	/*
	 * paste the data from the clipboard to sheet
	 * @param {int} index: the index of the data in clipboard to paste,
	 * if null/undefined then use the last one
     * @param {String} pasteType: the paste type, can be one of "default", "data", "style" or "reverse", if empty then means "default"
     * @param {Boolean} sclient: true to not show the pasteTypeKit beside the cell after pasted
     * @param {Array} toCoord: the coord to paste, if not define then use the selection coord
     * @param {Boolean} notUpdateSelection: true means not select the pasted range
	 */
	paste : function(index, pasteType, sclient, toCoord, notUpdateSelection){		
		if(!this.clipRange || !(this.stack && this.stack.length)){
			return;
		}
		var sheet = this.sheet;
		var sm = sheet.getSelectionModel(), store = sheet.getStore();
		
		var clipRange = this.clipRange;
			
		var curSheetId = sheet.getSheetId();		
		if(false == SCOM.typeOf(index)){
			index = this.stack.length-1;
		}
		var range = this.clipRange.clone();		
		/*
		 * for merged range, can not paste reverse
		 */
		if(range.includeMergedCell() || !range.isCellRange()){
			this.reversePasteBtn.hide();
		}else{
			this.reversePasteBtn.show();
		}
		if(range.isInSingleSheet()){	
			/*
			 * get the left-top cell of the range
			 */
			var minPos = range.getMinPos(), oldMinRow = minPos.row, oldMinCol = minPos.col;			
			var curCoordSpan = toCoord || sm.selection2Span();
			
			var row = curCoordSpan[1], col = curCoordSpan[2];
			/*
			 * calculate the row/col offset
			 */
			var rowOffset = row-minPos.row, colOffset = col-minPos.col;						
			
			var oldRange = range.clone();
			var oldCoord = oldRange.getCoord(), oldCoordSpan = oldCoord[0];
			
			var oldRowSpan = 0 == oldCoordSpan[3] ? 0 : oldCoordSpan[3]-oldCoordSpan[1]+1, oldColSpan = 0 == oldCoordSpan[4] ? 0 : oldCoordSpan[4]-oldCoordSpan[2]+1;
			var curRowSpan = 0 == curCoordSpan[3] ? 0 : curCoordSpan[3]-curCoordSpan[1]+1, curColSpan = 0 == curCoordSpan[4] ? 0 : curCoordSpan[4]-curCoordSpan[2]+1;
			/*
			 * check whether the paste range is the same shape as the copy range
			 */
			if(((0 == oldRowSpan || 0 == curRowSpan) && oldRowSpan != curRowSpan) ||
				((0 == oldColSpan || 0 == curColSpan) && oldColSpan != curColSpan)){
				Ext.Msg.alert(SLANG['hint'], SLANG['paste_copy_not_same_shape']);
				return;
			}
			
			var rowProp = 1, colProp = 1;
			if(1 == oldCoord.length){
				prop = this.isFactorSpan(oldCoordSpan, curCoordSpan);
				if(prop){
					var tmpSpan = [].concat(oldCoordSpan);
					tmpSpan[3] = tmpSpan[1]+curCoordSpan[3]-curCoordSpan[1];
					tmpSpan[4] = tmpSpan[2]+curCoordSpan[4]-curCoordSpan[2];
					
					/*
					 * expand the coord
					 */
					range.setCoord([tmpSpan]);
					rowProp = prop.rowProp;
					colProp = prop.colProp;
				}
			}	
           
			/*
			 * move the range to the paste coord
			 */			
			range.moveCoord(curSheetId, rowOffset, colOffset);
			var newCoord = range.getCoord();
			curCoordSpan = newCoord[0];
			
			var nextFn = function(){
				/*
				 * avoid hideClipKit
				 */
				this.suspendHideFlag = true;	
				/*
				 * check whether there is merged cell not fully included in this move action
				 */
				var coord = [oldCoordSpan, curCoordSpan];
				if(store.withBrokenMergedCell(coord)){
					Ext.Msg.alert(SLANG['hint'], SLANG['can_not_change_part_merged_cell']);
					return;
				}		
				coord = [curCoordSpan];
				if('reverse' == pasteType){					
					/*
					 * reverse the range
					 */
					range.reverseCoord();	
					/*
					 * add reversed coord for further refresh
					 */
					var tmpCoord = range.getCoord();
					curCoordSpan = tmpCoord[0];
					coord = coord.concat(tmpCoord);
				}
	
				/*
				 * get the left-top cell of the moved range
				 */
				minPos = range.getMinPos();
				var newRange = range.clone();
				if(this.clearFlag){
					/*
					 * if it's cut then merge the old range
					 */
					newRange.mergeCoord(oldCoord, true);
				}
				/*
				 * fire beforepaste event by sheet, cancel the paste process if listener return false
				 */
				if(false !== sheet.fireEvent('beforepaste', newRange, sheet)){
					/*
					 * a lookup cache and count for record the condition id,
					 * for condition cell, when we copy/paste, we need reset the id, because it could be different with
					 * the original condition, with the same id, we can not list them all in the condition manager
					 */
					var lookup = {}, cdtMap = {};
					var oldCdt = sheet.getCdtsFromCoord(oldCoord), originCdts = {}, newCdts = {};
					for(var p in oldCdt){
						if(oldCdt.hasOwnProperty(p)){
							var it = oldCdt[p];
							var id = Ext.id()+'-'+SCOM.genTimeStamp();
							lookup[p] = id;
							newCdts[id] = {
								sheet: oldCoordSpan[0],
								name: id
							};
							originCdts[id] = {
								sheet: oldCoordSpan[0],
								name: id	
							};
							/*
							 * if clear the old range then also need add old cdt 
							 */
							if(this.clearFlag){
								originCdts[p] = it;
							}
							cdtMap[p] = {
	                            id: id,
								sheet: curCoordSpan[0],
								cdt: Ext.decode(it.json)
							};
						}
					}
	                var oldCellCdtLookup = {};
	                store.walkRange(oldCoord, function(rd){
	                    var sid = rd.data.sheet, r = rd.data.row, c = rd.data.col;
	                    var cdt = sheet.getConditionOfCell(sid, r, c);
	                    if(0 < cdt.length){
	                        var id = [sid, r+rowOffset, c+colOffset].join(store.separateChar);
	                        oldCellCdtLookup[id] = cdt;
	                    }
	                }, this);
					/*
					 * get the cells which need recalculated
					 */
					var reCalCells = sheet.getRecalculateCellsByCoord(newRange.coord);
					var changedHeights = {};
					/*
					 * fire prepare event to let history prepare undo/redo
					 */
					sheet.fireEvent('preparepaste', newRange, sheet, originCdts, reCalCells, changedHeights);				
					
					/*
					 * cache the origin data
					 */
					var originCache = {};
					store.walkRange(oldCoord, function(rd, walkSpan, store, internalId){
						var cd = store.getCellProperty(rd.data.sheet, rd.data.row, rd.data.col, true);
						originCache[internalId] = cd;
					});
					
					/*
					 * clean the dest range first
					 */
					range.clean(true, undefined, true, true);
	                var refs = [];
					for(var r = 0; r < rowProp; r++){
						var roff = rowOffset+r*oldRowSpan;
						for(var c = 0; c < colProp; c++){
							var coff = colOffset+c*oldColSpan;
							store.walkRange(oldCoord, function(rd, walkSpan, store, internalId){
								
								var oldRow = rd.data.row, oldCol = rd.data.col;					
								/*
								 * get from cache
								 */
								var cd = originCache[internalId];
								var nowRow = Number(rd.data.row)+roff, nowCol = Number(rd.data.col)+coff;
								
								if('reverse' == pasteType){
									/*
									 * for reverse paste
									 */
									var tmp = nowRow-minPos.row;
									nowRow = minPos.row+nowCol-minPos.col;
									nowCol = minPos.col+tmp;
								}
								var cell = store.getCellProperty(curSheetId, nowRow, nowCol);
								if(!store.isDisabledForMe(cell.dsd)){
									cd = sheet.prepareForMoveCell(cd, curSheetId, nowRow, nowCol, rd.data.sheet, oldRow, oldCol, lookup, pasteType);
		                            if(cd.cal && cd.refs){
		                                refs = refs.concat(cd.refs);
		                            }
		                            /*
		                             * remove the disabled property
		                             */
		                            delete(cd.dsd);
									/*
									 * save the copied cell to the dest
									 */								
									store.setCell(curSheetId, nowRow, nowCol, cd, null, true, 'data' != pasteType ? 'clear' : null);
								}
							}, this);
						}
					}								
										
					/*
					 * save the last clearFlag
					 */
					this.lastClearFlag = this.clearFlag;
					if(this.clearFlag){					
						delete(this.clearFlag);
						coord = coord.concat(oldRange.getCoord());
						oldRange.clean(true, range, true);
						sheet.getReferenceModel().hide();
					}	
					/*
					 * check autoHeight for ralted range
					 */
					if(range.isCellCoord()){
						Ext.apply(changedHeights, sheet.checkAutoHeightForCoord(this.lastClearFlag ? null : oldCoord, coord, false, true));
					}
	           
					/*
					 * set condition for toSpan
					 */
					sheet.syncConditonForCoord([curCoordSpan], newCdts, cdtMap, oldCellCdtLookup);
					/*
					 * extend the recalculated cells
					 */
					Ext.applyIf(reCalCells, sheet.getCalCdtCellsFromCoord([curCoordSpan]));
					/*
					 * need refresh the calculate and condition cells too
					 */
					//sheet.refreshRange(coord, reCalCells);
	                if(0 < refs.length){
	                    sheet.loadMask.show(SLANG['calculating'], sheet.calMaskDelayTime);
	                    store.checkLoadCoord(refs, function(){
	                        sheet.refreshRange(undefined, reCalCells);
	                        sheet.loadMask.hide();
	                    }, this);
	                }else{
	                    sheet.refreshRange(undefined, reCalCells);
	                }
	
	                if(!notUpdateSelection){
	                    /*
	                     * try to select the range
	                     */
	                    range.select();
	                    sheet.refreshFocus();
	                }
					if(!sclient){
						this.showClipKit(range);
					}				
					/*
					 * fire paste event
					 */
					sheet.fireEvent('paste', newRange, sheet, clipRange, originCdts, reCalCells);
				}
				delete(this.suspendHideFlag);
				if(!this.lastClearFlag){
					this.clipRange = clipRange;
				}else{
					delete(this.clipRange);
				}
			}
			if(store.isCoordContainDisabledCell(newCoord)){
				Ext.Msg.show({
					title: SLANG['hint'], 
					msg: SLANG['confirm_process_action_on_disabled_cell'],
					buttons: Ext.Msg.YESNO,
					fn: function(bid){
						if('yes' === bid){
							return;
						}else{
							nextFn.call(this);
						}
					},
					scope: this
				});				
			}else{
				nextFn.call(this);
			}
		}		
	},
	
	/*
	 * check whether the size of first span is a factor of the second span 
	 */
	isFactorSpan : function(factor, mother){
		var mRowSpan = mother[3]-mother[1]+1, mColSpan = mother[4]-mother[2]+1;
		var fRowSpan = factor[3]-factor[1]+1, fColSpan = factor[4]-factor[2]+1; 
		var flag = 0 == mRowSpan%fRowSpan && 0 == mColSpan%fColSpan;
		if(flag){
			var rowProp = Math.floor(mRowSpan/fRowSpan);
			var colProp = Math.floor(mColSpan/fColSpan);
			return {
				rowProp: rowProp,
				colProp: colProp
			}
		}
	},
	
	initClipMenu : function(){
		if(!this.clipMenu){
			this.reversePasteBtn = new Ext.button.Button({
				iconCls:'icon-reverse-paste24',
				scale:'medium',
				tooltip:SLANG['paste_reverse'],
				handler:this.pasteReverse
			});
			this.clipMenu = new Ext.menu.Menu({
				plain:true,										
				items:['<b class="menu-title">'+SLANG['paste']+'</b>', {
					xtype:'buttongroup',
					frame:false,
					border:false,
					columns:4,
					defaults:{
						style:'padding:2px;',						
						scope:this
					},					
					items:[{
						iconCls:'icon-default-paste24',
						scale:'medium',
						tooltip:SLANG['paste'],
						handler:this.pasteDefault
					}, {
						iconCls:'icon-calculate-paste24',
						scale:'medium',
						tooltip:SLANG['paste_calculate'],
						handler:this.pasteData
					}, /*{
						iconCls:'icon-calculate-format-paste24',
						scale:'medium',
						tooltip:SLANG['paste_calculate_format']
					},*/ {
						iconCls:'icon-style-paste24',
						scale:'medium',
						tooltip:SLANG['paste_style'],
						handler:this.pasteStyle
					}, this.reversePasteBtn]
				}/*, '<b class="menu-title">'+SLANG['paste_number']+'</b>', {	
					xtype:'buttongroup',
					frame:false,
					border:false,
					columns:4,
					defaults:{
						style:'padding:2px;',						
						scope:this
					},
					items:[{
						iconCls:'icon-value-paste24',
						scale:'medium',
						tooltip:SLANG['paste_value']
					}, {
						iconCls:'icon-value-format-paste24',
						scale:'medium',
						tooltip:SLANG['paste_value_format']	
					}, {
						iconCls:'icon-value-style-paste24',
						scale:'medium',						
						tooltip:SLANG['paste_value_style']						
					}]
				}*/]			
			}); 
		}
	},
	
	/*
	 * show a clip tool kit on the UI
	 */
	showClipKit : function(range){
		var maxPos = range.getMaxPos();
		var store = this.sheet.getStore(), sheetId = this.sheet.getSheetId();
		var x = store.getRangeWidth(sheetId, 1, maxPos.col)+this.kitOffset[0];
		var y = store.getRangeHeight(sheetId, 1, maxPos.row)+this.kitOffset[1];
		
		if(!this.clipKit){
			
			this.clipKit = new EnterpriseSheet.sheet.floating.Floor({
				sheet:this.sheet,
                localKit: true,
				floatingConfig:{
					xtype:'button',
					iconCls:'icon-paste',
					x:x,
					y:y,
					ddConfig:false,
					resizeConfig:false,
					destroyMenu: false,
					menu: true,
                    handler: function(btn){
                        this.clipMenu.showBy(btn);
                    },
                    scope: this
				}
			});
		}else{			
			/*
			 * register to the sheet
			 */
			this.sheet.registerFloor(this.clipKit, true);
			this.clipKit.setXY([x, y]);
			this.clipKit.show();
			delete(this.clipMenu.floatParent);
		}	
		/*
		 * auto hide after a while
		 */
		Ext.Function.defer(function(){
			this.hideClipKit();
		}, this.autoHideKitTime, this);
	},
	
	/*
	 * hide the clipKit and destory related comp
	 */
	hideClipKit : function(){
		if(this.clipKit && !this.suspendHideFlag){				
			this.clipKit.destroy();
			delete(this.clipKit);
		}
	},
	
	pasteStyle : function(){		
		this.sheet.fireEvent('undo', true);		
		this.clearFlag = this.lastClearFlag;
		this.paste(null, 'style');
		if(this.clipMenu){
			this.clipMenu.hide();
		}
	},
	
	pasteDefault : function(){			
		this.sheet.fireEvent('undo', true);		
		this.clearFlag = this.lastClearFlag;
		this.paste();
		if(this.clipMenu){
			this.clipMenu.hide();
		}
	},
	
	pasteData : function(){		
		this.sheet.fireEvent('undo', true);		
		this.clearFlag = this.lastClearFlag;
		this.paste(null, 'data');
		if(this.clipMenu){
			this.clipMenu.hide();
		}
	},
	
	pasteReverse : function(){		
		this.sheet.fireEvent('undo', true);		
		this.clearFlag = this.lastClearFlag;
		this.paste(null, 'reverse');
		if(this.clipMenu){
			this.clipMenu.hide();
		}
	},
	
	/**
	 * insert the copied range
	 */
	insertCopyRange : function(){
		var range = this.clipRange, newRange = range;
		var sheet = this.sheet;
		var sheetId = sheet.getSheetId();
		var store = sheet.getStore();
		var coord = range.getCoord();
		var span = coord[0];
		var sm = sheet.getSelectionModel();
		var pos = sm.getMinMaxPos();	
		
		var mincol = pos.mincol, minrow = pos.minrow;		
		var colSpan = span[4]-span[2]+1;
		var rowSpan = span[3]-span[1]+1;
		var maxrow = minrow+rowSpan-1;
		var maxcol = mincol+colSpan-1;
		
		if(EnterpriseSheet.sheet.calculate.Coordinate.prototype.isOverlappedSpan(span, [sheetId, minrow, mincol, maxrow, maxcol])){
			Ext.Msg.alert(SLANG['hint'], SLANG['insert_copy_overlap']);
			return;
		}
		var clearFlag = this.clearFlag;		
		if(0 === maxrow){	
			/*
			 * fire event through sheet
			 */				
			if(false !== sheet.fireEvent('beforeinsertcopied', pos, span, this)){					
				store.insertColumn(sheetId, mincol, colSpan);
				if(mincol < span[2]){
					span[2] += colSpan;
					span[4] += colSpan;
				}
				this.copy([span]);
				this.clearFlag = clearFlag;
				sm.selectRange({row: minrow, col: mincol}, {row: maxrow, col: maxcol});
				this.paste(undefined, undefined, true);
				if(clearFlag){						
					store.removeColumn(sheetId, span[2], span[4]);
				}
				sheet.fireEvent('insertcopied', pos, span, this);
			}			
			if(this.clearFlag){
				delete(this.clipRange);
			}
		}else if(0 === maxcol){
			/*
			 * fire event through sheet
			 */					
			if(false !== sheet.fireEvent('beforeinsertcopied', pos, span, this)){					
				store.insertRow(sheetId, minrow, rowSpan);
				if(minrow < span[1]){
					span[1] += rowSpan;
					span[3] += rowSpan;
				}
				this.copy([span]);
				this.clearFlag = clearFlag;
				sm.selectRange({row: minrow, col: mincol}, {row: maxrow, col: maxcol});
				this.paste(undefined, undefined, true);
				if(clearFlag){						
					store.removeRow(sheetId, span[1], span[3]);
				}
				sheet.fireEvent('insertcopied', pos, span, this);
			}	
			if(this.clearFlag){
				delete(this.clipRange);
			}
		}else{		
			SPOP.showInsertCopiedCellOption({
				applyCallback:{
					fn:function(opt){									
						if(0 === opt){
							maxrow = minrow+rowSpan-1;
							maxcol = mincol+colSpan-1;
							var flag = (mincol === span[2] && maxcol === span[4]);
							if(!flag){
								if((mincol >= span[2] && mincol <= span[4]) || (maxcol >= span[2] && maxcol <= span[4]) ||
									(mincol <= span[2] && maxcol >= span[2]) || (mincol <= span[4] && maxcol >= span[4])){
									Ext.Msg.alert(SLANG['hint'], SLANG['insert_copy_overlap']);
									return;
								}
							}
							/*
							 * fire event through sheet
							 */
							if(false !== sheet.fireEvent('beforeinsertcopied', pos, span, this)){	
								
								sheet.insertCellMoveBottom(sheetId, {
									minrow: minrow, 
									maxrow: maxrow,
									mincol: mincol,
									maxcol: maxcol
								});
								if(flag && minrow < span[1]){
									span[1] += rowSpan;
									span[3] += rowSpan;
								}
								this.copy([span]);
								this.clearFlag = clearFlag;
								sm.selectRange({row: minrow, col: mincol}, {row: maxrow, col: maxcol});
								this.paste(undefined, undefined, true);
								if(clearFlag){						
									sheet.deleteCellMoveTop(span[0], {
										minrow: span[1], 
										mincol: span[2],
										maxrow: span[3],
										maxcol: span[4]
									});
								}
								sheet.fireEvent('insertcopied', pos, span, this);
								if(this.clearFlag){
									delete(this.clipRange);
								}
							}
						}else{
							maxrow = minrow+rowSpan-1;
							maxcol = mincol+colSpan-1;
							var flag = (minrow === span[1] && maxrow === span[3]);
							if(!flag){
								if((minrow >= span[1] && minrow <= span[3]) || (maxrow >= span[1] && maxrow <= span[3]) ||
									(minrow <= span[1] && maxrow >= span[1]) || (minrow <= span[3] && maxrow >= span[3])){
									Ext.Msg.alert(SLANG['hint'], SLANG['insert_copy_overlap']);
									return;
								}
							}
							/*
							 * fire event through sheet
							 */
							if(false !== sheet.fireEvent('beforeinsertcopied', pos, span, this)){			
								
								sheet.insertCellMoveRight(sheetId, {
									minrow: minrow, 
									maxrow: maxrow,
									mincol: mincol,
									maxcol: maxcol
								});
								if(flag && mincol < span[2]){
									span[2] += colSpan;
									span[4] += colSpan;
								}
								this.copy([span]);
								this.clearFlag = clearFlag;
								sm.selectRange({row: minrow, col: mincol}, {row: maxrow, col: maxcol});
								this.paste(undefined, undefined, true);
								if(clearFlag){						
									sheet.deleteCellMoveLeft(span[0], {
										minrow: span[1], 
										mincol: span[2],
										maxrow: span[3],
										maxcol: span[4]
									});
								}
								sheet.fireEvent('insertcopied', pos, span, this);
							}
							if(this.clearFlag){
								delete(this.clipRange);
							}
						}
					},
					scope: this
				}
			});						
		}
		
		this.lastClearFlag = this.clearFlag;
	},
           
    onChangeReadOnly : function(readOnly, sheet){
        if(readOnly){
            this.hideClipKit();
        }
    }
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.pop.NumberSpecialWin', {
	
	/* Begin Definitions */
		
	extend : 'EnterpriseSheet.common.pop.PopWin',
	
	requires: [
	    'Ext.form.field.Text'
	],
	
	/* End Definitions */
	width : 450,    	
	
	height: 300,
        
	layout : 'border',

	bodyStyle: 'padding:15px;background-color:white;',
	
	prepareButton : Ext.emptyFn,
	
	cancelText: SLANG['close'],
	
	title: SLANG['formatCells'],
	
	locale: SCONFIG.default_locale,
	
	closeAction: 'hide',
	
	formatWith: null,
	
	/**
	 * an empty function to override
	 */
	checkValid : function(){
		return true;
	},
	
	initComponent : function(){
		
		var locales = Ext.create('Ext.data.Store', {
	        fields: ['id', 'name'],
	        data: SCONST.locale_list
		});
		this.localeCombo = Ext.create('Ext.form.field.ComboBox', { 
			fieldLabel: SLANG['locale'],
            editable:false,
            store : locales,
            displayField:'name',
            valueField:'id',
            queryMode :'local',
            triggerAction:'all',
            width: 305,
            forceSelection: true,
            listeners : {
                'select' : {
                    fn : this._onLocaleComboSelectFn,
                    scope : this
                }
            }
        }); 
		
		this.hintField = Ext.create('Ext.form.field.Display', {
			fieldLabel: SLANG['type'],
			anchor: '100%'
		});

		this.typeStore = Ext.create('Ext.data.Store', {
			fields: ['id', 'name'],
			data: [{id: '0', name: "0"}]
	    });
		this.listView = new Ext.grid.Panel({
	        region: 'center',
	        store: this.typeStore,
	        multiSelect: false,
	        hideHeaders: true,
	        columns: [{
	            text: 'Name',
	            flex: 1,
	            dataIndex: 'name'
	        }]
	    });
		
		this.items = [{
			xtype: 'container',
			region: 'north',
			layout: 'anchor',
			items: [this.localeCombo, this.hintField]
		}, this.listView];
		
		this.dockedItems = [{
			xtype: 'container',
			dock: 'right',
			width: 100,
			style: 'padding:0px 10px;',
			layout: {
				type: 'vbox',
				align: 'stretch'
			},
			items: [{
				xtype: 'button',
				text: this.okText,
				handler: this.onOK,
				scope: this
			}, {
				xtype: 'button',
				text: this.cancelText,
				style: 'margin-top:10px;',
				handler: this.onCancel,
				scope: this
			}]
		}];
				
		this.callParent();		
		
		this.mon(this.listView, {
			scope: this,
			'selectionchange': this.onSelectionChange,
			'itemdblclick' : this.onDoubleClick
		});
		
	},
	
	popup : function(){		
		this.show();
		this.localeCombo.setValue(this.locale);
		
		// init the value for listview
		this.initStore();
	},
	
	/**
	 * init store
	 */
	initStore : function() {
		this.typeStore.removeAll();	
		
		var items = [], today = new Date(); 
		var localeList = SCONST[this.locale+'_number_special'];
		for(var i = 0, len = localeList.length; i < len; i++){
    		var fm = localeList[i];
    		items.push({
    			name: fm.name,
    			id: fm.id
    		});
    	}
		
		this.typeStore.add(items);
	},
		
	onKeyPress : function(field, e){
		var key = e.getKey();
		var keyObj = Ext.EventObject ? Ext.EventObject : Ext.event.Event;
		if(keyObj.ENTER == key){
			this.onOK();
		}
	},
	
	_onLocaleComboSelectFn : function(combo, rd, index){
        this.locale = combo.getValue();
        this.initStore();
    },
	
	onOK : function() {
		if (this.formatWith) {
			this.sheet.setSpecialFormatForSelection(this.formatWith);
			this.hide();
		} 
	},
	
	/**
	 * when selection change of list view
	 */
	onSelectionChange : function(sm, selection){
		if(0 < selection.length){
			var sel = selection[0];
			this.formatWith = sel.data.id;	
		} else 
			this.formatWith = null;
	},
	
	onDoubleClick : function(dv, record, item, index, e){
		this.sheet.setSpecialFormatForSelection(record.data.id);
		this.hide();
	},
	
	/*
	 * bind sheet for handler use
	 */
	bindSheet : function(sheet){
		this.sheet = sheet;
	}
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.pop.NumberCustomWin', {
	
	/* Begin Definitions */
		
	extend : 'EnterpriseSheet.common.pop.PopWin',
	
	requires: [
	    'Ext.form.field.Text',
        'EnterpriseSheet.sheet.data.CustomStore',
        'EnterpriseSheet.common.Helper'
	],
	
	/* End Definitions */
	width : 600,    	
	
	height: 400,
        
	layout : 'border',
	
	labelWidth : 80,
	
	bodyStyle: 'padding:15px;background-color:white;',
	
	prepareButton : Ext.emptyFn,
	
	cancelText: SLANG['close'],
	
	deleteText: SLANG['delete'],
	
	listEmptyText: SLANG['none'],
	
	title: SLANG['customFormat'],
	
	/**
	 * an empty function to override
	 */
	checkValid : function(){
		return true;
	},
	
	initComponent : function(){
		
		this.nameField = new Ext.form.field.Text({
			labelAlign: 'top',
			fieldLabel: SLANG['customEnter'],			
			allowBlank:false,
			enableKeyEvents:true,	
			value: this.nameValue,
			listeners:{
				'keypress':{
					fn:this.onKeyPress,
					scope:this
				}
			},
			anchor: '100%'
		});
		
		this.positiveField = new Ext.form.field.Display({
			fieldLabel: SLANG['positive'],
			name: 'positive',
			hidden: true
		});
		
		this.negativeField = new Ext.form.field.Display({
			fieldLabel: SLANG['negative'],
			name: 'negative',
			hidden: true
		});
		
		this.zeroField = new Ext.form.field.Display({
			fieldLabel: SLANG['zero'],
			name: 'zero',
			hidden: true
		});
		
		/*
		 * init store for list view
		 */
		this.initStore();
		
		var selModel = Ext.create('Ext.selection.CheckboxModel', {});
		this.listView = new Ext.grid.Panel({
	        region: 'center',
	        store: this.store,
	        multiSelect: false,
	        hideHeaders: true,
	        viewConfig: {
	            emptyText: '<div style="padding:10px;">'+this.listEmptyText+'</div>',
	            deferEmptyText: false
	        },
	        selModel: selModel,
	        columns: [{
	            text: 'Name',
	            flex: 1,
	            dataIndex: 'text'
	        }]
	    });
		
		this.items = [{
			xtype: 'container',
			region: 'north',
			layout: 'anchor',
			items: [this.nameField, this.positiveField, this.negativeField, this.zeroField]
		}, this.listView];
		
		this.deleteBtn = new Ext.button.Button({
			disabled: true,
			iconCls: 'icon-delete',
			style: 'margin-top:10px;',
			text: this.deleteText,
			handler: this.onDelete,
			scope: this
		});
		
		this.applyBtn = new Ext.button.Button({
			disabled: true,
			style: 'margin-top:10px;',
			text: SLANG['apply'],
			handler: this.onApply,
			scope: this
		});
		
		this.dockedItems = [{
			xtype: 'container',
			dock: 'right',
			width: 100,
			style: 'padding:0px 10px;',
			layout: {
				type: 'vbox',
				align: 'stretch'
			},
			items: [{
				xtype: 'button',
				text: SLANG['create'],
				handler: this.onOK,
				scope: this
			}, this.deleteBtn, this.applyBtn, {
				xtype: 'button',
				text: this.cancelText,
				style: 'margin-top:10px;',
				handler: this.onCancel,
				scope: this
			}]
		}];
				
		this.callParent();		
		
		this.mon(this.listView, {
			scope: this,
			'selectionchange': this.onSelectionChange
		});
		
	},
	
	popup : function(){		
		this.show();	
		this.nameField.focus(true, 100);
	},
	
	/**
	 * init store
	 */
	initStore : function(){
		this.store = Ext.create('EnterpriseSheet.sheet.data.CustomStore', {});
		this.store.load();
	},
		
	onKeyPress : function(field, e){
		this.setFields();
		var key = e.getKey();
		var keyObj = Ext.EventObject ? Ext.EventObject : Ext.event.Event;
		if(keyObj.ENTER == key){
			this.onOK();
		}
	},
	
	setFields : function() {		
		// check and reset other field ...
		var nameVal = this.nameField.getValue();
		if (nameVal.indexOf(';') > -1) {
			var items = nameVal.split(';');

		    this.positiveField.setValue(HELPER.parseNumberFm(items[0]));
		    
		    if (items.length > 1)  this.negativeField.setValue(HELPER.parseNumberFm(items[1]));
		    else this.negativeField.setValue('');
		    
		    if (items.length > 2) this.zeroField.setValue(HELPER.parseNumberFm(items[2]));
		    else this.zeroField.setValue('');
		    
		    this.positiveField.setVisible(true);
		    this.negativeField.setVisible(true);
		    this.zeroField.setVisible(true);
		} else {
			this.positiveField.setVisible(false);
			this.negativeField.setVisible(false);
			this.zeroField.setVisible(false);
		}
	},
	
	onOK : function(){
		if(this.nameField.isValid()){
			var name = this.nameField.getValue();
			
			// add to the system now ...
			Ext.Ajax.request({
				url : SCONFIG.urls['addCustom'],
				params : {
					content : name,
					category : 'number'
				},
				success : function(result, request) {
					var jsonData = Ext.decode(result.responseText);
					if (jsonData.success) {
						this.store.reload();
					} else {
						Ext.MessageBox.alert(SLANG['error'], jsonData.info);
					}
				},
				scope : this
			});
		}
	},
	
	onApply : function(){
		var sm = this.listView.getSelectionModel();
		var sel = sm.getLastSelected();
		var sheet = this.sheet;
    	if(sheet){ 
    		var format = sel.data.text;
    		// check whether this format is end with %
    		if (HELPER.endWith(format, '%')) sheet.setPercentFormatForSelection(format);
    		else sheet.setNumberFormatForSelection(format);
    	}
	},
	
	/**
	 * when selection change of list view
	 */
	onSelectionChange : function(sm, selection){		
		if(1 == selection.length){
			var sel = selection[0];
			this.nameField.setValue(sel.data.text);
			this.deleteBtn.enable();
			this.applyBtn.enable();	
		}else{
			this.deleteBtn.disable();
			this.applyBtn.disable();	
		}
		
		this.setFields();
	},
	
	/**
	 * delete the selection
	 */
	onDelete : function(){
		var sm = this.listView.getSelectionModel();
		var sel = sm.getLastSelected();
		this.store.remove(sel);
		// add to the system now ...
		Ext.Ajax.request({
			url : SCONFIG.urls['deleteCustom'],
			params : {
				id: sel.data.id
			},
			success : function(result, request) {
				var jsonData = Ext.decode(result.responseText);
				if (jsonData.success) {
					this.store.reload();
				} else {
					Ext.MessageBox.alert(SLANG['error'], jsonData.info);
				}
			},
			scope : this
		});
	},
	
	bindSheet : function(sheet){
		this.sheet = sheet;
	}
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.pop.DateSelectWin', {
	
	/* Begin Definitions */
		
	extend : 'EnterpriseSheet.common.pop.PopWin',
	
	requires: [
	    'Ext.form.field.Text'
	],
	
	/* End Definitions */
	width : 450,    	
	
	height: 300,
        
	layout : 'border',

	bodyStyle: 'padding:15px;background-color:white;',
	
	prepareButton : Ext.emptyFn,
	
	cancelText: SLANG['close'],
	
	title: SLANG['formatCells'],
	
	locale: SCONFIG.default_locale,
	
	closeAction: 'hide',
	
	formatWith: null,
	
	/**
	 * an empty function to override
	 */
	checkValid : function(){
		return true;
	},
	
	initComponent : function(){
		
		var locales = Ext.create('Ext.data.Store', {
	        fields: ['id', 'name'],
	        data: SCONST.locale_list
		});
		this.localeCombo = Ext.create('Ext.form.field.ComboBox', { 
			fieldLabel: SLANG['locale'],
            editable:false,
            store : locales,
            displayField:'name',
            valueField:'id',
            queryMode :'local',
            triggerAction:'all',
            width: 305,
            forceSelection: true,
            listeners : {
                'select' : {
                    fn : this._onLocaleComboSelectFn,
                    scope : this
                }
            }
        }); 
		
		this.hintField = Ext.create('Ext.form.field.Display', {
			fieldLabel: SLANG['type'],
			anchor: '100%'
		});

		this.typeStore = Ext.create('Ext.data.Store', {
			fields: ['fm', 'name'],
			data: [{fm: 'y', name: "2014-03-20"}]
	    });
		this.listView = new Ext.grid.Panel({
	        region: 'center',
	        store: this.typeStore,
	        multiSelect: false,
	        hideHeaders: true,
	        columns: [{
	            text: 'Name',
	            flex: 1,
	            dataIndex: 'name'
	        }]
	    });
		
		this.items = [{
			xtype: 'container',
			region: 'north',
			layout: 'anchor',
			items: [this.localeCombo, this.hintField]
		}, this.listView];
		
		this.dockedItems = [{
			xtype: 'container',
			dock: 'right',
			width: 100,
			style: 'padding:0px 10px;',
			layout: {
				type: 'vbox',
				align: 'stretch'
			},
			items: [{
				xtype: 'button',
				text: this.okText,
				handler: this.onOK,
				scope: this
			}, {
				xtype: 'button',
				text: this.cancelText,
				style: 'margin-top:10px;',
				handler: this.onCancel,
				scope: this
			}]
		}];
				
		this.callParent();		
		
		this.mon(this.listView, {
			scope: this,
			'selectionchange': this.onSelectionChange,
			'itemdblclick' : this.onDoubleClick
		});
		
	},
	
	popup : function(){		
		this.show();
		this.localeCombo.setValue(this.locale);
		
		// init the value for listview
		this.initStore();
	},
	
	/**
	 * init store
	 */
	initStore : function() {
		this.typeStore.removeAll();	
		
		var items = [], today = new Date(); 
		var localeList = SCONFIG[this.locale+'_moreDateTimeFm'];
		for(var i = 0, len = localeList.length; i < len; i++){
    		var fm = localeList[i];
    		items.push({
    			name: Ext.Date.format(today, fm),
    			fm: fm
    		});
    	}
		
		this.typeStore.add(items);
	},
		
	onKeyPress : function(field, e){
		var key = e.getKey();
		var keyObj = Ext.EventObject ? Ext.EventObject : Ext.event.Event;
		if(keyObj.ENTER == key){
			this.onOK();
		}
	},
	
	_onLocaleComboSelectFn : function(combo, rd, index){
        this.locale = combo.getValue();
        this.initStore();
    },
	
	onOK : function() {
		if (this.formatWith) {
			this.sheet.setDateTimeFormatForSelection(this.formatWith);
			this.hide();
		} 
	},
	
	/**
	 * when selection change of list view
	 */
	onSelectionChange : function(sm, selection){
		if(0 < selection.length){
			var sel = selection[0];
			this.formatWith = sel.data.fm;	
		} else 
			this.formatWith = null;
	},
	
	onDoubleClick : function(dv, record, item, index, e){
		this.sheet.setDateTimeFormatForSelection(record.data.fm);
		this.hide();
	},
	
	/*
	 * bind sheet for handler use
	 */
	bindSheet : function(sheet){
		this.sheet = sheet;
	}
});
// this is for container for share purpose ...
Ext.define('EnterpriseSheet.sheet.pop.MoneySelectContainer', {
	
	extend : 'Ext.container.Container',
	
	requires: [
	    'Ext.form.field.Text'
	],
	
	withSheetName: true,
	
	currencyName: SCONFIG.default_currency,
	
	decimalNo: 2,
	
	formatWith: 'none',
	
	initComponent : function(){
		
		var moneys = Ext.create('Ext.data.Store', {
	        fields: ['abbr', 'name'],
	        data: SCONST.money_list
		});
		this.moneyCombo = Ext.create('Ext.form.field.ComboBox', { 
			fieldLabel: SLANG['symbol'],
            editable:false,
            store : moneys,
            displayField:'name',
            valueField:'abbr',
            queryMode :'local',
            triggerAction:'all',
            width: 355,
            forceSelection: true,
            listeners : {
                'select' : {
                    fn : this._onMoneyComboSelectFn,
                    scope : this
                }
            }
        }); 
		
		this.useCodeField = Ext.create('Ext.form.field.Checkbox', { 
			fieldLabel: " ",
			labelSeparator : "",
			boxLabel: SLANG['currencyCodeUse'],
			name: 'useCurrencyCode',
			listeners: {
				'change' : {
					fn: this._onCurrencyCodeCheckFn,
					scope: this
				}
			}
		});

		// for decimal place
		this.decimal = Ext.create('Ext.form.field.Number', {
			fieldLabel: SLANG['decimalPlaces'],
			value: 2,
	        maxValue: 30,
	        minValue: 0,
			anchor: '100%',
			listeners : {
                'spin' : {
                    fn : this._onDecimalSelectFn,
                    scope : this
                }
            }
		}); 
		
		this.hintField = Ext.create('Ext.form.field.Display', {
			fieldLabel: SLANG['nagativeNo'],
			anchor: '100%'
		});

		this.typeStore = Ext.create('Ext.data.Store', {
			fields: ['id', 'name'],
			data: [{id: "negative1", name: "-" + SCONST.money_code['dollar'] + "1,234.00"},
			       {id: "negative2", name: "<font color='red'>-" + SCONST.money_code['dollar'] + "1,234.00</font>"}]
	    });
		this.listView = new Ext.grid.Panel({
	        region: 'center',
	        store: this.typeStore,
	        multiSelect: false,
	        hideHeaders: true,
	        columns: [{
	            text: 'Name',
	            flex: 1,
	            dataIndex: 'name'
	        }]
	    });
		
		this.items = [{
			xtype: 'container',
			region: 'north',
			layout: 'anchor',
			items: [this.moneyCombo, this.useCodeField, this.decimal, this.hintField]
		}, this.listView];
		
		this.callParent();		
		
		var sm = this.listView.getSelectionModel();
		sm.on({
			scope: this,
			'selectionchange': this.onSelectionChange
		});
	},
	
	/**
	 * when selection change of list view
	 */
	onSelectionChange : function(sm, selection){
		if(0 < selection.length){
			var sel = selection[0];
			this.formatWith = sel.data.id;	
		} else 
			this.formatWith = "none";
	},
	
	_onMoneyComboSelectFn : function(combo, rd, index){
        this.currencyName = combo.getValue();
        this.initStore();
    },
    
    _onCurrencyCodeCheckFn : function(item, checked){
        this.initStore();
    },
    
    _onDecimalSelectFn : function(numberField, dir, eOpts){
        var decimal = numberField.getValue();
        if (dir == "up") this.decimalNo = decimal + 1;
        else this.decimalNo = decimal - 1;
        
        this.initStore();
    },
    
    initCt : function(name) {
    	this.moneyCombo.setValue(name);
		this.currencyName = name;
		this.decimalNo = 2;
		
		// init the value for listview
		this.initStore();
    },
    
    /**
	 * init store
	 */
	initStore : function() {
		this.typeStore.removeAll();		
		var arr = [];		
		var name = this.currencyName;
		
		// update field label
		var code = SCONST.money_code[name];
		var label = SLANG['symbol'] + ' (' + code + ')' + ':';
		if (this.useCodeField.getValue()) {
			label = SLANG['currency'] + ' (' + name.toUpperCase() + ')' + ':';
			code = name.toUpperCase() + ' ';
		}
		this.moneyCombo.labelEl.update(label);
		
		var decimalZero = "";
		if (this.decimalNo > 0) {
			decimalZero = ".";
			for (var i=0; i<this.decimalNo; i++) {
				decimalZero += "0";
			}
		}
		var formatter = code + "1,234" + decimalZero;
		
		arr.push({id: "negative1", name: "-" + formatter});
		arr.push({id: "negative2", name: "<font color='red'>" + formatter + "</font>"});
		arr.push({id: "negative3", name: "<font color='red'>-" + formatter + "</font>"});
		this.typeStore.add(arr);
	},
	
	getFormat : function() {
		if (this.currencyName) {
			// check to see whether using currency code ....
			var name = SCONST.money_code[this.currencyName];
			if (this.useCodeField.getValue()) {
				name = this.currencyName.toUpperCase();
			}

			var format = "money|" + name + "|" + this.decimalNo + "|" + 
			             this.formatWith + "|" + this.moneyCombo.getValue()+"|"+this.useCodeField.getValue();
			return format;			
		}
		
		return null;
	},
	
	setFormat : function(format) {
		var moneyCombineFormat = format.split("|");
		var negativeNo = moneyCombineFormat[3];
		
		this.currencyName = moneyCombineFormat[4];
		this.moneyCombo.setValue(this.currencyName);
		this.decimalNo = moneyCombineFormat[2];
		this.decimal.setValue(this.decimalNo);
		
		// for checkbox ...
		this.useCodeField.setValue(moneyCombineFormat[5]);
		
		// init the value for listview
		this.initStore();
	}
	
});

Ext.define('EnterpriseSheet.sheet.pop.MoneySelectWin', {
	
	/* Begin Definitions */
		
	extend : 'EnterpriseSheet.common.pop.PopWin',
	
	requires: [
	    'Ext.form.field.Text'
	],
	
	/* End Definitions */
	width : 500,    	
	
	height: 300,
        
	bodyStyle: 'padding:15px;background-color:white;',
	
	prepareButton : Ext.emptyFn,
	
	cancelText: SLANG['close'],
	
	title: SLANG['formatCells'],
	
	/**
	 * an empty function to override
	 */
	checkValid : function(){
		return true;
	},
	
	initComponent : function(){

		this.currencyConfigCt = Ext.create('EnterpriseSheet.sheet.pop.MoneySelectContainer', {
    		sheet: this.sheet
    	});
		
        this.items = [this.currencyConfigCt];
		
		this.dockedItems = [{
			xtype: 'container',
			dock: 'right',
			width: 100,
			style: 'padding:0px 10px;',
			layout: {
				type: 'vbox',
				align: 'stretch'
			},
			items: [{
				xtype: 'button',
				text: this.okText,
				handler: this.onOK,
				scope: this
			}, {
				xtype: 'button',
				text: this.cancelText,
				style: 'margin-top:10px;',
				handler: this.onCancel,
				scope: this
			}]
		}];
		
        this.callParent();
	},
	
	popup : function(name){		
		this.show();
		
		if (!name) name = SCONFIG.default_currency;		
		this.currencyConfigCt.initCt(name);
	},
			
	onKeyPress : function(field, e){
		var key = e.getKey();
		var keyObj = Ext.EventObject ? Ext.EventObject : Ext.event.Event;
		if(keyObj.ENTER == key){
			this.onOK();
		}
	},

	onOK : function() {
		var format = this.currencyConfigCt.getFormat();
		if (format) {
			this.sheet.setTextFormatForSelection(format);
			this.hide();
		}
	},
	
	/*
	 * bind sheet for handler use
	 */
	bindSheet : function(sheet){
		this.sheet = sheet;
	}
});

/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.pop.PrintSettingWin', {
	
	/* Begin Definitions */
		
	extend : 'EnterpriseSheet.common.pop.PopWin',
	
	requires: [
	    
	],
	
	/* End Definitions */
	width : 500,
    	
    height: 500,
		
    title: SLANG['print_setting'],
    
    layout: 'fit',
	
	bodyStyle: 'background-color:white;padding:10px;',
	
	initComponent : function(){
        
		this.hfStore = this.getHFStore();
		
		this.headerPreview = Ext.create('Ext.Component', {					
			anchor: '100%',
			cls: 'ss-header-preview',
			name: 'header-preview',
			height: 40
		});
		
		this.footerPreview = Ext.create('Ext.Component', {					
			anchor: '100%',
			cls: 'ss-footer-preview',
			name: 'footer-preview',
			height: 40
		});
		
		this.headerCombo = Ext.create('Ext.form.field.ComboBox', {					
			fieldLabel: SLANG['header'],
			anchor: '100%',
			store: this.hfStore,
			value: 0,
			valueField: 'id',
			displayField: 'text',
			listeners: {
				'select': {
					fn: function(combo){						
						var val = combo.getValue();
														
						var rec = combo.store.getById(val);		
						if(0 === val){
							this.tabSettingCache['header'] = '';
							this.tabSettingLookup['header'] = {};
						}else{
							this.tabSettingCache['header'] = rec.data.value;
							var obj = rec.data.obj;							
							this.tabSettingLookup['header'] = Ext.apply({}, obj);
							this.updatePreview('header');
						}						
					},
					scope: this
				}
			}
		});
		
		this.footerCombo = Ext.create('Ext.form.field.ComboBox', {			
			fieldLabel: SLANG['footer'],
			anchor: '100%',
			store: this.hfStore,
			valueField: 'id',
			displayField: 'text',
			value: 0,
			listeners: {
				'select': {
					fn: function(combo){	
						var val = combo.getValue();						
						var rec = combo.store.getById(val);							
						if(0 === val){
							this.tabSettingCache['footer'] = '';
							this.tabSettingLookup['footer'] = {};
						}else{
							this.tabSettingCache['footer'] = rec.data.value;
							var obj = rec.data.obj;							
							this.tabSettingLookup['footer'] = Ext.apply({}, obj);
							this.updatePreview('footer');
						}	
					},
					scope: this
				}
			}
		});
		
		this.oddEvenCB = Ext.create('Ext.form.field.Checkbox', {			
			boxLabel: SLANG['different_on_odd_even_page'],
			handler: function(box){
				var checked = box.getValue();
				if(checked || this.firstPageCB.getValue()){
					this.headerCombo.disable();
					this.footerCombo.disable();
				}else{
					this.headerCombo.enable();
					this.footerCombo.enable();
				}
				this.setupHeaderFooterTabs();
			},
			scope: this
		});
		
		this.firstPageCB = Ext.create('Ext.form.field.Checkbox', {			
			boxLabel: SLANG['different_on_first_page'],
			handler: function(box){
				var checked = box.getValue();
				if(checked || this.oddEvenCB.getValue()){
					this.headerCombo.disable();
					this.footerCombo.disable();
				}else{
					this.headerCombo.enable();
					this.footerCombo.enable();
				}
				this.setupHeaderFooterTabs();
			},
			scope: this
		});
		
		this.protraitRD = Ext.create('Ext.form.field.Radio', {			
			checked: true,
			boxLabel: SLANG['portrait'],
			name: 'orientation'
		});
		
		this.landscapeRD = Ext.create('Ext.form.field.Radio', {			
			boxLabel: SLANG['landscape'],
			name: 'orientation'
		});
		
		this.scaleField = Ext.create('Ext.form.field.Number', {								
			fieldLabel: SLANG['adjust_to'],
			labelWidth: 75,
			name: 'scale',
			minValue: 10,
			maxValue: 400,
			value: 100,
			width: 160
		});
		
		this.paperSizeCombo = Ext.create('Ext.form.field.ComboBox', {					
			anchor: '100%',
			fieldLabel: SLANG['paper_size'],
			name: 'paperSize', 
			store: SCOM.paperSizeStore,
			valueField: 'id',
			displayField: 'text',
			value: 9
		});
		
		this.blackWhiteCB = Ext.create('Ext.form.field.Checkbox', {			
			boxLabel: SLANG['black_and_white'],
			name: 'blackAndWhite'
		});
		
		this.headerTabs = Ext.create('Ext.Component', {
			cls: 'ss-hf-tabs',
			height: 30,
			listeners: {
				'afterrender': {
					fn: this.afterHFRender,
					scope: this
				}
			}
		});
		
		this.footerTabs = Ext.create('Ext.Component', {
			cls: 'ss-hf-tabs',
			height: 30,
			listeners: {
				'afterrender': {
					fn: this.afterHFRender,
					scope: this
				}
			}
		});
		
		this.tabs = Ext.create('Ext.TabPanel', {
			plain: true,
			defaults: {
				xtype: 'container'
			},
			items: [{				
				title: SLANG['page'],				
				padding: '10',
				layout: 'anchor',
				items: [{
					xtype: 'fieldset',
					title: SLANG['orientation'],	
					layout: {
						type: 'hbox',
						pack: 'center'
					},
					padding: '10 50 15 50',
					items: [this.protraitRD, {
						xtype: 'component',
						flex: 1
					}, this.landscapeRD]
				}, {
					xtype: 'fieldset',
					title: SLANG['scaling'],						
					padding: '10 50 15 50',
					layout: {
						type: 'hbox'
					},
					items: [this.scaleField, {
						xtype: 'label',
						text: ' % '+SLANG['normal_size'],
						padding: '4 10'
					}]
				}, this.paperSizeCombo, this.blackWhiteCB, {
					xtype: 'component',
					cls: 'ss-print-hint',
					html: SLANG['print_hint']
				}]
			}, {
				xtype: 'form',
				title: SLANG['margins'],
				layout: 'anchor',
				padding: 20,
				items: [{
					xtype: 'numberfield',
					anchor: '100%',
					fieldLabel: SLANG['top_margin'],
					name: 'top',
					minValue: 0,
					value: 1.9,
					step: 0.1,
					maxValue: 100
				}, {
					xtype: 'numberfield',
					anchor: '100%',
					name: 'bottom',
					fieldLabel: SLANG['bottom_margin'],
					minValue: 0,
					step: 0.1,
					value: 1.9,
					maxValue: 100
				}, {
					xtype: 'numberfield',
					anchor: '100%',
					fieldLabel: SLANG['left_margin'],
					name: 'left',
					minValue: 0,
					step: 0.1,
					value: 1.8,
					maxValue: 100
				}, {
					xtype: 'numberfield',
					anchor: '100%',
					name: 'right',
					fieldLabel: SLANG['right_margin'],
					minValue: 0,
					value: 1.8,
					step: 0.1,
					maxValue: 100
				}, {
					xtype: 'numberfield',
					anchor: '100%',
					name: 'header',
					fieldLabel: SLANG['header_margin'],
					minValue: 0,
					value: 0.8,
					step: 0.1,
					maxValue: 100
				}, {
					xtype: 'numberfield',
					anchor: '100%',
					name: 'footer',
					fieldLabel: SLANG['footer_margin'],
					minValue: 0,
					value: 0.8,
					step: 0.1,
					maxValue: 100
				}]
			}, {
				title: SLANG['header']+'/'+SLANG['footer'],
				layout: 'anchor',
				padding: '10 20',
				items: [this.headerTabs, this.headerPreview, this.headerCombo, {
					xtype: 'container',
					anchor: '100%',
					height: 50,
					layout: {
						type: 'hbox',
						pack: 'center'
					},
					padding: 12,
					items: [{
						xtype: 'button',
						text: SLANG['define_header']+'..',
						handler: function(){
							this.popupCustomerDefine({
								pos: 'header',
								oddEven: this.oddEvenCB.getValue(),
								firstPage: this.firstPageCB.getValue()
							});
						},
						scope: this
					}, {
						xtype: 'component',
						width: 20
					}, {
						xtype: 'button',
						text: SLANG['define_footer']+'..',
						handler: function(){
							this.popupCustomerDefine({
								pos: 'footer',
								oddEven: this.oddEvenCB.getValue(),
								firstPage: this.firstPageCB.getValue()
							});
						},
						scope: this
					}]
				}, this.footerCombo, this.footerPreview, this.footerTabs, {
					xtype: 'fieldset',
					title: 'Options',
					margin: '20 0 0 0',
					items: [this.oddEvenCB, this.firstPageCB]
				}]
			}]
		});
		this.items = [this.tabs];
		
		this.callParent();
        
	},
	
	afterHFRender : function(comp){
		var el = comp.getEl();
		el.on('click', function(e){
			for(var i = 0, len = el.dom.childNodes.length; i < len; i++){
				Ext.get(el.dom.childNodes[i]).removeCls('selected');
			}
			var target = Ext.get(e.getTarget());
			if(target.hasCls('ss-hftab')){
				target.addCls('selected');
				this.updatePreview(target.getAttribute('name'));
			}
		}, this);
	},
	
	getHFStore : function(){
		var data = [
		    [0, SLANG['none'], SLANG['none'], {}],
		    [1, SLANG['page_1'], SLANG['page_&'], {c: SLANG['page_1']}],
		    [2, SLANG['page_1_total_page'], SLANG['page_&_total_page'], {c: SLANG['page_1_total_page']}]
		];
		var sheet = this.sheet, store = sheet.getStore();
		var fileName = store.fileName, curSheet = store.getSheetById(store.getActivedSheetId());
		var sheetName = curSheet.name;
		data.push([data.length, fileName, fileName, {c: fileName}]);
		data.push([data.length, sheetName, sheetName, {c: sheetName}]);
		data.push([data.length, fileName+', '+SLANG['page_1'], fileName+', '+SLANG['page_&'], {c: fileName, r: SLANG['page_1']}]);
		data.push([data.length, sheetName+', '+SLANG['page_1'], sheetName+', '+SLANG['page_&'], {c: sheetName, r: SLANG['page_1']}]);
		var store = new Ext.data.ArrayStore({
			fields: [{name : 'id', type : 'int'}, 'text', 'value', 'obj'],
			data: data
		});
		
		return store;
	},
	
	transferVal2Parts : function(it){
		var flag = false;
		var s = it.replace(/(&L)|(&C)|(&R)/gi, function(w){
			var l = w[1].toLowerCase();
			if(flag){
				r = "',"+l+":'";
			}else{
				r = l+":'";
			}
			flag = true;
			return r;
		});
		var o;
		if(flag){
			s += "'";
			o = Ext.decode('{'+s+'}');
		}else{
			o = {
				c: s
			};
		}							
		for(var q in o){
			if(o.hasOwnProperty(q)){
				var val = o[q];
				val = val.replace('&P', '&['+SLANG['page_no']+']');
				val = val.replace('&N', '&['+SLANG['total_page']+']');
				val = val.replace('&D', '&['+SLANG['date']+']');
				o[q] = val;
			}
		}
		return o;		
	},
	
	popup : function(){
		var store = this.sheet.getStore(), sheetObj = store.getSheetById(store.getActivedSheetId());		
		this.show();
		this.tabSettingCache = {};
		this.tabSettingLookup = {};
		var extraInfo = sheetObj.extraInfo;
		if(extraInfo){
			extraInfo = Ext.decode(extraInfo);
			var printSetting = extraInfo.printSetting;
			if(printSetting){
				var pageMargins = printSetting.pageMargins;
				if(pageMargins){
					var form = this.tabs.items.get(1);
					form.items.get(0).setValue(Number(pageMargins.top));
					form.items.get(1).setValue(Number(pageMargins.bottom));
					form.items.get(2).setValue(Number(pageMargins.left));
					form.items.get(3).setValue(Number(pageMargins.right));
					form.items.get(4).setValue(Number(pageMargins.header));
					form.items.get(5).setValue(Number(pageMargins.footer));
				}
				var pageSetup = printSetting.pageSetup;
				if(pageSetup){
					if('protrait' === pageSetup.orientation){
						this.protraitRD.setValue(true);
					}else{
						this.landscapeRD.setValue(true);
					}
					this.paperSizeCombo.setValue(pageSetup.paperSize);
					this.blackWhiteCB.setValue(pageSetup.blackAndWhite);
					this.scaleField.setValue(pageSetup.scale);
				}
				var headerFooter = printSetting.headerFooter;
				if(headerFooter){
					if((!headerFooter.differentOddEven && headerFooter.differentFirst) ||
							(!headerFooter.differentOddEven && !headerFooter.differentFirst)){
						if(headerFooter['oddHeader']){
							headerFooter['header'] = headerFooter['oddHeader'];
							delete(headerFooter['oddHeader']);
						}
						if(headerFooter['oddFooter']){
							headerFooter['footer'] = headerFooter['oddFooter'];
							delete(headerFooter['oddFooter']);
						}
					}
					this.tabSettingCache = Ext.apply({}, headerFooter);
					delete(this.tabSettingCache.differentOddEven);
					delete(this.tabSettingCache.differentFirst);					
					
					for(var p in this.tabSettingCache){
						if(this.tabSettingCache.hasOwnProperty(p)){
							var it = this.tabSettingCache[p];
							if(Ext.isString(it)){
								this.tabSettingLookup[p] = this.transferVal2Parts(it);
							}							
						}
					}
					this.oddEvenCB.setValue(headerFooter.differentOddEven);
					this.firstPageCB.setValue(headerFooter.differentFirst);
					this.setupHeaderFooterTabs();					
				}
			}
		}		
	},
	
	setupHeaderFooterTabs : function(){
		var cache = this.tabSettingCache, arr = [], arr1 = [], name, name1;		
		var differentOddEven = this.oddEvenCB.getValue(), differentFirst = this.firstPageCB.getValue(); 
		if(differentOddEven || differentFirst){
			var map = {
				'firstHeader': SLANG['first_page'],
				'oddHeader': SLANG['odd_page'],
				'evenHeader': SLANG['even_page'],
				'header': SLANG['other_page'],
				'firstFooter': SLANG['first_page'],
				'oddFooter': SLANG['odd_page'],
				'evenFooter': SLANG['even_page'],
				'footer': SLANG['other_page']
			};
			var hs = [], fs = [];
			if(differentOddEven && differentFirst){
				hs = ['firstHeader', 'oddHeader', 'evenHeader'];
				fs = ['firstFooter', 'oddFooter', 'evenFooter'];
			}else if(differentOddEven){
				hs = ['oddHeader', 'evenHeader'];
				fs = ['oddFooter', 'evenFooter'];
			}else{
				hs = ['firstHeader', 'header'];
				fs = ['firstFooter', 'footer'];
			}
			var css = 'selected';
			for(var i = 0, len = hs.length; i < len; i++){
				var p = hs[i];
				if(cache[p]){
					arr.push('<div name="'+p+'" class="ss-hftab '+css+'">'+map[p]+'</div>');
					css = '';
					if(!name){
						name = p;
					}
				}
			}
			css = 'selected';
			for(var i = 0, len = fs.length; i < len; i++){
				var p = fs[i];
				if(cache[p]){
					arr1.push('<div name="'+p+'" class="ss-hftab '+css+'">'+map[p]+'</div>');
					css = '';
					if(!name1){
						name1 = p;
					}
				}
			}
			
			this.updatePreview(name);
			this.updatePreview(name1);
		}else{
			this.updatePreview('header');
			this.updatePreview('footer');
		}	
		this.headerTabs.update(arr.join(''));
		this.footerTabs.update(arr1.join(''));
		
	},
	
	updatePreview : function(name){
		if(!name){
			this.headerPreview.update('');
			this.footerPreview.update('');
			this.headerCombo.setValue(0);
			this.footerCombo.setValue(0);
			return;
		}
		var box, combo;
		if(-1 !== name.toLowerCase().indexOf('header')){
			box = this.headerPreview;
			combo = this.headerCombo;
		}else{
			box = this.footerPreview;
			combo = this.footerCombo;
		}
		var it = this.tabSettingLookup[name];
		if(it){		
			box.update(['<table class="ss-hf-table"><tbody><tr>',
			    '<td class="ss-hf-left">', it.l, '</td>',
			    '<td class="ss-hf-center">', it.c, '</td>',
			    '<td class="ss-hf-right">', it.r, '</td>',			    
			'</tr></tbody></table>'].join(''));
			var val = this.tabSettingCache[name], flag;
			this.hfStore.each(function(rec){
				if(rec.data.value === val){
					combo.setValue(rec.data.id);
					flag = true;
					return false;
				}
			}, this);
			if(!flag){
				var p = this.transferVal2Parts(val);				
				var arr = [];
				if(p.l){
					arr.push(p.l);
				}
				if(p.c){
					arr.push(p.c);
				}
				if(p.r){
					arr.push(p.r);
				}
				var text = arr.join(', ');
				
				combo.setRawValue(text);
			}
		}else{
			box.update('');
			combo.setValue(0);
		}
	},
	
	popupCustomerDefine : function(config){
		config = config || {};
		var pos = config.pos, oddEven = config.oddEven, firstPage = config.firstPage;
		if(!this.customerDefineWin){
			this.defineTabs = Ext.create('Ext.TabPanel', {
				plain: true,				
				region: 'north',
				listeners: {
					'tabchange': {
						fn: this.onDefineTabChange,
						scope: this
					}
				}
			});
			this.leftPart = Ext.create('Ext.form.field.TextArea', {
				xtype: 'textarea',
				labelAlign: 'top',
				fieldLabel: SLANG['left'],						
				flex: 1, 
				listeners: {
					'focus': {
						fn: this.onPartFocus,
						scope: this
					},
					'blur': {
						fn: this.onPartBlur,
						scope: this
					}
				}
			});
			this.centerPart = Ext.create('Ext.form.field.TextArea', {
				xtype: 'textarea',
				labelAlign: 'top',
				fieldLabel: SLANG['center'],						
				flex: 1,
				listeners: {
					'focus': {
						fn: this.onPartFocus,
						scope: this
					},
					'blur': {
						fn: this.onPartBlur,
						scope: this
					}
				}
			});
			this.rightPart = Ext.create('Ext.form.field.TextArea', {
				xtype: 'textarea',
				labelAlign: 'top',
				fieldLabel: SLANG['right'],						
				flex: 1,
				listeners: {
					'focus': {
						fn: this.onPartFocus,
						scope: this
					},
					'blur': {
						fn: this.onPartBlur,
						scope: this
					}
				}
			})
			this.customerDefineWin = Ext.create('Ext.window.Window', {				
				modal: true,
				width: 600,
				height: 400,
				closeAction: 'hide',
				bodyStyle: 'background:white;padding:20px;',
				layout: 'border',
				items: [this.defineTabs, {
					xtype: 'container',
					padding: 10,
					region: 'north',
					layout: {
						type: 'hbox',
						pack: 'center'
					},
					items: [{
						xtype: 'button',
						text: '# '+SLANG['insert_page_no'],
						handler: this.insertPageNo,
						scope: this
					}, {
						xtype: 'button',
						style: 'margin-left:10px;',
						text: '? '+SLANG['insert_total_page'],
						handler: this.insertTotalPage,
						scope: this
					}, {
						xtype: 'button',
						style: 'margin-left:10px;',
						text: SLANG['insert_date'],
						handler: this.insertDate,
						scope: this
					}]
				}, {
					xtype: 'container',
					region: 'center',
					layout: {
						type: 'hbox',
						padding: '10 0',
						align: 'stretch'
					},
					padding: '0 0 20 0',					
					items: [this.leftPart, {
						xtype: 'component',
						width: 20
					}, this.centerPart, {
						xtype: 'component',
						width: 20
					}, this.rightPart]
				}],
				buttons: [{
					text: SLANG['ok'],
					handler: this.onDoneCustomDefine,
					scope: this
				}, {
					text: SLANG['cancel'],
					handler: function(){
						this.customerDefineWin.hide();
					},
					scope: this
				}]
			});
		}
		if('header' === pos){
			this.defineTabs.removeAll();
			if(firstPage && oddEven){
				this.defineTabs.add([{
					title: SLANG['first_page_header'],
					name: 'firstHeader',					
					border: false
				}, {
					title: SLANG['odd_page_header'],
					name: 'oddHeader',
					border: false
				}, {
					title: SLANG['even_page_header'],
					name: 'evenHeader',
					border: false
				}]);
			}else if(firstPage){
				this.defineTabs.add([{
					title: SLANG['first_page_header'],
					name: 'firstHeader',					
					border: false
				}, {
					title: SLANG['header'],
					name: 'header'
				}]);
			}else if(oddEven){
				this.defineTabs.add([{
					title: SLANG['odd_page_header'],
					name: 'oddHeader',
					border: false
				}, {
					title: SLANG['even_page_header'],
					name: 'evenHeader',
					border: false
				}]);
			}else{
				this.defineTabs.add({
					title: SLANG['header'],
					name: 'header'
				});
			}			
			this.customerDefineWin.setTitle(SLANG['define_header']);
		}else{
			this.defineTabs.removeAll();
			if(firstPage && oddEven){
				this.defineTabs.add([{
					title: SLANG['first_page_footer'],
					name: 'firstFooter',
					border: false
				}, {
					title: SLANG['odd_page_footer'],
					name: 'oddFooter',
					border: false
				}, {
					title: SLANG['even_page_footer'],
					name: 'evenFooter',
					border: false
				}]);
			}else if(firstPage){
				this.defineTabs.add([{
					title: SLANG['first_page_footer'],
					name: 'firstFooter',
					border: false
				}, {
					title: SLANG['footer'],
					name: 'footer'
				}]);
			}else if(oddEven){
				this.defineTabs.add([{
					title: SLANG['odd_page_footer'],
					name: 'oddFooter',
					border: false
				}, {
					title: SLANG['even_page_footer'],
					name: 'evenFooter',
					border: false
				}]);
			}else{
				this.defineTabs.add({
					title: SLANG['footer'],
					name: 'footer'
				});
			}
			this.customerDefineWin.setTitle(SLANG['define_footer']);
		}
		this.defineTabs.setActiveTab(0);
		this.customerDefineWin.show();
	},
	
	onPartFocus : function(textArea){
		this.curFocusPart = textArea;		
	},
	
	onPartBlur : function(textArea){
		
	},
			
	insertPageNo : function(){
		if(this.curFocusPart){
			this.curFocusPart.focus(50);
			Ext.Function.defer(function(){
				var p = SCOM.getCursorPosition(this.curFocusPart.getFocusEl().dom);
				var val = this.curFocusPart.getValue();
				if(Ext.isNumber(p)){
					var pre = val.slice(0, p);
					var pos = val.slice(p);
					this.curFocusPart.setValue(pre+'&['+SLANG['page_no']+']'+pos);
				}else{
					this.curFocusPart.setValue(val+'&['+SLANG['page_no']+']');
				}
			}, 100, this);
		}
	},
	
	insertTotalPage : function(){
		if(this.curFocusPart){
			this.curFocusPart.focus(50);
			Ext.Function.defer(function(){
				var p = SCOM.getCursorPosition(this.curFocusPart.getFocusEl().dom);
				var val = this.curFocusPart.getValue();
				if(Ext.isNumber(p)){
					var pre = val.slice(0, p);
					var pos = val.slice(p);
					this.curFocusPart.setValue(pre+'&['+SLANG['total_page']+']'+pos);
				}else{
					this.curFocusPart.setValue(val+'&['+SLANG['total_page']+']');
				}
			}, 100, this);
		}
	},
	
	insertDate : function(){
		if(this.curFocusPart){
			this.curFocusPart.focus(50);
			Ext.Function.defer(function(){
				var p = SCOM.getCursorPosition(this.curFocusPart.getFocusEl().dom);
				var val = this.curFocusPart.getValue();
				if(Ext.isNumber(p)){
					var pre = val.slice(0, p);
					var pos = val.slice(p);
					this.curFocusPart.setValue(pre+'&['+SLANG['date']+']'+pos);
				}else{
					this.curFocusPart.setValue(val+'&['+SLANG['date']+']');
				}
			}, 100, this);
		}
	},
	
	getCustomSetting : function(){
		var fn = function(part, pre){
			var val = part.getValue();
			if(SCOM.isEmptyValue(val)){
				return '';
			}
			val = val.replace('&['+SLANG['page_no']+']', '&P');
			val = val.replace('&['+SLANG['total_page']+']', '&N');
			val = val.replace('&['+SLANG['date']+']', '&D');		
			val = pre+val;
			return val;
		}		
		var val = fn(this.leftPart, '&L');
		val += fn(this.centerPart, '&C');
		val += fn(this.rightPart, '&R');
		return {
			val: val,
			setting: {
				'l': this.leftPart.getValue() || '',
				'c': this.centerPart.getValue() || '',
				'r': this.rightPart.getValue() || ''
			}
		};
	},
	
	/**
	 * need save the setting when tab change
	 */
	onDefineTabChange : function(tabs, activeTab, preActiveTab){
		this.tabSettingCache = this.tabSettingCache || {};
		this.tabSettingLookup = this.tabSettingLookup || {};
		if(preActiveTab){
			var name = preActiveTab.name;
			var obj = this.getCustomSetting();		
			this.tabSettingCache[name] = obj.val;		
			this.tabSettingLookup[name] = obj.setting;
		}
		if(activeTab){
			var found = this.tabSettingLookup[activeTab.name];
			if(found){
				this.leftPart.setValue(found.l);
				this.centerPart.setValue(found.c);
				this.rightPart.setValue(found.r);
			}else{
				this.leftPart.setValue('');
				this.centerPart.setValue('');
				this.rightPart.setValue('');
			}
		}
	},
	
	onDoneCustomDefine : function(){
		this.onDefineTabChange(this.defineTabs, null, this.defineTabs.getActiveTab());
		this.customerDefineWin.hide();
		this.setupHeaderFooterTabs();
	},
	
	prepareParam : function(){
		var obj = {};
		obj['pageSetup'] = {
			'scale': this.scaleField.getValue(),
			'orientation': this.protraitRD.getValue() ? 'protrait' : 'landscape',
			'paperSize': this.paperSizeCombo.getValue(),
			'blackAndWhite': this.blackWhiteCB.getValue()
		};
		obj['pageMargins'] = this.tabs.items.get(1).getValues();
		for(var p in obj['pageMargins']){
			if(obj['pageMargins'].hasOwnProperty(p)){
				obj['pageMargins'][p] = Number(obj['pageMargins'][p]);
			}
		}
		var differentFirst = this.firstPageCB.getValue();
		var differentOddEven = this.oddEvenCB.getValue();
		obj['headerFooter'] = {
			'differentFirst': differentFirst,
			'differentOddEven': differentOddEven
		};
		if(differentFirst && differentOddEven){
			Ext.copyTo(obj.headerFooter, this.tabSettingCache, 'firstHeader,oddHeader,evenHeader,firstFooter,oddFooter,evenFooter');
		}else if(differentFirst){
			Ext.copyTo(obj.headerFooter, this.tabSettingCache, 'firstHeader,header,firstFooter,footer');
			if(obj.headerFooter['header']){
				obj.headerFooter['oddHeader'] = obj.headerFooter['header'];
				delete(obj.headerFooter['header']);
			}
			if(obj.headerFooter['footer']){
				obj.headerFooter['oddFooter'] = obj.headerFooter['footer'];
				delete(obj.headerFooter['footer']);
			}
		}else if(differentOddEven){
			Ext.copyTo(obj.headerFooter, this.tabSettingCache, 'oddHeader,evenHeader,oddFooter,evenFooter');
		}else{
			Ext.copyTo(obj.headerFooter, this.tabSettingCache, 'header,footer');
			if(obj.headerFooter['header']){
				obj.headerFooter['oddHeader'] = obj.headerFooter['header'];
				delete(obj.headerFooter['header']);
			}
			if(obj.headerFooter['footer']){
				obj.headerFooter['oddFooter'] = obj.headerFooter['footer'];
				delete(obj.headerFooter['footer']);
			}
		}
				
		return obj;
	}
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.pop.KeyShortcuts', {
	extend: 'EnterpriseSheet.common.pop.PopWin',
	
	alias: 'widget.keyshortcuts',
	
	requires: [   
	],
	
	layout: 'anchor',
           
    autoScroll: true,

	initComponent : function(){
		
		if(!this.originHint){
			this.originHint = SLANG['keyboard_shortcuts_desc'];
		}
				
        this.html = this.originHint;
           
		if(!this.title){
			this.title = SLANG['keyboard_shortcuts'];
		}		
		

		this.buttons = [{
            text: SLANG['close'],
            handler: function() {
                this.close();
            },
            scope: this
        }];
		
		this.callParent(arguments);	
	},
	
	/**
	 * popup the window
	 */
	popup : function(config){	
		this.show();	    
	}
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.pop.FormulaFunctionWin', {
	
	extend : 'EnterpriseSheet.common.pop.PopWin',
	
    width : 400,
    	
    height: 500,
        
	layout : 'border',
	
	labelWidth : 90,
	
	bodyStyle: 'background-color:white;',
	
	initComponent : function(){
		
		this.functionTypeCombo = Ext.create('Ext.form.field.ComboBox', { 
            editable:false,
            store : new Ext.data.SimpleStore({
                fields:['type','text']
            }),
            listeners : {
                'select' : {
                    fn : this._onFunctionTypeComboSelectFn,
                    scope : this
                }
            },
            displayField:'text',
            valueField:'type',
            queryMode :'local',
            triggerAction:'all',
            width:200,
            selectOnFocus:true
        });  
		
		//formula function list.
        this.listView = Ext.create('Ext.grid.Panel', {
        	listeners: {
			    itemmouseenter: this._onMouseenterFn,
			    itemclick: this._onSelectionchangeFn,
			    scope : this
			},
			border: false,
            hideHeaders: true,
            region:'center',
            store: new Ext.data.ArrayStore({
                fields: ['name', 'example', 'description', 'type'],
		        sortInfo: {field:'name', direction:'ASC'},
                data: []
            }),
            reserveScrollOffset: false,
            columns: [{
                dataIndex: 'name',
                flex: 1
            }, {
                dataIndex : 'type',
                flex : 1,
                renderer: function(value) {
	                return '<font color="gray">'+ SLANG[value] +'</font>';
	            }
            }],
            tbar : [this.functionTypeCombo,'->',{
                text: SLANG['help'],
                handler: function(){
                    var newWindow = window.open("http://www.enterprisesheet.com/api", '_blank');
                    newWindow.focus();
                }
            }]
        });
			
		this.descriptionPanel = new Ext.Container({
			region : 'south',
            height: 120,
            cls: 'ss-formula-win-desc',
            autoScroll:true,
            frame:true
        });

		this.items = [this.listView, this.descriptionPanel];	
		
		this.callParent();	
	},
	
	/**
     *First open the window initialization data.
     */  
    _initData:function(){
        var formulaData = EnterpriseSheet.sheet.floating.CalculateHint.prototype.hintData;
        var typeBoxData=[],tmpAry=[];
        for(var i=0;i<formulaData.length;i++){
            var typeValue=(formulaData[i])[3];
            if(!this._arrayContain(tmpAry,typeValue)){
                tmpAry.push(typeValue);
                typeBoxData.push([typeValue, SLANG[typeValue]]);
            }
        }

        typeBoxData = [['all', SLANG['all']]].concat(typeBoxData);
        this.functionTypeCombo.store.loadData(typeBoxData);
        this.listView.store.loadData(formulaData);
        this.functionTypeCombo.setValue('all');
    },
    
    /** judge array contains item.
      *  @param{Array} all data in the array.
       * @param{String}  item is compare data.
    */  
    _arrayContain: function(array, item) {
        var i, ln;
        for (i = 0, ln = array.length; i < ln; i++) {
            if (array[i] === item) {
                return true;
            }
        }
        return false;
    },
    
    /**change combobox option loaded  different types of data.
     *  @param{Ext.form.ComboBox} active combobox.
     * @param{Ext.data.Record} rd is the selected data.
     *  @param{Number}index of the selected row index.
     */
    _onFunctionTypeComboSelectFn:function(combo, rd, index){
        var resultData=this._filterFormulaData(combo.getValue());
        this.listView.store.loadData(resultData);
    },

    /**
     * @param{String} type: fiter type.
     **/
    _filterFormulaData:function(type){
        var formulaData = EnterpriseSheet.sheet.floating.CalculateHint.prototype.hintData;
        if(type=='all') return formulaData;
        var resultData=[];
        for(var i=0;i<formulaData.length;i++){
            var tmpDta=formulaData[i];
            if(tmpDta[3]==type){
                resultData.push(tmpDta);
            }
        }
        return resultData;
    },

    /**
     * mouse over list view.
     * @param{Ext.list.ListView} view is grid rows.
     * @param{Number} selected row of the grid row index.
     * @param{Element} selected element of list view.
     * 	@param {Ext.EventObject} e The click event
     * */
    _onMouseenterFn:function(view, record, item, index, e, options){
        this.descriptionPanel.update(record.data.description);
    },
    
    /**
     * selected row of the grid.
     * @param{Ext.list.ListView} view is grid rows.
     * @param{Number} selected row of the grid row index.
     * @param{Element} selected element of list view.
     * 	@param {Ext.EventObject} e The click event
     * */
    _onSelectionchangeFn:function(view, record, item, index, e, options){
    	var ss = this.spreadsheet;
    	var editor = ss.editor;
    	editor.setValue("="+record.data.name+"(");
    	
    	var region = this.spreadsheet.getCurrentRegion();
		var sm = region.getSelectionModel();
		var fc = sm.getFocusCell();	  	
        editor.startEdit(fc.row, fc.col, region, e, false, true);

        this.hide();
    },

	popup : function(sheet){
        this.nameChanged = false;
        this.show();
        
        if(this.listView.store.getCount()==0){
            this._initData();
        }
	}
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.pop.CellOptionWin', {
	
	/* Begin Definitions */
		
	extend : 'EnterpriseSheet.common.pop.PopWin',
	
	requires: ['Ext.form.field.Radio'],
	
	/* End Definitions */
	
	boxLabel1 : '',
	
	boxLabel2 : '',
	
	boxLabel3 : '',
	
	boxLabel4 : '',
	
	title : '',	
	
	bodyStyle : 'padding:10px;',
	
	width : 250,
	
	layout: 'anchor',
	
	autoHeight : true,
	
	initComponent : function(){
		
		this.defaults = {
			'anchor': '100%'
		};
		
		this.items = [];
		
		if (this.boxLabel1) {
		    this.items.push({
				xtype:'radio',
				checked:true,
				boxLabel:this.boxLabel1,
				name:'cell-option'
			});	
		}
		
		if (this.boxLabel2) {
		    this.items.push({
				xtype:'radio',
				boxLabel:this.boxLabel2,
				name:'cell-option'
			});	
		}
		
		if (this.boxLabel3) {
		    this.items.push({
				xtype:'radio',
				boxLabel:this.boxLabel3,
				name:'cell-option'
			});	
		}
		
		if (this.boxLabel4) {
		    this.items.push({
				xtype:'radio',
				boxLabel:this.boxLabel4,
				name:'cell-option'
			});	
		}
		
		this.callParent();		
	},
	
	/*
	 * update some config, such as callback
	 */
	updateConfig : function(config){
		Ext.apply(this, config);
		
		if(config.title){
			this.setTitle(config.title);
		}
		
		var total = 0;		
		if(config.boxLabel1){	
			var radio = this.items.get(total);
			var boxEl = Ext.get(radio.getId()+'-boxLabelEl');
			boxEl.update(config.boxLabel1);
			total = total + 1;
		}
		if(config.boxLabel2){			
			var radio = this.items.get(total);
			var boxEl = Ext.get(radio.getId()+'-boxLabelEl');
			boxEl.update(config.boxLabel2);
			total = total + 1;
		}
		if(config.boxLabel3){
			var radio = this.items.get(total);
			var boxEl = Ext.get(radio.getId()+'-boxLabelEl');
			boxEl.update(config.boxLabel3);
			total = total + 1;
		}
		if(config.boxLabel4){			
			var radio = this.items.get(total);
			var boxEl = Ext.get(radio.getId()+'-boxLabelEl');
			boxEl.update(config.boxLabel4);
			total = total + 1;
		}		
	},
	
	/*
	 * overwrite to prepare the params
	 */
	prepareParam : function(){
		var opt, i = 0;
		this.items.each(function(it){				
			if(it.getValue()){
				opt = i;
				return false;
			}
			i++;
		}, this);
		return opt;
	}
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.pop.ChartSettingWin', {
	
	/* Begin Definitions */
		
	extend : 'Ext.window.Window',
	
	requires: [
	    'EnterpriseSheet.common.menu.ScaleMenu', 
	    'Ext.form.RadioGroup',
	    'Ext.form.FieldSet',
	    'Ext.form.field.Text'
	],
	
	/* End Definitions */		
	
	title : SLANG['chart_setting'],		      
    
    closable : true,
    
    closeAction : 'hide',
    
    bodyStyle: 'background:white;padding:10px;',
    
    layout: 'anchor',    
    
    /*
     * override ghost function, this function has bug in Extjs4.1RC
     */
    ghost: function(cls) {
    	/*
	     * for a bug in 4.1RC
	     */
	    if(!Ext.getVersion('core').isLessThan('4.0.9')){
	    	var me = this;
	    	me.ghostPanel = new Ext.panel.Panel({
	            renderTo: document.body,
	            floating: {
	                shadow: false
	            },
	            frame: (Ext.supports.CSS3BorderRadius && !me.isWindow) ? me.frame : false,
	            overlapHeader: me.overlapHeader,
	            headerPosition: me.headerPosition,
	            baseCls: me.baseCls,
	            cls: me.baseCls + '-ghost ' + (cls ||'')
	        });
	    }    	
    	return this.callParent(arguments);
    },
	
	initComponent : function(){
		
		this.chartTypeBtn = new Ext.button.Button({
			scale: 'large',
			style: 'margin-bottom:10px;',
			iconCls: 'icon-column32',
			iconAlign: 'top',
			minWidth: 70,
			text: SLANG['chart_type'],
			menu: new EnterpriseSheet.common.menu.ScaleMenu({
				scale : 'large',
				defaults: {
					scope: this,
					handler: this.changeChartType
				},
				items: [{
					xtype: 'scaleitem',
					scale: 'large',
					iconCls: 'icon-column32',
					text: SLANG['column'],
					chartType: 'column'
				}, {
					xtype: 'scaleitem',
					scale: 'large',
					iconCls: 'icon-area32',
					text: SLANG['area'],
					chartType: 'area'
				}, {
					xtype: 'scaleitem',
					scale: 'large',
					iconCls: 'icon-pie32',
					text: SLANG['pie'],
					chartType: 'pie'
				}, {
					xtype: 'scaleitem',
					scale: 'large',
					iconCls: 'icon-line32',
					text: SLANG['line'],
					chartType: 'line'
				}, {
					xtype: 'scaleitem',
					scale: 'large',
					iconCls: 'icon-bar32',
					text: SLANG['bar'],
					chartType: 'bar'
				}, {
					xtype: 'scaleitem',
					scale: 'large',
					iconCls: 'icon-scatter32',
					text: SLANG['scatter'],
					chartType: 'scatter'
				}, {
					xtype: 'scaleitem',
					scale: 'large',
					iconCls: 'icon-radar32',
					text: SLANG['radar'],
					chartType: 'radar'
				}]
			})
		});
				
		this.seriesPositionGroup = new Ext.form.RadioGroup({			
			columns: 2,
			items: [
			    {boxLabel: SLANG['row'], name: 'series-dir', inputValue: 'row'},			  
			    {boxLabel: SLANG['column'], name: 'series-dir', inputValue: 'col'}			    
			]
		});
           
        
		this.seriesFieldSet = new Ext.form.FieldSet({
			title: SLANG['series_position'],
			items: [this.seriesPositionGroup],			
			anchor: '100%'
		});
		
		this.legendPositionGroup = new Ext.form.RadioGroup({			
			columns: 2,
			items: [
			    {boxLabel: SLANG['top'], name: 'legend-position', inputValue: 'top'},			  
			    {boxLabel: SLANG['bottom'], name: 'legend-position', inputValue: 'bottom'},
			    {boxLabel: SLANG['left'], name: 'legend-position', inputValue: 'left'},
			    {boxLabel: SLANG['right'], name: 'legend-position', inputValue: 'right'}
			]
		});
		
		this.legendFieldSet = new Ext.form.FieldSet({
			title: SLANG['legend_position'],
			items: [this.legendPositionGroup],
			anchor: '100%'
		});
		
		this.firstAsLabelGroup = new Ext.form.CheckboxGroup({		
			columns: 1,
			items: [
                {boxLabel: SLANG['first_row_as_label'], inputValue: true, name: 'first_row_as_label'},
			    {boxLabel: SLANG['first_col_as_label'], inputValue: true, name: 'first_col_as_label'}
			]
		});
		
		this.labelFieldSet = new Ext.form.FieldSet({
			title: SLANG['label_setting'],
			items: [this.firstAsLabelGroup],
			anchor: '100%'
		});
		
		this.xTitleField = new Ext.form.field.Text({
			labelAlign: 'top',
			enableKeyEvents: true,
			fieldLabel: SLANG['title_x_axis'],			
			anchor: '100%'
		});
		
		this.yTitleField = new Ext.form.field.Text({
			labelAlign: 'top',
			enableKeyEvents: true,
			fieldLabel: SLANG['title_y_axis'],			
			anchor: '100%'
		});
		
		this.deleteBtn = new Ext.button.Button({
			iconCls: 'icon-delete',
			style: 'margin-top:10px;',
			text: SLANG['delete_chart'],
			handler: this.deleteChart,
			scope: this			
		});
		
		this.items = [
		    this.chartTypeBtn,
		    this.seriesFieldSet,	
		    this.legendFieldSet,	
		    this.labelFieldSet,
		    this.xTitleField,
		    this.yTitleField,
		    this.deleteBtn
		];
				
				
		this.callParent();		
		
		this.on('hide', function(){
			if(this.chart){
				this.chart.removeCls('ss-chart-actived');
			}
		}, this);
		/*
		 * for delete chart, may need move focus
		 */
		if(this.sheet){
			this.mon(this.sheet, {
				scope: this,
				'deletechart': this.onDeleteChart
			});
		}	
		
		this.mon(this.seriesPositionGroup, 'change', this.onSeriesPositionChange, this, {buffer: 100});
		this.mon(this.legendPositionGroup, 'change', this.onLegendPositionChange, this, {buffer: 100});
		this.mon(this.firstAsLabelGroup, 'change', this.onLabelChange, this, {buffer: 100});
		this.mon(this.xTitleField, 'keyup', this.onXTitleKeyUp, this, {buffer: 100});
		this.mon(this.yTitleField, 'keyup', this.onYTitleKeyUp, this, {buffer: 100});	
	},
	
	/*
	 * update some config, such as title, fieldlabel, and callback
	 */
	updateConfig : function(config){
		Ext.apply(this, config);		
		if(config.title){
			this.setTitle(config.title);
		}
	},
	
	/*
	 * bind the setting win to the chart
	 */
	bindChart : function(chart){
		/*
		 * disable the actived cls of old chart
		 */
		if(this.chart && this.chart != chart){
			this.chart.removeCls('ss-chart-actived');		
		}
		chart.addCls('ss-chart-actived');
		this.chart = chart;		
		
		this.syncSetting();
	},
	
	syncSetting : function(){
        this.syncSettingFlag = true;
		var setting = this.chart.getChartSetting();
		this.chartTypeBtn.setIconCls('icon-'+setting.chartType+'32');
		if('row' == setting.seriesPosition){
			this.seriesPositionGroup.items.get(0).setValue(true);
		}else{
			this.seriesPositionGroup.items.get(1).setValue(true);
		}
		if('top' == setting.legendPosition){
			this.legendPositionGroup.items.get(0).setValue(true);
		}else if('bottom' == setting.legendPosition){
			this.legendPositionGroup.items.get(1).setValue(true);
		}else if('left' == setting.legendPosition){
			this.legendPositionGroup.items.get(2).setValue(true);
		}else{
			this.legendPositionGroup.items.get(3).setValue(true);
		}
        this.firstAsLabelGroup.items.get(0).setValue(setting.firstRowLabel || false);
        this.firstAsLabelGroup.items.get(1).setValue(setting.firstColLabel || false);

		//this.seriesPositionGroup.setValue({'series-dir': setting.seriesPosition});
		//this.legendPositionGroup.setValue({'legend-position': setting.legendPosition});
		this.xTitleField.setValue(setting.xTitle);
		this.yTitleField.setValue(setting.yTitle);
		
		this.switchSeriesPosition();
		this.switchTitleField();
        delete(this.syncSettingFlag);
	},
	
	/*
	 * show or hide series fieldset
	 */
	switchSeriesPosition: function(){			
		if(this.isSeriesRect()){
			this.seriesFieldSet.show();
		}else{
			this.seriesFieldSet.hide();
		}
	},
	
	switchTitleField : function(){
		if('pie' == this.chart.chartType || 'radar' == this.chart.chartType){					
			this.xTitleField.hide();
			this.yTitleField.hide();
		}else{			
			this.xTitleField.show();
			this.yTitleField.show();
		}
	},
	
	isSeriesRect : function(){
		var rangeStore = this.chart.getRangeStore();
		
		return rangeStore.isSeriesRect();
		
	},
	
	/*
	 * popup the window
	 */
	popup : function(config){
		/*
		 * disable the actived cls of old chart
		 */
		this.bindChart(config.chart);											
				
		if(!this.isVisible()){
			if(config.xy){
				this.showAt(config.xy);
			}else{
				this.show();
			}
		}		
	},
	
	/*
	 * delete the related chart 
	 */
	deleteChart : function(){
		if(this.chart){
			this.chart.destroy();
			this.hide();
		}
	},
	
	/*
	 * change the chart type
	 */
	changeChartType : function(item){
		var chartType = item.chartType;
		this.chartTypeBtn.setIconCls(item.iconCls);
		this.chartTypeBtn.setText(item.text);
		if(this.chart){
			this.chart.changeChartType(chartType);
		}
		this.syncSetting();
	},
	
	/*
	 * when a chart is deleted, may need move focus
	 */
	onDeleteChart : function(chartType, chart, rangeStore, posize, sheet){
		if(this.chart == chart){
			var floorSet = sheet.getFloorSet();			
			for(var p in floorSet){
				var it = floorSet[p];
				if(it != chart && it instanceof EnterpriseSheet.sheet.floating.chart.ChartFloor){
					this.bindChart(it);
					return;
				}
			}
			/*
			 * means no chart any more
			 */
			this.hide();
		}
	},
	
	/*
	 * when legend position change
	 */
	onLegendPositionChange : function(fieldSet, newVal, oldVal){
        if(this.syncSettingFlag){
            return;
        }
        
        var oldPos = oldVal['legend-position'];
        var pos = newVal['legend-position'];
        if(oldPos){
            this.chart.changeLegendPosition(pos);
        }
	},
	
	/*
	 * when series position change
	 */
	onSeriesPositionChange : function(fieldSet, newVal, oldVal){
        if(this.syncSettingFlag){
            return;
        }
		var oldPos = oldVal['series-dir'];
		var pos = newVal['series-dir'];
		if(oldPos){
			var rangeStore = this.chart.getRangeStore();
			rangeStore.changeSeriesPosition(pos);
			if(Ext.checkVersion && Ext.checkVersion('6.0.0+')){		
				this.chart.changeChartType(this.chart.chartType, true);
			}
		}
	},
           
    onLabelChange : function(fieldSet, newVal, oldVal){
        if(this.syncSettingFlag){
            return;
        }
        var rangeStore = this.chart.getRangeStore();
        if(rangeStore.isRectangleCoord()){
            rangeStore.refreshAsLabelChange(newVal['first_row_as_label'] || false, newVal['first_col_as_label'] || false);
            this.chart.changeChartType(this.chart.chartType, true);
        }else{
            Ext.Msg.alert(SLANG['hint'], SLANG['not_rectangle_range']);
        }
    },
	
	/*
	 * update title for axes
	 */
	onXTitleKeyUp : function(textField, e, options){
		if(this.chart){
			this.chart.updateXTitle(textField.getValue());
		}
	},
	
	onYTitleKeyUp : function(textField, e, options){
		if(this.chart){
			this.chart.updateYTitle(textField.getValue());
		}
	}
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.pop.CommentWin', {
	
	/* Begin Definitions */
		
	extend : 'EnterpriseSheet.common.pop.PopWin',
	
	requires: [
	    'Ext.form.HtmlEditor'
	],
	
	/* End Definitions */
	width : 400,
    	
    height: 300,
        
	layout : 'anchor',
	
	labelWidth : 90,
	
	fieldLabel: SLANG['comment'],
	
	bodyStyle: 'padding:20px;background-color:white;',
	
	initComponent : function(){
		
		this.commentField = new Ext.form.field.TextArea({
			labelAlign: 'top',
			fieldLabel: this.fieldLabel,			
			allowBlank:false,
			enableKeyEvents:true,
			value: this.comment,
			height: 200,
			listeners:{
				'keypress':{
					fn:this.onKeyPress,
					scope:this
				}
			},
			anchor: '100%'
		});
		
		this.items = [this.commentField];
				
		this.callParent();		
		
		this.on('show', this._onShow, this);
	},
	
	_onShow : function(){		
		if(!SCOM.nullOrUndefined(this.commentField._value)){
			this.commentField.setValue(this.commentField._value);
		}
		this.commentField.focus(true, 100);
	},
	
	/*
	 * update some config, such as title, fieldlabel, and callback
	 */
	updateConfig : function(config){
		Ext.apply(this, config);
		if(config.fieldLabel){
			var El = this.commentField.getEl();		
			/*
			 * need back to parentNode.parentNode, cause the label is actually render by the form layout
			 */
			var labelel = Ext.DomQuery.selectNode('label', El.dom.parentNode.parentNode);
			labelel.innerHTML = this.fieldLabel;
		}
		if(config.title){
			this.setTitle(config.title);
		}
		if(config.comment){
			this.commentField._value = config.comment;			
			this.commentField.setValue(config.comment);
		}else{
			delete(this.commentField._value);
		}
	},
		
	onKeyPress : function(field, e){
		var key = e.getKey();
		var keyObj = Ext.EventObject ? Ext.EventObject : Ext.event.Event;
		if(keyObj.ENTER == key){
			this.onOK();
		}
	},
	
	onOK : function(){
		if(this.commentField.isValid()){
			var comment = this.commentField.getValue();
			if(this.applyCallback){
				var fn = this.applyCallback.fn, scope = this.applyCallback.scope;
				fn.call(scope, comment);				
			}
			this.hide();
		}
	}
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.pop.CopiedCellOptionWin', {
	
	/* Begin Definitions */
		
	extend : 'EnterpriseSheet.common.pop.PopWin',
	
	requires: ['Ext.form.field.Radio'],
	
	/* End Definitions */
	
	boxLabel1 : '',
	
	boxLabel2 : '',
	
	title : '',	
	
	bodyStyle : 'padding:10px;',
	
	width : 250,
	
	layout: 'anchor',
	
	autoHeight : true,
	
	initComponent : function(){
		
		this.defaults = {
			'anchor': '100%'
		};
		this.items = [{
			xtype:'radio',
			checked:true,
			boxLabel:this.boxLabel1,
			name:'cell-option'
		}, {
			xtype:'radio',
			boxLabel:this.boxLabel2,
			name:'cell-option'
		}];				
		
		this.callParent();		
	},
	
	/*
	 * update some config, such as callback
	 */
	updateConfig : function(config){
		Ext.apply(this, config);
		
		if(config.title){
			this.setTitle(config.title);
		}
		if(config.boxLabel1){	
			var radio = this.items.get(0);
			var boxEl = Ext.get(radio.getId()+'-boxLabelEl');
			boxEl.update(config.boxLabel1);
		}
		if(config.boxLabel2){			
			var radio = this.items.get(1);
			var boxEl = Ext.get(radio.getId()+'-boxLabelEl');
			boxEl.update(config.boxLabel2);
		}
	},
	
	/*
	 * overwrite to prepare the params
	 */
	prepareParam : function(){
		var opt, i = 0;
		this.items.each(function(it){				
			if(it.getValue()){
				opt = i;
				return false;
			}
			i++;
		}, this);
		return opt;
	}
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.pop.FloatingContainer', {
	
	/* Begin Definitions */
		
	extend : 'Ext.container.Container',		
	
	/* End Definitions */	
	
	floating: true,        
		
	delayHideInterval: 1000,
	
	/**
	 * Shows the floating menu by the specified {@link Ext.Component Component} or {@link Ext.Element Element}.
     * @param {Ext.Component/Ext.Element} component The {@link Ext.Component} or {@link Ext.Element} to show the menu by.
     * @param {String} [position] Alignment position as used by {@link Ext.Element#getAlignToXY}.
     * Defaults to `{@link #defaultAlign}`.
     * @param {Number[]} [offsets] Alignment offsets as used by {@link Ext.Element#getAlignToXY}.
     * @return {Ext.menu.Menu} This.
	 */
	showBy: function(cmp, pos, off) {
        var me = this;
        me.showTimeStamp = new Date();
        if (me.floating && cmp) {
            me.show();

            // Align to Component or Element using setPagePosition because normal show
            // methods are container-relative, and we must align to the requested element
            // or Component:
            me.setPagePosition(me.el.getAlignToXY(cmp.el || cmp, pos || me.defaultAlign, off));            
        }
        return me;
    },
    
    delayHide : function(){    	
    	Ext.Function.defer(function(){
    		var me = this.me, timestamp = this.timestamp;    		
    		if(!me.showTimeStamp || (me.showTimeStamp.valueOf() <= timestamp.valueOf())){
    			me.hide();
    		}
    	}, this.delayHideInterval, {
    		me: this,
    		timestamp: new Date()
    	});    	
    }
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.pop.LinkWin', {
	
	extend : 'EnterpriseSheet.common.pop.PopWin',
	
	requires: ['Ext.form.field.Text'],
	
	width : 270,
    	
    minHeight: 100,
        
	layout : 'anchor',
	
	labelWidth : 70,
	
	invalidMsg : SLANG['not_valid_url'],		
	
	initComponent : function(){
		
		this.urlField = new Ext.form.field.Text({
			fieldLabel:this.fieldLabel,
			msgTarget:'side',
			allowBlank: false,
			enableKeyEvents:true,
			invalidMsg:this.invalidMsg,
			//vtype: 'url',
			//regex: SCONST['urlReg'],
			//regexText: 'This field should be a URL in the format "www.example.com"',
            validator : this.urlValidator,
			listeners:{
				'keypress':{
					fn:this.onKeyPress,
					scope:this
				}
			},
			anchor: '100%'
		});	
		
		this.cellSelectField = Ext.create('EnterpriseSheet.sheet.range.RangeField', {
			fieldLabel:this.fieldLabel,
            sheet: this.sheet,
            singleSelect: true,
            simpleSelect: true,
            disabled: true,
            hidden: true,
            anchor: '100%',
            allowBlank: false,
            listeners: {
                'minimode': {
                    scope: this,
                    fn: function(){
                        this.hide();
                    }
                },
                'normalmode': {
                    scope: this,
                    fn: function(){                  	
                        this.show();  
                        this.placeInDocCheck.setValue(true);
                    }
                }
            }
        });
			
		// check to see whether it is link inside cell ...place in this document
		this.placeInDocCheck = Ext.create('Ext.form.field.Checkbox', {
			fieldLabel: " ",
			labelSeparator : "",
            boxLabel: SLANG['placeInDoc']
        });
				
		this.items = [this.urlField, this.cellSelectField, this.placeInDocCheck];
				
		this.callParent();		
		
		this.on('show', this._onShow, this);
		
		this.placeInDocCheck.on({
            scope: this,
            'change': this.onPlaceInDocChange
        });
	},
	
	_onShow : function(){		
		this.urlField.focus(true, 100);
	},
	
	onPlaceInDocChange : function() {
		var placeInDoc = this.placeInDocCheck.getValue();
		
		if (placeInDoc) {
			this.urlField.setDisabled(true);
			this.cellSelectField.setDisabled(false);
			this.urlField.hide();
			this.cellSelectField.show();
		} else {
			this.urlField.setDisabled(false);
			this.cellSelectField.setDisabled(true);
			this.urlField.show();
			this.cellSelectField.hide();
		}
	},
	
	/*
	 * update some config, such as title, fieldlabel, and callback
	 */
	updateConfig : function(config){
		Ext.apply(this, config);
		if(config.fieldLabel){
			var El = this.urlField.getEl();		
			/*
			 * need back to parentNode.parentNode, cause the label is actually render by the form layout
			 */
			var labelel = Ext.DomQuery.selectNode('label', El.dom.parentNode.parentNode);
			labelel.innerHTML = this.fieldLabel;
		}
		if(config.title){
			this.setTitle(config.title);
		}
	},
	
	/*
	 * overwrite to prepare the params
	 */
	prepareParam : function(){		
		var val = this.urlField.getValue();
		if (this.placeInDocCheck.getValue()) val = this.cellSelectField.getValue();
		
		if(!SCONST['urlProReg'].test(val) && !EnterpriseSheet.sheet.calculate.Coordinate.prototype.isCoordSpan(val)){
			val = 'http://'+val;
		}
		return val;
	},	
	
	onKeyPress : function(field, e){
		var key = e.getKey();
		var keyObj = Ext.EventObject ? Ext.EventObject : Ext.event.Event;
		if(keyObj.ENTER == key){
			this.onOK();
		}
	},
    
    /**
     * validate the url
     */
    urlValidator : function(val){
        if(SCONST['urlReg'].test(val)){
            return true;
        }else{
            return EnterpriseSheet.sheet.calculate.Coordinate.prototype.isCoordSpan(val);
        }
	}   
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.pop.ReferenceNameList', {
	
	/* Begin Definitions */
		
	extend : 'EnterpriseSheet.sheet.pop.FloatingContainer',
	
	requires: [
	    'Ext.menu.Manager',
	    'Ext.form.field.Text'
	],
	
	/* End Definitions */
	width : 250,    	
	
	height: 250,	
        
	layout : 'fit',	
	
	style: 'border:1px solid silver;padding:10px;background-color:rgb(250,250,250);',
		
	listEmptyText: SLANG['no_reference_name'],		
	
	withSheetName: true,
		
	initComponent : function(){			
		var prefix = Ext.baseCSSPrefix;
        this.cls = this.cls || '';
		this.cls += ' '+prefix+'menu';
		
		/*
		 * init store for list view
		 */
		this.initStore();
		
		this.posField = new Ext.form.field.Text({    		
    		emptyText: SLANG['input_pos'],
    		flex: 1,
    		enableKeyEvents:true,
    		allowBlank: false,
			listeners:{
				'keypress':{
					fn:this.onKeyPress,
					scope:this
				}
			}
    	});
		
		this.listView = new Ext.grid.Panel({
	        region: 'center',
	        store: this.store,
	        multiSelect: false,
	        hideHeaders: true,
	        viewConfig: {
	            emptyText: '<div style="padding:10px;">'+this.listEmptyText+'</div>',
	            deferEmptyText: false
	        },
	        columns: [{
	            text: 'Name',
	            flex: 40,
	            dataIndex: 'name'
	        },{
	            text: 'Range',
	            flex: 60,
	            dataIndex: 'coord'
	        }],
	        bbar: {
	        	layout: 'hbox',
	        	items: [this.posField, {
		        	xtype: 'button',
		        	iconCls: 'icon-popout',
		        	text: SLANG['goto'],
		        	handler: this.go2Pos,
		        	scope: this
		        }]
	        }
	    });
				
		this.items = [this.listView];
				
		this.callParent();		
		
		/*
		 * register to manager
		 */
		Ext.menu.Manager.register(this);
		
		this.mon(this.listView, {
			scope: this,
			'itemclick': this.onItemClick
		});
	},
		
	/**
	 * init store
	 */
	initStore : function(){
		this.store = Ext.create('Ext.data.Store', {
			fields: ['id', 'name', 'ctype', 'coord', 'coordObj']
	    });
		if(this.refList){
			this.loadRefList(this.refList);
		}
	},
	
	loadRefList : function(refList){
		var store = this.store, sheetStore = this.sheet.getStore(), arr = [];
		store.removeAll();
		for(var i = 0, len = refList.length; i < len; i++){
			var it = refList[i], ctype = it.ctype;
            if('ref' === ctype){
                var obj = Ext.decode(it.json), coordStr;
                if(Ext.isArray(obj)){
                    var tmp = [];
                    for(var k = 0, size = obj.length; k < size; k++){
                        var span = obj[k].span;
                        span[0] = sheetStore.getSheetNameById(span[0]);
                        tmp.push(EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String([{
                            span: span,
                            type: SCONST.ABSOLUTE_COORD
                        }], undefined, true));
                    }
                    coordStr = tmp.join(',');
                }else{
                    var span = obj.span;
                    span[0] = sheetStore.getSheetNameById(span[0]);
                    coordStr = EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String([{
                        span: span,
                        type: SCONST.ABSOLUTE_COORD
                    }], undefined, true);
                }
			
                arr.push({
                    id: it.id,
                    name: it.name,
                    ctype: ctype,
                    coord: coordStr,
                    coordObj: obj
                });
            }
		}
		store.add(arr);
		if(this.deleteBtn){
			this.deleteBtn.disable();
		}
	},
	
	/**
	 * when click an item, go to the related position
	 */
	onItemClick : function(grid, rec){
		var coordObj = rec.data.coordObj;
		var span;
		if(Ext.isArray(coordObj)){
			span = coordObj[0].span;
		}else{
			span = coordObj.span;
		}
		var sheet = this.sheet, store = sheet.getStore(), sm = sheet.getSelectionModel();
		var sheetId = span[0];
		if(Ext.isString(sheetId)){
			sheetId = store.getSheetIdByName(sheetId);
		}		
		var curSheetId = sheet.getSheetId();
		if(curSheetId === sheetId){			
			sheet.go2Pos(span[1], span[2]);
			sm.selectRange({
				row: span[1],
				col: span[2]
			}, {
				row: span[3],
				col: span[4]
			});
		}else{
			sheet.go2Sheet(sheetId, function(){
				sheet.go2Pos(span[1], span[2]);
				sm.selectRange({
					row: span[1],
					col: span[2]
				}, {
					row: span[3],
					col: span[4]
				});
			});
		}
	},
	
	/*
	 * go to a position
	 */
	go2Pos : function(){
		if(!this.posField.isValid()){
			return;
		}
		var val = this.posField.getValue();
		var sheet = this.sheet, store = sheet.getStore();
		try{
            sheet.go2CoordSpan(val);			
		}catch(e){
			
		}
	},
	
	onKeyPress : function(field, e){
		var key = e.getKey();
		e.stopPropagation();
		var keyObj = Ext.EventObject ? Ext.EventObject : Ext.event.Event;
		if(keyObj.ENTER == key){			
			this.go2Pos();
		}
	}
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.pop.ReferenceNameWin', {
	
	/* Begin Definitions */
		
	extend : 'EnterpriseSheet.common.pop.PopWin',
	
	requires: [
	    'Ext.form.field.Text',
	    'EnterpriseSheet.sheet.calculate.Coordinate'
	],
	
	/* End Definitions */
	width : 500,
	
	height: 350,
        
	layout : 'border',
	
	labelWidth : 90,
	
	fieldLabel: SLANG['input_name'],
	
	bodyStyle: 'padding:15px;background-color:white;',
	
	prepareButton : Ext.emptyFn,
	
	cancelText: SLANG['close'],
	
	deleteText: SLANG['delete'],
	
	listEmptyText: SLANG['no_reference_name'],
	
	rangeLabelText : SLANG['value'],
           
    sheetLabelText : SLANG['scope'],
	
	withSheetName: true,
	
	/**
	 * an empty function to override
	 */
	checkValid : function(){
		return true;
	},
	
	initComponent : function(){
        var me = this;
		this.nameField = new Ext.form.field.Text({
			labelAlign: 'top',
			fieldLabel: this.fieldLabel,			
			allowBlank:false,
			enableKeyEvents:true,	
			value: this.nameValue,
			vtype: 'alphanum',
			listeners:{
				'keypress':{
					fn:this.onKeyPress,
					scope:this
				}
			},
			anchor: '100%'
		});
           
        /*
         * init store for list view
         */
        this.initStore();
           
        this.sheetField = new Ext.form.field.ComboBox({
            labelAlign: 'top',
            fieldLabel: this.sheetLabelText,
            allowBlank:false,
            store: this.scopeStore,
            valueField: 'id',
            displayField: 'name',
            queryMode: 'local',
            value: -1,
            anchor: '100%'
        });
				
		this.listView = new Ext.grid.Panel({
	        region: 'center',
	        store: this.store,
	        multiSelect: false,
	        //hideHeaders: true,
	        viewConfig: {
	            emptyText: '<div style="padding:10px;">'+this.listEmptyText+'</div>',
	            deferEmptyText: false
	        },
	        columns: [{
	            text: SLANG['name'],
	            flex: 40,
	            dataIndex: 'name'
            }, {
                text: SLANG['scope'],
                flex: 40,
                dataIndex: 'scope',
                renderer: function(val){
                    var rec = me.scopeStore.getById(val);
                    if(rec){
                        return rec.data.name;
                    }
                    return '';
                }
            }, {
	            text: SLANG['value'],
	            flex: 60,
	            dataIndex: 'coord'
	        }]
	    });
		
		this.rangeField = new EnterpriseSheet.sheet.range.RangeField({
			labelAlign: 'top',
			fieldLabel: this.rangeLabelText,
			/*
			 * need a ref of EnterpriseSheet.Sheet
			 */
			sheet:this.sheet,
			withSheetName: this.withSheetName,
			simpleSelect: this.simpleSelect,
			value: this.refValue,
			allowBlank:false,			
			anchor: '100%'
		});
		
		this.items = [{
			xtype: 'container',
			region: 'north',
			layout: 'anchor',
			items: [this.nameField]
		}, this.listView, {
			xtype: 'container',
			region: 'south',
			layout: 'anchor',
			style: 'padding-top:10px;',
			items: [this.sheetField, this.rangeField]
		}];
		
		this.deleteBtn = new Ext.button.Button({
			disabled: true,
			iconCls: 'icon-delete',
			style: 'margin-top:10px;',
			text: this.deleteText,
			handler: this.onDelete,
			scope: this
		});
		
		this.dockedItems = [{
			xtype: 'container',
			dock: 'right',
			width: 100,
			style: 'padding:0px 10px;',
			layout: {
				type: 'vbox',
				align: 'stretch'
			},
			items: [{
				xtype: 'button',
				text: this.okText,
				handler: this.onOK,
				scope: this
			}, {
				xtype: 'button',
				text: this.cancelText,
				style: 'margin-top:10px;',
				handler: this.onCancel,
				scope: this
			}, this.deleteBtn]
		}];
				
		this.callParent();		
		
		this.on('show', this._onShow, this);
        this.on('hide', this._onHide, this);
		
		this.mon(this.listView, {
			scope: this,
			'selectionchange': this.onSelectionChange
		});
		
		this.mon(this.rangeField, {
			scope: this,
			'minimode': this.onRangeMiniMode,
			'normalmode': this.onRangeNormalMode
		});
	},
	
	_onShow : function(){
		if(!SCOM.nullOrUndefined(this.nameField._nameValue)){
			this.nameField.setValue(this.nameField._nameValue);
		}
		if(!SCOM.nullOrUndefined(this.rangeField._refValue)){
			this.rangeField.setValue(this.rangeField._refValue);
		}
		this.nameField.focus(true, 100);
	},
           
    _onHide : function(){
        var rm = this.sheet.getReferenceModel();
        rm.hide();
    },
	
	/**
	 * init store
	 */
	initStore : function(){
		this.store = Ext.create('Ext.data.Store', {
			fields: ['fid', 'name', 'ctype', 'scope', 'coord']
	    });
		if(this.refList){
			this.loadRefList(this.refList);
		}
           
        this.scopeStore = Ext.create('Ext.data.Store', {
            fields: ['id', 'name']
        });
        this.loadScopeList();
	},
           
    loadScopeList : function(){
        var sheetStore = this.sheet.getStore(), sheets = sheetStore.getSheets();
        var data = [{'id': -1, 'name': SLANG['current_document']}];
        for(var i = 0, len = sheets.length; i < len; i++){
            var it = sheets[i];
            data.push({'id': it.id, 'name': it.name});
        }
        this.scopeStore.removeAll();
        this.scopeStore.add(data);
    },
	
	loadRefList : function(refList){
		var store = this.store, sheetStore = this.sheet.getStore(), arr = [], funcs = [];
		store.removeAll();
		for(var i = 0, len = refList.length; i < len; i++){
			var it = refList[i], ctype = it.ctype;
            if('ref' === ctype){
                var obj = Ext.decode(it.json), coordStr;
                if(Ext.isArray(obj)){
                    var tmp = [];
                    for(var k = 0, size = obj.length; k < size; k++){
                        var span = obj[k].span;
                        span[0] = sheetStore.getSheetNameById(span[0]);
                        tmp.push(EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String([{
                            span: span,
                            type: SCONST.ABSOLUTE_COORD
                        }], undefined, true));
                    }
                    coordStr = tmp.join(',');
                }else{
                    var span = obj.span;
                    span[0] = sheetStore.getSheetNameById(span[0]);
                    coordStr = EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String([{
                        span: span,
                        type: SCONST.ABSOLUTE_COORD
                    }], undefined, true);
                }
			
                arr.push({
                    fid: it.id,
                    name: it.name,
                    ctype: ctype,
                    scope: -1,
                    coord: coordStr
                });
            }else if('named_func' == ctype){
                var cal = it.json, scope, flag = true;
                try{
                    var jsonObj = Ext.decode(it.json);
                    if(!Ext.isArray(jsonObj)){
                        jsonObj = [jsonObj];
                    }
                    for(var k = 0, size = jsonObj.length; k < size; k++){
                        var jsonIt = jsonObj[k];
                        scope = jsonIt.scope;
                        cal = jsonIt.cal;
                        funcs.push({
                            fid: it.id,
                            name: it.name,
                            scope: (!Ext.isDefined(scope)) ? -1 : Number(scope),
                            ctype: ctype,
                            coord: '='+cal
                        });
                    }
                }catch(e){
                    funcs.push({
                        fid: it.id,
                        name: it.name,
                        scope: (!Ext.isDefined(scope)) ? -1 : Number(scope),
                        ctype: ctype,
                        coord: '='+cal
                    });
                }
            }
		}
		store.add(arr.concat(funcs));
		if(this.deleteBtn){
			this.deleteBtn.disable();
		}
	},
	
	/*
	 * update some config, such as title, fieldlabel, and callback
	 */
	updateConfig : function(config){
		Ext.apply(this, config);
		if(config.fieldLabel){
			var El = this.nameField.getEl();		
			/*
			 * need back to parentNode.parentNode, cause the label is actually render by the form layout
			 */
			var labelel = Ext.DomQuery.selectNode('label', El.dom.parentNode.parentNode);
			labelel.innerHTML = this.fieldLabel;
		}
		if(config.title){
			this.setTitle(config.title);
		}
		if(config.nameValue){
			this.nameField._nameValue = config.nameValue;			
			this.nameField.setValue(config.nameValue);
		}else{
			delete(this.nameField._nameValue);
		}
		
		if(config.refValue){
			this.rangeField._refValue = config.refValue;			
			this.rangeField.setValue(config.refValue);
		}else{
			delete(this.rangeField._nameValue);
		}
		
		if(config.refList){
			this.loadRefList(config.refList);
		}
        this.loadScopeList();
	},
		
	onKeyPress : function(field, e){
		var key = e.getKey();
		var keyObj = Ext.EventObject ? Ext.EventObject : Ext.event.Event;
		if(keyObj.ENTER == key){
			this.onOK();
		}
	},
	
	onOK : function(){
		if(this.nameField.isValid() && this.rangeField.isValid() && this.checkValid(this)){
			var name = this.nameField.getValue();
			if(this.applyCallback){
				var fn = this.applyCallback.fn, scope = this.applyCallback.scope, sheetId = this.sheetField.getValue();
                if(-1 === sheetId){
                    sheetId = undefined;
                }
				var v = this.rangeField.getValue();
                if('=' === v[0]){
                    var func = v.slice(1, v.length);
                    fn.call(scope, name, func, 'named_func', sheetId);
                }
			}
			this.hide();
		}
	},
	
	/**
	 * when selection change of list view
	 */
	onSelectionChange : function(sm, selection){
		if(0 < selection.length){
			var sel = selection[0];
			this.nameField.setValue(sel.data.name);
			this.deleteBtn.enable();
			
		}else{
			this.deleteBtn.disable();
		}
	},
	
	/**
	 * delete the selection
	 */
	onDelete : function(){
		var sm = this.listView.getSelectionModel();
		var sel = sm.getLastSelected();
		this.store.remove(sel);		
        if(this.deleteCallback){
            var fn = this.deleteCallback.fn, scope = this.deleteCallback.scope;
            fn.call(scope, sel.data.ctype, sel.data.name, -1 === sel.data.scope ? undefined : sel.data.scope);
        }
        this.nameField.reset();
	},
	
	/**
	 * when the range field collapse to mini mode
	 */
	onRangeMiniMode : function(miniWin, rangeField){
        this.nameField._nameValue = this.nameField.getValue();
		this.hide();
	},
	
	/**
	 * when the range field collapse to mini mode
	 */
	onRangeNormalMode : function(miniWin, rangeField){
		this.show();
	}
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.pop.SizeWin', {
	
	/* Begin Definitions */
		
	extend : 'EnterpriseSheet.common.pop.PopWin',
	
	requires: ['Ext.form.field.Number'],
	
	/* End Definitions */
	width : 270,
    	
    minHeight: 80,
        
	layout : 'anchor',
	
	labelWidth : 90,
	
	invalidMsg : 'Can not be a negative number',		
	
	initComponent : function(){
		
		this.numberField = new Ext.form.NumberField({
			fieldLabel:this.fieldLabel,
			msgTarget:'side',
			allowBlank:false,
			enableKeyEvents:true,
			invalidMsg:this.invalidMsg,
			listeners:{
				'keypress':{
					fn:this.onKeyPress,
					scope:this
				}
			},
			validator:function(v){
				if(0 <= v){
					return true;
				}else{
					return this.invalidMsg;
				}
			},
			anchor: '100%'
		});
		
		this.items = [this.numberField];
				
		this.callParent();		
		
		this.on('show', this._onShow, this);
	},
	
	_onShow : function(){		
		this.numberField.focus(true, 100);
	},
	
	/*
	 * update some config, such as title, fieldlabel, and callback
	 */
	updateConfig : function(config){
		Ext.apply(this, config);
		if(config.fieldLabel){
			var El = this.numberField.getEl();		
			/*
			 * need back to parentNode.parentNode, cause the label is actually render by the form layout
			 */
			var labelel = Ext.DomQuery.selectNode('label', El.dom.parentNode.parentNode);
			labelel.innerHTML = this.fieldLabel;
		}
		if(config.title){
			this.setTitle(config.title);
		}
	},
	
	/*
	 * overwrite to prepare the params
	 */
	prepareParam : function(){		
		return this.numberField.getValue();
	},	
	
	onKeyPress : function(field, e){
		var key = e.getKey();
		var keyObj = Ext.EventObject ? Ext.EventObject : Ext.event.Event;
		if(keyObj.ENTER == key){
			this.onOK();
		}
	}
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.pop.SortOptionWin', {
	
	/* Begin Definitions */
		
	extend : 'EnterpriseSheet.common.pop.PopWin',
	
	requires: ['Ext.form.field.Radio'],
	
	/* End Definitions */
	
	boxLabel1 : '',
	
	boxLabel2 : '',
	
	title : '',	
	
	bodyStyle : 'padding:10px;',
	
	width : 250,
	
	layout: 'anchor',
	
	autoHeight : true,
	
	initComponent : function(){
		
		// check config file to see whether boxLabel2:SLANG['only_current_range'] is disabled 
		var disableSortRange = false;
		if (SCONFIG.DISABLE_SORT_CURRENT_RANGE) disableSortRange = true;
		
		this.defaults = {
			'anchor': '100%'
		};
		this.items = [{
			xtype:'radio',
			checked:true,
			boxLabel:this.boxLabel1,
			name:'cell-option'
		}, {
			xtype:'radio',
			disabled: disableSortRange,
			boxLabel:this.boxLabel2,
			name:'cell-option'
		}];				
		
		this.callParent();		
	},
	
	/*
	 * update some config, such as callback
	 */
	updateConfig : function(config){
		Ext.apply(this, config);		
		if(config.title){
			this.setTitle(config.title);
		}
		
		if(config.boxLabel1){
			var labelEl = this.items.get(0).labelEl;
			labelEl.update(config.boxLabel1);
		}
		if(config.boxLabel2){			
			var labelEl = this.items.get(1).labelEl;
			labelEl.update(config.boxLabel2);
		}		
	},
	
	/*
	 * overwrite to prepare the params
	 */
	prepareParam : function(){
		var opt, i = 0;
		this.items.each(function(it){				
			if(it.getValue()){
				opt = i;
				return false;
			}
			i++;
		}, this);
		return opt;
	}
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.pop.TextWin', {
	
	/* Begin Definitions */
		
	extend : 'EnterpriseSheet.common.pop.PopWin',
	
	requires: [
	    'Ext.form.field.Text'
	],
	
	/* End Definitions */
	width : 400,    	    
        
	layout : 'anchor',
	
	labelWidth : 90,
	
	fieldLabel: SLANG['input_name'],
	
	bodyStyle: 'padding:25px;background-color:white;',
	
	initComponent : function(){
		
		this.nameField = new Ext.form.field.Text({
			labelAlign: 'top',
			fieldLabel: this.fieldLabel,			
			allowBlank:false,
			enableKeyEvents:true,	
			value: this.value,
			vtype: this.filedVtype,
			listeners:{
				'keypress':{
					fn:this.onKeyPress,
					scope:this
				}
			},
			anchor: '100%'
		});
		
		this.items = [this.nameField];
				
		this.callParent();		
		
		this.on('show', this._onShow, this);
	},
	
	_onShow : function(){				
		if(!SCOM.nullOrUndefined(this.nameField._value)){
			this.nameField.setValue(this.nameField._value);
		}		
		this.nameField.focus(true, 100);
	},
	
	/*
	 * update some config, such as title, fieldlabel, and callback
	 */
	updateConfig : function(config){
		Ext.apply(this, config);
		if(config.fieldLabel){
			var El = this.nameField.getEl();		
			/*
			 * need back to parentNode.parentNode, cause the label is actually render by the form layout
			 */
			var labelel = Ext.DomQuery.selectNode('label', El.dom.parentNode.parentNode);
			labelel.innerHTML = this.fieldLabel;
		}
		if(config.title){
			this.setTitle(config.title);
		}
		if(config.value){
			this.nameField._value = config.value;			
			this.nameField.setValue(config.value);
		}else{
			delete(this.nameField._value);
		}
	},
		
	onKeyPress : function(field, e){
		var key = e.getKey();
		var keyObj = Ext.EventObject ? Ext.EventObject : Ext.event.Event;
		if(keyObj.ENTER == key){
			this.onOK();
		}
	},
	
	onOK : function(){
		if(this.nameField.isValid()){
			var name = this.nameField.getValue();
			var flag = false;
			if(this.applyCallback){
				var fn = this.applyCallback.fn, scope = this.applyCallback.scope;
				flag = fn.call(scope, name);				
			}
			if(true !== flag){
				this.hide();
			}			
		}
	}
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.pop.ValidationWin', {
	
	/* Begin Definitions */
		
	extend : 'EnterpriseSheet.common.pop.PopWin',
	
	requires: [
	    'Ext.form.field.Date'
	],
	
	/* End Definitions */
	
	title : SLANG['validation'],
	
	width : 680,
    	
    autoHeight: true,
    
    modal: false,
    
    /*
     * item separate char
     */
    itemSepChar : ',',
        
	layout : 'anchor',	
	
	fieldLabel: SLANG['comment'],
	
	listEmptyText: SLANG['new_validation'],
	
	skipResetOnShow : true,
	
	bodyStyle: 'padding:40px 20px 10px 20px;background-color:white;',	
	
	/**
	 * init store
	 */
	initStore : function(){
		this.store = Ext.create('Ext.data.Store', {
			fields: ['vid', 'coord', 'json']
	    });
		
	},
	
	initComponent : function(){		
		/*
		 * init store for list view
		 */
		this.initStore();
		this.listView = new Ext.view.View({
			dock: 'left',	
			width: 120,
			cls: 'ss-validation-list',
	        store: this.store,
	        multiSelect: false,
	        tpl: new Ext.XTemplate([
				'<tpl for=".">',
					'<div class="item">',
					  '{coord}',
					'</div>',
				'</tpl>'
	        ].join(''), {
	        	compile: true
	        }),
	        itemSelector: 'div.item',
	        overItemCls : 'x-item-over',
	        emptyText: '<div style="padding:10px;">'+this.listEmptyText+'</div>'
	    });
		
		this.rangeField = new EnterpriseSheet.sheet.range.RangeField({	
			fieldLabel: SLANG['cell_range'],
			labelWidth : 70,
			/*
			 * need a ref of EnterpriseSheet.Sheet
			 */
			sheet:this.sheet,			
			flex:1,
			anchor: '100%',
			value:this.value,
			margin: '0 0 15 0',
			allowBlank:false
		});
		
		this.dataTypeBtn = new Ext.button.Button({
			text: SLANG['number'],
			dtype: SCONST.validateDataType['number'],
			width: 90,
			menu: [{
				text: SLANG['number'],
				dtype: SCONST.validateDataType['number'],
				handler: this.selectNumber,
				scope: this
			}, {
				text: SLANG['text'],
				dtype: SCONST.validateDataType['text'],
				handler: this.selectText,
				scope: this
			}, {
				text: SLANG['date'],
				dtype: SCONST.validateDataType['date'],
				handler: this.selectDate,
				scope: this
			}, {
				text: SLANG['item_list'],
				dtype: SCONST.validateDataType['list'],
				handler: this.selectItem,
				scope: this
			}],
        	margin: '0 5 0 0'
		});
		
		this.optionBtn = new Ext.button.Button({
			text: SLANG['between'],
			option: SCONST.validateOption['between'],
			width: 100,
			menu: {
				defaults: {
					handler: this.selectOption,
					scope: this
				},
				items: [{
					option: SCONST.validateOption['between'],
					dtype: SCONST.validateDataType['number'],
					text: SLANG['between']
				}, {
					option: SCONST.validateOption['not_between'],
					dtype: SCONST.validateDataType['number'],
					text: SLANG['not_between']
				}, {
					option: SCONST.validateOption['less'],
					dtype: SCONST.validateDataType['number'],
					text: '<'
				}, {
					option: SCONST.validateOption['less_equal'],
					dtype: SCONST.validateDataType['number'],
					text: '<='
				}, {
					option: SCONST.validateOption['greater'],
					dtype: SCONST.validateDataType['number'],
					text: '>'
				}, {
					option: SCONST.validateOption['greater_equal'],
					dtype: SCONST.validateDataType['number'],
					text: '>='
				}, {
					option: SCONST.validateOption['equal'],
					dtype: SCONST.validateDataType['number'],
					text: '='
				}, {
					option: SCONST.validateOption['not_equal'],
					dtype: SCONST.validateDataType['number'],
					text: '!='
				}, {
					option: SCONST.validateOption['contain'],
					dtype: SCONST.validateDataType['text'],
					hidden: true,
					text: SLANG['contain']
				}, {
					option: SCONST.validateOption['not_contain'],
					dtype: SCONST.validateDataType['text'],
					hidden: true,
					text: SLANG['not_contain']
				}, {
					option: SCONST.validateOption['equal'],
					dtype: SCONST.validateDataType['text'],
					hidden: true,
					text: SLANG['equal']
				}, {
					option: SCONST.validateOption['is_email'],
					dtype: SCONST.validateDataType['text'],
					hidden: true,
					text: SLANG['is_valid_email']
				}, {
					option: SCONST.validateOption['is_url'],
					dtype: SCONST.validateDataType['text'],
					hidden: true,
					text: SLANG['is_valid_url']
				}, {
					option: SCONST.validateOption['is_date'],
					dtype: SCONST.validateDataType['date'],
					hidden: true,
					text: SLANG['is_valid_date']
				}, {
					option: SCONST.validateOption['equal'],
					dtype: SCONST.validateDataType['date'],
					hidden: true,
					text: SLANG['equal']
				}, {
					option: SCONST.validateOption['date_before'],
					dtype: SCONST.validateDataType['date'],
					hidden: true,
					text: SLANG['before']
				}, {
					option: SCONST.validateOption['date_on_before'],
					dtype: SCONST.validateDataType['date'],
					hidden: true,
					text: SLANG['on_before']
				}, {
					option: SCONST.validateOption['date_after'],
					dtype: SCONST.validateDataType['date'],
					hidden: true,
					text: SLANG['after']
				}, {
					option: SCONST.validateOption['date_on_after'],
					dtype: SCONST.validateDataType['date'],
					hidden: true,
					text: SLANG['on_after']
				}, {
					option: SCONST.validateOption['between'],
					dtype: SCONST.validateDataType['date'],
					hidden: true,
					text: SLANG['between']
				}, {
					option: SCONST.validateOption['not_between'],
					dtype: SCONST.validateDataType['date'],
					hidden: true,
					text: SLANG['not_between']
                }, {
                    option: SCONST.validateOption['any_number'],
                    dtype: SCONST.validateDataType['number'],
                    hidden: true,
                    text: SLANG['any_number']
                }]
			},
        	margin: '0 5 0 0'
		});
		
		this.hintField = new Ext.form.field.Text({
			fieldLabel: SLANG['hint_text'],
			labelWidth : 70,
			labelSeparator : '',
			anchor: '100%',
			//allowBlank: false,
			margin: '0 0 15 0'
		});
		
		this.allowInvalidCheckbox = new Ext.form.field.Checkbox({
			fieldLabel: '&nbsp;',
			labelWidth : 70,
			checked: true,
			labelSeparator : '',
			boxLabel: SLANG['allow_invalid'],
			margin: '0 0 15 0'
		});
		
		this.ignoreBlankCheckbox = new Ext.form.field.Checkbox({
			fieldLabel: '&nbsp;',
			labelWidth : 70,
			checked: true,
			labelSeparator : '',
			boxLabel: SLANG['ignore_blank'],
			margin: '0 0 15 0'
		});
		
		this.numField = new Ext.form.field.Number({
			hidden: true,
			flex: 1,
			margin: '0 5 0 0',
            allowBlank: false
		});
           
        this.intCheckbox = new Ext.form.field.Checkbox({
			hidden: true,
            labelSeparator : '',            
            hideLabel: true,
            width: 100,
            boxLabel: SLANG['integer_only'],
			margin: '0 0 0 5'
        });
		
		this.minField = new Ext.form.field.Number({
			margin: '0 5 0 0',
			flex: 1,
            allowBlank: false
		});
		
		this.maxField = new Ext.form.field.Number({
			flex: 1,
            allowBlank: false
		});
		
		this.textField = new Ext.form.field.Text({
			hidden: true,
			flex: 2,
            allowBlank: false
		});
		
		this.dateField = new Ext.form.field.Date({
			hidden: true,
			flex: 2,
            allowBlank: false
		});
		
		this.minDateField = new Ext.form.field.Date({
			hidden: true,
			margin: '0 5 0 0',
            allowBlank: false
		});
		
		this.maxDateField = new Ext.form.field.Date({
			hidden: true,
            allowBlank: false
		});
		
		this.emptyBox = new Ext.Component({
			hidden: true,
			flex: 2
		});
		
		this.fieldCt = new Ext.form.FieldContainer({
            fieldLabel: SLANG['criteria'],
            labelWidth : 70,
            combineErrors: true,
            msgTarget : 'qtip',
            layout: 'hbox',
            defaults: {                
                hideLabel: true                
            },
            items: [
                this.dataTypeBtn, 
                this.optionBtn, 
                this.minField, this.maxField, this.numField, this.intCheckbox,
                this.textField, 
                this.dateField, this.minDateField, this.maxDateField,
                this.emptyBox
            ],
            margin: '0 0 15 0'
		});
		
		this.itemField = new Ext.form.field.Text({
            style: 'margin-top:10px;',
            width: '100%',
			allowBlank: false
		});
		
		this.itemListCt = new Ext.form.FieldContainer({
            fieldLabel: '&nbsp;',
            labelWidth : 70,
            labelSeparator : '',
            combineErrors: true,
            msgTarget : 'qtip',
			hidden: true,
			layout: 'fit',
			items: [{
				xtype: 'component',
				cls: 'sc-item-list-hint',
				html: SLANG['item_hint']
			}, this.itemField],
			margin: '0 0 15 0'
		});
		
		
		this.items = [
		    this.rangeField, 
		    this.fieldCt, 
		    this.itemListCt,
		    this.hintField, 
		    this.allowInvalidCheckbox,
		    this.ignoreBlankCheckbox,
		    {
		    	xtype: 'container',
		    	layout: {
		    		type: 'hbox',
		    		pack: 'end'
		    	},
		    	style: 'padding-top:30px;',
		    	items: [{
		    		xtype: 'button',
		    		margins: '0 10 0 0',
		    		minWidth: 70,
					text: SLANG['save'],
					handler:this.onSave,
					scope:this
				}, {
					xtype: 'button',
					text: SLANG['remove_validation'],
					margins: '0 10 0 0',
					handler:this.onRemoveValidation,
					scope:this
				}, {
					xtype: 'button',
					text: SLANG['close'],
					minWidth: 70,
					handler:this.onCancel,
					scope:this
				}]
		    }
		];
		
		this.dockedItems = [this.listView];
				
		this.callParent();		
		
		this.on('show', this._onShow, this);
		
		this.mon(this.rangeField, {
			scope: this,
			'minimode': function(){
				this.hide();
			},
			'normalmode': function(){
				this.show();
			}
		});
		
		this.mon(this.listView, {
			scope: this,
			'selectionchange': this.onValidateSelectionChange
		});
		
		/*
		 * check the valid value when min/max field is changed
		 */
		this.mon(this.minField, {
			scope: this,
			'change': this.onMinChange
		});
		
		this.mon(this.maxField, {
			scope: this,
			'change': this.onMaxChange
		});
		
		this.mon(this.minDateField, {
			scope: this,
			'change': this.onMinDateChange
		});
		
		this.mon(this.maxDateField, {
			scope: this,
			'change': this.onMaxDateChange
		});
	},
	
	/**
	 * set the data type
	 */
	setDataTypeOption : function(dt, op){
		var found;
		var menu = this.dataTypeBtn.menu;
		if(!SCOM.nullOrUndefined(dt)){
			this.dataTypeBtn.dtype = dt;
			
			menu.items.each(function(it){
				if(dt === it.dtype){
					found = it;
					this.dataTypeBtn.setText(it.text);
					return false;
				}
			}, this);
		}else{
			var it = menu.items.first();
			found = it;
			this.dataTypeBtn.dtype = it.dtype;
			this.dataTypeBtn.setText(it.text);
		}
		
		found.handler.call(this, found);
		
		menu = this.optionBtn.menu;
		if(!SCOM.nullOrUndefined(op)){
			this.optionBtn.option = op;
			menu.items.each(function(it){
				if(op === it.option){
					this.optionBtn.setText(it.text);
					found = it;
					return false;
				}
			}, this);
		}else{
			var it = menu.items.first();
			this.optionBtn.option = it.option;
			this.optionBtn.setText(it.text);
			found = it;
		}
		this.selectOption(found);
	},
	
	/**
	 * popup this win
	 */
	popup : function(){
		this.show();
		var sheet = this.sheet;
		if(sheet){		
			this.prepareValidation();
		}
	},
	
	/**
	 * when this window show, we need turn on the reference model for sheet
	 * and turn off the selection model
	 */
	_onShow : function(){		
		var sheet = this.sheet;
		if(sheet){			
			/*
			 * disable the selectionModel and editor
			 */
			sheet.disableSelect();
			sheet.disableEdit();			
			/*
			 * enable reference model, clear the reference selection, and set it to single select mode 
			 */
			sheet.enableRefer(true);
			
		}
		this.rangeField.focus(null, 10);
	},
	
	/**
	 * check whether the validation setting is valid
	 */
	isValid : function(){
		var valid = true;
		if(!this.rangeField.isValid()){
			valid = false;
		}
		if(!this.hintField.isValid()){
			valid = false;
		}
		
		if(this.minField.isVisible() && !this.minField.isValid()){
			valid = false;
		}
		
		if(this.maxField.isVisible() && !this.maxField.isValid()){
			valid = false;
		}
		
		if(this.numField.isVisible() && !this.numField.isValid()){
			valid = false;
		}
		
		if(this.textField.isVisible() && !this.textField.isValid()){
			valid = false;
		}
		
		if(this.dateField.isVisible() && !this.dateField.isValid()){
			valid = false;
		}
		
		if(this.minDateField.isVisible() && !this.minDateField.isValid()){
			valid = false;
		}
		
		if(this.maxDateField.isVisible() && !this.maxDateField.isValid()){
			valid = false;
		}
		
		if(this.itemListCt.isVisible() && !this.itemField.isValid()){
			valid = false;
		}
		
		return valid;
	},
	
	/*
	 * overwrite quit
	 */
	quit : function(){
		this.callParent(arguments);		
		/*
		 * when this window quit, we need turn off the reference model for sheet
		 * and turn on the selection model
		 */
		var sheet = this.sheet;
		if(sheet){	
			sheet.enableSelect();
			sheet.enableEdit();
			/*
			 * disable reference model, clear the reference selection, and cancel the single select mode 
			 */
			sheet.disableRefer(true);
		}
	},
	
	/*
	 * update some config, such as title, fieldlabel, and callback
	 */
	updateConfig : function(config){
		Ext.apply(this, config);
		
	},
	
	prepareButton : function(){
		delete(this.buttons);
	},
	
	/**
	 * get the validation setting
	 */
	getValidSetting : function(){	
		var sels = this.listView.getSelectionModel().getSelection();
		var sel = sels[0];
		var dts = SCONST.validateDataType, ops = SCONST.validateOption;
		var dataType = this.dataTypeBtn.dtype;
		var option = this.optionBtn.option;
		
		var json = {
			'id': sel.data.vid,
			'dt': dataType,
			'op': option
		};
		if(dts['number'] === dataType){
			if(ops['between'] === option || ops['not_between'] === option){
				var min = this.minField.getValue();
				var max = this.maxField.getValue();
				json['min'] = min;
				json['max'] = max;
			}else{
				var num = this.numField.getValue();
				json['num'] = num;
			}
            if(this.intCheckbox.getValue()){
                json['io'] = true;
            }
		}else if(dts['text'] === dataType){
			if(ops['is_email'] !== option && ops['is_url'] !== option){
				var text = this.textField.getValue();
				json['txt'] = text;
			}			
		}else if(dts['date'] === dataType){
			if(ops['between'] === option || ops['not_between'] === option){
				var mind = this.minDateField.getValue();
				var maxd = this.maxDateField.getValue();
				json['mind'] = Ext.Date.format(mind, 'Y-m-d');
				json['maxd'] = Ext.Date.format(maxd, 'Y-m-d');
			}else if(ops['is_date'] !== option){
				var date = this.dateField.getValue();			
				json['date'] = Ext.Date.format(date, 'Y-m-d');
			}			
		}else if(dts['list'] === dataType){
			json['list'] = this.getItemList();
		}
		json['hint'] = this.hintField.getValue();
		json['allow'] = this.allowInvalidCheckbox.getValue();
		json['ignoreBlank'] = this.ignoreBlankCheckbox.getValue();
		var coord = this.rangeField.getCoord();
		var arr = [];
		for(var i = 0, len = coord.length; i < len; i++){
			arr.push(coord[i].span);
		}
		json['coord'] = arr;
		
		return json;
	},
	
	/**
	 * click save
	 */
	onSave : function(){	
		if(this.isValid()){
			var setting = this.getValidSetting();
			
			var id = setting.id;
			delete(setting.id);
			this.sheet.setValidation(setting, false, false, id);
			this.hide();
		}		
	},
		
	
	/**
	 * on remove the validation
	 */
	onRemoveValidation : function(){
		var sels = this.listView.getSelectionModel().getSelection();
		var sel = sels[0];
		var id = sel.data.vid;
		if(id){
			Ext.Msg.show({
				title: SLANG['confirm'],
				msg: SLANG['do_u_really_wanna_delete'],
				icon: Ext.Msg.QUESTION,
				buttons: Ext.Msg.YESNO,
				fn: function(btn){
					if('yes' == btn){
						this.sheet.setValidation(null, false, false, id, 'delete');
						this.hide();
					}
				},
				scope: this
			});
		}else{
			this.hide();
		}
	},
	
	/**
	 * switch options
	 */
	switchOptions : function(dtype){
		var items = this.optionBtn.menu.items;
		var first;
		items.each(function(it){
			if(it.dtype === dtype){
				if(!first){
					first = it;
				}
				it.show();
			}else{
				it.hide();
			}
		});
		if(first){
			this.selectOption(first);
		}
	},
	
	/**
	 * select the number 
	 */
	selectNumber : function(item){		
		this.optionBtn.show();
		this.itemListCt.hide();
		if(Ext.isFunction(this.doLayout)){
        	this.doLayout();
        }else if(Ext.isFunction(this.updateLayout)){
        	this.updateLayout();
        } 
		this.dataTypeBtn.setText(item.text);
		this.dataTypeBtn.dtype = item.dtype;	
		this.switchOptions(item.dtype);
	},
	
	/**
	 * select the text 
	 */
	selectText : function(item){
		this.optionBtn.show();
		this.itemListCt.hide();
		if(Ext.isFunction(this.doLayout)){
        	this.doLayout();
        }else if(Ext.isFunction(this.updateLayout)){
        	this.updateLayout();
        } 
		this.dataTypeBtn.setText(item.text);
		this.dataTypeBtn.dtype = item.dtype;
		this.switchOptions(item.dtype);
	},
	
	/**
	 * select the date 
	 */
	selectDate : function(item){
		this.optionBtn.show();
		this.itemListCt.hide();
		if(Ext.isFunction(this.doLayout)){
        	this.doLayout();
        }else if(Ext.isFunction(this.updateLayout)){
        	this.updateLayout();
        } 
		this.dataTypeBtn.setText(item.text);
		this.dataTypeBtn.dtype = item.dtype;
		this.switchOptions(item.dtype);
	},
	
	/**
	 * select the item 
	 */
	selectItem : function(item){
		this.intCheckbox.hide();
		this.minField.hide();
		this.maxField.hide();
		this.textField.hide();
		this.dateField.hide();
		this.minDateField.hide();
		this.maxDateField.hide();
		this.emptyBox.show();
		this.optionBtn.hide();
		this.itemListCt.show();
		if(Ext.isFunction(this.doLayout)){
        	this.doLayout();
        }else if(Ext.isFunction(this.updateLayout)){
        	this.updateLayout();
        } 
		this.dataTypeBtn.setText(item.text);
		this.dataTypeBtn.dtype = item.dtype;
		this.switchOptions(item.dtype);
	},
	
	/**
	 * select an option
	 */
	selectOption : function(item){
		var option = item.option;
		this.optionBtn.option = option;
		this.optionBtn.setText(item.text);
		var dtype = this.dataTypeBtn.dtype;
		var dts = SCONST.validateDataType, ops = SCONST.validateOption;
		
		if(dts['number'] == dtype){
            this.intCheckbox.show();
			if(ops['between'] === option || ops['not_between'] === option){
				this.minField.show();
				this.maxField.show();
				this.numField.hide();
				this.dateField.hide();
				this.minDateField.hide();
				this.maxDateField.hide();
				this.textField.hide();
				this.emptyBox.hide();
           }else if(ops['any_number'] === option){
                this.minField.hide();
                this.maxField.hide();
                this.numField.hide();
                this.dateField.hide();
                this.minDateField.hide();
                this.maxDateField.hide();
                this.textField.hide();
                this.emptyBox.hide();
           }else{
				this.minField.hide();
				this.maxField.hide();
				this.numField.show();
				this.dateField.hide();
				this.minDateField.hide();
				this.maxDateField.hide();
				this.textField.hide();
				this.emptyBox.hide();
			}
		}else if(dts['text'] == dtype){
            this.intCheckbox.hide();
			if(ops['is_email'] === option || ops['is_url'] === option){
				this.minField.hide();
				this.maxField.hide();
				this.numField.hide();
				this.dateField.hide();
				this.minDateField.hide();
				this.maxDateField.hide();
				this.textField.hide();
				this.emptyBox.show();
			}else{
				this.minField.hide();
				this.maxField.hide();
				this.numField.hide();
				this.dateField.hide();
				this.minDateField.hide();
				this.maxDateField.hide();
				this.textField.show();
				this.emptyBox.hide();
			}
		}else if(dts['date'] == dtype){
            this.intCheckbox.hide();
			if(ops['is_date'] === option){
				this.minField.hide();
				this.maxField.hide();
				this.numField.hide();
				this.dateField.hide();
				this.minDateField.hide();
				this.maxDateField.hide();
				this.textField.hide();
				this.emptyBox.show();
			}else if(ops['between'] === option || ops['not_between'] === option){
				this.minField.hide();
				this.maxField.hide();
				this.numField.hide();
				this.dateField.hide();
				this.minDateField.show();
				this.maxDateField.show();
				this.textField.hide();
				this.emptyBox.hide();
			}else{
				this.minField.hide();
				this.maxField.hide();
				this.numField.hide();
				this.dateField.show();
				this.minDateField.hide();
				this.maxDateField.hide();
				this.textField.hide();
				this.emptyBox.hide();
			}
		}else{
			this.intCheckbox.hide();
		}
	},
	
	/**
	 * prepare sheet validation
	 */
	prepareValidation : function(){
		var store = this.store;
		var sheet = this.sheet;
		var sheetId = sheet.getSheetId();
		var sm = sheet.getSelectionModel();
		
		var sep = EnterpriseSheet.sheet.calculate.Coordinate.prototype.separator;		
		
		store.removeAll();
		
		var sheetStore = sheet.getStore();
		
		var vds = sheetStore.getValidationBySheet(sheetId) || [];
		var lookup = {};
		
		for(var i = 0, len = vds.length; i < len; i++){
			var it = vds[i];
			var coord = it.coord;
			
			var coordStr = sheet.coord2StringWithSheetName(coord, sep, true);						
			lookup[coordStr] = store.add({
				vid: it.id,
				coord: coordStr,
				json: it
			});			
		}
		var coord = sm.selection2Coord();
		var coordStr = sheet.coord2StringWithSheetName(coord, sep, true);
		if(!lookup[coordStr]){
			store.insert(0, {
				coord: coordStr,
				json: {coord: coord}
			});
		}else{
			store.remove(lookup[coordStr]);
			store.insert(0, lookup[coordStr]);
		}
		
		this.rangeField.focus(null, 10);
		this.rangeField.setValue(coord);
		
		this.listView.select(0);
	},
	
	/**
	 * when select different validation in the list
	 */
	onValidateSelectionChange : function(){
		var list = this.listView;
		var sels = list.selModel.getSelection();
		
		if(0 < sels.length){
			var rec = sels[0];
			var json = rec.data.json;
			this.presetFields(json);
			this.rangeField.focus(100);
		}
	},
	
	/**
	 * preset the fields
	 */
	presetFields : function(json){
		var coord = json.coord;
		this.rangeField.setValue(coord);
		var dt = json.dt, op = json.op, io = json.io;
		this.setDataTypeOption(dt, op);
           
        this.intCheckbox.setValue(io ? true : false);
		if(Ext.isNumber(json.min)){
			this.minField.setValue(json.min);
		}else{
			this.minField.reset();
		}
		if(Ext.isNumber(json.max)){
			this.maxField.setValue(json.max);
		}else{
			this.maxField.reset();
		}
		if(Ext.isNumber(json.num)){
			this.numField.setValue(json.num);
		}else{
			this.numField.reset();
		}
		
		if(json.txt){
			this.textField.setValue(json.txt);
		}else{
			this.textField.reset();
		}
		
		
		if(json.date){
			this.dateField.setValue(json.date);
		}else{
			this.dateField.reset();
		}
		if(json.mind){
			this.minDateField.setValue(json.mind);
		}else{
			this.minDateField.reset();
		}
		if(json.maxd){
			this.maxDateField.setValue(json.maxd);
		}else{
			this.maxDateField.reset();
		}
		
		if(json.list){
			var str = json.list.join(this.itemSepChar);
			this.itemField.setValue(str);
		}else{
			this.itemField.reset();
		}
		
		if(json.hint){
			this.hintField.setValue(json.hint);
		}else{
			this.hintField.reset();
		}
		
		if(false === json.allow){
			this.allowInvalidCheckbox.setValue(false);
		}else{
			this.allowInvalidCheckbox.setValue(true);
		}
		
		if(false === json.ignoreBlank){
			this.ignoreBlankCheckbox.setValue(false);
		}else{
			this.ignoreBlankCheckbox.setValue(true);
		}
	},
	
	/**
	 * when min field is changed
	 */
	onMinChange : function(field, newVal, oldVal){
		var other = this.maxField.getValue();
		if(other < newVal){
			this.maxField.setValue(newVal);
		}
	},
	
	/**
	 * when max field is changed
	 */
	onMaxChange : function(field, newVal, oldVal){
		var other = this.minField.getValue();
		if(other > newVal){
			this.minField.setValue(newVal);
		}
	},
	
	/**
	 * when min date field is changed
	 */
	onMinDateChange : function(field, newVal, oldVal){
		var other = this.maxDateField.getValue();
		if(0 < newVal-other){
			this.maxDateField.setValue(newVal);
		}
	},
	
	/**
	 * when max field is changed
	 */
	onMaxDateChange : function(field, newVal, oldVal){
		var other = this.minDateField.getValue();
		if(0 > newVal-other){
			this.minDateField.setValue(newVal);
		}
	},
	
	/**
	 * get item list
	 */
	getItemList : function(){
		var val = this.itemField.getValue();
		var arr = val.split(this.itemSepChar);
		var list = [];
		for(var i = 0, len = arr.length; i < len; i++){
			var it = Ext.String.trim(arr[i]);
			if(it){
				list.push(it);
			}
		}
		return list;
	}
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.pop.AttachmentWin', {
	
	/* Begin Definitions */
		
	extend : 'EnterpriseSheet.common.pop.PopWin',
	
	requires: [
	    'EnterpriseSheet.common.PhotoViewer'
	],
	
	/* End Definitions */
	width : 600,
    	
    height: 500,
	
	labelWidth : 90,
	
	title: SLANG['attachment'],
           
    layout: 'border',
	
	bodyStyle: 'background-color:white;',
	
	initComponent : function(){
        this.uploadForm = Ext.create('Ext.form.Panel', {
            border: false,
            fileUpload: true,
            url: SCONFIG.urls['uploadFile'],
            width: 100,
            layout: {
                type: 'hbox',
                align: 'middle'
            },
            items: [{
                xtype: 'filefield',
                buttonOnly: true,
                name: 'filePath',
                buttonConfig: {
                    iconCls: 'icon-attach',
                    text: SLANG['upload_file'],
                    ui: 'default-toolbar'
                },
                listeners: {
                    'change': {
                        fn: this.onSelectLocalFile,
                        scope: this
                    }
                }
            }]
        });
        this.dockedItems = [{
            xtype: 'toolbar',
            layout: {
                type:'hbox',
                padding: '5'
            },
            style: 'background:white;',
            items: [this.uploadForm, {
                xtype: 'component',
                flex: 1,
                cls: 'ss-attach-hint',
                html: SLANG['upload_linke_attachment']
            }, {
                xtype: 'container',
                width: 100,
                layout: {
                    type: 'hbox',
                    align: 'middle',
                    pack: 'end'
                },
                items: [{
                    xtype: 'button',
                    iconCls: 'icon-link',
                    hidden: true,
                    text: SLANG['link_file'],
                    ui: 'default-toolbar'                        
                }]
            }]
        }];
				
        this.hintBox = Ext.create('Ext.Component', {
            cls: 'ss-upload-hint',
            region: 'north',
            html: SLANG['uploading'],
            hidden: true
        });
           
        this.store = this.store || Ext.create('Ext.data.ArrayStore', {
            fields: [
                {name: 'aid', type: 'string'},
                {name: 'url', type: 'string'},
                {name: 'name', type: 'string'},                     
                {name: 'type', type: 'string'}
            ]
        });
        
        var listTpl = new Ext.XTemplate(
            ['<tpl for=".">',
                '<div class="ss-attach-item {["file"==values.type?"ss-attach-file":""]}">',
                    '<tpl if="this.isImg(type)">',
                        '<img src="{url}">',
                    '</tpl>',
                    '<tpl if="!this.isImg(type)">',
                        '<img src="', SCONFIG['ATTACH_ICON32'],'">',
                    '</tpl>',
                    '<div class="ss-attach-delete"></div>',
                    '<div class="ss-attach-name" data-qtip="{name}">{name}</div>',             
                '</div>',
             '</tpl>'].join(''), {
            isImg : function(type){
                return 'img' === type;
            }
        });
           
        this.listView = Ext.create('Ext.view.View', {
            cls: 'ss-attach-list ss-attach-view',
            region: 'center',
            store: this.store,
            autoScroll: true,
            tpl: listTpl,
            itemSelector: 'div.ss-attach-item',
            selectedItemCls: 'ss-attach-item-selected',
            overItemCls: 'ss-attach-item-over'
        });
           
        this.items = [this.hintBox, this.listView];
           
		this.callParent();
           
        this.listView.on('itemclick', function(view, rec, item, index, e){
            var target = Ext.get(e.getTarget());
            if(target.hasCls('ss-attach-delete')){
                this.store.remove(rec);
            }else{
                this.viewAttach(view, rec, item, index, e);
            }
        }, this);
	},
           
    onSelectLocalFile : function(){
        this.hintBox.show();
        this.uploadForm.submit({
            params: {
                parentId : this.folderId || 0
            },
            failure: function(form, action) {
                
            },
            // everything ok...
            success: function(form, action) {
                var jsonData = action.result;
                if(jsonData.success && jsonData.success != "false"){
                    var fileId = jsonData.attachId, fileName = jsonData.fileName;
                    var url = SCONFIG.urls['downloadFile']+'?attachId='+fileId;
                    var o = {
                        url: url,
                        aid: fileId,
                        name: fileName
                    };
                    var imgEl = Ext.DomHelper.append(Ext.getBody(), '<img src="'+url+'" />', true);
                    imgEl.on('error', function(){
                        o.type = 'file';
                        this.store.add(o);
                        Ext.removeNode(imgEl.dom);
                        this.hintBox.hide();
                        this.listView.scrollBy([0, 100000], true);
                    }, this);
                    imgEl.on('load', function(){
                        o.type = 'img';
                        this.store.add(o);
                        Ext.removeNode(imgEl.dom);
                        this.hintBox.hide();
                        this.listView.scrollBy([0, 100000], true);
                    }, this);
                }else{

                }
            },
            scope: this
        });
    },
           
    prepareParam : function(){
        var arr = [];
        this.store.each(function(rec){
            arr.push({
                aid: rec.data.aid,
                url: rec.data.url,
                type: rec.data.type,
                name: rec.data.name
            });
        }, this);
        return arr;
    },
           
    viewAttach : function(view, rec, item, index, e){
        var photos = [];
        this.store.each(function(rd){
            photos.push(rd.data);
        }, this);
        
        PHOTOVIEWER.showPhotos(photos, index);
    },
           
    prepareButton : function(){
        delete(this.buttons);
    },
           
    quit : function(){
        if(this.applyCallback){
            var o = this.applyCallback;
            o.fn.call(o.scope || this, this.prepareParam(), this);
        }
    }
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.pop.ErrorReportWin', {
	
	/* Begin Definitions */
		
	extend : 'EnterpriseSheet.common.pop.PopWin',
	
	requires: [
	    'Ext.form.field.Text'
	],
	
	/* End Definitions */
	width : 400,    	    
        
	layout : 'anchor',
	
	labelWidth : 90,
           
    plain: true,
           
    border: false,
	
	bodyStyle: 'padding:25px;background-color:transparent;',
	
	initComponent : function(){
        this.title = SLANG['error'];
        
        this.memoField = Ext.create('Ext.form.field.TextArea', {
            height: 100,
            hidden: true,
            style: 'margin-top:10px;',
            emptyText: SLANG['add_comment_for_error'],
            anchor: '100%'
        });
           
        this.items = [{
            xtype: 'component',
            html: SLANG['backend_error_occur']
        }, this.memoField];
           
		this.callParent();
	},
           
    prepareButton : function(){
        this.reportBtn = new Ext.Button({
            text: SLANG['report'],
            handler:this.onReport,
            scope:this
        });
        this.buttons = [this.reportBtn, {
            text:this.cancelText,
            handler:this.onCancel,
            scope:this
        }];
    },
           
    popup : function(){
        this.memoField.hide();
        this.memoField.reset();
        this.reportBtn.setText(SLANG['report']);
        this.show();
    },
           
    onReport : function(){
        if(!this.memoField.isVisible()){
           this.memoField.show();
           this.reportBtn.setText(SLANG['submit']);
           return;
        }
        if(this.reportCallback){
            this.reportCallback.fn.call(this.reportCallback.scope, this.memoField.getValue());
        }
        this.hide();
    }
});
Ext.define('EnterpriseSheet.sheet.plugin.CellRender', {
	
	singleton : true,
	
	cellDataRenders: {
		'contactRender': function(sheetId, row, col, data){
			/*
			 * here we just get the itms and render all elements with css style
			 */
			var itms = data.itms, arr = [];
			if(itms){
				itms = Ext.decode(itms);
    			for(var i = 0, len = itms.length; i < len; i++){
    				var it = itms[i];
    				arr.push('<span class="ss-contact" data-qtip="'+it.email+'">'+it.name+'</span>');
    			}
    			return arr.join('');
			}
		},
		
		'dropRender': function(sheetId, row, col, cell){
			var data = cell.data;
			if(data){
				return '<span class="ss-list">'+ data +'</span>';
			}
		},
		
		'itemRender': function(sheetId, row, col, data){
			var itms = data.itms, arr = [];
			if(itms){
				itms = Ext.decode(itms);
    			for(var i = 0, len = itms.length; i < len; i++){
    				var it = itms[i];
    				if(Ext.isObject(it)){
    					var color = SCOM.colors[it.idx];
    					arr.push('<span class="ss-item" style="background-color:'+color+';">'+it.data+'</span>');
    				}else{
    					var color = SCOM.colors[i%SCOM.colors.length];
    					arr.push('<span class="ss-item" style="background-color:'+color+';">'+it+'</span>');
    				}
    			}
    			return arr.join('');
			}
		},
           
        'attachRender': function(sheetId, row, col, data){
            var itms = data.itms, arr = [];
            if(itms){
                itms = Ext.decode(itms);
                for(var i = 0, len = itms.length; i < len; i++){
                    var it = itms[i];
                    var cls = 'normal' == data.ws ? 'ss-incell-attach-ww' : 'ss-incell-attach';
                    if('img' === it.type){
                        arr.push('<img class="'+cls+'" src="'+it.url+'" />');
                    }else{
                        arr.push('<div class="ss-attach-file"></div>');
                    }
                }
                return arr.join('');
            }
        }
	},	
	
	addRender : function(obj){		
    	Ext.apply(this.cellDataRenders, obj);
	},
	
	getRender : function(name){
		return this.cellDataRenders[name];
	}
}, function(){
	SCRENDER = EnterpriseSheet.sheet.plugin.CellRender;
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.plugin.editor.DateEditor', {
	
	extend : 'Ext.container.Container',	
	
	cls: 'ss-date-editor',
	
	width: 250,
	
	//height: 30,
	
	floating: true,
           
    shadow: false,
	
	focusDelay : 500,
			
	layout: {
		type: 'hbox',
		align: 'middle',
		padding: 5
	},
	
	initComponent : function(){
		this.dateField = Ext.create('Ext.form.field.Date', {			
			format: 'Y-m-d',
			allowBlank: false,
			flex: 1,
			enableKeyEvents: true,
			listeners: {
				'keydown': {
					fn: function(field, e){
						this.onEditorKeydown(e);
					},
					scope: this
				}
			}
		});
		this.timeField = Ext.create('Ext.form.field.Time', {			
			format: 'H:i',
			allowBlank: false,
			margin: '0 0 0 5',
			flex: 1,
			enableKeyEvents: true,
			listeners: {
				'keydown': {
					fn: function(field, e){
						this.onEditorKeydown(e);
					},
					scope: this
				}
			}
		});
		this.items = [this.dateField, this.timeField, {
			xtype: 'button',
			margin: '0 0 0 5',
			iconCls: 'icon-tick',
            ui: 'default-toolbar',
			handler: this.onDoneEdit,
			scope: this
		}, {
			xtype: 'button',
			margin: '0 0 0 5',
			iconCls: 'icon-cross',
            ui: 'default-toolbar',                      
			handler: function(){
				this.hide();			
			},
			scope: this
		}];
		
		this.callParent(arguments);
	},
	
	onEditorKeydown : function(e){
		var key = e.getKey();
		if(this.isVisible()){
			var keyObj = Ext.EventObject ? Ext.EventObject : Ext.event.Event;
			if(keyObj.ESC == key){
				e.stopEvent();
				this.hide();				
				return false;
			}else if(keyObj.ENTER == key){
				e.stopEvent();
				this.onDoneEdit();
				return false;
			}
		}		
	},		
	
	onDoneEdit :  function(){
		var dateField = this.dateField, timeField = this.timeField;
		if(dateField.isValid() && (!timeField.isVisible() || timeField.isValid())){
			var date = dateField.getValue(), time = timeField.getValue();
			date = Ext.Date.format(date, 'Y-m-d');
			time = Ext.Date.format(time, 'H:i');								
			var data;
			if(timeField.isVisible()){
				data = date+' '+time;
			}else{
				data = date;
			}									
			this.hide();
			this.fireEvent('done', data, undefined, this);
		}
	},	
	
	showEditor : function(date, time, el, withTime, expand){		
		var dateField = this.dateField;
		var timeField = this.timeField;
		if(withTime){
			dateField.setValue(date);				
			timeField.setValue(time);
			timeField.show();
		}else{
			dateField.setValue(date);
			timeField.hide();
		}					
		this.showBy(el, 'tl-tl?');
		if(expand){
			Ext.Function.defer(function(){
				dateField.expand();
			}, 10, this);			
		}
		dateField.focus(undefined, this.focusDelay);
	},
	
	collapsePicker : function(){
		this.dateField.collapse();
		this.timeField.collapse();
	}
});
Ext.define('EnterpriseSheet.sheet.plugin.editor.ListRemoteEditor', {
	
	extend : 'Ext.container.Container',	
	
	cls: 'ss-list-editor',
	
	width: 270,
	
	floating: true,
	
	focusDelay : 500,
           
    shadow: false,           
			
	layout: {
		type: 'hbox',
		align: 'middle',
		padding: 5
	},
	
	initComponent : function(){
		var me = this;
		
        Ext.define('DropListModel', {
		    extend: 'Ext.data.Model',
		    fields: [
		        {name: 'value', type: 'string'},
		        {name: 'id', type: 'int'}
		    ]
		});
		
		this.listStore = Ext.create('Ext.data.Store', {
			model: 'DropListModel',
		    proxy: {
		        type: 'ajax',
		        url : '',
		        reader: {
		            type: 'json',
		            root: 'results'
		        }
		    }
		});
			
		this.listField = Ext.create('Ext.form.field.ComboBox', {
			width: 200,
			minChars: 2,			
			emptyText: "Enter 2 chars to search ...",			
			store: this.listStore,
			displayField: 'value',			
		    valueField: 'id',
		    allowBlank: false,
		    enableKeyEvents: true,
			forceSelection: true,
			listeners: {
				'select': {
                	fn: this.onDoneEdit,
                	scope: this
                },
                'keydown': {
					fn: function(field, e){
						if(!field.isExpanded){
							this.onEditorKeydown(e);
						}							
					},
					scope: this
				}
			}
		});	
		
		this.items = [this.listField, {
			xtype: 'button',
			margin: '0 0 0 5',
			iconCls: 'icon-tick',
            ui: 'default-toolbar',
			handler: this.onDoneEdit,
			scope: this
		}, {
			xtype: 'button',
			margin: '0 0 0 5',
			iconCls: 'icon-cross',
            ui: 'default-toolbar',                      
			handler: function(){
				this.hide();			
			},
			scope: this
		}];
		
		this.callParent(arguments);
	},
	
	onEditorKeydown : function(e){
		var key = e.getKey();
		if(this.isVisible()){
			var keyObj = Ext.EventObject ? Ext.EventObject : Ext.event.Event;
			if(keyObj.ESC == key){
				e.stopEvent();
				this.hide();				
				return false;
			}else if(keyObj.ENTER == key){
				e.stopEvent();
				this.onDoneEdit();
				return false;
			}
		}		
	},		
	
	onDoneEdit :  function(){
		var listField = this.listField;
		if(listField.isValid()){	
			var id = listField.getValue();
			var data = listField.getRawValue();		
			this.hide();
			this.fireEvent('done', data, {dropId: id, render: 'dropRender'}, this);
		}
	},	
	
	showEditor : function(cell, el, obj){
		var me = this, listField = this.listField;
		this.showBy(el, 'tl-tl?');

		this.listStore.getProxy().url = obj.url;
		this.listStore.on('load', function(){
		    listField.setValue(cell.dropId);
		});
		this.listStore.load();
		
        Ext.Function.defer(function(){
			listField.expand();
		}, 100);
		listField.focus(undefined, me.focusDelay);	
	}
});
Ext.define('EnterpriseSheet.sheet.plugin.editor.ListEditor', {
	
	extend : 'Ext.container.Container',	
	
	cls: 'ss-list-editor',
	
	width: 200,
	
	//height: 30,
	
	floating: true,
	
	focusDelay : 500,
           
    shadow: false,           
			
	layout: {
		type: 'hbox',
		align: 'middle',
		padding: 5
	},
	
	initComponent : function(){
		var me = this;
		this.listStore = Ext.create('Ext.data.ArrayStore', {
			fields: [
		       {name: 'val', type: 'string'}
		    ]
		});		
		
		this.listField = Ext.create('Ext.form.field.ComboBox', {			
			queryMode: 'local',
			store: this.listStore,
			displayField: 'val',
		    valueField: 'val',
			allowBlank: false,
			flex: 1,
			enableKeyEvents: true,
			forceSelection: true,
			validator: function(val){
				if(val){
					return -1 !== me.listStore.find('val', val);
				}
				return true;
			},
			listeners: {
				'keydown': {
					fn: function(field, e){
						if(!field.isExpanded){
							this.onEditorKeydown(e);
						}							
					},
					scope: this
				},
				'select': {
                	fn: this.onDoneEdit,
                	scope: this
                }
			}
		});
		
		this.items = [this.listField, {
			xtype: 'button',
			margin: '0 0 0 5',
			iconCls: 'icon-tick',
            ui: 'default-toolbar',
			handler: this.onDoneEdit,
			scope: this
		}, {
			xtype: 'button',
			margin: '0 0 0 5',
			iconCls: 'icon-cross',
            ui: 'default-toolbar',                      
			handler: function(){
				this.hide();			
			},
			scope: this
		}];
		
		this.callParent(arguments);
	},
	
	onEditorKeydown : function(e){
		var key = e.getKey();
		if(this.isVisible()){
			var keyObj = Ext.EventObject ? Ext.EventObject : Ext.event.Event;
			if(keyObj.ESC == key){
				e.stopEvent();
				this.hide();				
				return false;
			}else if(keyObj.ENTER == key){
				e.stopEvent();
				this.onDoneEdit();
				return false;
			}
		}		
	},		
	
	onDoneEdit :  function(){
		var listField = this.listField;
		if(listField.isValid()){									
			var data = listField.getValue();
			
			this.hide();
			this.fireEvent('done', data, undefined, this);
		}
	},	
	
	showEditor : function(data, el, obj, expand){
		var list, me = this;

		if(Ext.isString(obj)){
			obj = Ext.decode(obj);			
		}
		list = obj.data;
		var setupVal = function(arr){
			if(-1 === arr.indexOf(data)){
            	data = '';
            }             	
	        me.listField.setValue(data);		
	        me.showBy(el, 'tl-tl?');
	        Ext.Function.defer(function(){
				me.listField.expand();
			}, 10);
			me.listField.focus(undefined, me.focusDelay);
		}
		
		if(list){
			var ds = [];
	        for(var i = 0, len = list.length; i < len; i++){
	            ds.push({
	                'val': list[i]
	            });
	        }
	        this.listStore.loadData(ds);
	        setupVal(list);
		}else{
			var id = obj.id;
			if(Ext.isDefined(id)){
				Ext.Ajax.request({
	                timeout: SCONST['PULLING_TIMEOUT'],
	                url: SCONFIG.urls['loadDataset'],
	                params: {
	                    id: id
	                },
	                success: function(response, options){
	                    var json = Ext.decode(response.responseText);
	                            
	                    if (true === json.success || 'true' === json.success) {
	                        obj = json['object'];	                        
	                        var arr = Ext.decode(obj.data), ds = [];
	                        for(var i = 0, len = arr.length; i < len; i++){
	                            ds.push({
	                                'val': arr[i]
	                            });
	                        }
	                        this.listStore.loadData(ds);
	                        setupVal(arr);	
	                    }
	                        
	                },
	                failure: function(response){
	                            
	                },
	                scope: this
	            });
			}
		}               	
	},
	
	collapsePicker : function(){
		this.listField.collapse();
	}
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.plugin.editor.MultiOptionEditor', {
	
	extend : 'Ext.container.Container',	
	
	cls: 'ss-list-editor',
	
	width: 250,
	
	//height: 30,
	
	floating: true,
           
    shadow: false,           
	
	focusDelay : 500,
			
	layout: {
		type: 'hbox',
		align: 'middle',
		padding: 5
	},
	
	initComponent : function(){
		var me = this;
		this.listStore = Ext.create('Ext.data.ArrayStore', {
			fields: [
		       {name: 'val', type: 'string'}
		    ]
		});		
		
		this.listField = Ext.create('Ext.form.field.ComboBox', {			
			queryMode: 'local',
			store: this.listStore,
			displayField: 'val',
		    valueField: 'val',
			flex: 1,
			allowBlank: false,
			enableKeyEvents: true,
			multiSelect: true,
			forceSelection: true,
			listConfig: {
				cls: 'ss-combo-picker'
			},
			validator: function(val){
				val = me.listField.getRawValue();
				if(val){
					var parts = val.split(',');
					for(var i = 0, len = parts.length; i < len; i++){
						var p = Ext.String.trim(parts[i]);
						if(-1 === me.listStore.find('val', p)){
							return false;
						}
					}
					return true;
				}else{
					return false;
				}				
			},
			listeners: {
				'keydown': {
					fn: function(field, e){
						if(!field.isExpanded){
							this.onEditorKeydown(e);
						}							
					},
					scope: this
				}
			}
		});
		
		this.items = [this.listField, {
			xtype: 'button',
			margin: '0 0 0 5',
			iconCls: 'icon-tick',
            ui: 'default-toolbar',
			handler: this.onDoneEdit,
			scope: this
		}, {
			xtype: 'button',
			margin: '0 0 0 5',
			iconCls: 'icon-cross',
            ui: 'default-toolbar',                      
			handler: function(){
				this.hide();			
			},
			scope: this
		}];
		
		this.callParent(arguments);
	},
	
	onEditorKeydown : function(e){
		var key = e.getKey();
		if(this.isVisible()){
			var keyObj = Ext.EventObject ? Ext.EventObject : Ext.event.Event;
			if(keyObj.ESC == key){
				e.stopEvent();
				this.hide();				
				return false;
			}else if(keyObj.ENTER == key){
				e.stopEvent();
				this.onDoneEdit();
				return false;
			}
		}		
	},		
	
	onDoneEdit :  function(){
		var listField = this.listField;
		if(listField.isValid()){									
			var arr = listField.getValue(), data = arr;											
			this.hide();
			if(Ext.isArray(arr)){
				data = arr.join(',');
			}
			var itms = [];
			for(var i = 0, len = arr.length; i < len; i++){
				var p = Ext.String.trim(arr[i]);
				var idx = this.listStore.find('val', p);				
				itms.push({
					idx: idx,
					data: p
				});
			}
			itms.sort(function(a, b){
				return a.idx-b.idx;
			});
			this.fireEvent('done', data, {
				itms: Ext.encode(itms),
				render: 'itemRender'
			}, this);
		}
	},	
	
	showEditor : function(data, el, obj, expand){
		var list, me = this;
		if(Ext.isString(obj)){
			obj = Ext.decode(obj);			
		}
		list = obj.data;
		var setupVal = function(){
			if(data){
				var parts = data.split(','), flag = true;
				for(var i = 0, len = parts.length; i < len; i++){
					var p = Ext.String.trim(parts[i]);
					if(-1 === me.listStore.find('val', p)){
						flag = false;
						break;
					}
				}
				if(flag){
					me.listField.setValue(parts);
				}else{
					me.listField.reset();
				}			
			}else{
				me.listField.reset();
			}
			me.showBy(el, 'tl-tl?');
			Ext.Function.defer(function(){
				me.listField.expand();
			}, 10);
			me.listField.focus(undefined, me.focusDelay);
		}
		if(list){
			var arr = [];
	        for(var i = 0, len = list.length; i < len; i++){
	            arr.push({
	                'val': list[i]
	            });
	        }
	        this.listStore.loadData(arr);	  
	        setupVal();
		}else{
			var id = obj.id;
			if(Ext.isDefined(id)){
				Ext.Ajax.request({
	                timeout: SCONST['PULLING_TIMEOUT'],
	                url: SCONFIG.urls['loadDataset'],
	                params: {
	                    id: id
	                },
	                success: function(response, options){
	                    var json = Ext.decode(response.responseText);
	                            
	                    if (true === json.success || 'true' === json.success) {
	                        obj = json['object'];	                        
	                        var arr = Ext.decode(obj.data), ds = [];
	                        for(var i = 0, len = arr.length; i < len; i++){
	                            ds.push({
	                                'val': arr[i]
	                            });
	                        }
	                        this.listStore.loadData(ds);
	                        setupVal();
	                    }	                    
	                },
	                failure: function(response){
	                            
	                },
	                scope: this
	            });
			}
		}               												
	},
	
	collapsePicker : function(){
		this.listField.collapse();
	}
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.plugin.editor.LongTextEditor', {
	
	extend : 'Ext.container.Container',	
	
	cls: 'ss-date-editor',
	
	width: 350,
	
	floating: true,
           
    shadow: false,
	
	focusDelay : 500,
			
	layout: {
		type: 'hbox',
		align: 'top',
		padding: 5
	},
	
	initComponent : function(){
		
		this.longTextField = Ext.create('Ext.form.field.TextArea', {			
			flex: 1,
			height: 150,
			enableKeyEvents: true,
			listeners: {
				'keydown': {
					fn: function(field, e){
						this.onEditorKeydown(e);
					},
					scope: this
				}
			}
		});
		
		this.items = [this.longTextField, {
			xtype: 'container',
			dock: 'right',
			width: 40,
			style: 'padding:0px 8px;',
			layout: {
				type: 'vbox',
				align: 'stretch'
			},
			items: [{
				xtype: 'button',
				margin: '5 0 0 0',
				iconCls: 'icon-tick',
	            ui: 'default-toolbar',
				handler: this.onDoneEdit,
				scope: this
			}, {
				xtype: 'button',
				margin: '5 0 0 0',
				iconCls: 'icon-cross',
	            ui: 'default-toolbar', 
				handler: this.onCancel,
				scope: this
			}]
		}];
		
		this.callParent(arguments);
	},
	
	onEditorKeydown : function(e){
		var key = e.getKey();
		if(this.isVisible()){
			var keyObj = Ext.EventObject ? Ext.EventObject : Ext.event.Event;
			if(keyObj.ESC == key){
				e.stopEvent();
				this.hide();				
				return false;
			}else if(keyObj.ENTER == key){
				e.stopEvent();
				this.onDoneEdit();
				return false;
			}
		}		
	},		
	
	onDoneEdit :  function(){
		var textField = this.longTextField;
		this.hide();
		this.fireEvent('done', textField.getValue(), undefined, this);
	},	
	
	onCancel : function(){		
		this.hide();
	},	
	
	showEditor : function(data, el, cell){
		this.longTextField.setValue(data);
		var textField = this.longTextField;
		this.showBy(el, 'tl-tl?');
		textField.focus(undefined, this.focusDelay);	
	}
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.plugin.editor.AttachEditor', {
	
	extend : 'Ext.container.Container',	
	
	requires: [
        'EnterpriseSheet.sheet.pop.AttachmentWin'
    ],
	
	cls: 'ss-attach-editor',
	
	width: 300,
           
    autoHeight: true,
	
	floating: true,
           
    shadow: false,
	
	focusDelay : 500,		
	
	initComponent : function(){
		var me = this;		
        this.store = Ext.create('Ext.data.ArrayStore', {
            fields: [
                {name: 'aid', type: 'string'},
                {name: 'name', type: 'string'},                     
                {name: 'url', type: 'string'},
                {name: 'type', type: 'string'}
            ]
        });
          
        var listTpl = new Ext.XTemplate(
            ['<tpl for=".">',
                '<div class="ss-attach-item {["file"==values.type?"ss-attach-file":""]}">',
                    '<tpl if="this.isImg(type)">',
                        '<img src="{url}">',
                    '</tpl>',
                    '<tpl if="!this.isImg(type)">',
                        '<img src="', SCONFIG['ATTACH_ICON32'],'">',
                    '</tpl>',
                    '<div class="ss-attach-delete"></div>',
                '</div>',
            '</tpl>'].join(''), {
            isImg : function(type){
                return 'img' === type;
            }
        });
        
        this.listView = Ext.create('Ext.view.View', {
            cls: 'ss-attach-list ss-attach-preview',
            region: 'center',
            //minHeight: 50,
            maxHeight: 500,
            store: this.store,
            tpl: listTpl,
            itemSelector: 'div.ss-attach-item',
            selectedItemCls: 'ss-attach-item-selected',
            overItemCls: 'ss-attach-item-over',
            deferEmptyText: false,
            emptyText: '<div class="empty-text">'+SLANG['no_attach_yet']+'</div>'
        });
		
        this.displayBox = Ext.create('Ext.Component', {
            cls: 'empty-text'
        });
        this.items = [{
            xtype: 'toolbar',
            border: false,
            style: 'background:transparent;',
            items: [this.displayBox, '->', {
                xtype: 'button',
                iconCls: 'icon-popout',
                handler: this.onAddAttach,
                scope: this
            }]
        }, this.listView];
		
		this.callParent(arguments);
           
        this.listView.on('itemclick', function(view, rec, item, index, e){
            var target = Ext.get(e.getTarget());
            if(target.hasCls('ss-attach-delete')){
                this.store.remove(rec);
                var arr = [];
                this.store.each(function(rec){
                    arr.push({
                        type: rec.data.type,
                        url: rec.data.url,
                        aid: rec.data.aid,
                        name: rec.data.name
                    });
                }, this);
                
                this.fireEvent('done', undefined, {
                    itms: Ext.encode(arr),
                    render: 'attachRender'
                }, this);
            }else{
                this.viewAttach(view, rec, item, index, e);
            }
        }, this);
        this.store.on('datachanged', function(){
            var len = this.store.getCount();
            if(0 === len){
                this.displayBox.update('');
            }else{
                this.displayBox.update(SLANG['attachment']+' : '+len);
            }
        }, this);
	},
	
	onEditorKeydown : function(e){
		var key = e.getKey();
		if(this.isVisible()){
			var keyObj = Ext.EventObject ? Ext.EventObject : Ext.event.Event;
			if(keyObj.ESC == key){
				e.stopEvent();
				this.hide();				
				return false;
			}else if(keyObj.ENTER == key){
				e.stopEvent();
				this.onDoneEdit();
				return false;
			}
		}		
	},		
	
	onDoneEdit :  function(){
		this.hide();
	},	
	
	showEditor : function(data, el, cell){
        this.store.removeAll();
        var display = '';
        if(cell.itms){
            var itms = Ext.decode(cell.itms), len = itms.length;
            for(var i = 0; i < len; i++){
                var it = itms[i];
                this.store.add(it);
            }
            display = SLANG['attachment']+' : '+len;
        }
        this.displayBox.update(display);
        this.showBy(el, 'tl-tl?');
	},
	
	onAddAttach : function(){
		if(!this.addAttachWin){
			this.addAttachWin = Ext.create('EnterpriseSheet.sheet.pop.AttachmentWin', {
				modal: true,
                store: this.store,
                applyCallback: {
                    fn: function(param){
                        this.fireEvent('done', undefined, {
                            itms: Ext.encode(param),
                            render: 'attachRender'
                        }, this);
                    },
                    scope: this
                }
			});
		}
		this.addAttachWin.show();
	},
           
    viewAttach : function(view, rec, item, index, e){
        var photos = [];
        this.store.each(function(rd){
            photos.push(rd.data);
        }, this);
           
        PHOTOVIEWER.showPhotos(photos, index);
    }
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.plugin.DataTypeProcessor', {
	
	requires: [
	    'EnterpriseSheet.sheet.plugin.editor.LongTextEditor',
	    'EnterpriseSheet.sheet.plugin.editor.ListRemoteEditor',
	    'EnterpriseSheet.sheet.plugin.editor.DateEditor',
	    'EnterpriseSheet.sheet.plugin.editor.ListEditor',
	    'EnterpriseSheet.sheet.plugin.editor.MultiOptionEditor',
	    'EnterpriseSheet.sheet.plugin.editor.AttachEditor'
	],	
	
	init : function(sheet){
		this.sheet = sheet;				
		
		sheet.on({
			scope: this,
			'cellclick': this.onCellClick,
			'clickcelltrigger': this.onClickCellTrigger,
			'rowscrolling': this.hideCurEditor,
			'colscrolling': this.hideCurEditor
		});
		
		var sm = sheet.getSelectionModel(), editor = sheet.getEditor();
		sm.on('selectionchange', function(){
			if(this.curEditor && this.curEditor.isVisible()){
				this.curEditor.hide();
			}			
		}, this);		
		editor.on('keydown', this.onEditorKeydown, this);
	},
	
	onClickCellTrigger : function(sheetId, row, col, region){
		var sheet = this.sheet, store = sheet.getStore();		
        var cell = store.getCell(sheetId, row, col);
        if(Ext.isDefined(cell.minrow)){
            row += cell.minrow;
            col += cell.mincol;
        }
        var cell = sheet.getCellValue(sheetId, row, col);
        if(cell.drop){
        	if('date' === cell.drop){
        		// this.showDateEditor(sheetId, row, col, region, cell, undefined, true);
        	}else if('list' === cell.drop){ 
        		var obj = undefined;
        		if (cell.dcfg) {
        			var dcfg = Ext.decode(cell.dcfg);
        			if (dcfg.url) {
        				this.showListRemoteEditor(sheetId, row, col, region, cell, {url: dcfg.url});
        				return;
        			}
        			obj = dcfg.list;
        		}
        		else if (cell.list) obj = cell.list;
        		this.showListEditor(sheetId, row, col, region, cell, {data: obj});
        	}
        }
	},
	
	/*
	 * when mouse down, we need check whether it's on the filter
	 */
	onCellClick : function(row, col, region, e){
        if(this.sheet.isReadOnly()){
            return;
        }
		var target = e.getTarget();
		var tgEl = Ext.get(target);
		/*
		 * for chart element, avoid the exception
		 */
		if(Ext.supports.ClassList && !target.classList){
			return;
		}
		if(tgEl.hasCls('ss-trigger')){
			this.onClickCellTrigger(region.getSheetId(), row, col, region);
		}
	},
	
	onEditorKeydown : function(e){
		var key = e.getKey();
		if(this.curEditor && this.curEditor.isVisible()){
			var keyObj = Ext.EventObject ? Ext.EventObject : Ext.event.Event;
			if(keyObj.ESC == key){
				e.stopEvent();
				this.curEditor.hide();
				this.sheet.refreshFocus();
				return false;
			}
		}		
	},
	
	getDateEditor : function(){
		if(!this.dateEditor){
			this.dateEditor = Ext.create('EnterpriseSheet.sheet.plugin.editor.DateEditor', {			
				hidden: true,			
				renderTo: Ext.getBody(),
				listeners: {
					'done': {
						fn: this.onDoneEdit,
						scope: this
					}
				}
			});
		}		
		return this.dateEditor;
	},		
	
	getListEditor : function(){		
		this.listEditor = this.listEditor || Ext.create('EnterpriseSheet.sheet.plugin.editor.ListEditor', {
			hidden: true,			
			renderTo: Ext.getBody(),
			listeners: {
				'done': this.onDoneEdit,
				scope: this				
			}
		});		
		return this.listEditor;
	},
	
	getListRemoteEditor : function(){		
		this.listRemoteEditor = this.listRemoteEditor || Ext.create('EnterpriseSheet.sheet.plugin.editor.ListRemoteEditor', {
			hidden: true,			
			renderTo: Ext.getBody(),
			listeners: {
				'done': this.onDoneEdit,
				scope: this				
			}
		});		
		return this.listRemoteEditor;
	},
	
	getMultiOptionEditor : function(){		
		this.multiOptionEditor = this.multiOptionEditor || Ext.create('EnterpriseSheet.sheet.plugin.editor.MultiOptionEditor', {
			hidden: true,			
			renderTo: Ext.getBody(),
			listeners: {
				'done': this.onDoneEdit,
				scope: this				
			}
		});		
		return this.multiOptionEditor;
	},
		
	getAttachEditor : function(){
		this.attachEditor = this.attachEditor || Ext.create('EnterpriseSheet.sheet.plugin.editor.AttachEditor', {
			hidden: true,			
			renderTo: Ext.getBody(),
			listeners: {
				'done': this.onDoneEdit,
				scope: this				
			}
		});
		return this.attachEditor;
	},
	
	getLongTextEditor : function(){
		this.longTextEditor = this.longTextEditor || Ext.create('EnterpriseSheet.sheet.plugin.editor.LongTextEditor', {
			hidden: true,			
			renderTo: Ext.getBody(),
			listeners: {
				'done': this.onDoneEdit,
				scope: this				
			}
		});
		return this.longTextEditor;
	},
				
	onDoneEdit :  function(data, modified, editor){
		var pos = this.editPos;
        if(this.attachEditor === editor){
            var range = Ext.create('EnterpriseSheet.sheet.range.Range', {
                sheet: this.sheet,
                coord: [[pos.sheetId, pos.row, pos.col, pos.row, pos.col]]
            });
            range.setProperty(modified);
        }else{
            this.sheet.setCell(pos.sheetId, pos.row, pos.col, Ext.apply({
                data: data
            }, modified));
        }
		this.sheet.refreshFocus();
	},
	
	hideCurEditor : function(){
		if(this.curEditor && this.curEditor.isVisible() && Ext.isFunction(this.curEditor.collapsePicker)){			
			this.curEditor.collapsePicker();
		}
	},
	
	processCellDataConfig : function(cell, scope){
		if(cell.dcfg){
    		var DTS = SCONST.validateDataType;
    		var cfg = Ext.decode(cell.dcfg);
    		var dt = cfg.dt;      	
    		cell.it = '';
			cell.itn = ''; 
    		if(DTS['number'] === dt){    			
    			   			
    		}else if(DTS['checkbox'] === dt){    			
    			cell.it = 'checkbox';
    			cell.itn = '';     			
    			delete(cell.data);    			
    		}else if(DTS['radio'] === dt){
    			cell.it = 'radio';
    			cell.itn = cfg.itn;
    			delete(cell.data);    			
    		}else if(DTS['date'] === dt){    			  		
    			if(cfg.wt){
    				cell.fm = SCONST['FORMAT_DATE_TIME'];
    				cell.dfm = SCONST.DEFAULT_DATE_FORMAT + ' H:i' || 'Y-m-d H:i';
    			}else{
    				cell.fm = SCONST['FORMAT_DATE'];
    				cell.dfm = cfg.dfm || SCONST.DEFAULT_DATE_FORMAT;
    			}
    		}else if(DTS['currency'] === dt){    			  		
    			cell.fm = cfg.format;
    		}else if(DTS['percent'] === dt){    
    			cell.fm = SCONST.FORMAT_PERCENT;
    			cell.dfm = cfg.format;
    		}
    		var dv = cfg.dv;
			if(Ext.isDefined(dv) && SCOM.isEmptyValue(cell.data)){
				cell.data = dv;
			} 
    	}
    	return cell;
	},
	
	checkBeforeEdit : function(sheetId, row, col, region){
		var sheet = this.sheet, store = sheet.getStore();
    	var DTS = SCONST.validateDataType;
    	var cellData = sheet.getCellProperty(sheetId, row, col);
    	var dcfg = cellData.dcfg;
    	if(dcfg){
    		dcfg = Ext.decode(dcfg);
    		var dt = dcfg.dt;
    		if(DTS['date'] === dt || DTS['checkbox'] === dt || DTS['radio'] === dt || DTS['long_text'] === dt
    				|| DTS['remote_select'] === dt || DTS['multi_options'] === dt || DTS['single_select'] === dt 
    				|| DTS['attachment'] === dt){
    			if(DTS['date'] === dt){
    				this.showDateEditor(sheetId, row, col, region, cellData, dcfg.wt);
    			}else if(DTS['single_select'] === dt){    				
    				this.showListEditor(sheetId, row, col, region, cellData, {data: dcfg.list});
    			}else if(DTS['multi_options'] === dt){
    				this.showMultiOptionEditor(sheetId, row, col, region, cellData, {data: dcfg.list});
    			}else if(DTS['attachment'] === dt){
    				this.showAttachEditor(sheetId, row, col, region, cellData);
    			}else if(DTS['long_text'] === dt){
    				this.showLongTextEditor(sheetId, row, col, region, cellData);
    			}else if(DTS['remote_select'] === dt){    				
    				this.showListRemoteEditor(sheetId, row, col, region, cellData, {url: dcfg.url});
    			}
    			return false;
    		}
    	}
    	var cdts = store.getConditionOfCell(sheetId, row, col);
		for(var i = 0, len = cdts.length; i < len; i++){
			var it = cdts[i];
			if('vd' === it.name){
				var opt = it.opt;
				if(opt.dt === DTS['single_select'] || DTS['list'] === opt.dt){
					this.showListEditor(sheetId, row, col, region, cellData, {data: opt.list});
					return false;
				}else if(DTS['date'] === opt.dt){
    				this.showDateEditor(sheetId, row, col, region, cellData, opt.wt);
    				return false;
    			}
			}
		}
		if(cellData.drop){
			if('date' === cellData.drop){
				this.showDateEditor(sheetId, row, col, region, cellData);
				return false;
			}else if ('list' === cellData.drop){
				this.showListEditor(sheetId, row, col, region, cellData, cellData.drop);
				return false;
			}					
		}
	},
	
	getDataTypeConfigForCell : function(sheetId, row, col){
		var store = this.sheet.getStore();
		var o = store.getCell(sheetId, 0, col);
		if(o.dcfg){
        	var obj = Ext.decode(o.dcfg);      	
        	return obj;
        }
	},
	
	showDateEditor : function(sheetId, row, col, region, cell, withTime, expand){
		if(region && sheetId === region.getSheetId()){
			var cellEl = region.getCellEl(row, col);
			this.editPos = {
				sheetId: sheetId,
				row: row,
				col: col
			};	
			if(this.curEditor){
				this.curEditor.hide();
			}
			this.curEditor = this.getDateEditor();
			var date, time;
			if(withTime){
				if(Ext.isString(cell.data)){
					var arr = cell.data.split(' ');
					date = arr[0];
					time = arr[1];					
				}
			}else if(cell.data){
				date = cell.data;
			}	
			this.dateEditor.getEl().appendTo(region.ifbodyEl);
			this.dateEditor.showEditor(date, time, cellEl, withTime, expand);			
		}
	},
	
	showListEditor : function(sheetId, row, col, region, cell, obj, expand){
		if(region && sheetId === region.getSheetId()){
			var cellEl = region.getCellEl(row, col);
			this.editPos = {
				sheetId: sheetId,
				row: row,
				col: col
			};						
			if(this.curEditor){
				this.curEditor.hide();
			}
			this.curEditor = this.getListEditor();
            var data = cell.data;    
			this.listEditor.getEl().appendTo(region.ifbodyEl);
			this.listEditor.showEditor(data, cellEl, obj, expand);									
		}
	},
	
	showListRemoteEditor : function(sheetId, row, col, region, cell, obj){
		if(region && sheetId === region.getSheetId()){
			var cellEl = region.getCellEl(row, col);
			this.editPos = {
				sheetId: sheetId,
				row: row,
				col: col
			};						
			if(this.curEditor){
				this.curEditor.hide();
			}
			this.curEditor = this.getListRemoteEditor();			                   
			this.listRemoteEditor.getEl().appendTo(region.ifbodyEl);
			this.listRemoteEditor.showEditor(cell, cellEl, obj);									
		}
	},
	
	showMultiOptionEditor : function(sheetId, row, col, region, cell, obj, expand){
		if(region && sheetId === region.getSheetId()){
			var cellEl = region.getCellEl(row, col);
			this.editPos = {
				sheetId: sheetId,
				row: row,
				col: col
			};						
			if(this.curEditor){
				this.curEditor.hide();
			}
			this.curEditor = this.getMultiOptionEditor();
            var data = cell.data;            
            
			this.multiOptionEditor.getEl().appendTo(region.ifbodyEl);
			this.multiOptionEditor.showEditor(data, cellEl, obj, expand);									
		}
	},
	
	showAttachEditor : function(sheetId, row, col, region, cell){
		if(region && sheetId === region.getSheetId()){
			var cellEl = region.getCellEl(row, col);
			this.editPos = {
				sheetId: sheetId,
				row: row,
				col: col
			};						
			if(this.curEditor){
				this.curEditor.hide();
			}
			this.curEditor = this.getAttachEditor();
            var data = cell.data;            
            
			this.attachEditor.getEl().appendTo(region.ifbodyEl);
			this.attachEditor.showEditor(data, cellEl, cell);
		}
	},
	
	showLongTextEditor : function(sheetId, row, col, region, cell){
		if(region && sheetId === region.getSheetId()){
			var cellEl = region.getCellEl(row, col);
			this.editPos = {
				sheetId: sheetId,
				row: row,
				col: col
			};						
			if(this.curEditor){
				this.curEditor.hide();
			}
			this.curEditor = this.getLongTextEditor();
            var data = cell.data;            
            
			this.longTextEditor.getEl().appendTo(region.ifbodyEl);
			this.longTextEditor.showEditor(data, cellEl, cell);
		}
	}
	
}, function(){
	
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.plugin.DropList', {
	
	requires: ['EnterpriseSheet.common.CONST'],
	
	constructor : function(config){
		Ext.apply(this, config);
		this.callParent(arguments);
		
		this.initListView();
        this.initDatePicker();
	},
	
	initListView : function(){
		this.store = Ext.create('Ext.data.ArrayStore', {
		    fields: [
		       {name: 'val', type: 'string'}
		    ]
		});
		var listTpl = new Ext.XTemplate(
			'<tpl for=".">',
				'<div class="ss-droplist-item">',
			          '{val}',
			    '</div>',
			'</tpl>'
		);

		this.listView = Ext.create('Ext.view.View', {
			cls: 'ss-droplist',
			style: 'z-index:'+SCONST['CORNER_Z_INDEX'],
		    store: this.store,
		    tpl: listTpl,
		    itemSelector: 'div.ss-droplist-item',	
		    selectedItemCls: 'ss-sdl-item',
		    overItemCls: 'ss-odl-item',
            emptyText: '<div class="empty-text">'+SLANG['no_match_item']+'</div>',
		    renderTo: Ext.getBody()
		});
		this.listView.on({
			scope: this,
			'itemclick': this.onListItemClick,
			'itemkeydown': function(listView, record, item, index, e, eOpts){
				var key = e.getKey();
				var keyObj = Ext.EventObject ? Ext.EventObject : Ext.event.Event;
				if(keyObj.ESC === key){
					this.hideListView();
					e.stopEvent();
					return false;
				}else if(keyObj.ENTER === key){					
					var sels = this.listView.getSelectionModel().getSelection();
					if(0 < sels.length){
						this.onListItemClick(this.listView, sels[0]);
						e.stopEvent();
						return false;
					}					
                }else{
                    e.stopEvent();
                    return false;
                }
			}
		});
		this.hideListView();
	},
	
	/**
	 * hide list view
	 */
	hideListView : function(){
		if(this.sheet){
    		this.sheet.focus();
    	}
		this.listView.hide();
		delete(this.listView.available);        
	},
           
    initDatePicker : function(){
        this.datePicker = Ext.create('Ext.picker.Date', {
        	style: 'z-index:'+SCONST['CORNER_Z_INDEX'],
            handler: this.onSelectDate,
            scope: this,
		    renderTo: Ext.getBody()
        });
        this.hideDatePicker();
    },

    /**
     * hide date picker
     */
    hideDatePicker : function(){
    	if(this.sheet){
    		this.sheet.focus();
    	}
        this.datePicker.hide();
        delete(this.datePicker.available); 
    },
           
	init : function(sheet){
		this.sheet = sheet;
		
		sheet.on({
			scope: this,
			'cellclick': this.onCellClick,
			'clickcelltrigger': this.onClickCellTrigger,
			'beforestartedit': this.beforeStartEdit,
			'editorkeyup': this.onEditorKeyup,
			'beforeeditorspecialkey': this.beforeEditorSpecialkey,
			'preparekeydown': function(e){
				var key = e.getKey();				
				return this.beforeEditorSpecialkey(key);
			},
            'cellmousedown': this.onMouseDownViewEl,
            'beforeswitchsheet': function(){
                 this.hideListView();
                 this.hideDatePicker();
            }
		});
        var editor = sheet.getEditor();
        sheet.on({
            scope:this,
            'beforecompleteedit': this.beforeCompleteEdit
        });
	},
	
	onMouseDownViewEl : function(e){
		this.hideListView();
        this.hideDatePicker();
	},
	
	
	onClickCellTrigger : function(sheetId, row, col, region){
		var sheet = this.sheet, store = sheet.getStore();		
        var cell = store.getCell(sheetId, row, col);
        if(Ext.isDefined(cell.minrow)){
            row += cell.minrow;
            col += cell.mincol;
        }
		this.showListView(sheetId, row, col, region);
	},
	
	/*
	 * when mouse down, we need check wether it's on the filter
	 */
	onCellClick : function(row, col, region, e){
        if(this.sheet.isReadOnly()){
            return;
        }
		var target = e.getTarget();
		var tgEl = Ext.get(target);
		/*
		 * for chart element, avoid the exception
		 */
		if(Ext.supports.ClassList && !target.classList){
			return;
		}
		if(tgEl.hasCls('ss-trigger')){
			this.onClickCellTrigger(region.getSheetId(), row, col, region);
		}
	},
	
	onListItemClick : function(list, rec){
		var sheetId = this.cellPos[0], row = this.cellPos[1], col = this.cellPos[2];
		this.sheet.setCellData(sheetId, row, col, {
			'data': rec.data.val
		});
		this.hideListView();
		var editor = this.sheet.getEditor();
		editor.cancelEdit();
	},
           
    onSelectDate : function(picker, date){
        var sheetId = this.cellPos[0], row = this.cellPos[1], col = this.cellPos[2];
        this.sheet.setCellData(sheetId, row, col, {
            'data': Ext.Date.format(date, 'Y-m-d'),
            'fm': 'date'
        });
        this.hideDatePicker();
        var editor = this.sheet.getEditor();
        editor.cancelEdit();
    },
           
    /**
     * load the drop list by id
     */
    loadDropListById : function(id){
        var obj = this.getDatasetById(id);
        if(obj){
            var arr = Ext.decode(obj.data), data = [];
            for(var i = 0, len = arr.length; i < len; i++){
                data.push({
                    'val': arr[i]
                });
            }
            this.store.loadData(data);
        }else{
            Ext.Ajax.request({
                timeout: SCONST['PULLING_TIMEOUT'],
                url: SCONFIG.urls['loadDataset'],
                params: {
                    id: id
                },
                success: function(response, options){
                    var json = Ext.decode(response.responseText);
                            
                    if (true === json.success || 'true' === json.success) {
                        obj = json['object'];
                        this.addDataset2Lookup(obj);
                        var arr = Ext.decode(obj.data), data = [];
                        for(var i = 0, len = arr.length; i < len; i++){
                            data.push({
                                'val': arr[i]
                            });
                        }
                        this.store.loadData(data);
                    }
                        
                },
                failure: function(response){
                            
                },
                scope: this
            });
        }
    },
           
   
	/**
	 * show the listview
	 */
	showListView : function(sheetId, row, col, region){
		var sheet = this.sheet, store = sheet.getStore();
        var cellEl = region.getCellEl(row, col);
        var regionCtEl = cellEl.up('.ss-region-ct');
        var ifCtEl = regionCtEl.down('.ss-ifct');
        var bodyEl = regionCtEl.down('.ss-ifbody');
           
		var cell = store.getCellData(sheetId, row, col);
        if('date' === cell.drop){
            /*
             * need call sheet.getCellData, because we need process the filter generated by the table template
             */
            this.cellPos = [sheetId, row, col];
            if(cellEl){                
            	this.datePicker.show();
                this.datePicker.getEl().appendTo(bodyEl);
           
                this.datePicker.alignTo(cellEl.down('.ss-date-picker'), 'tr-br?');                
                this.datePicker.available = true;
                this.ifCtEl = ifCtEl;
            }
        }else if(cell.drop){
			/*
			 * need call sheet.getCellData, because we need process the filter generated by the table template
			 */
			this.cellPos = [sheetId, row, col];
			var drop = Ext.decode(cell.drop);
            if(drop.data){
                var arr;
                if(Ext.isString(drop.data)){
                    arr = drop.data.split(',');
                }else{
                    arr = drop.data
                }
                var data = [];
                for(var i = 0, len = arr.length; i < len; i++){
                    data.push({
                        'val': arr[i]
                    });
                }
                this.store.loadData(data);
            }else if(Ext.isDefined(drop.id)){
                this.store.removeAll();
                this.loadDropListById(drop.id);
            }

			if(cellEl){
				this.listView.getEl().appendTo(bodyEl);
				this.listView.show();				
				
				this.listView.alignTo(cellEl.down('.ss-trigger'), 'tr-br?');
				this.listView.available = true;
                this.ifCtEl = ifCtEl;
			}			
		}
	},
	
	/**
	 * before start edit something
	 */
	beforeStartEdit : function(editor, sheet, sheetId, row, col, region){
		this.showListView(sheetId, row, col, region);
	},
	
	onEditorKeyup : function(e, row, col, region, editor, isCal){
		if(this.listView.available){
            var val = editor.getValue();
            this.store.filterBy(function(rec){
                var display = Ext.String.trim(rec.data.val.toLowerCase());
                                
                if(Ext.isString(val)){
                    val = Ext.String.trim(val.toLowerCase());
                }
                
                return 0 === display.indexOf(val);
            });
        }
	},
	
	beforeEditorSpecialkey : function(key){
		var keyObj = Ext.EventObject ? Ext.EventObject : Ext.event.Event;
		if(this.listView.available){
			var sm = this.listView.getSelectionModel();
			var sels = sm.getSelection();			
			if(keyObj.DOWN === key || keyObj.RIGHT === key || keyObj.UP === key || keyObj.LEFT === key){
                if(0 === sels.length){
                    sm.select(0);
                }
                return false;
           }else if(keyObj.ESC === key){
				this.hideListView();
				var editor = this.sheet.getEditor();
				editor.cancelEdit();
				return false;
			}else if(keyObj.ENTER === key){
				if(0 < sels.length){
					this.onListItemClick(this.listView, sels[0]);
					return false;
				}else{
					var nodes = this.listView.getNodes(0, 0);
					if(0 < nodes.length){
						sm.select(0);
						return false;
					}else{
						this.hideListView();
					}
				}
			}
		}
        if(this.datePicker.available){
            if(keyObj.ESC === key){
                this.hideDatePicker();
                var editor = this.sheet.getEditor();
                editor.cancelEdit();
                return false;
            }else if(keyObj.ENTER === key){
                this.hideDatePicker();
            }
        }
	},
           
    beforeCompleteEdit : function(sheetId, row, col, editor){
        var store = this.sheet.getStore();
        var cell = store.getCell(sheetId, row, col);
        if(cell.ovil){
           var rawValue = editor.getRawTextValue();
           if(-1 == this.store.find('val', rawValue)){
                editor.cancelEdit();
                return false;
           }
        }
    }
}, function(){
    Ext.apply(EnterpriseSheet.sheet.plugin.DropList.prototype, {
        'datasetLookup': {},
        addDataset2Lookup : function(ds){
            var lookup = EnterpriseSheet.sheet.plugin.DropList.prototype.datasetLookup;
            lookup[ds.id] = ds;
        },
        getDatasetById : function(id){
            var lookup = EnterpriseSheet.sheet.plugin.DropList.prototype.datasetLookup;
            return lookup[id];
        },
        deleteDatasetFromLookup : function(ds){
            var lookup = EnterpriseSheet.sheet.plugin.DropList.prototype.datasetLookup;
            delete(lookup[ds.id]);
        }
    });
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.pop.droplist.DropListConfigContainer', {
           
    /* Begin Definitions */
           
    extend : 'Ext.container.Container',
           
    requires: [
        'Ext.form.field.Text',
        'EnterpriseSheet.sheet.plugin.DropList'
    ],
           
    /* End Definitions */                  
           
    initComponent : function(){
         
        this.optionBtn = Ext.create('Ext.button.Button', {
            text: SLANG['select_data_source'],
            menu: [{
                text: SLANG['input_drop_list'],
                handler: this.selectInputOption,
                scope: this
            }, {
                text: SLANG['select_data_source'],
                handler: this.selectDatasourceOption,
                scope: this
            }]
        });
           
        this.store = Ext.create('Ext.data.ArrayStore', {
            fields: [
                {name: 'id', type: 'string'},
                {name: 'name', type: 'string'},
                {name: 'data', type: 'string'}
            ],
            proxy: {
                type: 'ajax',
                timeout: SCONST['PULLING_TIMEOUT'],
                url : SCONFIG.urls['listDataset']
            }
        });
        
        this.store.on({
            scope: this,
            'load': this.afterDroplistStoreLoad
        });
           
        var listTpl = new Ext.XTemplate(
            '<tpl for=".">',
                '<div class="ss-droplist-item">',
                    '{name}',
                '</div>',
            '</tpl>'
        );
           
        this.dataSourceList = Ext.create('Ext.view.View', {
            cls: 'ss-droplist ss-dataset-list',
            store: this.store,
            deferEmptyText: false,
            tpl: listTpl,
            itemSelector: 'div.ss-droplist-item',
            selectedItemCls: 'ss-sdl-item',
            overItemCls: 'ss-odl-item',
            emptyText: '<div class="empty-text">'+SLANG['no_dataset_available']+'</div>'
        });
           
        this.listItemCt = Ext.create('Ext.container.Container', {
            cls: 'ss-datasource-item',
            region: 'east',
            width: 200,
            html: '<div class="empty-text">'+SLANG['select_from_left_list']+'</div>'
        });
           
        this.deleteDroplistBtn = Ext.create('Ext.button.Button', {
            text: SLANG['delete'],
            disabled: true,
            handler: this.onDeleteDropList,
            scope: this
        });
           
        this.editDroplistBtn = Ext.create('Ext.button.Button', {
            text: SLANG['edit'],
            disabled: true,
            handler: this.onEditDropList,
            scope: this
        });
           
        this.addBtn = Ext.create('Ext.button.Button', {            
            iconCls: 'icon-add',
            text: SLANG['add_new_dataset'],
            handler: this.onAddNewDataset,
            scope: this
        });
        this.dataSourceCt = Ext.create('Ext.container.Container', {
            layout: 'border',
            height: 150,
            cls: 'ss-datasource-detail',
            style: 'margin-top:10px;',
            items: [{
                xtype: 'panel',
                region: 'center',
                layout: 'fit',
                items: [this.dataSourceList],
                bbar: [this.addBtn, '->', this.editDroplistBtn, '-', this.deleteDroplistBtn]
            }, this.listItemCt]
        });
           
        this.itemField = new Ext.form.field.Text({
            fieldLabel: SLANG['item_hint'],
            labelSeparator : '',
            labelAlign: 'top',
            style: 'margin-top:10px;',
            width: '100%',
            hidden: true,
            allowBlank: false
        });
           
        this.onlyValueInListCB = Ext.create('Ext.form.field.Checkbox', {
            boxLabel: SLANG['only_allow_data_in_droplist'],
            hidden: this.hideOnlyValueInList,
            checked: this.checkOnlyValueInList
        });
           
        this.items = [this.optionBtn, this.dataSourceCt, this.itemField, {
            xtype: 'container',
            cls: 'ss-dl-setting',
            items: [this.onlyValueInListCB]
        }];
           
        this.callParent();
           
        var sm = this.dataSourceList.getSelectionModel();
        sm.on({
            scope: this,
            'selectionchange': this.onDatasetSelectionChange
        });        
    },
    
    loadDropListStore : function(){
    	var docId = this.sheet.getStore().fileId;
    	if(docId){
	    	this.store.load({
	            params: {
	                'documentId': docId
	            }
	        });
	    	this.addBtn.enable();
    	}else{
    		this.addBtn.disable();
    	}
    },
           
    selectInputOption : function(){
        this.optionBtn.setText(SLANG['input_drop_list']);
        this.dataSourceCt.hide();
        this.itemField.show();
        if(Ext.isFunction(this.doLayout)){
        	this.doLayout();
        }else if(Ext.isFunction(this.updateLayout)){
        	this.updateLayout();
        }        
    },
       
    selectDatasourceOption : function(){
        this.optionBtn.setText(SLANG['select_data_source']);
        this.dataSourceCt.show();
        this.itemField.hide();
        if(Ext.isFunction(this.doLayout)){
        	this.doLayout();
        }else if(Ext.isFunction(this.updateLayout)){
        	this.updateLayout();
        } 
    },
      
    isValid : function(){    
        if(this.dataSourceCt.isVisible()){
           var sm = this.dataSourceList.getSelectionModel();
           if(sm.hasSelection()){
                this.dataSourceList.removeCls('ss-dataset-list-invalid');
                return true;
           }
           this.dataSourceList.addCls('ss-dataset-list-invalid');
           return false;
        }else{
           return this.itemField.isValid();
        }
    },
    
    popupDatasetEdior : function(dataset){
        if(!this.newDataSetWin){
           
            this.newDatasetNameField = Ext.create('Ext.form.field.Text', {
                anchor: '100%',
                fieldLabel: SLANG['new_dataset_name'],
                labelSeparator : '',
                labelAlign: 'top',
                allowBlank: false
            });
            this.newDatasetItemField = Ext.create('Ext.form.field.Text', {
                anchor: '100%',
                fieldLabel: SLANG['new_dataset_hint'],
                labelSeparator : '',
                labelAlign: 'top',
                style: 'margin-top:10px;',
                allowBlank: false
            });
            this.newDataSetWin = Ext.create('Ext.window.Window', {
                modal: true,
                title: SLANG['add_new_dateset'],
                width: 400,
                closeAction: 'hide',
                bodyStyle: 'background:white;padding:20px;',
                layout: 'anchor',
                items: [this.newDatasetNameField, this.newDatasetItemField],
                buttons: [{
                    text: SLANG['add'],
                    handler: function(){
                        if(this.newDatasetNameField.isValid() && this.newDatasetItemField.isValid()){
                            this.saveNewDataset();
                            this.newDataSetWin.hide();
                        }
                    },
                    scope: this
                }, {
                    text: SLANG['cancel'],
                    handler: function(){
                        this.newDataSetWin.hide();
                    },
                    scope: this
                }]
            });
        }

        if(dataset){
           this.newDatasetNameField.setValue(dataset.data.name);
           var str = Ext.decode(dataset.data.data).join(',');
           this.newDatasetItemField.setValue(str);
        }else{
           this.newDatasetNameField.reset();
           this.newDatasetItemField.reset();
        }
        this.newDataSetWin.editDataset = dataset;
        this.newDataSetWin.show();
    },
           
    /*
     * add a new data set
     */
    onAddNewDataset : function(){
        this.popupDatasetEdior();
    },
     
    /**
     * save the new dateset
     */
    saveNewDataset : function(){
        var name = this.newDatasetNameField.getValue(), content = this.newDatasetItemField.getValue();
        // var id = Ext.id();
        var arr = content.split(','), dataArr = [];
        for (var i=0; i<arr.length; i++) {
        	// var item = {id:i,name:arr[i].trim()};
        	dataArr.push(arr[i].trim());
        }
        var fileId = this.sheet.getStore().fileId;
        this.sheet.addDropdownStore(name, dataArr, function(success, json){
            if(success){
                this.store.on('load', function(){
                    this.onDatasetSelectionChange();
                }, this, {single: true});
                this.store.load({
                    params: {
                        'documentId': fileId
                    }
                });
            }
        }, this);            
    },
           
    onDatasetSelectionChange : function(){
        var sm = this.dataSourceList.getSelectionModel();
        var sels = sm.getSelection();
        if(0 < sels.length){
           var rec = sels[0];
           rec = this.store.getById(rec.data.id);
           var json = Ext.decode(rec.data.data);
           var html = json.join('<br>');
           this.listItemCt.update(html);
           this.deleteDroplistBtn.enable();
           this.editDroplistBtn.enable();
           this.dataSourceList.removeCls('ss-dataset-list-invalid');
        }else{
           this.listItemCt.update('<div class="empty-text">'+SLANG['select_from_left_list']+'</div>');
           this.deleteDroplistBtn.disable();
           this.editDroplistBtn.disable();
           this.dataSourceList.addCls('ss-dataset-list-invalid');
        }
    },
           
    prepareParam : function(){
        if(this.dataSourceCt.isVisible()){
           var sm = this.dataSourceList.getSelectionModel();
           var sels = sm.getSelection();
           var rec = sels[0];
           var list = [];
           this.store.each(function(rec){
                list = Ext.decode(rec.data.data);
            });
           return {
                drop: Ext.encode({
                    id: rec.data.id
                }),
                ovil: this.onlyValueInListCB.getValue(),
                list: list
           };
        }else{
           var json = this.itemField.getValue();
           json = json.split(',');
           return {
                drop: Ext.encode({
                    data: json
                }),
                ovil: this.onlyValueInListCB.getValue(),
                list: json
           }
        }
    },
           
    /*
     * delete the dataset
     */
    onDeleteDropList : function(){
        var sm = this.dataSourceList.getSelectionModel();
        var sels = sm.getSelection();
        var rec = sels[0];
        var fileId = this.sheet.getStore().fileId;
        Ext.Msg.show({
            title: SLANG['confirm'],
            msg: SLANG['want2delete_dataset'],
            buttons: Ext.Msg.YESNO,
            fn: function(bid){
                if('yes' === bid){
                    this.sheet.deleteDropdownStore(rec.data, function(success){
                        if(success){
                            this.store.load({
                                params: {
                                    'documentId': fileId
                                }
                            });
                        }
                     }, this);
                }
            },
            icon: Ext.Msg.QUESTION,
            scope: this
        });
    },
           
    onEditDropList : function(){
        var sm = this.dataSourceList.getSelectionModel();
        var sels = sm.getSelection();
        var rec = sels[0];
        this.popupDatasetEdior(rec);
    },
       
    afterDroplistStoreLoad : function(){
        var recs = this.store.getRange();
        for(var i = 0, len = recs.length; i < len; i++){
           var it = recs[i];
           EnterpriseSheet.sheet.plugin.DropList.prototype.addDataset2Lookup(it.data);
        }
    }, 
    
    setup : function(cfg){
    	var drop = cfg.drop;
    	if(drop.id){
    		this.selectDatasourceOption();
    		var sm = this.dataSourceList.getSelectionModel(), store = this.dataSourceList.getStore();    		
    		var rec = store.getById(drop.id);
    		if(rec){
    			sm.select([rec]);
    		}else{
    			store.on('load', function(){
    				rec = store.getById(drop.id);
    				sm.select([rec]);
    			}, this, {single:true});
    		}    		
    	}else{
    		this.selectInputOption();   
    		var list = cfg.list;
    		this.itemField.setValue(list.join(','));
    	}
    }
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.pop.droplist.DropListConfigWin', {
           
    /* Begin Definitions */
           
    extend : 'EnterpriseSheet.common.pop.PopWin',
           
    requires: [        
        'EnterpriseSheet.sheet.pop.droplist.DropListConfigContainer'
    ],
           
    /* End Definitions */
    
    bodyStyle: 'padding:25px;background-color:white;',
    
    width : 500,
           
    initComponent : function(){
    	this.dropListConfigCt = Ext.create('EnterpriseSheet.sheet.pop.droplist.DropListConfigContainer', {
    		sheet: this.sheet
    	});
        this.items = [this.dropListConfigCt];
        
        this.callParent();
        
        this.dropListConfigCt.loadDropListStore();
    },           
      
    isValid : function(){
        return this.dropListConfigCt.isValid();
    },
    
      
    prepareParam : function(){
    	return this.dropListConfigCt.prepareParam();
    },
           
    updateConfig : function(config){    	
        Ext.apply(this, config);
    }
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.pop.DataTypeConfigWin', {
	
	/* Begin Definitions */
		
	extend : 'EnterpriseSheet.common.pop.PopWin',
	
	requires: [
	    'Ext.form.field.ComboBox',
	    'EnterpriseSheet.sheet.pop.droplist.DropListConfigContainer'       
	],	
	
	modal: true,
	
	closeAction: 'hide',
	
	width: 500,
	
	height: 400,           
	
	bodyStyle: 'padding:20px;background:white;',
	
	layout: 'border',
	
	initComponent : function(){	
		var DTS = SCONST['validateDataType'];
		this.dataTypeCombo = Ext.create('Ext.form.ComboBox', {
			region: 'north',
		    emptyText: SLANG['pick_data_type'],		    
		    store:  Ext.create('Ext.data.Store', {
		        fields: ['name', 'display', 'icon'],
		        data : [
		            {"display":SLANG["text"], "name":DTS["text"], "icon": SCONFIG.TITLE_ICONS_PATH+"/text.png"},
		            {"display":SLANG["text_long"], "name":DTS["long_text"], "icon": SCONFIG.TITLE_ICONS_PATH+"/textLong.png"},
		            {"display":SLANG["number"], "name":DTS["number"], "icon": SCONFIG.TITLE_ICONS_PATH+"/number.png"},
		            {"display":SLANG["date"], "name":DTS["date"], "icon": SCONFIG.TITLE_ICONS_PATH+"/date.png"},          		            
		            {"display":SLANG["phone"], "name":DTS["phone"], "icon": SCONFIG.TITLE_ICONS_PATH+"/phone.png"},
		            {"display":SLANG["email"], "name":DTS["email"], "icon": SCONFIG.TITLE_ICONS_PATH+"/email.png"},
		            {"display":SLANG["url"], "name":DTS["url"], "icon": SCONFIG.TITLE_ICONS_PATH+"/link.png"},		            
		            {"display":SLANG["checkbox"], "name":DTS["checkbox"], "icon": SCONFIG.TITLE_ICONS_PATH+"/checkbox.png"},
		            {"display":SLANG["radio"], "name":DTS["radio"], "icon": SCONFIG.TITLE_ICONS_PATH+"/radio.png"},
		            {"display":SLANG["remote_select"], "name":DTS["remote_select"], "icon": SCONFIG.TITLE_ICONS_PATH+"/remoteList.png"},
		            {"display":SLANG["single_select"], "name":DTS["single_select"], "icon": SCONFIG.TITLE_ICONS_PATH+"/dropdown.png"},
		            {"display":SLANG["multi_options"], "name":DTS["multi_options"], "icon": SCONFIG.TITLE_ICONS_PATH+"/dropdown.png"},
		            {"display":SLANG["attachment"], "name":DTS["attachment"], "icon": SCONFIG.TITLE_ICONS_PATH+"/attach.png"},
		            {"display":SLANG["currency"], "name":DTS["currency"], "icon": SCONFIG.TITLE_ICONS_PATH+"/money_dollar.png"},
		            {"display":SLANG["percent"], "name":DTS["percent"], "icon": SCONFIG.TITLE_ICONS_PATH+"/percent.png"}
		        ]
		    }),
		    tpl: Ext.create('Ext.XTemplate', [
		        '<tpl for=".">',
		            '<div class="x-boundlist-item"><img src="{icon}" style="vertical-align: middle;" />&nbsp;&nbsp;&nbsp;{display}</div>',
		        '</tpl>'
		    ].join(''), {
		    	compile: true
		    }),
		    queryMode: 'local',
		    displayField: 'display',
		    valueField: 'name',
		    editable: false,
		    anchor: '100%',
		    listeners: {
		    	'select': {
		    		fn: this.onSelectDataType,
		    		scope: this
		    	}
		    }
		});
		
		this.cardCt = Ext.create('Ext.container.Container', {
			region: 'center',
			layout: 'card',
			activeItem: 0,
			padding: '20 0',
			items: [{
				xtype: 'component'
			}, this.getTextConfigCt(), this.getTextLongConfigCt(), this.getPhoneConfigCt(), this.getUrlConfigCt(), this.getEmailConfigCt(), this.getSingleSelectConfigCt(),			
			this.getNumberConfigCt(), this.getDateConfigCt(), this.getCheckboxConfigCt(), this.getRadioConfigCt(), this.getAttachConfigCt(),
			this.getCurrencyConfigCt(), this.getPercentConfigCt(), this.getRemoteSelectConfigCt()]
		});
		
		this.items = [this.dataTypeCombo, this.cardCt];
		
		this.callParent(arguments);
	},
	
	popup : function(cfg){		
		this.show();
		if(cfg){
			var DTS = SCONST['validateDataType'];
			var dt = cfg.dt;
			this.dataTypeCombo.setValue(dt);
			this.onSelectDataType();
			if(DTS['date'] === dt){
				this.dateConfigCt.setValues(cfg);
			}else if(DTS['number'] === dt){
				this.numberConfigCt.setValues(cfg);
			}else if(DTS['single_select'] === dt || DTS['multi_options'] === dt){
				this.singleSelectConfigCt.setValues(cfg);
			}else if(DTS['phone'] === dt){
				this.phoneConfigCt.setValues(cfg);
			}else if(DTS['email'] === dt){
				this.emailConfigCt.setValues(cfg);
			}else if(DTS['attachment'] === dt){
				this.attachConfigCt.setValues(cfg);
			}else if(DTS['url'] === dt){
				this.urlConfigCt.setValues(cfg);
			}else if(DTS['radio'] === dt){
				this.radioConfigCt.setValues(cfg);
			}else if(DTS['checkbox'] === dt){
				this.checkboxConfigCt.setValues(cfg);
			}else if(DTS['currency'] === dt){
				this.currencyConfigCt.setValues(cfg);
			}else if(DTS['percent'] === dt){
				this.percentConfigCt.setValues(cfg);
			}else if(DTS['long_text'] === dt){
				this.longTextConfigCt.setValues(cfg);
			}else if(DTS['remote_select'] === dt){
				this.remoteSelectConfigCt.setValues(cfg);
			}
			
			this.cleanBtn.show();
		}else{
			this.cleanBtn.hide();
		}
	},
	
	reset : function(){
		this.callParent(arguments);
		this.cardCt.getLayout().setActiveItem(0);
	},
	
	getTextConfigCt : function(){
		var DTS = SCONST['validateDataType'];
		var me = this;
		this.textConfigCt = Ext.create('Ext.container.Container', {
			name: DTS['text'],
			layout: 'anchor',
			items: [{
				xtype: 'component',
				anchor: '100%',
				style: 'padding-bottom:10px;',
				html: SLANG['text_type_hint']
			}, {
				xtype: 'textfield',
				checked: true,
				emptyText: SLANG['input_default_value'],
				anchor: '100%'
			}],
			getValues : function(){
				var dv = me.textConfigCt.items.get(1).getValue();
				var o = {
					dt: DTS['text']
				};
				if(Ext.isDefined(dv)){
					o.dv = dv;
				}
				return o;
			}
		});
		
		return this.textConfigCt;
	},		
	
	getTextLongConfigCt : function(){
		var DTS = SCONST['validateDataType'];
		var me = this;
		this.longTextConfigCt = Ext.create('Ext.container.Container', {
			name: DTS['long_text'],
			layout: 'anchor',
			items: [{
				xtype: 'component',
				anchor: '100%',
				style: 'padding-bottom:10px;',
				html: SLANG['text_type_hint2']
			}, {
				xtype: 'checkbox',
				boxLabel: SLANG['add_text_icon'],
				checked: true,
				anchor: '100%'
			}],
			getValues : function(){				
				var titleIcon = me.longTextConfigCt.items.get(1).getValue();
				var o = {
					dt: DTS['long_text'],
					titleIcon: titleIcon == true ? "textLong" : null
				};				
				return o;
			},
			setValues : function(cfg){
				if(cfg.titleIcon){
					me.longTextConfigCt.items.get(1).setValue(true);
				}else{
					me.longTextConfigCt.items.get(1).setValue(false);
				}
			}
		});
		
		return this.longTextConfigCt;
	},	
	
	getRemoteSelectConfigCt : function(){
		var DTS = SCONST['validateDataType'];
		var me = this;
		
		this.urlField = Ext.create('Ext.form.field.Text', { 
			allowBlank: false,
			value: 'fakeData/dropdownList',
            anchor: '100%'
        }); 
		
		this.remoteSelectConfigCt = Ext.create('Ext.container.Container', {
			name: DTS['remote_select'],
			layout: 'anchor',
			items: [{
				xtype: 'component',
				anchor: '100%',
				style: 'padding-bottom:10px;',
				html: SLANG['remote_select_type_hint'] + '<br/><pre>{"results":[{"id":1,"value":"HR Dept"},{"id":2,"value":"QA Dept"},\n{"id":3,"value":"Sale Dept"}],"success":"true"}</pre>'
				 
			}, this.urlField, {
				xtype: 'checkbox',
				boxLabel: SLANG['add_drop_icon'],
				checked: true,
				anchor: '100%'
			}],
			getValues : function(){		
				var dt = me.dataTypeCombo.getValue();
				var titleIcon = me.remoteSelectConfigCt.items.get(2).getValue();		
				var o = {
					dt: dt,
					url: me.urlField.getValue(),
					titleIcon: titleIcon == true ? "remoteList" : null
				};
				return o;
			},
			setValues : function(cfg){
				if(cfg.titleIcon){
					me.remoteSelectConfigCt.items.get(2).setValue(true);
				}else{
					me.remoteSelectConfigCt.items.get(2).setValue(false);
				}
				me.remoteSelectConfigCt.items.get(1).setValue(cfg.url);
			}
		});
		
		return this.remoteSelectConfigCt;
	},
	
	getSingleSelectConfigCt : function(){
		var DTS = SCONST['validateDataType'];
		var me = this;
		this.dropListConfigCt = Ext.create('EnterpriseSheet.sheet.pop.droplist.DropListConfigContainer', {
			sheet: this.sheet,
			hideOnlyValueInList: true,
			checkOnlyValueInList: true
		});
		this.singleSelectConfigCt = Ext.create('Ext.container.Container', {
			name: DTS['single_select'],
			layout: 'anchor',
			items: [{
				xtype: 'component',
				anchor: '100%',
				style: 'padding-bottom:10px;',
				html: SLANG['single_select_type_hint']
			}, this.dropListConfigCt],
			getValues : function(){		
				var dt = me.dataTypeCombo.getValue();
				var o = {
					dt: dt
				};
				var param = me.dropListConfigCt.prepareParam();
				o.list = param.list;
				o.drop = Ext.decode(param.drop);
				return o;
			},
			setValues : function(cfg){
				if(DTS['single_select'] === cfg.dt){
					me.singleSelectConfigCt.items.get(0).update(SLANG['single_select_type_hint']);
				}else if(DTS['multi_options'] === cfg.dt){
					me.singleSelectConfigCt.items.get(0).update(SLANG['multi_options_type_hint']);
				}
				me.dropListConfigCt.setup(cfg);
			}
		});
		
		return this.singleSelectConfigCt;
	},
	
	getPhoneConfigCt : function(){
		var DTS = SCONST['validateDataType'];
		var me = this;
		this.phoneConfigCt = Ext.create('Ext.container.Container', {
			name: DTS['phone'],
			layout: 'anchor',
			items: [{
				xtype: 'component',
				anchor: '100%',
				style: 'padding-bottom:10px;',
				html: SLANG['phone_type_hint']
			}, {
				xtype: 'checkbox',
				boxLabel: SLANG['add_phone_icon'],
				checked: true,
				anchor: '100%'
			}],
			getValues : function(){				
				var titleIcon = me.phoneConfigCt.items.get(1).getValue();
				var o = {
					dt: DTS['phone'],
					titleIcon: titleIcon == true ? "phone" : null
				};				
				return o;
			},
			setValues : function(cfg){
				if(cfg.titleIcon){
					me.phoneConfigCt.items.get(1).setValue(true);
				}else{
					me.phoneConfigCt.items.get(1).setValue(false);
				}
			}
		});
		
		return this.phoneConfigCt;
	},
	
	getUrlConfigCt : function(){
		var DTS = SCONST['validateDataType'];
		var me = this;
		this.urlConfigCt = Ext.create('Ext.container.Container', {
			name: DTS['url'],
			layout: 'anchor',
			items: [{
				xtype: 'component',
				anchor: '100%',
				style: 'padding-bottom:10px;',
				html: SLANG['url_type_hint']
			}, {
				xtype: 'checkbox',
				checked: true,
				boxLabel: SLANG['add_url_icon'],
				anchor: '100%'
			}],
			getValues : function(){				
				var titleIcon = me.urlConfigCt.items.get(1).getValue();
				var o = {
					dt: DTS['url'],
					titleIcon: titleIcon == true ? "k" : null
				};				
				return o;
			},
			setValues : function(cfg){
				if(cfg.titleIcon){
					me.urlConfigCt.items.get(1).setValue(true);
				}else{
					me.urlConfigCt.items.get(1).setValue(false);
				}
			}
		});
		
		return this.urlConfigCt;
	},
	
	getEmailConfigCt : function(){
		var DTS = SCONST['validateDataType'];
		var me = this;
		this.emailConfigCt = Ext.create('Ext.container.Container', {
			name: DTS['email'],
			layout: 'anchor',
			items: [{
				xtype: 'component',
				anchor: '100%',
				style: 'padding-bottom:10px;',
				html: SLANG['email_type_hint']
			}, {
				xtype: 'checkbox',
				boxLabel: SLANG['add_email_icon'],
				checked: true,
				anchor: '100%'
			}],
			getValues : function(){				
				var titleIcon = me.emailConfigCt.items.get(1).getValue();
				var o = {
					dt: DTS['email'],
					titleIcon: titleIcon == true ? "email" : null
				};				
				return o;
			},
			setValues : function(cfg){
				if(cfg.titleIcon){
					me.emailConfigCt.items.get(1).setValue(true);
				}else{
					me.emailConfigCt.items.get(1).setValue(false);
				}
			}
		});
		
		return this.emailConfigCt;
	},
	
	getNumberConfigCt : function(){		
		var me = this;
		var DTS = SCONST['validateDataType'];
		
		var minField = Ext.create('Ext.form.field.Number', {
			flex: 1,
			margin: '0 0 0 10',
			disabled: true,
			allowBlank: false
		});
		var maxField = Ext.create('Ext.form.field.Number', {
			flex: 1,
			margin: '0 0 0 10',
			disabled: true,
			allowBlank: false,
			validator: function(val){
				if(!minField.disabled && val < minField.getValue()){
					return false;
				}
				return true;
			}
		});
		
		var minCheckbox = Ext.create('Ext.form.Checkbox', {					
			boxLabel: SLANG['min_value'],
			width: 120,
			handler : function(comp, checked){
				if(checked){
					minField.enable();
				}else{
					minField.disable();
				}
			},
			scope: this
		});
		var maxCheckbox = Ext.create('Ext.form.Checkbox', {					
			boxLabel: SLANG['max_value'],
			width: 120,
			handler : function(comp, checked){
				if(checked){
					maxField.enable();
				}else{
					maxField.disable();
				}
			}
		});
		
		this.numberConfigCt = Ext.create('Ext.container.Container', {
			name: DTS['number'],
			layout: 'anchor',
			items: [{
				xtype: 'component',
				anchor: '100%',
				style: 'padding-bottom:10px;',
				html: SLANG['number_type_hint']
			}, {
				xtype: 'numberfield',
				emptyText: SLANG['input_default_value'],
				anchor: '100%',
				validator: function(val){
					if(val && !minField.disabled && val < minField.getValue()){
						return false;
					}
					if(val && !maxField.disabled && val > maxField.getValue()){
						return false;
					}
					return true;
				}
			}, {
				xtype: 'checkbox',
				boxLabel: SLANG['integer_only'],
				anchor: '100%'
			}, {
				xtype: 'container',
				layout: {
					type: 'hbox'
				},
				anchor: '100%',
				items: [minCheckbox, minField]
			}, {
				xtype: 'container',
				layout: {
					type: 'hbox'
				},
				anchor: '100%',
				margin: '10 0 10 0',
				items: [maxCheckbox, maxField]
			}, {
				xtype: 'checkbox',
				checked: true,
				boxLabel: SLANG['add_number_icon'],
				anchor: '100%'
			}],
			
			getValues : function(){
				var dv = me.numberConfigCt.items.get(1).getValue(), intOnly = me.numberConfigCt.items.get(2).getValue(),
				    numberIcon = me.numberConfigCt.items.get(5).getValue();
				var op = SCONST['validateOption']['any_number'];
				var o = {
					dt: DTS['number'],					
					io: intOnly,
					ignoreBlank: true,
					titleIcon: numberIcon == true ? "number" : null
				};
				if(!minField.disabled && !maxField.disabled){
					o.min = minField.getValue();
					o.max = maxField.getValue();
					op = SCONST['validateOption']['between'];
				}else if(!minField.disabled){
					o.num = minField.getValue();
					op = SCONST['validateOption']['greater_equal'];
				}else if(!maxField.disabled){
					o.num = maxField.getValue();
					op = SCONST['validateOption']['less_equal'];
				}
				o.op = op;
				if(Ext.isDefined(dv)){
					o.dv = dv;
				}
				return o;
			},
			
			setValues : function(cfg){				
				if(Ext.isDefined(cfg.dv)){
					me.numberConfigCt.items.get(1).setValue(cfg.dv);
				}else{
					me.numberConfigCt.items.get(1).reset();
				}
				if(cfg.io){
					me.numberConfigCt.items.get(2).setValue(true);
				}else{
					me.numberConfigCt.items.get(2).setValue(false);
				}
				
				if(cfg.titleIcon){
					me.numberConfigCt.items.get(5).setValue(true);
				}else{
					me.numberConfigCt.items.get(5).setValue(false);
				}
				
				if(SCONST['validateOption']['between'] === cfg.op){
					minField.setValue(cfg.min);
					minCheckbox.setValue(true);
					maxField.setValue(cfg.max);
					maxCheckbox.setValue(true);
				}else if(SCONST['validateOption']['greater_equal'] === cfg.op){
					minField.setValue(cfg.num);
					minCheckbox.setValue(true);
					maxCheckbox.setValue(false);
					maxField.reset();
				}else if(SCONST['validateOption']['less_equal'] === cfg.op){
					maxField.setValue(cfg.num);
					maxCheckbox.setValue(true);
					minCheckbox.setValue(false);
					minField.reset();
				}else{
					minCheckbox.setValue(false);
					minField.reset();
					maxCheckbox.setValue(false);
					maxField.reset();
				}
				
			}
		});
		
		return this.numberConfigCt;
	},
	
	getDateConfigCt : function(){	
		var me = this, DTS = SCONST['validateDataType'];
		
		var date_list = [], formats = SCONST.jsDateFm, today = new Date(); 
		for(var i = 0, len = formats.length; i < len; i++){
    		var fm = formats[i];
    		date_list.push({
    			name: Ext.Date.format(today, fm),
    			fm: fm
    		});
		}	
		var dateFms = Ext.create('Ext.data.Store', {
	        fields: ['name', 'fm'],
	        data: date_list
		});
		this.dateCombo = Ext.create('Ext.form.field.ComboBox', { 
			fieldLabel: SLANG['format'],
            editable:false,
            store : dateFms,
            displayField:'name',
            valueField:'fm',
            queryMode :'local',
            triggerAction:'all',
            width: 355,
            value: SCONST.DEFAULT_DATE_FORMAT,
            forceSelection: true
        }); 
		
		this.dateConfigCt = Ext.create('Ext.container.Container', {
			name: DTS['date'],
			layout: 'anchor',
			items: [{
				xtype: 'component',
				anchor: '100%',
				style: 'padding-bottom:10px;',
				html: SLANG['date_type_hint']
			}, this.dateCombo, {
				xtype: 'checkbox',
				boxLabel: SLANG['add_time_field'],
				anchor: '100%'
			}, {
				xtype: 'checkbox',
				checked: true,
				boxLabel: SLANG['add_date_icon'],
				anchor: '100%'
			}],
			getValues : function(){
				var withTime = me.dateConfigCt.items.get(2).getValue(),
				    titleIcon = me.dateConfigCt.items.get(3).getValue(),
				    dateFm = me.dateConfigCt.items.get(1).getValue();
				var o = {
					dt: DTS['date'],
					op: SCONST['validateOption']['is_date'],
					dfm: dateFm,
					titleIcon: titleIcon == true ? "date" : null
				};
				if(Ext.isDefined(withTime)){
					o.wt = withTime;
				}
				return o;
			},
			setValues : function(cfg){
				if(cfg.wt) me.dateConfigCt.items.get(2).setValue(true);
				else me.dateConfigCt.items.get(2).setValue(false);		
				if(cfg.titleIcon) me.dateConfigCt.items.get(3).setValue(true);
				else me.dateConfigCt.items.get(3).setValue(false);
				if (cfg.dfm) me.dateCombo.setValue(cfg.dfm);			
			}
		});
		
		return this.dateConfigCt;
	},
	
	getCheckboxConfigCt : function(){	
		var me = this;
		var DTS = SCONST['validateDataType'];
		this.checkboxConfigCt = Ext.create('Ext.container.Container', {
			name: DTS['checkbox'],
			layout: 'anchor',
			items: [{
				xtype: 'component',
				anchor: '100%',
				style: 'padding-bottom:10px;',
				html: SLANG['checkbox_type_hint']
			}, {
				xtype: 'checkbox',
				checked: true,
				boxLabel: SLANG['add_checkbox_icon'],
				anchor: '100%'
			}],
			getValues : function(){							
				var titleIcon = me.checkboxConfigCt.items.get(1).getValue();
				var o = {
					dt: DTS['checkbox'],
					ignoreBlank: true,
					titleIcon: titleIcon == true ? "checkbox" : null
				};				
				return o;
			},
			setValues : function(cfg){
				if(cfg.titleIcon){
					me.checkboxConfigCt.items.get(1).setValue(true);
				}else{
					me.checkboxConfigCt.items.get(1).setValue(false);
				}
			}
		});
		
		return this.checkboxConfigCt;
	},
	
	getCurrencyConfigCt : function() {
		var me = this;
		var DTS = SCONST['validateDataType'];
		
		this.currencyCt = Ext.create('EnterpriseSheet.sheet.pop.MoneySelectContainer', {
    		sheet: this.sheet
    	});
		
		this.currencyConfigCt = Ext.create('Ext.container.Container', {
			name: DTS['currency'],
			layout: 'anchor',
			items: [this.currencyCt, {
				style: 'margin-top:15px;',
				xtype: 'checkbox',
				checked: true,
				boxLabel: SLANG['add_currency_icon'],
				anchor: '100%'
			}],
			
			getValues : function(){	
				var titleIcon = me.currencyConfigCt.items.get(1).getValue();
				var o = {
					dt: DTS['currency'],
					format: me.currencyCt.getFormat(),
					titleIcon: titleIcon == true ? "money_dollar" : null
				};				
				return o;
			},
			
			setValues : function(cfg){
				if(cfg.titleIcon){
					me.currencyConfigCt.items.get(1).setValue(true);
				}else{
					me.currencyConfigCt.items.get(1).setValue(false);
				}
				// check format ...
				if (cfg.format) {
					me.currencyCt.setFormat(cfg.format);
				}
			}
		});
		
		return this.currencyConfigCt;
	},
	
	getRadioConfigCt : function(){	
		var me = this;
		var DTS = SCONST['validateDataType'];
		this.radioConfigCt = Ext.create('Ext.container.Container', {
			name: DTS['radio'],
			layout: 'anchor',
			items: [{
				xtype: 'component',
				anchor: '100%',
				style: 'padding-bottom:10px;',
				html: SLANG['radio_type_hint']
			}, {
				xtype: 'checkbox',
				checked: true,
				boxLabel: SLANG['add_radio_icon'],
				anchor: '100%'
			}],
			getValues : function(){							
				var titleIcon = me.radioConfigCt.items.get(1).getValue();
				var o = {
					dt: DTS['radio'],	
					itn: 'radio-'+SCOM.genTimeStamp(),
					ignoreBlank: true,
					titleIcon: titleIcon == true ? "radio" : null
				};				
				return o;
			},
			setValues : function(cfg){
				if(cfg.titleIcon){
					me.radioConfigCt.items.get(1).setValue(true);
				}else{
					me.radioConfigCt.items.get(1).setValue(false);
				}
			}
		});
		
		return this.radioConfigCt;
	},
	
	getAttachConfigCt : function(){	
		var me = this;
		var DTS = SCONST['validateDataType'];
		this.attachConfigCt = Ext.create('Ext.container.Container', {
			name: DTS['attachment'],
			layout: 'anchor',
			items: [{
				xtype: 'component',
				anchor: '100%',
				style: 'padding-bottom:10px;',
				html: SLANG['attach_type_hint']
			}, {
				xtype: 'checkbox',
				checked: true,
				boxLabel: SLANG['add_attach_icon'],
				anchor: '100%'
			}],
			getValues : function(){							
				var titleIcon = me.attachConfigCt.items.get(1).getValue();
				var o = {
					dt: DTS['attachment'],
					ignoreBlank: true,
					titleIcon: titleIcon == true ? "attach" : null
				};				
				return o;
			},
			setValues : function(cfg){
				if(cfg.titleIcon){
					me.attachConfigCt.items.get(1).setValue(true);
				}else{
					me.attachConfigCt.items.get(1).setValue(false);
				}
			}
		});
		
		return this.attachConfigCt;
	},
	
	getPercentConfigCt : function(){	
		var me = this;
		var DTS = SCONST['validateDataType'];
		var percents = Ext.create('Ext.data.Store', {
	        fields: ['name'],
	        data: SCONST.percent_list
		});
		this.percentCombo = Ext.create('Ext.form.field.ComboBox', { 
			fieldLabel: SLANG['percent'],
            editable:false,
            store : percents,
            displayField:'name',
            valueField:'name',
            queryMode :'local',
            triggerAction:'all',
            width: 355,
            value: '0%',
            forceSelection: true
        }); 
		this.percentConfigCt = Ext.create('Ext.container.Container', {
			name: DTS['percent'],
			layout: 'anchor',
			items: [this.percentCombo, {
				xtype: 'checkbox',
				checked: true,
				boxLabel: SLANG['add_perent_icon'],
				anchor: '100%'
			}],
			getValues : function(){							
				var titleIcon = me.percentConfigCt.items.get(1).getValue();
				var o = {
					dt: DTS['percent'],
					format: me.percentCombo.getValue(),
					titleIcon: titleIcon == true ? "percent" : null
				};				
				return o;
			},
			setValues : function(cfg){
				if(cfg.titleIcon){
					me.percentConfigCt.items.get(1).setValue(true);
				}else{
					me.percentConfigCt.items.get(1).setValue(false);
				}

				if (cfg.format) {
					me.percentCombo.setValue(cfg.format);
				}
			}
		});
		
		return this.percentConfigCt;
	},
	
	onSelectDataType : function(){
		var DTS = SCONST['validateDataType'];
		var name = this.dataTypeCombo.getValue(), found;
		if(DTS['multi_options'] === name || DTS['single_select'] === name){
			found = this.singleSelectConfigCt;
			if(DTS['single_select'] === name){
				this.singleSelectConfigCt.items.get(0).update(SLANG['single_select_type_hint']);
			}else{
			    this.singleSelectConfigCt.items.get(0).update(SLANG['multi_options_type_hint']);
			}			
			if(!this.firstDropListFlag){
				this.firstDropListFlag = true;
				this.dropListConfigCt.loadDropListStore();
			}
		}else{				
			// check for currency
			if(DTS['currency'] === name){
				this.currencyCt.initCt(SCONFIG.default_currency);
			}
			
			this.cardCt.items.each(function(it){
				if(it.name === name){
					found = it;
					return false;
				}
			}, this);
		}
		if(found){
			this.cardCt.getLayout().setActiveItem(found);
		}
	},
	
	prepareParam : function(){
		var ct = this.cardCt.getLayout().getActiveItem();
		if(Ext.isFunction(ct.getValues)){
			var o = ct.getValues();
			return o;
		}
	},
	
	prepareButton : function(){
		this.cleanBtn = Ext.create('Ext.button.Button', {
    		text: SLANG['clean_data_type'],
    		handler: this.cleanDataType,
    		scope: this
    	});
    	this.buttons = [this.cleanBtn, '->', {
			text:this.okText,
			handler:this.onOK,
			scope:this
		}, {
			text:this.cancelText,
			handler:this.onCancel,
			scope:this
		}];
    },
    
    cleanDataType : function(){
    	if(this.cleanCallback){
    		this.cleanCallback.fn.call(this.cleanCallback.scope);
    	}
    	this.hide();
    }
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.pop.condition.AverageWin', {
	
	/* Begin Definitions */
		
	extend : 'EnterpriseSheet.common.pop.PopWin',
	
	requires: [
	    'Ext.form.field.ComboBox',
	    'Ext.form.Label'
	],
	
	/* End Definitions */
	
	modal : false,
	
	width : 400,
	
	height : 140,			
	
	initComponent : function(){
				
		this.styleField = new Ext.form.field.ComboBox({
			flex:1.5,
			value:1,
			store:SCOM.boolStyleStore,
			valueField:'id',
			displayField:'text',
			typeAhead:true,		    
		    mode:'local',		    
		    triggerAction:'all'
		});
		
		this.labelField = new Ext.form.Label({			
			text:this.label
		});
		this.items = [this.labelField, {
			xtype:'container',
			style:'padding-top:5px;',
			layout:{
				type:'hbox'				
			},
			items:[			    
			    {
			    	xtype:'label',
			    	style:'padding:5px 25px 5px 5px;',
			    	text:SLANG['set_as']
			    },
			    this.styleField
			]
		}];
		
		this.callParent();		
		
		this.on({
			scope:this,
			'show':this._onShow
		});
	},
	
	/*
	 * when this window show, we need turn off the selection model
	 */
	_onShow : function(){		
		var sheet = this.sheet;
		if(sheet){			
			/*
			 * disable the selectionModel and editor
			 */
			sheet.disableSelect();
			sheet.disableEdit();			
		}		
	},
	
	/*
	 * overwrite quit
	 */
	quit : function(){
		this.callParent(arguments);		
		/*
		 * when this window quit, we need turn on the selection model
		 */
		var sheet = this.sheet;
		if(sheet){	
			sheet.enableSelect();
			sheet.enableEdit();			
		}
	},
	
	updateConfig : function(config){		
		if(config.label){
			this.labelField.setText(config.label);
		}
		if(config.title){
			this.setTitle(config.title);
		}
		Ext.apply(this, config);
	},
	
	/*
	 * overwrite to prepare the params
	 */
	prepareParam : function(){
		var id = this.styleField.getValue();
		var store = this.styleField.store;
		var rd = store.getAt(store.find('id', id));		
		return {			
			style:rd.data.style
		};
	}
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.pop.condition.IconSetRuleWin', {
	
	/* Begin Definitions */
		
	extend : 'EnterpriseSheet.common.pop.PopWin',
	
	requires: [
	    'Ext.form.field.ComboBox',       
        'EnterpriseSheet.common.IconField',
        'EnterpriseSheet.common.IconSetField'
	],
	
	/* End Definitions */
	
	modal : false,
	
	width : 640,
	
	height : 400,
           
    skipResetOnShow: true,
           
    bodyStyle: 'padding: 20px 40px;background:white;',
	
	initComponent : function(){
        this.title = this.title || this.getStr('iconset_rule');
        
        var labelWidth = 80;
           
        this.defaults = {
            labelWidth: labelWidth
        }
        
        this.iconSetField = Ext.create('EnterpriseSheet.common.IconSetField', {
            allowBlank: true
        });
        
        this.reverseIconField = Ext.create('Ext.form.field.Checkbox', {
            boxLabel: SLANG['reverse_icon_set'],
            style: 'margin-top:20px;'
        });
           
        this.showIconOnlyField = Ext.create('Ext.form.field.Checkbox', {
            boxLabel: SLANG['show_icon_only'],
            style: 'margin-bottom:20px;'
        });
        var iconSet = this.iconSetField.getIconValue();
           
        this.items = [
            this.iconSetField,
            this.reverseIconField,
            this.showIconOnlyField
        ].concat(this.generateLines(iconSet));
           
		this.callParent();		
		
		this.on({
			scope:this,
			'show':this._onShow
		});
           
        this.iconSetField.on({
            scope: this,
            'valuechange': this.onIconSetChange
        });
	},
           
    onIconSetChange : function(oldVal, val, iconSetField){
        var count = this.items.getCount();
        var icons = val.icons, ilen = icons.length, setIndex = val['set'];
        if(count-3 === ilen){
            for(var i = 0; i < ilen; i++){
                var line = this.items.get(3+i);
                var iconField = line.items.get(0);
                iconField.setValue({
                    'set': setIndex,
                    'idx': icons[i]
                }, true);
            }
        }else{
            var arr = [];
            for(var i = 3; i < count; i++){
                arr.push(this.items.get(i));
            }
            for(var i = 0, len = arr.length; i < len; i++){
                this.remove(arr[i]);
            }
            this.add(this.generateLines(val));
        }
        var line = this.items.get(3), valField = line.items.get(2);
        valField.focus(null, 100);
    },
           
    onIconChange : function(){
        this.iconSetField.setValue(undefined, true);
    },
           
    /**
     * generate the lines based on the iconset selected
     */
    generateLines : function(iconSet){
        var icons = iconSet['icons'], setIndex = iconSet['set'], level = iconSet['level'], arr = [];
        var len = icons.length;
        for(var i = len-1; i >= 0; i--){
            arr.push(this.getIconLine(setIndex, icons[i], level));
        }
        var per = Math.round(100/len);
        for(var i = 0; i < len; i++){
            var it = arr[i];
            if(i === len-1){
                var display = it.items.get(1);
                display.setFieldLabel(SLANG['when_value_is']+' <= '+(100-per*i));
            }else{
                var optField = it.items.get(1), unitField = it.items.get(3), valField = it.items.get(2);
                var val = 100-per*(i+1);
                if(0 !== i){
                    optField.setFieldLabel(SLANG['when_value_is']+' <= '+(100-per*i)+' '+SLANG['and']+' ');
                }
                unitField.setValue('percent');
                valField.setValue(val);
            }
        }
        return arr;
    },
           
    getIconLine : function(setIndex, iconIndex, level){
        var iconField = Ext.create('EnterpriseSheet.common.IconField', {
            iconValue: {'set': setIndex, 'idx': iconIndex},
            listeners: {
                'valuechange': {
                    fn: this.onIconChange,
                    scope: this
                }
            }
        });
        var items = [];
        if(0 < iconIndex){
            var optField = Ext.create('Ext.form.field.ComboBox', {
                style: 'margin-left:20px;',
                width: 260,
                labelWidth: 200,
                fieldLabel: SLANG['when_value_is'],
                labelSeparator: '',
                valueField: 'value',
                displayField: 'value',
                editable: false,
                value: '>',
                store: new Ext.data.ArrayStore({
                    fields:['value'],
                    data:[
                        ['>'],
                        ['>=']
                    ]
                })
            });
            var valField = Ext.create('EnterpriseSheet.sheet.range.RangeField', {
                style: 'margin-left:20px;',
                width: 80,
                sheet: this.sheet,
                singleSelect: true,
                simpleSelect: true,
                allowBlank: false,
                listeners: {
                    'minimode': {
                        scope: this,
                        fn: function(){
                            this.hide();
                        }
                    },
                    'normalmode': {
                        scope: this,
                        fn: function(){
                            this.show();
                        }
                    },
                    'blur': {
                        scope: this,
                        fn: function(field){
                            var line = field.up('container[cls~=icon-rule-line]');
                            if(line){
                                var index = this.items.indexOf(line);
                                var nextLine = this.items.get(index+1);
                                if(nextLine){
                                    var label = nextLine.items.get(1);
                                    var val = line.items.get(2).getValue();
                                    if(EnterpriseSheet.sheet.calculate.Calculate.prototype.isCalculate(val)){
                                        val = SLANG['formula'];
                                    }
                                    label.setFieldLabel(SLANG['when_value_is']+' <= '+val);
                                }
                            }
                        }
                    }
                }
            });
           
            var unitField = Ext.create('Ext.form.field.ComboBox', {
                style: 'margin-left:10px;',
                width: 80,
                valueField: 'value',
                displayField: 'display',
                editable: false,
                value: 'percent',
                store: new Ext.data.ArrayStore({
                    fields:['value', 'display'],
                    data:[
                        ['percent', SLANG['percent']],
                        ['number', SLANG['number']]
                    ]
                })
            });
            
            items = [
                iconField,
                optField,
                valField,
                unitField
            ];
            
        }else{
            var display = Ext.create('Ext.form.field.Display', {
                width: 260,
                labelWidth: 200,
                style: 'margin-left:20px;',
                labelSeparator: '',
                fieldLabel: SLANG['when_value_is']
            });
            items = [iconField, display];
        }
        var ct = Ext.create('Ext.container.Container', {
            cls: 'icon-rule-line',
            style: 'margin-top:20px;',      
            layout: {
                type: 'hbox'
            },
            items: items
        });
        return ct;
    },
	
	/*
	 * when this window show, we need turn off the selection model
	 */
	_onShow : function(){		
		var sheet = this.sheet;
		if(sheet){			
			/*
			 * disable the selectionModel and editor
			 */
			sheet.disableSelect();
			sheet.disableEdit();
            /*
             * enable reference model, clear the reference selection, and set it to single select mode
             */
            sheet.enableRefer(true, true);
		}
	},
           
    popup : function(){
        this.show();
        var arr = [];
        for(var i = 3, len = this.items.getCount(); i < len; i++){
            arr.push(this.items.get(i));
        }
        for(var i = 0, len = arr.length; i < len; i++){
           this.remove(arr[i]);
        }
        this.iconSetField.setValue(this.iconSetField.iconSetStore.getAt(0).data, true);
        this.onIconSetChange(undefined, this.iconSetField.getIconValue(), this.iconSetField);
        var line = this.items.get(3), valField = line.items.get(2);
		valField.focus(null, 100);
	},
	
	/*
	 * overwrite quit
	 */
	quit : function(){
		this.callParent(arguments);		
		/*
		 * when this window quit, we need turn on the selection model
		 */
		var sheet = this.sheet;
		if(sheet){	
			sheet.enableSelect();
			sheet.enableEdit();
            /*
             * disable reference model, clear the reference selection, and cancel the single select mode
             */
            sheet.disableRefer(true);
		}
	},
	
	updateConfig : function(config){		
		
		Ext.apply(this, config);
	},
	
	/*
	 * overwrite to prepare the params
	 */
	prepareParam : function(){
        var iconSet = this.iconSetField.getIconValue();
        var reverse = this.reverseIconField.getValue(), showIconOnly = this.showIconOnlyField.getValue();
        var arr = [], count = this.items.getCount();
        for(var i = count-2; i >= 3; i--){
            var line = this.items.get(i);
            var val = line.items.get(2).getCoord();
            arr.push({
                v: val,
                c: '>' == line.items.get(1).getValue() ? '<=' : '<',
                u: line.items.get(3).getValue()
            });
        }
        if(!iconSet){
            iconSet = [];
            for(var i = count-1; i >= 3; i--){
                var line = this.items.get(i);
                var val = line.items.get(0).getIconValue();
                iconSet.push(val);
            }
        }
        return {
            is: iconSet,
            rv: reverse,
            only: showIconOnly,
            ths: arr
		};
	}
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.pop.condition.BetweenWin', {
	
	/* Begin Definitions */
		
	extend : 'EnterpriseSheet.common.pop.PopWin',
	
	requires : [
	    'EnterpriseSheet.sheet.range.RangeField',
	    'Ext.form.field.ComboBox',
	    'Ext.form.Label'
	],
	
	/* End Definitions */
	
	modal : false,
	
	width : 550,
	
	height : 140,			
	
	initComponent : function(){
		
		this.minField = new EnterpriseSheet.sheet.range.RangeField({
			/*
			 * need a ref of EnterpriseSheet.Sheet
			 */
			sheet:this.sheet,
			flex:1,
			singleSelect: true,
			simpleSelect: true,
			value:this.min,
			allowBlank:false
		});
		
		this.maxField = new EnterpriseSheet.sheet.range.RangeField({
			/*
			 * need a ref of EnterpriseSheet.Sheet
			 */
			sheet:this.sheet,
			flex:1,
			singleSelect: true,
			simpleSelect: true,
			value:this.max,
			allowBlank:false
		});
		
		this.styleField = new Ext.form.field.ComboBox({
			flex:1.5,
			value:1,
			store:SCOM.boolStyleStore,
			valueField:'id',
			displayField:'text',
			typeAhead:true,		    
		    mode:'local',		    
		    triggerAction:'all'
		});
		
		this.labelField = new Ext.form.Label({			
			text:this.label
		});
		this.items = [this.labelField, {
			xtype:'container',
			style:'padding-top:5px;',
			layout:{
				type:'hbox'				
			},
			items:[
			    this.minField,
			    {
			    	xtype:'label',
			    	style:'padding:5px;',
			    	text:SLANG['to']
			    },
			    this.maxField,
			    {
			    	xtype:'label',
			    	style:'padding:5px;',
			    	text:SLANG['set_as']
			    },
			    this.styleField
			]
		}];
				
		this.callParent();		
		
		this.on({
			scope:this,
			'show':this._onShow
		});
		
		this.mon(this.minField, {
			scope: this,
			'minimode': function(){
				this.hide();
			},
			'normalmode': function(){
				this.show();
			}
		});
		
		this.mon(this.maxField, {
			scope: this,
			'minimode': function(){
				this.hide();
			},
			'normalmode': function(){
				this.show();
			}
		});
	},
	
	/*
	 * when this window show, we need turn on the reference model for sheet
	 * and turn off the selection model
	 */
	_onShow : function(){		
		var sheet = this.sheet;
		if(sheet){			
			/*
			 * disable the selectionModel and editor
			 */
			sheet.disableSelect();
			sheet.disableEdit();
			/*
			 * enable reference model, clear the reference selection, and set it to single select mode 
			 */
			sheet.enableRefer(true, true);
		}
		this.minField.focus(null, 100);
		if(this.minRangeValue){
			this.minField.setValue(this.minRangeValue);
		}
	},
	
	/*
	 * overwrite quit
	 */
	quit : function(){
		this.callParent(arguments);		
		/*
		 * when this window quit, we need turn off the reference model for sheet
		 * and turn on the selection model
		 */
		var sheet = this.sheet;
		if(sheet){	
			sheet.enableSelect();
			sheet.enableEdit();
			/*
			 * disable reference model, clear the reference selection, and cancel the single select mode 
			 */
			sheet.disableRefer(true);
		}
	},
	
	updateConfig : function(config){
		if(config.min){
			this.minRangeValue = config.min;
			this.minField.setValue(config.min);
		}else{
			delete(this.minRangeValue);
			this.minField.reset();
		}
		if(config.max){
			this.maxField.setValue(config.max);
		}else{
			this.maxField.reset();
		}
		if(config.label){
			this.labelField.setText(config.label);
		}
		if(config.title){
			this.setTitle(config.title);
		}
		Ext.apply(this, config);
	},
	
	/*
	 * overwrite to prepare the params
	 */
	prepareParam : function(){
		var id = this.styleField.getValue();
		var store = this.styleField.store;
		var rd = store.getAt(store.find('id', id));
		var min = this.minField.getCoord(), max = this.maxField.getCoord();
		var fn = function(o){
			if(o){
				if('array' == SCOM.typeOf(o) && 0 < o.length){
					return(o[0]);				
				}			
			}else{
				return 0;
			}
			return o;
		}
		var base = {
			min : fn(min),
			max : fn(max)
		};
		return {
			base:base,
			style:rd.data.style
		};
	}
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.pop.condition.BoolWin', {
	
	/* Begin Definitions */
		
	extend : 'EnterpriseSheet.common.pop.PopWin',
	
	requires : [
	    'EnterpriseSheet.sheet.range.RangeField',
	    'Ext.form.field.ComboBox',
	    'Ext.form.Label'
	],
	
	/* End Definitions */
	
	modal : false,
	
	width : 400,
	
	height : 140,		
	
	initComponent : function(){
		
		this.rangeField = new EnterpriseSheet.sheet.range.RangeField({
			/*
			 * need a ref of EnterpriseSheet.Sheet
			 */
			sheet:this.sheet,
			flex:1,
			singleSelect: true,
			simpleSelect: true,
			value:this.value,
			allowBlank:false
		});
		
		this.styleField = new Ext.form.field.ComboBox({
			flex:1.5,
			value:1,
			store:SCOM.boolStyleStore,
			valueField:'id',
			displayField:'text',
			typeAhead:true,		    
		    mode:'local',		    
		    triggerAction:'all'
		});
		
		this.labelField = new Ext.form.Label({			
			text:this.label
		});
		this.items = [this.labelField, {
			xtype:'container',
			style:'padding-top:5px;',
			layout:{
				type:'hbox'				
			},
			items:[
			    this.rangeField,
			    {
			    	xtype:'label',
			    	style:'padding:5px;',
			    	text:SLANG['set_as']
			    },
			    this.styleField
			]
		}];
		
		this.callParent();		
		
		this.on({
			scope:this,
			'show':this._onShow
		});
		
		this.mon(this.rangeField, {
			scope: this,
			'minimode': function(){
				this.hide();
			},
			'normalmode': function(){
				this.show();
			}
		});
	},
	
	/*
	 * when this window show, we need turn on the reference model for sheet
	 * and turn off the selection model
	 */
	_onShow : function(){		
		var sheet = this.sheet;
		if(sheet){			
			/*
			 * disable the selectionModel and editor
			 */
			sheet.disableSelect();
			sheet.disableEdit();			
			/*
			 * enable reference model, clear the reference selection, and set it to single select mode 
			 */
			sheet.enableRefer(true, true);
		}
		this.rangeField.focus(null, 100);
	},
	
	/*
	 * overwrite quit
	 */
	quit : function(){
		this.callParent(arguments);		
		/*
		 * when this window quit, we need turn off the reference model for sheet
		 * and turn on the selection model
		 */
		var sheet = this.sheet;
		if(sheet){	
			sheet.enableSelect();
			sheet.enableEdit();
			/*
			 * disable reference model, clear the reference selection, and cancel the single select mode 
			 */
			sheet.disableRefer(true);
		}
	},
	
	updateConfig : function(config){
		if(config.value){
			this.rangeValue = config.value;
			this.rangeField.setValue(config.value);
		}else{
			delete(this.rangeValue);
			this.rangeField.reset();
		}
		if(config.label){
			this.labelField.setText(config.label);
		}
		if(config.title){
			this.setTitle(config.title);
		}
		Ext.apply(this, config);
	},
	
	/*
	 * overwrite to prepare the params
	 */
	prepareParam : function(){
		var id = this.styleField.getValue();
		var store = this.styleField.store;
		var rd = store.getAt(store.find('id', id));
		var base = this.rangeField.getCoord();		
		if(base){
			if('array' == SCOM.typeOf(base) && 0 < base.length){
				base = base[0];				
			}			
		}else{
			base = 0;
		}
		return {
			base:base,
			style:rd.data.style
		};
	}
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.pop.condition.DateWin', {
	
	/* Begin Definitions */
		
	extend : 'EnterpriseSheet.common.pop.PopWin',
	
	requires : [
	    'EnterpriseSheet.sheet.range.RangeField',
	    'Ext.form.field.ComboBox',
	    'Ext.form.Label'
	],
	
	/* End Definitions */
	
	modal : false,
	
	width : 400,
	
	height : 140,
	
	initComponent : function(){
		
		this.typeField = new Ext.form.field.ComboBox({
			store:SCOM.dateOptionStore,
			valueField:'id',
			displayField:'text',
			typeAhead:true,		    
		    mode:'local',		    
		    triggerAction:'all',
		    value:0
		});
		
		this.styleField = new Ext.form.field.ComboBox({
			flex:1.5,
			value:1,
			store:SCOM.boolStyleStore,
			valueField:'id',
			displayField:'text',
			typeAhead:true,		    
		    mode:'local',		    
		    triggerAction:'all'
		});
		
		this.labelField = new Ext.form.Label({			
			text:this.label
		});
		this.items = [this.labelField, {
			xtype:'container',
			style:'padding-top:5px;',
			layout:{
				type:'hbox'				
			},
			items:[
			    this.typeField,
			    {
			    	xtype:'label',
			    	style:'padding:5px;',
			    	text:SLANG['set_as']
			    },
			    this.styleField
			]
		}];
				
		this.callParent();		
		
		this.on({
			scope:this,
			'show':this._onShow
		});
	},
	
	/*
	 * when this window show, we need turn off the selection model
	 */
	_onShow : function(){		
		var sheet = this.sheet;
		if(sheet){			
			/*
			 * disable the selectionModel and editor
			 */
			sheet.disableSelect();
			sheet.disableEdit();			
		}		
	},
	
	/*
	 * overwrite quit
	 */
	quit : function(){
		this.callParent(arguments);		
		/*
		 * when this window quit, we need turn on the selection model
		 */
		var sheet = this.sheet;
		if(sheet){	
			sheet.enableSelect();
			sheet.enableEdit();			
		}
	},
	
	updateConfig : function(config){
		if(config.value){
			this.typeField.setValue(config.value);
		}
		if(config.label){
			this.labelField.setText(config.label);
		}
		if(config.title){
			this.setTitle(config.title);
		}
		Ext.apply(this, config);
	},
	
	/*
	 * overwrite to prepare the params
	 */
	prepareParam : function(){
		var id = this.styleField.getValue();
		var store = this.styleField.store;
		var rd = store.getAt(store.find('id', id));		
		return {
			base:this.typeField.getValue(),
			style:rd.data.style
		};
	}
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.pop.condition.PositionWin', {
	
	/* Begin Definitions */
		
	extend : 'EnterpriseSheet.common.pop.PopWin',
	
	requires: [
	    'Ext.form.field.Number',
	    'Ext.form.field.ComboBox',
	    'Ext.form.Label'
	],
	/* End Definitions */
	
	modal : false,
	
	width : 400,
	
	height : 140,		
	
	setAsTxt : 'Set as',		
	
	initComponent : function(){
		
		this.posField = new Ext.form.field.Number({
			value:this.value || 10,
			minValue:this.minValue || 1,
			maxValue:this.maxValue
		});
		
		this.styleField = new Ext.form.field.ComboBox({
			flex:1.5,
			value:1,
			store:SCOM.boolStyleStore,
			listWidth:200,
			valueField:'id',
			displayField:'text',
			typeAhead:true,		    
		    mode:'local',		    
		    triggerAction:'all'
		});
		
		this.labelField = new Ext.form.Label({			
			text:this.label
		});
		
		this.setAsLabel = new Ext.form.Label({
			style:'padding:5px;',
	    	text:this.setAsTxt
		});
		
		this.items = [this.labelField, {
			xtype:'container',
			style:'padding-top:5px;',
			layout:{
				type:'hbox'				
			},
			items:[
			    this.posField,
			    this.setAsLabel,
			    this.styleField
			]
		}];
				
		this.callParent();		
		
		this.on({
			scope:this,
			'show':this._onShow
		});
	},
	
	/*
	 * when this window show, we need turn off the selection model
	 */
	_onShow : function(){		
		var sheet = this.sheet;
		if(sheet){			
			/*
			 * disable the selectionModel and editor
			 */
			sheet.disableSelect();
			sheet.disableEdit();			
		}		
	},
	
	/*
	 * overwrite quit
	 */
	quit : function(){
		this.callParent(arguments);		
		/*
		 * when this window quit, we need turn on the selection model
		 */
		var sheet = this.sheet;
		if(sheet){	
			sheet.enableSelect();
			sheet.enableEdit();			
		}
	},
	
	updateConfig : function(config){
		if(config.value){
			this.posField.setValue(config.value);
		}
		if(false != SCOM.typeOf(config.minValue)){
			this.posField.minValue = config.minValue;
		}
		if(false != SCOM.typeOf(config.maxValue)){
			this.posField.maxValue = config.maxValue;
		}
		if(config.setAsTxt){
			this.setAsLabel.setText(config.setAsTxt);
		}
		if(config.label){
			this.labelField.setText(config.label);
		}
		if(config.title){
			this.setTitle(config.title);
		}
		Ext.apply(this, config);
	},
	
	/*
	 * overwrite to prepare the params
	 */
	prepareParam : function(){
		var id = this.styleField.getValue();
		var store = this.styleField.store;
		var rd = store.getAt(store.find('id', id));		
		return {
			base:this.posField.getValue(),
			style:rd.data.style
		};
	}
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.pop.condition.RangeWin', {
	
	/* Begin Definitions */
		
	extend : 'EnterpriseSheet.common.pop.PopWin',
	
	requires : [
	    'EnterpriseSheet.sheet.range.RangeField',
	    'Ext.form.field.ComboBox',
	    'Ext.form.Label'
	],
	
	/* End Definitions */
	
	modal : false,
	
	width : 400,
	
	height : 140,		
	
	layout: 'form',
	
	initComponent : function(){
		
		this.labelField = new Ext.form.Label({			
			text:this.label
		});
		
		this.rangeField = new EnterpriseSheet.sheet.range.RangeField({
			/*
			 * need a ref of EnterpriseSheet.Sheet
			 */
			sheet:this.sheet,
			simpleSelect: this.simpleSelect,
			value:this.value,
			allowBlank:false,			
			anchor: '100%'
		});
		
		this.items = [this.labelField, this.rangeField];
		
		this.callParent();		
		
		this.on({
			scope:this,
			'show':this._onShow
		});
		
		this.mon(this.rangeField, {
			scope: this,
			'minimode': function(){
				this.hide();
			},
			'normalmode': function(){
				this.show();
			}
		});
	},
	
	/*
	 * when this window show, we need turn on the reference model for sheet
	 * and turn off the selection model
	 */
	_onShow : function(){		
		var sheet = this.sheet;
		if(sheet){			
			/*
			 * disable the selectionModel and editor
			 */
			sheet.disableSelect();
			sheet.disableEdit();			
			/*
			 * enable reference model, clear the reference selection, and set it to single select mode 
			 */
			sheet.enableRefer(true, this.singleSelect, this.simpleSelect);
		}
		this.rangeField.focus(null, 100);
		if(this.rangeValue){
			this.rangeField.setValue(this.rangeValue);
		}
	},
	
	/*
	 * overwrite quit
	 */
	quit : function(){
		this.callParent(arguments);		
		/*
		 * when this window quit, we need turn off the reference model for sheet
		 * and turn on the selection model
		 */
		var sheet = this.sheet;
		if(sheet){	
			sheet.enableSelect();
			sheet.enableEdit();
			/*
			 * disable reference model, clear the reference selection, and cancel the single select mode 
			 */
			sheet.disableRefer(true);
		}
	},
	
	updateConfig : function(config){
		if(config.value){
			this.rangeValue = config.value;
			this.rangeField.setValue(config.value);
		}else{
			delete(this.rangeValue);
			this.rangeField.reset();
		}
		/*
		 * update simpleSelect 
		 */
		this.rangeField.simpleSelect = config.simpleSelect;
		
		if(config.label){
			this.labelField.setText(config.label);
		}
		if(config.title){
			this.setTitle(config.title);
		}
		Ext.apply(this, config);
	},
	
	/*
	 * overwrite to prepare the params
	 */
	prepareParam : function(){
		
		var base = this.rangeField.getCoord();		
		if(base){
			if('array' == SCOM.typeOf(base) && 0 < base.length){
				base = base[0];				
			}			
		}else{
			base = 0;
		}
		return {
			base:base
		};
	}
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.pop.condition.RepeatWin', {
	
	/* Begin Definitions */
		
	extend : 'EnterpriseSheet.common.pop.PopWin',
	
	requires: [	   	
	   	'Ext.form.field.ComboBox',
	    'Ext.form.Label'
	],	   		   
	
	/* End Definitions */
	
	modal : false,
	
	width : 400,
	
	height : 140,		
	
	initComponent : function(){
		
		this.typeField = new Ext.form.field.ComboBox({
			store:SCOM.repeatStore,
			valueField:'id',
			displayField:'text',
			typeAhead:true,		    
		    mode:'local',		    
		    triggerAction:'all',
		    value:SCONST.REPEAT_VALUE
		});
		
		this.styleField = new Ext.form.field.ComboBox({
			flex:1.5,
			value:1,
			store:SCOM.boolStyleStore,
			valueField:'id',
			displayField:'text',
			typeAhead:true,		    
		    mode:'local',		    
		    triggerAction:'all'
		});
		
		this.labelField = new Ext.form.Label({			
			text:this.label
		});
		this.items = [this.labelField, {
			xtype:'container',
			style:'padding-top:5px;',
			layout:{
				type:'hbox'				
			},
			items:[
			    this.typeField,
			    {
			    	xtype:'label',
			    	style:'padding:5px;',
			    	text:SLANG['set_as']
			    },
			    this.styleField
			]
		}];
			
		this.callParent();		
		
		this.on({
			scope:this,
			'show':this._onShow
		});
	},
	
	/*
	 * when this window show, we need turn off the selection model
	 */
	_onShow : function(){		
		var sheet = this.sheet;
		if(sheet){			
			/*
			 * disable the selectionModel and editor
			 */
			sheet.disableSelect();
			sheet.disableEdit();			
		}		
	},
	
	/*
	 * overwrite quit
	 */
	quit : function(){
		this.callParent(arguments);		
		/*
		 * when this window quit, we need turn on the selection model
		 */
		var sheet = this.sheet;
		if(sheet){	
			sheet.enableSelect();
			sheet.enableEdit();			
		}
	},
	
	updateConfig : function(config){
		if(config.value){
			this.typeField.setValue(config.value);
		}
		if(config.label){
			this.labelField.setText(config.label);
		}
		if(config.title){
			this.setTitle(config.title);
		}
		Ext.apply(this, config);
	},
	
	/*
	 * overwrite to prepare the params
	 */
	prepareParam : function(){
		var id = this.styleField.getValue();
		var store = this.styleField.store;
		var rd = store.getAt(store.find('id', id));		
		return {
			base:this.typeField.getValue(),
			style:rd.data.style
		};
	}
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 *
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 *
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.pop.condition.ManageWin', {
	
	/* Begin Definitions */
		
	extend : 'EnterpriseSheet.common.pop.PopWin',
	
	requires: [
	    'Ext.grid.Panel',       
	    'EnterpriseSheet.sheet.range.RangeField', 
	    'EnterpriseSheet.sheet.model.ConditionModel'
	],
	
	/* End Definitions */
	
	modal : false,
	
	width : 600,
	
	height : 300,		
	
	layout : 'fit',
	
	resizable: true,
	
	initComponent : function(){
		this.title = this.title || this.getStr('condition_style_manager'); 
		
		this.conditionStore = new Ext.data.Store({
			model: 'EnterpriseSheet.sheet.model.ConditionModel'
		});
		
		this.optionStore = new Ext.data.Store({
			fields:[
			    {name : 'id', type : 'int'},				
				'name'
			]
		});
		
		this.optionCombo = new Ext.form.ComboBox({
			store: this.optionStore,
			valueField:'id',
			displayField:'name',
			typeAhead : true,		    
		    queryMode : 'local',		    
		    triggerAction : 'all',		    
		    selectOnFocus : true,		    
		    forceSelection : true
		});
		
		this.deleteBtn = new Ext.button.Button({
			iconCls:'icon-delete',
			disabled:true,
			text:this.getStr('delete_condition_style'),
			handler:this.onDelete,
			scope:this
		});
		
		/*
		 * create the grid
		 */
		this.grid = new Ext.grid.Panel({
			columns:[{
				header:this.getStr('condition'),
				dataIndex:'name',
				sortable : true,	
				flex: 1,
				renderer:Ext.Function.bind(function(v){
					return this.getStr(v);
				}, this)
			}, /*{
				header:this.getStr('style'),
				dataIndex:'opt',
				sortable : true,	
				flex: 1,
				renderer:Ext.Function.bind(function(value, metaData, record, rowIndex, colIndex, store){
					var html = '<div class="ss-colorbar-sample" style="background:red;"></div>';
					return html;
				}, this)
			},*/ {
				header:this.getStr('range'),
				dataIndex:'rng',
				sortable : false,				
				flex: 2,
				tdCls: 'ss-cdt-rng',
				renderer:Ext.Function.bind(function(value, metaData, record, rowIndex, colIndex, store){
					var html = '='+EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String(record.data.coord, undefined, true);
					return html;
				}, this)
			}],
			selType: 'rowmodel',
			store:this.conditionStore,			
			tbar:[{
				xtype:'label',
				text:this.getStr('show_condition_style_of')+' : ',
				style:'padding:5px;'
			}, this.optionCombo, '->', this.deleteBtn]
		});
		
		this.items = [
		    this.grid
		];
		
		this.callParent();		
		
		this.on({
			scope:this,
			'show':this._onShow
		});
		
		this.mon(this.optionCombo, {
			scope:this,
			'select':this.setup
		});	
		this.mon(this.grid.getSelectionModel(), {
			scope:this,
			'selectionchange':this.onSelectionChange
		});
		this.mon(this.grid, {
			scope: this,
			'itemclick': this.onGridItemClick
		});
	},
	
	/*
	 * on selection change, disable/enable btn
	 */
	onSelectionChange : function(sm){
		var sels = sm.getSelection();
		if(0 < sels.length){
			this.deleteBtn.enable();
		}else{
			this.deleteBtn.disable();
		}
	},
		
	/*
	 * when this window show, we need turn off the selection model
	 */
	_onShow : function(){		
		if(this.sheet){
			var sheets = this.sheet.getStore().getSheets();		
			this.optionStore.removeAll();
			this.optionStore.add({
				id:-1,
				name:this.getStr('selection_range')
			});
			for(var i = 0, len = sheets.length; i < len; i++){				
				this.optionStore.add({
					id:sheets[i].id,
					name:sheets[i].name
				});
			}
			this.optionCombo.setValue(-1);
			/*
			 * disable the selectionModel and editor
			 */
			this.sheet.disableSelect();
			this.sheet.disableEdit();
			/*
			 * enable reference model, clear the reference selection, and set it to single select mode 
			 */
			this.sheet.enableRefer(true, false);
		}	
		this.setup();
	},
	
	/*
	 * overwrite quit
	 */
	quit : function(){
		this.callParent(arguments);		
		/*
		 * when this window quit, we need turn off the reference model for sheet
		 * and turn on the selection model
		 */
		var sheet = this.sheet;
		if(sheet){	
			sheet.enableSelect();
			sheet.enableEdit();
			/*
			 * disable reference model, clear the reference selection, and cancel the single select mode 
			 */
			sheet.disableRefer(true);
		}
	},
	
	/*
	 * setup the condition info for current selection
	 */
	setup : function(){
		var sheet = this.sheet;
		if(sheet){
			var curSheetId = sheet.getSheetId();
			var store = sheet.getStore();
			var opt = this.optionCombo.getValue();
			var conditions = {};		
			var fn = function(rd){									
				var cdt = sheet.getConditionOfCell(rd.data.sheet, rd.data.row, rd.data.col);
				if(0 < cdt.length){											
					for(var i = 0, len = cdt.length; i < len; i++){
						var c = cdt[i];
						if(!conditions[c.id]){
							/*
							 * get the condition by id
							 */
							c = SCOM.copy(c);
							c.sheet = rd.data.sheet;
							/*
							 * create coord property to hold the coord
							 */
							c.coord = [];
							for(var k = 0, count = c.rng.length; k < count; k++){
								var piece = c.rng[k];
								var span = piece['span'] || piece['SPAN'], type = piece['type'] || piece['TYPE'];
												
								c.rng[k] = span;
								var sheetId;
								if(span && !SCOM.nullOrUndefined(span[0]) && '' !== span[0]){
									sheetId = span[0];
								}else{
									sheetId = curSheetId;
								}
								var sheetName = store.getSheetNameById(sheetId);
								c.coord.push({
									span: [sheetName, span[1], span[2], span[3], span[4]],
									type: SCONST.ABSOLUTE_COORD
								});
							}								
							conditions[c.id] = c;
						}
					}
				}
			};
			if(-1 == opt){				
				sheet.walkSelection(fn, this);
			}else{
				store.walkWhole(opt, fn, this);
			}			
			/*
			 * there is a bug related with current extjs4.0.2a
			 * we need call refresh by self
			 */
			this.conditionStore.removeAll(true);
			this.grid.getView().refresh();		
			
			
			for(var p in conditions){	
				if(conditions.hasOwnProperty(p)){					
					this.conditionStore.add(SCOM.copy(conditions[p]));
				}
			}
			
			/*
			 * save all related condition id in the store
			 */
			this.conditions = conditions;
			this.changedCdts = {};
		}
		
		
	},
	
	prepareButton : function(){
		this.applyBtn = new Ext.Button({			
			text:this.getStr('apply'),
			handler:this.onApply,
			scope:this
		});
		
    	this.buttons = [{
			text:this.getStr('ok'),
			handler:this.onOK,
			scope:this
		}, {
			text:this.getStr('close'),
			handler:this.onCancel,
			scope:this
		}, this.applyBtn];
    },
    
    updateConfig : function(config){
    	
    },
    
    /*
     * delete a condition
     */
    onDelete : function(){
    	var sm = this.grid.getSelectionModel(), store = this.grid.getStore();
    	var sels = sm.getSelection();
    	if(0 < sels.length){
	    	for(var i = 0, len = sels.length; i < len; i++){
	    		var rd = sels[i];
	    		/*
	    		 * save it to changedCdt cache
	    		 */
	    		this.changedCdts[rd.data.id] = 'deleted';
	    		store.remove(rd);
	    	}	    	
    	}
    },
    
    onOK : function(){
    	this.onApply();
    	this.hide();
    },
    
    /*
     * apply the changes
     */
    onApply : function(){
    	var me = this;
    	var sheet = this.sheet;
    	var cdtStore = this.conditionStore;
    	if(sheet){
    		var posCdtCache = {};
    		for(var p in this.changedCdts){
    			if(this.changedCdts.hasOwnProperty(p)){
    				if('deleted' !== this.changedCdts[p]){
    					var rd = cdtStore.getById(p);
        				if(rd){
        					posCdtCache[p] = rd.data;
        				}
    				}    				
    			}
    		}
    		sheet.changeConditions(this.changedCdts, this.conditions, posCdtCache)
    		
    	}
    },
    
    /**
     * click a row in grid
     */
    onGridItemClick : function(grid, rec, item, index, e){
    	var target = e.getTarget('.ss-cdt-rng');
    	if(target){
    		var store = this.sheet.getStore();
    		var miniBox = EnterpriseSheet.sheet.range.RangeField.prototype.getMiniRangeBox(this.sheet, this);
    		var miniRangeField = miniBox.getRangeField();
    		miniRangeField.setValue(rec.data.rng);
    		this.hide();
    		miniBox.show();
    		this.on('normalmode', function(){
    			var coord = miniRangeField.getCoord();
    			var rng = [];
    			for(var i = 0, len = coord.length; i < len; i++){
    				var span = coord[i].span;
    				rng.push([].concat(span));
    				span[0] = store.getSheetNameById(span[0]);
    			}
    			/*
    			 * change the rng
    			 */
    			rec.set({
    				'rng': rng,
    				'coord': coord
    			});
    			
    			/*
    			 * save it to changed cache
    			 */
    			this.changedCdts[rec.data.id] = 'update';
    			
    			grid.getStore().commitChanges();
    			this.un({
    				scope:this,
    				'show':this._onShow
    			});
    			this.show();
    			this.on({
    				scope:this,
    				'show':this._onShow
    			});
    			
    		}, this, {single: true});
    	}
    }
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.pop.Popup', {
	
	/* Begin Definitions */
			
	requires : [
	    'EnterpriseSheet.sheet.pop.CellOptionWin',
	    'EnterpriseSheet.sheet.pop.CopiedCellOptionWin',
	    'EnterpriseSheet.sheet.pop.SortOptionWin',
	    'EnterpriseSheet.sheet.pop.SizeWin',
	    'EnterpriseSheet.sheet.pop.LinkWin',
	    'EnterpriseSheet.sheet.pop.condition.AverageWin',
	    'EnterpriseSheet.sheet.pop.condition.BetweenWin',
	    'EnterpriseSheet.sheet.pop.condition.BoolWin',
	    'EnterpriseSheet.sheet.pop.condition.DateWin',
	    'EnterpriseSheet.sheet.pop.condition.ManageWin',
	    'EnterpriseSheet.sheet.pop.condition.PositionWin',
	    'EnterpriseSheet.sheet.pop.condition.RepeatWin',
	    'EnterpriseSheet.sheet.pop.condition.RangeWin',
	    'EnterpriseSheet.sheet.pop.ChartSettingWin',
	    'EnterpriseSheet.sheet.pop.CommentWin',
	    'EnterpriseSheet.sheet.pop.TextWin',
	    'EnterpriseSheet.sheet.pop.ReferenceNameWin',
		'EnterpriseSheet.sheet.pop.droplist.DropListConfigWin',
	    'EnterpriseSheet.sheet.pop.ValidationWin'
	],
	
	/* End Definitions */
	
	
	
	constructor : function(){
		
		this.callParent(arguments);
	},
	
	/*
	 * show the row height setting window
	 */
	showRowHeightBox : function(config){
		var win = this.getSizeWin(Ext.apply({
			/*
			 * language stuff
			 */
			invalidMsg:SLANG['positive_number'],
			fieldLabel:SLANG['row_height'],
			title:SLANG['row_height'],
			okText:SLANG['ok'],
			cancelText:SLANG['cancel']
		}, config));
		win.show();
	},
	
	showColumnWidthBox : function(config){
		var win = this.getSizeWin(Ext.apply({
			invalidMsg:SLANG['positive_number'],
			fieldLabel:SLANG['column_width'],
			title:SLANG['column_width'],
			okText:SLANG['ok'],
			cancelText:SLANG['cancel']
		}, config));
		win.show();
	},
	
	showLinkBox : function(config){
		var win = this.getLinkWin(Ext.apply({
			invalidMsg:SLANG['invalid_url'],
			fieldLabel:SLANG['hyperlink'],
			title:SLANG['hyperlink'],
			okText:SLANG['ok'],
			cancelText:SLANG['cancel']
		}, config));
		win.show();
	},
	
	showCommentBox : function(config){
		var win = this.getCommentWin(Ext.apply({}, config));
		win.show();
	},
	
	showTextBox : function(config){
		var win = this.getTextWin(Ext.apply({}, config));
		win.show();
	},
	
	showVarTextBox : function(config){
		var win = this.getVarTextWin(Ext.apply({
			filedVtype: 'varname'
		}, config));
		win.show();
	},
	
	showReferenceNameBox : function(config){
		var win = this.getReferenceNameWin(Ext.apply({}, config));
		win.show();
	},
	
	showValidationBox : function(config){
		var win = this.getValidationWin(Ext.apply({}, config));
		win.popup();
	},
	
	/*
	 * show insert cell option window
	 */
	showInsertCellOption : function(config){
		var win = this.getCellOptionWin(Ext.apply(config, {
			title:SLANG['insert_option'],
			boxLabel1:SLANG['move_current_cell_bottom'],
			boxLabel2:SLANG['move_current_cell_right'],
			boxLabel3:SLANG['insert_whole_row'],
			boxLabel4:SLANG['insert_whole_column'],
			okText:SLANG['ok'],
			cancelText:SLANG['cancel']
		}));
		win.show();
	},
	
	/*
	 * show remove cell option window
	 */
	showRemoveCellOption : function(config){
		var win = this.getCellOptionWin(Ext.apply(config, {
			title:SLANG['remove_option'],
			boxLabel1:SLANG['bottom_side_cell_move_top'],
			boxLabel2:SLANG['right_side_cell_move_left'],
			boxLabel3:SLANG['remove_whole_row'],
			boxLabel4:SLANG['remove_whole_column'],
			okText:SLANG['ok'],
			cancelText:SLANG['cancel']
		}));
		win.show();
	},
	
	/**
	 * show insert copied cell option window
	 */
	showInsertCopiedCellOption : function(config){
		var win = this.getCopiedCellOptionWin(Ext.apply(config, {
			title:SLANG['insert_copied_option'],
			boxLabel1:SLANG['move_current_cell_bottom'],
			boxLabel2:SLANG['move_current_cell_right'],
			okText:SLANG['ok'],
			cancelText:SLANG['cancel']
		}));
		win.show();
	},
	
	/*
	 * show sort on column option window
	 */
	showSortColumnOption : function(config){
		var win = this.getSortOptionWin(Ext.apply(config, {
			title:SLANG['sort_option'],
			boxLabel1:SLANG['expand_whole_row'],
			boxLabel2:SLANG['only_current_range'],			
			okText:SLANG['ok'],
			cancelText:SLANG['cancel']
		}));
		win.show();
	},	
	
	/*
	 * show condition bool window
	 */
	showConditionBool : function(config){
		var win = this.getConditionBoolWin(Ext.apply(config, {
			okText:SLANG['ok'],
			cancelText:SLANG['cancel']
		}));
		win.show();
	},
	
	/*
	 * show condition range window
	 */
	showConditionRange : function(config){
		var win = this.getConditionRangeWin(Ext.apply(config, {
			okText:SLANG['ok'],
			cancelText:SLANG['cancel']
		}));
		win.show();
	},
	
	/*
	 * show condition between window
	 */
	showConditionBetween : function(config){
		var win = this.getConditionBetweenWin(Ext.apply(config, {
			okText:SLANG['ok'],
			cancelText:SLANG['cancel']
		}));
		win.show();
	},
	
	/*
	 * show condition repeat window
	 */
	showConditionRepeat : function(config){
		var win = this.getConditionRepeatWin(Ext.apply(config, {
			okText:SLANG['ok'],
			cancelText:SLANG['cancel']
		}));
		win.show();
	},
	
	/*
	 * show condition average window
	 */
	showConditionAverage : function(config){
		var win = this.getConditionAverageWin(Ext.apply(config, {
			okText:SLANG['ok'],
			cancelText:SLANG['cancel']
		}));
		win.show();
	},
	
	/*
	 * show condition position window
	 */
	showConditionPosition : function(config){
		var win = this.getConditionPositionWin(Ext.apply(config, {
			okText:SLANG['ok'],
			cancelText:SLANG['cancel']
		}));
		win.show();
	},
	
	/*
	 * show condition date window
	 */
	showConditionDate : function(config){
		var win = this.getConditionDateWin(Ext.apply(config, {
			okText:SLANG['ok'],
			cancelText:SLANG['cancel']
		}));
		win.show();
	},
	
	/*
	 * show condition manage window
	 */
	showConditionManage : function(config){
		var win = this.getConditionManageWin(config);
		win.show();
	},
	
    /*
     * show condition manage window
     */
    showDropListConfig : function(config){
        var win = this.getDropListConfigWin(config);
        win.show();
    },
           
	/****************************************************************
	 * below is for create the different kind of windows
	 ****************************************************************/
	/*
	 * private, get an instance of CellOptionWin, if it's null then create one
	 */
	getCellOptionWin : function(config){
		if(!this.cellOptionWin){
			this.cellOptionWin = new EnterpriseSheet.sheet.pop.CellOptionWin(config);
			this.cellOptionWin.on('destroy', function(){
				/*
				 * remove the ref of this win
				 */
				delete(this.cellOptionWin);
			}, this);
		}else{
			this.cellOptionWin.updateConfig(config);
		}
		return this.cellOptionWin;
	},
	
	/*
	 * private, get an instance of CopiedCellOptionWin, if it's null then create one
	 */
	getCopiedCellOptionWin : function(config){
		if(!this.copiedCellOptionWin){
			this.copiedCellOptionWin = new EnterpriseSheet.sheet.pop.CopiedCellOptionWin(config);
			this.copiedCellOptionWin.on('destroy', function(){
				/*
				 * remove the ref of this win
				 */
				delete(this.copiedCellOptionWin);
			}, this);
		}else{
			this.copiedCellOptionWin.updateConfig(config);
		}
		return this.copiedCellOptionWin;
	},
	
	/*
	 * private, get an instance of SortOptionWin, if it's null then create one
	 */
	getSortOptionWin : function(config){
		if(!this.sortOptionWin){
			this.sortOptionWin = new EnterpriseSheet.sheet.pop.SortOptionWin(config);
			this.sortOptionWin.on('destroy', function(){
				/*
				 * remove the ref of this win
				 */
				delete(this.sortOptionWin);
			}, this);
		}else{
			this.sortOptionWin.updateConfig(config);
		}
		return this.sortOptionWin;
	},
	
	/*
	 * private, get an instance of SizeWin, if it's null then create one
	 */
	getSizeWin : function(config){
		if(!this.sizeWin){
			this.sizeWin = new EnterpriseSheet.sheet.pop.SizeWin(config);
			this.sizeWin.on('destroy', function(){
				/*
				 * remove the ref of this win
				 */
				delete(this.sizeWin);
			}, this);
		}else{
			this.sizeWin.updateConfig(config);
		}
		return this.sizeWin;
	},
	
	/*
	 * private, get an instance of LinkWin, if it's null then create one
	 */
	getLinkWin : function(config){
		if(!this.linkWin){
			this.linkWin = new EnterpriseSheet.sheet.pop.LinkWin(config);
			this.linkWin.on('destroy', function(){
				/*
				 * remove the ref of this win
				 */
				delete(this.linkWin);
			}, this);
		}else{
			this.linkWin.updateConfig(config);
		}
		return this.linkWin;
	},
	
	/*
	 * get an instance of ConditionBoolWin, if it's null then create one
	 */
	getConditionBoolWin : function(config){
		if(!this.conditionBoolWin){
			this.conditionBoolWin = new EnterpriseSheet.sheet.pop.condition.BoolWin(config);
		}else{
			this.conditionBoolWin.updateConfig(config);
		}
		return this.conditionBoolWin;
	},
	
	/*
	 * get an instance of ConditionBoolWin, if it's null then create one
	 */
	getConditionRangeWin : function(config){
		if(!this.conditionRangeWin){
			this.conditionRangeWin = new EnterpriseSheet.sheet.pop.condition.RangeWin(config);
		}else{
			this.conditionRangeWin.updateConfig(config);
		}
		return this.conditionRangeWin;
	},
	
	/*
	 * get an instance of ConditionBetweenWin, if it's null then create one
	 */
	getConditionBetweenWin : function(config){
		if(!this.conditionBetweenWin){
			this.conditionBetweenWin = new EnterpriseSheet.sheet.pop.condition.BetweenWin(config);
		}else{
			this.conditionBetweenWin.updateConfig(config);
		}
		return this.conditionBetweenWin;
	},
	
	/*
	 * get an instance of ConditionRepeatWin, if it's null then create one
	 */
	getConditionRepeatWin : function(config){
		if(!this.conditionRepeatWin){
			this.conditionRepeatWin = new EnterpriseSheet.sheet.pop.condition.RepeatWin(config);
		}else{
			this.conditionRepeatWin.updateConfig(config);
		}
		return this.conditionRepeatWin;
	},
	
	/*
	 * get an instance of ConditionRepeatWin, if it's null then create one
	 */
	getConditionDateWin : function(config){
		if(!this.conditionDateWin){
			this.conditionDateWin = new EnterpriseSheet.sheet.pop.condition.DateWin(config);
		}else{
			this.conditionDateWin.updateConfig(config);
		}
		return this.conditionDateWin;
	},
	
	/*
	 * get an instance of ConditionAverageWin, if it's null then create one
	 */
	getConditionAverageWin : function(config){
		if(!this.conditionAverageWin){
			this.conditionAverageWin = new EnterpriseSheet.sheet.pop.condition.AverageWin(config);
		}else{
			this.conditionAverageWin.updateConfig(config);
		}
		return this.conditionAverageWin;
	},
	
	/*
	 * get an instance of ConditionPostionWin, if it's null then create one
	 */
	getConditionPositionWin : function(config){
		if(!this.conditionPositionWin){
			this.conditionPositionWin = new EnterpriseSheet.sheet.pop.condition.PositionWin(config);
		}else{
			this.conditionPositionWin.updateConfig(config);
		}
		return this.conditionPositionWin;
	},
	
	/*
	 * get an instance of ConditionManageWin, if it's null then create one
	 */
	getConditionManageWin : function(config){
		if(!this.conditionManageWin){
			this.conditionManageWin = new EnterpriseSheet.sheet.pop.condition.ManageWin(config);
		}else{
			this.conditionManageWin.updateConfig(config);
		}
		return this.conditionManageWin;
	},
	
	/*
	 * get an instance of ChartSettingWin, if it's null then create one
	 */
	getChartSettingWin : function(config){
		if(!this.charSettingWin){
			this.charSettingWin = new EnterpriseSheet.sheet.pop.ChartSettingWin(config);
		}else{
			this.charSettingWin.updateConfig(config);
		}
		return this.charSettingWin;
	},
	
	/*
	 * get an instance of CommentWin, if it's null then create one
	 */
	getCommentWin : function(config){
		if(!this.commentWin){
			this.commentWin = new EnterpriseSheet.sheet.pop.CommentWin(config);
		}else{
			this.commentWin.updateConfig(config);
		}
		return this.commentWin;
	},
	
	/*
	 * get an instance of TextWin, if it's null then create one
	 */
	getTextWin : function(config){
		if(!this.textWin){
			this.textWin = new EnterpriseSheet.sheet.pop.TextWin(config);
		}else{
			this.textWin.updateConfig(config);
		}
		return this.textWin;
	},
	
	getVarTextWin : function(config){
		if(!this.varTextWin){
			this.varTextWin = new EnterpriseSheet.sheet.pop.TextWin(config);
		}else{
			this.varTextWin.updateConfig(config);
		}
		return this.varTextWin;
	},
	
	getReferenceNameWin : function(config){
		if(!this.refNameWin){
			this.refNameWin = new EnterpriseSheet.sheet.pop.ReferenceNameWin(config);
		}else{
			this.refNameWin.updateConfig(config);
		}
		return this.refNameWin;
	},
	
	getValidationWin : function(config){
		if(!this.validationWin){
			this.validationWin = new EnterpriseSheet.sheet.pop.ValidationWin(config);
		}else{
			this.validationWin.updateConfig(config);
		}
		return this.validationWin;
	},
           
    getDropListConfigWin : function(config){
        if(!this.dropListConfigWin){
           this.dropListConfigWin = new EnterpriseSheet.sheet.pop.droplist.DropListConfigWin(config);
        }else{
           this.dropListConfigWin.updateConfig(config);
        }
        return this.dropListConfigWin;
    }
}, function(){
	SPOP = new EnterpriseSheet.sheet.pop.Popup();
});
Ext.define('EnterpriseSheet.sheet.action.HotKey', {
	/* Begin Definitions */
	
	extend: 'Ext.util.Observable',
	
	constructor : function(){
		this.callParent(arguments);		
		Ext.getDoc().on('keydown', this.onKeyDown, this);		
	},
	
	/**
	 * on cursor keydown --- this will handle keyboard ...
	 */
	onKeyDown : function(e){		
		var ctrl = e.ctrlKey ? 1 : 0, alt = e.altKey ? 1: 0, shift = e.shiftKey ? 1 : 0;
		var key = e.getKey();
		
		var id = [key, ctrl, alt, shift].join('-');
		
		this.lookup = this.lookup || {};
		var lookup = this.lookup;
		var found = lookup[id];	
		
		if(found){						
			found.callback.call(found.scope, e);
			
			e.stopEvent();
			
			return false;
		}
		
		// ok, we need remove shift key - this is for capital - Shift a, b, c etc 
		if(ctrl || alt || found){
			return false;
		}
	},
	
	bindHotKey : function(key, ctrl, alt, shift, callback, scope){
		ctrl = ctrl ? 1 : 0;
		alt = alt ? 1 : 0;
		shift = shift ? 1 : 0;
		var id = [key, ctrl, alt, shift].join('-');
		this.lookup = this.lookup || {};
		this.lookup[id] = {
			key: key,
			ctrl: ctrl,
			alt: alt,
			shift: shift,
			callback: callback,
			scope: scope
		};
	}
}, function(){
	/*
	 * the global hotkey
	 */

	PHKey = function() {
		var hkey = new EnterpriseSheet.sheet.action.HotKey();
		return {
			bindHotKey : function(key, ctrl, alt, shift, callback, scope) {
				return hkey.bindHotKey(key, ctrl, alt, shift, callback, scope);
			}
		};
	}();
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.pop.OpenFileWin', {
	
	/* Begin Definitions */
		
	extend : 'Ext.window.Window',
	
	/* End Definitions */
    requires: [
        'Ext.form.field.Text',
        'Ext.layout.container.Form',
        'EnterpriseSheet.model.FileModel'
    ],
           
    bodyStyle : 'background-color:white;',
           
    title: SLANG['open_sheet'],
           
    plain: true,
           
    modal: true,
           
    resizable: false,
           
    shim : true,
           
    closeAction: 'hide',
           
    layout: 'fit',
           
    buttonAlign: 'right',
           
    initComponent : function(){
           
        // create the Data Store
	    this.fileStore = Ext.create('Ext.data.Store', {
	        pageSize: 50,
	        model: EnterpriseSheet.model.FileModel,
	        remoteSort: true,
	        proxy: {
	            type: 'ajax',
                url: SCONFIG.urls['listOpen'],
	            reader: {
	                root: 'results',
	                totalProperty: 'totalCount'
	            }
	        }
	    });
        
        this.queryField = Ext.create('Ext.form.field.Text', {
            width: 300,
            enableKeyEvents: true,
            listeners: {
                'keydown': {
                    fn: this.onQueryKeyDown,
                    scope: this
                }
            }
        });
         
        this.fileGrid = Ext.create('Ext.grid.Panel', {
	        store: this.fileStore,
	        loadMask: true,
            border: false,
	        columns:[{
				width: 56,
				dataIndex: 'exname',
				menuDisabled: true,
				resizable: false,
				draggable: false,
				renderer: this.renderIcon
			},{
	            text: SLANG['file_name'],
	            dataIndex: 'name',
	            flex: 1,
	            sortable: true
	        }, {
				text: SLANG['update_date'],
				dataIndex: 'updateDate',
                style: 'border-right:none;',
				minWidth: 150,
	            maxWidth: 250,
				menuDisabled: true,
				resizable: false,
				draggable: false
			}],
	        dockedItems: [{
                dock: 'top',
                xtype: 'toolbar',
                style: 'padding-left:10px;background:white;',
                height: 36,
                layout: {
                    type: 'hbox',
                    align: 'middle'
                },
                items: [this.queryField, {
                    style: 'margin-left:2px;',
                    text: SLANG['search'],
                    handler: this.onSearchFn,
                    scope: this
                }]
            }],
	        // paging bar on the bottom
	        bbar: Ext.create('Ext.PagingToolbar', {
	            store: this.fileStore,
	            displayInfo: true,
	            displayMsg: 'Displaying items {0} - {1} of {2}',
	            emptyMsg: "No items to display"
	        })
	    });
        this.fileStore.load();
           
        this.openBtn = Ext.create('Ext.button.Button', {
            disabled: true,
            text: SLANG['open'],
            handler: this.onOpenFn,
            scope: this
        });
           
        this.items = [this.fileGrid];
           
        this.buttons = [this.openBtn];
           
        this.callParent(arguments);
           
        this.on({
            scope: this,
            'hide': this.onHideFn
        });
        
        this.fileGrid.on({
            scope: this,
            'itemclick': this.onRowSelectFn,
            'itemdblclick': this.onRowDblClickFn
        });
    },
    
    /**
	 * render the photo
	 */
	renderIcon : function(val, meta, rec, rowIndex, colIndex, store, view){
		var result = '<img src="' + SCONFIG.IMAGES_PATH + '/icons/open.png' + '"></img>';

		if (rec.data.exname == 'xls') {
			result = '<img src="' + SCONFIG.IMAGES_PATH + '/sheet_darkgreen.png' + '"></img>';
		} else if (rec.data.exname == 'xlt') {
			result = '<img src="' + SCONFIG.IMAGES_PATH + '/sheet_tpl.png' + '"></img>';
		} 
		return result;
	},       
           
    onHideFn : function(){
        if(this.hideCallback){
           this.hideCallback.call(this.scope, this);
        }
    },
           
    setTitle : function(title){
        this.titleBox.update(title);
    },
           
    /**
     * setup the config and show
     */
    popup : function(config){
        if(config){
            Ext.apply(this, config);
        }
        this.show();
    },
           
    /**
     * on save the file
     */
    onOpenFn : function() {
        var sels = this.fileGrid.getSelectionModel().getSelection();

        this.hide();
        if(this.callback){
            this.callback.call(this.scope, sels[0].data.id);
        }
    },
           
    onCancelFn : function(){
        this.hide();
    },
           
    /**
     * when select a node in dir tree
     */
    onRowSelectFn : function(list, rec, item, index, e){
        var selectedId = rec.data.id;
        var exname = rec.data.exname;
        
        if (exname == 'xls' || exname == 'xlt')
            this.openBtn.enable();
        else 
            this.openBtn.disable();
    },
    
    onRowDblClickFn : function(list, rec, item, index, e) {
        var selectedId = rec.data.id;
        var exname = rec.data.exname;
        if (exname == 'xls' || exname == 'xlt'){
            this.hide();
            if(this.callback){
                this.callback.call(this.scope, selectedId);
            }
        }
    },
           
    // this is for search function ...
    onQueryKeyDown : function(field, e){
        var key = e.getKey();
        var keyObj = Ext.EventObject ? Ext.EventObject : Ext.event.Event;
        if(keyObj.ENTER === key){
           this.onSearchFn();
        }else if(keyObj.ESC === key){
           if('' !== this.queryField.getValue()){
                this.queryField.setValue('');
                this.onSearchFn();
           }
        }
    },
           
    /**
     * search files ...
     */
    onSearchFn : function(){
        var query = this.queryField.getValue();
        this.fileStore.load({
            params:{
                query: query
            }
        });
    }
}, function(){
    SOPEN = (function(){
        var win;
        return {
            popup : function(config){
                if(!win){
                    win = new EnterpriseSheet.pop.OpenFileWin({
                        width: 550,
                        height: 400
                    });
                }
                Ext.apply(win, config);
                win.popup();
             }
        }
    })();
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.pop.SaveFileWin', {
	
	/* Begin Definitions */
		
	extend : 'Ext.window.Window',
	
	/* End Definitions */
    requires: [
        'Ext.form.field.Text',
        'Ext.layout.container.Form'
    ],
           
    bodyStyle : 'background-color:white;',
           
    title: SLANG['save_sheet_as'],
           
    plain: true,
           
    modal: true,
           
    resizable: false,
           
    shim : true,
           
    closeAction: 'hide',
           
    layout: 'fit',
           
    buttonAlign: 'right',
           
    initComponent : function(){
           
        // create the Data Store
	    this.fileStore = Ext.create('Ext.data.Store', {
	        pageSize: 50,
	        model: EnterpriseSheet.model.FileModel,
	        remoteSort: true,
	        proxy: {
	            type: 'ajax',
                url: SCONFIG.urls['list'],
	            reader: {
	                root: 'results',
	                totalProperty: 'totalCount'
	            }
	        }
	    });
        
        
        this.saveBtn = Ext.create('Ext.button.Button', {
            text: SLANG['save'],
            style: 'margin-left:10px;',
            minWidth: 65,
            handler: this.onSaveFn,
            scope: this
        });
         
        this.fileNameField = Ext.create('Ext.form.field.Text', {
            flex: 1,
            labelWidth: 60,
            fieldLabel: SLANG['file_name'],
            allowBlank: false
        });
        
        this.exnameField = Ext.create('Ext.form.ComboBox', {
            flex: 1,
            labelWidth: 60,
            fieldLabel: SLANG['save_as'],
            queryMode: 'local',
            displayField: 'name',
            valueField: 'name',
            value: 'xls',
            allowBlank: false,
            store: Ext.create('Ext.data.Store', {
                fields: ['name'],
                data: [{'name': 'xls'}, {'name': 'xlt'}]
            })
        });
        this.fileGrid = Ext.create('Ext.grid.Panel', {
	        store: this.fileStore,
	        loadMask: true,
            border: false,
	        columns:[{
				width: 56,
				dataIndex: 'exname',
				menuDisabled: true,
				resizable: false,
				draggable: false,
				renderer: this.renderIcon
			},{
	            text: SLANG['file_name'],
	            dataIndex: 'name',
	            flex: 1,
	            sortable: true
	        }, {
				text: SLANG['update_date'],
				dataIndex: 'updateDate',
                style: 'border-right:none;',
				minWidth: 150,
	            maxWidth: 250,
				menuDisabled: true,
				resizable: false,
				draggable: false
			}],
	        dockedItems: [{
                dock: 'top',
                xtype: 'container',
                style: 'padding:0px 30px;background:white;',
                height: 36,
                layout: {
                    type: 'hbox',
                    align: 'bottom'
                },
                items: [this.fileNameField, this.saveBtn]
            }, {
                dock: 'top',
                xtype: 'container',
                style: 'padding:0px 105px 10px 30px;background:white;',
                height: 50,
                layout: {
                    type: 'hbox',
                    align: 'middle'
                },
                items: [this.exnameField]
            }],
	        // paging bar on the bottom
	        bbar: Ext.create('Ext.PagingToolbar', {
	            store: this.fileStore,
	            displayInfo: true,
	            displayMsg: 'Displaying items {0} - {1} of {2}',
	            emptyMsg: "No items to display"
	        })
	    });
        this.fileStore.load();
           
        this.items = [this.fileGrid];
           
        this.callParent(arguments);
           
        this.on({
            scope: this,
            'hide': this.onHideFn
        });
        
        this.fileGrid.on({
            scope: this,
            'itemclick': this.onRowSelectFn,
            'itemdblclick': this.onRowDblClickFn
        });
    },
    
    /**
	 * render the photo
	 */
	renderIcon : function(val, meta, rec, rowIndex, colIndex, store, view){
		var result = '<img src="' + SCONFIG.IMAGES_PATH + '/icons/open.png' + '"></img>';

		if (rec.data.exname == 'xls') {
			result = '<img src="' + SCONFIG.IMAGES_PATH + '/sheet_darkgreen.png' + '"></img>';
		} else if (rec.data.exname == 'xlt') {
			result = '<img src="' + SCONFIG.IMAGES_PATH + '/sheet_tpl.png' + '"></img>';
		} 
		return result;
	},       
           
    onHideFn : function(){
        if(this.hideCallback){
           this.hideCallback.call(this.scope, this);
        }
    },
           
    setTitle : function(title){
        this.titleBox.update(title);
    },
           
    /**
     * setup the config and show
     */
    popup : function(config){
        if(config){
            Ext.apply(this, config);
        }
        this.show();
    },
           
    /**
     * on save the file
     */
    onSaveFn : function() {
        var sels = this.fileGrid.getSelectionModel().getSelection();
        this.doSaving(0 < sels.length ? sels[0].data : undefined);
    },
           
    doSaving : function(data){
        if(this.fileNameField.isValid() && this.exnameField.isValid()){
            var sels = this.fileGrid.getSelectionModel().getSelection();
            var fileId, fileName = this.fileNameField.getValue(), exname = this.exnameField.getValue();
            if(data && data.name === fileName && exname === data.exname){
                fileId = sels[0].data.id;
            }
            this.hide();
            if(this.callback){
                this.callback.call(this.scope, fileName, exname, fileId);
            }
        }
    },
           
    onCancelFn : function(){
        this.hide();
    },
           
    /**
     * when select a node in dir tree
     */
    onRowSelectFn : function(list, rec, item, index, e){
        var selectedId = rec.data.id;
        var exname = rec.data.exname;
        
        if (exname == 'xls' || exname == 'xlt'){
            this.saveBtn.enable();
            this.fileNameField.setValue(rec.data.name);
        }else{
            this.saveBtn.disable();
        }
    },
    
    onRowDblClickFn : function(list, rec, item, index, e) {
        this.doSaving(rec.data);
    },
           
    // this is for search function ...
    onQueryKeyDown : function(field, e){
        var key = e.getKey();
        var keyObj = Ext.EventObject ? Ext.EventObject : Ext.event.Event;
        if(keyObj.ENTER === key){
           this.onSearchFn();
        }else if(keyObj.ESC === key){
           if('' !== this.queryField.getValue()){
                this.queryField.setValue('');
                this.onSearchFn();
           }
       }
    },
           
    /**
     * search files ...
     */
    onSearchFn : function(){
        var query = this.queryField.getValue();
        this.fileStore.load({
            params:{
                query: query
            }
        });
    }
}, function(){
    SSAVE = (function(){
        var win;
        return {
            popup : function(config){
                if(!win){
                    win = new EnterpriseSheet.pop.SaveFileWin({
                        width: 550,
                        height: 400
                    });
                }
                Ext.apply(win, config);
                win.popup();
             }
        }
    })();
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.pop.ImportFileWin', {
	
	extend : 'Ext.window.Window',
	
	requires: [
        'Ext.form.field.Text',
        'Ext.form.field.File',
        'Ext.form.Panel'
    ],

    bodyStyle : 'background-color:white;padding:10px;',
           
	width : 450,    	
	
	height: 220,
	
    plain: true,
           
    modal: true,
        
    resizable: false,
           
    shim : true,
           
	prepareButton : Ext.emptyFn,
        
	layout: 'fit',
	
	title: SLANG['importFile'],
	
	closeAction: 'hide',
	
	initComponent : function(){
		
		this.fileLabel = Ext.create('Ext.form.field.Display', { 
	        hideLabel:true,
	        labelSeparator:'',
	        value: SLANG['file_name'],
	        anchor:'95%'
	    });
		
		this.fileField = Ext.create('Ext.form.field.File', {
	        emptyText: SLANG['supportImportFormat'],
	        hideLabel:true,
	        labelSeparator:'',
	        name: 'filePath',
	        allowBlank: false,
	        style:'margin-bottom:50px;',
	        anchor: '95%'
	    });
	
	    this.tipLabel = Ext.create('Ext.form.field.Display', { 
	        hideLabel:true,
	        labelSeparator:'',
	        value: SLANG['uploadHint'],
	        anchor:'95%'
	    });
	    
	    // this is the label need to be hidden at initial time ...
	    this.okLabel = Ext.create('Ext.form.field.Display', { 
	    	hidden: true,
	        hideLabel:true,
	        labelSeparator:'',
	        style:'font-size:13px; margin-top: 10px;',
	        value: SLANG['importedSuccess'],
	        anchor:'95%'
	    });
	
	    this.importForm = Ext.create('Ext.form.Panel', {
	        fileUpload: true,
	        baseCls: 'x-plain',
	        labelWidth: 70,
	        url: SCONFIG.urls['importExcelUpload'],
	        items: [this.fileLabel, this.fileField, this.tipLabel, this.okLabel]
	    });
		
		this.items = [this.importForm];
		
		this.dockedItems = [{
			xtype: 'container',
			dock: 'right',
			width: 100,
			style: 'padding:0px 10px;',
			layout: {
				type: 'vbox',
				align: 'stretch'
			},
			items: [{
				xtype: 'button',
				text: SLANG['import'],
				handler: this.onOK,
				scope: this
			}, {
				xtype: 'button',
				text: SLANG['cancel'],
				style: 'margin-top:10px;',
				handler: this.onCancel,
				scope: this
			}]
		}];
				
		this.callParent();		
	},

	popup : function(){		
		this.show();
	},
	
	onCancel : function(){		
		this.hide();
	},
	
	onOK : function() {
		if (this.importForm.form.isValid()) {
            this.importForm.form.submit({
                waitMsg:'In processing',
                failure: function(form, action) {
                    Ext.MessageBox.alert('Error Message', action.result.info);
                },
                // everything ok...
                success: function(form, action) {
                    var jsonData = action.result;
                    if (jsonData.success) {
                        // ok now need open this file by id ...
                        var fileId = jsonData.fileId;
                        
                        this.tipLabel.hide();
                        this.okLabel.show();
                        
                        if (jsonData.status == "ok") {
                            this.hide();
                            if(this.callback){
                                this.callback.call(this.scope, fileId);
                            }
                        } else {
                        	/**
                        	this.okLabel.setValue(SLANG['importedError']);                                                             
                            Ext.fly(this.okLabel.el).on('click', function(e){
	                           var tg = e.target;
	                           if((tg.className).indexOf('x-import-open') > -1){
	                                this.onViewFile(fileId);
	                           }
	                           if((tg.className).indexOf('x-import-error') > -1){
	                                this.openErrorFile(fileId);
	                           }
	                        }, this);
	                        **/
                        }
                        
                    } else {
                        Ext.MessageBox.alert('Failed', jsonData.info);
                    }
                },
                scope: this
            });
        }
	},
	
	onKeyPress : function(field, e){
		var key = e.getKey();
		var keyObj = Ext.EventObject ? Ext.EventObject : Ext.event.Event;
		if(keyObj.ENTER == key){
			this.onOK();
		}
	}
    
}, function(){
    SIMPORT = (function(){
        var win;
        return {
            popup : function(config){
                if(!win){
                    win = new EnterpriseSheet.pop.ImportFileWin({});
                }
                Ext.apply(win, config);
                win.popup();
            }
        }
    })();
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.pop.CreateSheetFromTpl', {
	
	/* Begin Definitions */
	
	extend: 'Ext.window.Window',
	
	requires: [
	    'Ext.form.field.Text',
	    'Ext.layout.container.Form'
	],
		
    bodyStyle : 'background-color:white;',
           
    title: SLANG['create_sheet_from_tpl'],
           
    plain: true,
           
    modal: true,
           
    resizable: false,
           
    shim : true,
        
    closeAction: 'hide',
           
    layout: 'fit',
           
    buttonAlign: 'right',
	
	initComponent : function(){	
		
		// create the Data Store
	    this.fileStore = Ext.create('Ext.data.Store', {
	        pageSize: 50,
	        model: EnterpriseSheet.model.FileModel,
	        remoteSort: true,
	        proxy: {
	            type: 'ajax',
                url: SCONFIG.urls['listSheet'],
	            reader: {
	                root: 'results',
	                totalProperty: 'totalCount'
	            }
	        }
	    });
		
		this.queryField = Ext.create('Ext.form.field.Text', {
            width: 300,
            enableKeyEvents: true,
            listeners: {
                'keydown': {
                    fn: this.onQueryKeyDown,
                    scope: this
                }
            }
        });
		
		this.fileGrid = Ext.create('Ext.grid.Panel', {
	        store: this.fileStore,
	        loadMask: true,
            border: false,
	        columns:[{
				width: 56,
				dataIndex: 'exname',
				menuDisabled: true,
				resizable: false,
				draggable: false,
				renderer: this.renderIcon
			},{
	            text: SLANG['file_name'],
	            dataIndex: 'name',
	            flex: 1,
	            sortable: true
	        }, {
				text: SLANG['update_date'],
				dataIndex: 'updateDate',
                style: 'border-right:none;',
				minWidth: 150,
	            maxWidth: 250,
				menuDisabled: true,
				resizable: false,
				draggable: false
			}],
	        dockedItems: [{
                dock: 'top',
                xtype: 'toolbar',
                style: 'padding-left:10px;background:white;',
                height: 36,
                layout: {
                    type: 'hbox',
                    align: 'middle'
                },
                items: [this.queryField, {
                    style: 'margin-left:2px;',
                    text: SLANG['search'],
                    handler: this.onSearchFn,
                    scope: this
                }]
            }],
	        // paging bar on the bottom
	        bbar: Ext.create('Ext.PagingToolbar', {
	            store: this.fileStore,
	            displayInfo: true,
	            displayMsg: 'Displaying items {0} - {1} of {2}',
	            emptyMsg: "No items to display"
	        })
	    });
        this.fileStore.load();
		
		this.openBtn = Ext.create('Ext.button.Button', {
			disabled: true,
			text: SLANG['copy'],
			handler: this.onOpenTplFn,
			scope: this
		});
		
		this.items = [this.fileGrid];
           
        this.buttons = [this.openBtn];
           
		this.callParent(arguments);
		
		this.on({
			scope: this,
			'hide': this.onHideFn
		});
		
        this.fileGrid.on({
            scope: this,
            'itemclick': this.onRowSelectFn,
            'itemdblclick': this.onRowDblClickFn
        });
	},
	
	/**
	 * render the photo
	 */
	renderIcon : function(val, meta, rec, rowIndex, colIndex, store, view){
		var result = '<img src="' + SCONFIG.IMAGES_PATH + '/icons/open.png' + '"></img>';

		if (rec.data.exname == 'xls') {
			result = '<img src="' + SCONFIG.IMAGES_PATH + '/sheet_darkgreen.png' + '"></img>';
		} else if (rec.data.exname == 'xlt') {
			result = '<img src="' + SCONFIG.IMAGES_PATH + '/sheet_tpl.png' + '"></img>';
		} 
		return result;
	},     

	onHideFn : function(){
		if(this.hideCallback){
			this.hideCallback.call(this.scope, this);
		}
	},
	
	setTitle : function(title){
		this.titleBox.update(title);
	},
	
	/**
	 * setup the config and show
	 */
	popup : function(config){
		if(config){
			Ext.apply(this, config);
		}					
		this.show();
	},	
	
	/**
	 * on copy and create a file from template
	 */
	onOpenTplFn : function() {	
		var sels = this.fileGrid.getSelectionModel().getSelection();
		var loadingMask = new Ext.LoadMask({target:Ext.getBody(), msg: SLANG['waiting']});
        loadingMask.show();
		
		// get new template file ...
		Ext.Ajax.request({
			url: SCONFIG.urls['copyFromTpl'],
			params: {
				tplFileId: sels[0].data.id
			},
			success: function(response, options){
				var json = Ext.decode(response.responseText);
				if(true == json.success || "true" == json.success){
					loadingMask.hide();
                    this.hide();
                    if(this.callback){
                        this.callback.call(this.scope, json.fileId);
                    }
				}
			},
			failure: function(){	
				loadingMask.hide();
			},
			scope: this
		});
	},
	
	onCancelFn : function(){
		this.hide();
	},
	
	/**
     * when select a node in dir tree
     */
    onRowSelectFn : function(list, rec, item, index, e){
        var selectedId = rec.data.id;
        var exname = rec.data.exname;
        
        if (exname == 'xls' || exname == 'xlt')
            this.openBtn.enable();
        else 
            this.openBtn.disable();
    },
	
	onRowDblClickFn : function(list, rec, item, index, e) {
		var selectedId = rec.data.id;
        var exname = rec.data.exname;
        if (exname == 'xlt'){
			this.onOpenTplFn();
        }
	},
	
	// this is for search function ...
	onQueryKeyDown : function(field, e){
        var key = e.getKey();
        var keyObj = Ext.EventObject ? Ext.EventObject : Ext.event.Event;
        if(keyObj.ENTER === key){
            this.onSearchFn();
        }else if(keyObj.ESC === key){
            if('' !== this.queryField.getValue()){
                this.queryField.setValue('');
                this.onSearchFn();
            }
        }
    },
    
    /**
     * search files ...
     */
    onSearchFn : function(){
        var query = this.queryField.getValue();
        this.fileStore.load({
            params:{
                query: query
            }
        });
    }
    
}, function(){
    STOPEN = (function(){
        var win;
        return {
            popup : function(config){
                if(!win){
                    win = new EnterpriseSheet.pop.CreateSheetFromTpl({
                        width: 550,
                        height: 400
                    });
                }
                Ext.apply(win, config);
                win.popup();
            }
        }
    })();
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.pop.AboutWin', {
    extend: 'Ext.window.Window',
	
	requires: [
	    'Ext.layout.container.Form',
	    'EnterpriseSheet.common.CONST'
	],
		    
    iconCls : 'icon-sheet',
    title : 'Enterprise Spreadsheet Solution',
    bodyStyle: 'background:white;padding:20px;',
    closable : true,
    closeAction: 'hide',
    resizable : false,
    modal : true,
    layout:'anchor',
    border: true,
    layoutConfig: {
        animate:false,
        deferredRender:true
    },

    initComponent: function () {

        var myHtml = '<div style="float:left;width: 321px;padding:1px 45px 10px 2px;"><img src="resource/images/enterpriseLogo.png"/></div>'
                    + '<div style="float:left;width: 225px;padding-top:5px;">'
                    + '    <span style="font-size:16px;"><b>EnterpriseSheet</b></span><br/><span style="font-size:12px;">Enterprise Spreadsheet Solution</span><br/>'
                    + '    <font color="grey">' 
                    +         SCONST.version
                    + '    </font>'
                    + '    <br/><br/>'               
                    + '</div>'
                    + '<div style="clear:left;padding: 1px 2px 10px 0px; font-size:12px;">'
                    + '    EnterpriseSheet provides an enterprise solution to integrate and build your business spreadsheet. It is an online spreadsheet running on your server. EnterpriseSheet makes your data visualization easier, and pop with colorful charts and graphs. Its Excel-like functions, build-in formulas, table templates, validation and conditional formatting features save your time and simplify your spreadsheet tasks.<br/><br/>'
                    + '    To process integration, please visit <a href="http://www.enterpriseSheet.com" TARGET=_BLANK>www.enterpriseSheet.com</a>. Any issues, please '
                    + '    contact us <a href="mailto: info@enterpriseSheet.com">info@enterpriseSheet.com</a>.'
                    + '    <br><br>EnterpriseSheet and EnterpriseSheet logos are the trademarks of the Feyasoft Inc.<br/><br/>'
                    + '    Copyright &copy; 2016 Feyasoft Inc. All right reserved.'

	    '</div>';
	
        this.html = myHtml;
	    
	    this.buttons = [{
            text: SLANG['close'],
            handler: function() {
                this.hide();
            },
            scope: this
        }];

        this.callParent();
    },
    
    /**
	 * popup the window
	 */
	popup : function(){	
		this.show();	    
	}
},  function(){
    SABOUT = new EnterpriseSheet.pop.AboutWin({
        width: 600
    });
});
Ext.define('EnterpriseSheet.sheet.action.ActionBox', {

	/* Begin Definitions */

	requires : [ 
	    'EnterpriseSheet.common.action.Action', 
	    'EnterpriseSheet.sheet.pop.Popup',
		'EnterpriseSheet.sheet.action.ClipBoard',
        'EnterpriseSheet.pop.OpenFileWin',
        'EnterpriseSheet.pop.SaveFileWin',
        'EnterpriseSheet.pop.CreateSheetFromTpl',
        'EnterpriseSheet.pop.ImportFileWin',
        'EnterpriseSheet.pop.AboutWin'                
	],

	/* End Definitions */

	constructor : function(sheet) {

		this.callParent();
		
		// this is for language
		this.langenAction = new EnterpriseSheet.common.action.Action({
			handler : this.langEn,
			scope : this
		});
		this.langzhAction = new EnterpriseSheet.common.action.Action({
			handler : this.langZh,
			scope : this
		});

        /*
		 * new file action
		 */
		this.newSheetAction = new EnterpriseSheet.common.action.Action({
			iconCls : 'icon-sheet',
			handler : this.newSheet,
			scope : this
		});
		
		this.newSheetTplAction = new EnterpriseSheet.common.action.Action({
			iconCls : 'icon-sheet-tpl',
			handler : this.newSheetTpl,
			scope : this
		});
		
		this.newSheetFromTplAction = new EnterpriseSheet.common.action.Action({
			iconCls : 'icon-sheet',
			handler : this.newSheetFromTpl,
			scope : this
		});

		/*
		 * open file action
		 */
		this.openFileAction = new EnterpriseSheet.common.action.Action({
			iconCls : 'icon-open',
			handler : this.openFile,
			scope : this
		});
		
        this.importFileAction = new EnterpriseSheet.common.action.Action({
            handler : this.importFile,
            scope : this
        });
        
        this.exportFileAction = new EnterpriseSheet.common.action.Action({
            handler : this.exportXlsx,
            scope : this
        });

		/*
		 * save file action
		 */
		this.saveFileAction = new EnterpriseSheet.common.action.Action({
			iconCls : 'icon-save',
			handler : this.saveFile,
			scope : this
		});

		/*
		 * save as file action
		 */
		this.saveAsFileAction = new EnterpriseSheet.common.action.Action({
			handler : this.saveAsFile,
			scope : this
		});

		/*
         * share file action
         */
        this.shareFileAction = new EnterpriseSheet.common.action.Action({
            handler : this.shareFile,
            scope : this
        });
           
        /*
         * public file action
         */
        this.publicFileAction = new EnterpriseSheet.common.action.Action({
            handler : this.publicFile,
            scope : this
        });

		/*
		 * cut action
		 */
		this.cutAction = new EnterpriseSheet.common.action.Action({			
			handler : this.cut,
			scope : this
		});

		/*
		 * copy action
		 */
		this.copyAction = new EnterpriseSheet.common.action.Action({			
			handler : this.copy,
			scope : this
		});

		/*
		 * paste action
		 */
		this.pasteAction = new EnterpriseSheet.common.action.Action({			
			handler : this.paste,
			scope : this
		});

		/*
		 * switch freeze action
		 */
		this.doFreezeAction = new EnterpriseSheet.common.action.Action({
			handler : this.doFreeze,
			scope : this
		});

		/*
		 * freeze first row/col
		 */
		this.freezeFirstRowAction = new EnterpriseSheet.common.action.Action({
			handler : this.freezeFirstRow,
			scope : this
		});

		this.freezeFirstColAction = new EnterpriseSheet.common.action.Action({
			handler : this.freezeFirstColumn,
			scope : this
		});

		/*
		 * split action
		 */
		this.doSplitAction = new EnterpriseSheet.common.action.Action({
			handler : this.doSplit,
			scope : this
		});

		/*
		 * insert range action
		 */
		this.insertRangeAction = new EnterpriseSheet.common.action.Action({
			handler : this.insertRange,
			scope : this
		});
		
		/*
		 * insert copied
		 */
		this.insertCopiedAction = new EnterpriseSheet.common.action.Action({
			handler: this.insertCopied,
			scope: this
		});

		/*
		 * insert row action
		 */
		this.insertRowAction = new EnterpriseSheet.common.action.Action({
			handler : this.insertRow,
			scope : this
		});

		/*
		 * insert column action
		 */
		this.insertColumnAction = new EnterpriseSheet.common.action.Action({
			handler : this.insertColumn,
			scope : this
		});

		/*
		 * insert cell action
		 */
		this.insertCellAction = new EnterpriseSheet.common.action.Action({
			handler : this.insertCell,
			scope : this
		});

		/*
		 * insert sheet action
		 */
		this.insertSheetAction = new EnterpriseSheet.common.action.Action({
			handler : this.insertSheet,
			scope : this
		});

		/*
		 * delete range action
		 */
		this.deleteRangeAction = new EnterpriseSheet.common.action.Action({
			handler : this.deleteRange,
			scope : this
		});

		this.deleteCellAction = new EnterpriseSheet.common.action.Action({
			handler : this.deleteCell,
			scope : this
		});

		this.deleteRowAction = new EnterpriseSheet.common.action.Action({
			handler : this.deleteRow,
			scope : this
		});

		this.deleteColumnAction = new EnterpriseSheet.common.action.Action({
			handler : this.deleteColumn,
			scope : this
		});

		this.deleteSheetAction = new EnterpriseSheet.common.action.Action({
			handler : this.deleteSheet,
			scope : this
		});

		/*
		 * set row height/column width action
		 */
		this.rowHeightAction = new EnterpriseSheet.common.action.Action({
			handler : this.setRowHeight,
			scope : this
		});

		this.columnWidthAction = new EnterpriseSheet.common.action.Action({
			handler : this.setColumnWidth,
			scope : this
		});

		/*
		 * auto adjust row height or column width action
		 */
		this.adjustRowHeightAction = new EnterpriseSheet.common.action.Action({
			handler : this.autoAdjustRowHeight,
			scope : this
		});

		this.adjustColumnWidthAction = new EnterpriseSheet.common.action.Action({
			handler : this.autoAdjustColumnWidth,
			scope : this
		});

		/*
		 * hide/show row/column action
		 */
		this.hideRowAction = new EnterpriseSheet.common.action.Action({
			handler : this.hideRow,
			scope : this
		});

		this.hideColumnAction = new EnterpriseSheet.common.action.Action({
			handler : this.hideColumn,
			scope : this
		});

		this.showRowAction = new EnterpriseSheet.common.action.Action({
			handler : this.showRow,
			scope : this
		});

		this.showColumnAction = new EnterpriseSheet.common.action.Action({
			handler : this.showColumn,
			scope : this
		});

		/*
		 * filter action
		 */
		this.filterAction = new EnterpriseSheet.common.action.Action({
			handler : this.filter,
			scope : this
		});

		/*
		 * sort action
		 */
		this.sortAscAction = new EnterpriseSheet.common.action.Action({
			handler : this.sortAsc,
			scope : this
		});

		this.sortDescAction = new EnterpriseSheet.common.action.Action({
			handler : this.sortDesc,
			scope : this
		});

		this.customSortAction = new EnterpriseSheet.common.action.Action({
			handler : this.customSort,
			scope : this
		});

		/*
		 * align action
		 */
		this.alignLeftAction = new EnterpriseSheet.common.action.Action({
			iconCls : 'icon-align-left',
			handler : this.alignLeft,
			scope : this
		});

		this.alignCenterAction = new EnterpriseSheet.common.action.Action({
			iconCls : 'icon-align-center',
			handler : this.alignCenter,
			scope : this
		});

		this.alignRightAction = new EnterpriseSheet.common.action.Action({
			iconCls : 'icon-align-right',
			handler : this.alignRight,
			scope : this
		});

		this.alignTopAction = new EnterpriseSheet.common.action.Action({
			iconCls : 'icon-align-top',
			handler : this.alignTop,
			scope : this
		});

		this.alignMiddleAction = new EnterpriseSheet.common.action.Action({
			iconCls : 'icon-align-middle',
			handler : this.alignMiddle,
			scope : this
		});

		this.alignBottomAction = new EnterpriseSheet.common.action.Action({
			iconCls : 'icon-align-bottom',
			handler : this.alignBottom,
			scope : this
		});

		/*
		 * indent action
		 */
		this.indentAction = new EnterpriseSheet.common.action.Action({
			iconCls : 'icon-indent',
			handler : this.incIndent,
			scope : this
		});

		this.removeIndentAction = new EnterpriseSheet.common.action.Action({
			iconCls : 'icon-remove-indent',
			handler : this.removeIndent,
			scope : this
		});

		/*
		 * word wrap action
		 */
		this.wordWrapAction = new EnterpriseSheet.common.action.Action({
			iconCls : 'icon-wordwrap',
			handler : this.doWordWrap,
			scope : this
		});

		/*
		 * merge actions
		 */
		this.mergeCenterAction = new EnterpriseSheet.common.action.Action({
			iconCls : 'icon-merge',
			handler : this.mergeCellandAlignCenter,
			scope : this
		});

		this.mergeCellAction = new EnterpriseSheet.common.action.Action({
			iconCls : 'icon-merge-cell',
			handler : this.mergeCell,
			scope : this
		});

		this.mergeRowAction = new EnterpriseSheet.common.action.Action({
			iconCls : 'icon-merge-row',
			handler : this.mergeCellInRow,
			scope : this
		});

		this.mergeColumnAction = new EnterpriseSheet.common.action.Action({
			iconCls : 'icon-merge-col',
			handler : this.mergeCellInColumn,
			scope : this
		});

		this.cancelMergeAction = new EnterpriseSheet.common.action.Action({
			iconCls : 'icon-cancel-merge',
			handler : this.cancelMergeCell,
			scope : this
		});

		/*
		 * inc and desc font size
		 */
		this.incFontSizeAction = new EnterpriseSheet.common.action.Action({
			iconCls : 'icon-sizeinc',
			handler : this.incFontSize,
			scope : this
		});

		this.descFontSizeAction = new EnterpriseSheet.common.action.Action({
			iconCls : 'icon-sizedes',
			handler : this.desFontSize,
			scope : this
		});

		/*
		 * bold/italic/underline etc
		 */
		this.boldAction = new EnterpriseSheet.common.action.Action({
			iconCls : 'icon-bold',
			handler : this.bold,
			scope : this
		});

		this.italicAction = new EnterpriseSheet.common.action.Action({
			iconCls : 'icon-italic',
			handler : this.italic,
			scope : this
		});

		this.underlineAction = new EnterpriseSheet.common.action.Action({
			iconCls : 'icon-underline',
			handler : this.underline,
			scope : this
		});

		this.overlineAction = new EnterpriseSheet.common.action.Action({
			iconCls : 'icon-overline',
			handler : this.overline,
			scope : this
		});

		this.strikeAction = new EnterpriseSheet.common.action.Action({
			iconCls : 'icon-strike',
			handler : this.strike,
			scope : this
		});

		/*
		 * for text format actions
		 */
		this.percentFormatAction = new EnterpriseSheet.common.action.Action({
			iconCls : 'icon-percent',
			handler : this.percentFormat,
			scope : this
		});

		this.commaFormatAction = new EnterpriseSheet.common.action.Action({
			iconCls : 'icon-comma',
			handler : this.commaFormat,
			scope : this
		});

		/*
		 * inc/desc the position of dot
		 */
		this.leftDotAction = new EnterpriseSheet.common.action.Action({
			iconCls : 'icon-dot-moveleft',
			handler : this.moveDot2Left,
			scope : this
		});

		this.rightDotAction = new EnterpriseSheet.common.action.Action({
			iconCls : 'icon-dot-moveright',
			handler : this.moveDot2Right,
			scope : this
		});

		/*
		 * for clean content and format function
		 */
		this.cleanAction = new EnterpriseSheet.common.action.Action({
			handler : this.clean,
			scope : this
		});

		this.cleanContentAction = new EnterpriseSheet.common.action.Action({
			handler : this.cleanContent,
			scope : this
		});

		this.cleanStyleAction = new EnterpriseSheet.common.action.Action({
			handler : this.cleanStyle,
			scope : this
		});

		/*
		 * for formulas
		 */
		this.sumAction = new EnterpriseSheet.common.action.Action({
			iconCls : 'icon-sum',
			handler : this.sum,
			scope : this
		});

		this.averageAction = new EnterpriseSheet.common.action.Action({
			handler : this.average,
			scope : this
		});

		this.countAction = new EnterpriseSheet.common.action.Action({
			handler : this.count,
			scope : this
		});

		this.maxValueAction = new EnterpriseSheet.common.action.Action({
			handler : this.maxValue,
			scope : this
		});

		this.minValueAction = new EnterpriseSheet.common.action.Action({
			handler : this.minValue,
			scope : this
		});
		
		this.insertFormulaAction = new EnterpriseSheet.common.action.Action({			
			handler : this.insertFormula,
			scope : this
		});

		/*
		 * autofill actions
		 */
		this.autofillDownAction = new EnterpriseSheet.common.action.Action({
			handler : this.autofillDown,
			scope : this
		});

		this.autofillUpAction = new EnterpriseSheet.common.action.Action({
			handler : this.autofillUp,
			scope : this
		});

		this.autofillLeftAction = new EnterpriseSheet.common.action.Action({
			handler : this.autofillLeft,
			scope : this
		});

		this.autofillRightAction = new EnterpriseSheet.common.action.Action({
			handler : this.autofillRight,
			scope : this
		});

		/*
		 * insert picture
		 */
		this.insertPictureByURLAction = new EnterpriseSheet.common.action.Action({
			handler : this.insertPictureByURL,
			scope : this
		});

		/*
		 * insert charts
		 */
		this.insertColumnChartAction = new EnterpriseSheet.common.action.Action({
			handler : this.insertColumnChart,
			scope : this
		});
		
		this.insertPieChartAction = new EnterpriseSheet.common.action.Action({
			handler : this.insertPieChart,
			scope : this
		});
		
		this.insertAreaChartAction = new EnterpriseSheet.common.action.Action({
			handler : this.insertAreaChart,
			scope : this
		});
		
		this.insertLineChartAction = new EnterpriseSheet.common.action.Action({
			handler : this.insertLineChart,
			scope : this
		});
		
		this.insertBarChartAction = new EnterpriseSheet.common.action.Action({
			handler : this.insertBarChart,
			scope : this
		});
		
		this.insertScatterChartAction = new EnterpriseSheet.common.action.Action({
			handler : this.insertScatterChart,
			scope : this
		});
		
		this.insertRadarChartAction = new EnterpriseSheet.common.action.Action({
			handler : this.insertRadarChart,
			scope : this
		});
		
		this.insertColumnMiniChartAction = new EnterpriseSheet.common.action.Action({
			handler : this.insertColumnMiniChart,
			scope : this
		});
		
        this.insertLineMiniChartAction = new EnterpriseSheet.common.action.Action({
            handler : this.insertLineMiniChart,
            scope : this
        });
        
		this.insertGainLossMiniChartAction = new EnterpriseSheet.common.action.Action({
			handler : this.insertGainLossMiniChart,
			scope : this
		});
		
		/*
		 * insert shapes
		 */
		this.insertCircleShapeAction = new EnterpriseSheet.common.action.Action({
			handler : this.insertCircleShape,
			scope : this
		});
		
		/*
		 * insert link
		 */
		this.insertHyperlinkAction = new EnterpriseSheet.common.action.Action({
			handler : this.insertHyperlink,
			scope : this
		});
		
		/*
		 * insert comment
		 */
		this.insertCommentAction = new EnterpriseSheet.common.action.Action({
			handler : this.insertComment,
			scope : this
		});
		
		this.insertVariableAction = new EnterpriseSheet.common.action.Action({
			handler : this.insertVariable,
			scope : this
		});
		
		/*
		 * delete comment
		 */
		this.deleteCommentAction = new EnterpriseSheet.common.action.Action({
			handler : this.deleteComment,
			scope : this
		});
		
		/*
		 * add group
		 */
		this.addGroupAction = new EnterpriseSheet.common.action.Action({
			handler : this.addGroup,
			scope : this
		});
		
		/*
		 * cancel group
		 */
		this.cancelGroupAction = new EnterpriseSheet.common.action.Action({
			handler : this.cancelGroup,
			scope : this
		});
		
		/*
		 * insert checkbox
		 */
		this.insertCheckboxAction = new EnterpriseSheet.common.action.Action({
			handler : this.insertCheckbox,
			scope : this
		});
		
		this.insertRadioAction = new EnterpriseSheet.common.action.Action({
			handler : this.insertRadio,
			scope : this
		});
		
		this.clearItemAction = new EnterpriseSheet.common.action.Action({
			handler: this.clearItem,
			scope: this
		});
		
		this.insertSequenceNoAction = new EnterpriseSheet.common.action.Action({
			handler : this.insertSequenceNo,
			scope : this
		});
		
		this.insertDropListAction = new EnterpriseSheet.common.action.Action({
			handler : this.insertDropList,
			scope : this
		});
		
		/*
		 * marke a range with a name
		 */
		this.markRangeAction = new EnterpriseSheet.common.action.Action({
			handler: this.markRange,
			scope: this
		});
		
		/*
		 * show validation option window
		 */
		this.validationAction = new EnterpriseSheet.common.action.Action({
			handler: this.showValidation,
			scope: this
		});
		
		/*
		 * enable/disable the selection 
		 */
		this.editableAction = new EnterpriseSheet.common.action.Action({
			handler: this.toggleEditable,
			scope: this
		});
		
		this.lockOtherEditAction = new EnterpriseSheet.common.action.Action({
			handler: this.toggleEditableForOther,
			scope: this
		});
				
		
		this.toggleGridLineAction = new EnterpriseSheet.common.action.Action({
			handler : this.toggleGridLine,
			scope : this
		});
		
		this.toggleRowNameAction = new EnterpriseSheet.common.action.Action({
			handler : this.toggleRowName,
			scope : this
		});
		
		this.toggleColNameAction = new EnterpriseSheet.common.action.Action({
			handler : this.toggleColName,
			scope : this
		});
		
        this.toggleTitleRegionAction = new EnterpriseSheet.common.action.Action({
            handler : this.toggleTitleRegion,
            scope : this
        });
		
		this.keyboardShortcutsAction = new EnterpriseSheet.common.action.Action({
			tooltip: SLANG['keyboard_shortcuts'],
			handler : this.keyboardShortcuts,
			scope : this
		});
		
        this.deleteRepeatAction = new EnterpriseSheet.common.action.Action({
            tooltip: SLANG['delete_repeat_item'],
            handler : this.deleteRepeatItem,
            scope : this
        });
		
        this.pivotTableAction = new EnterpriseSheet.common.action.Action({
            tooltip: SLANG['pivot_table'],
            handler : this.createPivotTable,
            scope : this
        });
           
        this.setHeaderTitleAction = new EnterpriseSheet.common.action.Action({
            tooltip: SLANG['set_header_title'],
            handler : this.setHeaderTitle,
            scope : this
        });
		
        this.insertDatePickerAction = new EnterpriseSheet.common.action.Action({
            tooltip: SLANG['insert_date_picker'],
            handler : this.insertDatePicker,
            scope : this
        });
		
		this.aboutSheetAction = new EnterpriseSheet.common.action.Action({
			tooltip: SLANG['aboutSheet'],
			handler : this.aboutSheetWin,
			scope : this
		});
		
	},
	
	/**
	 * add hot key here - see 
	 *     http://www.cambiaresearch.com/articles/15/javascript-char-codes-key-codes
	 *     https://support.office.microsoft.com/en-ca/article/Excel-shortcut-and-function-keys-1798d9d5-842a-42b8-9c99-9b7213f0040f?CorrelationId=72fc6362-0890-4416-b878-0e56b5a83429&ui=en-US&rs=en-CA&ad=CA
	 */
	addHotKey : function(sheet){
        var scope = {
            getSheet: function(){
                return sheet;
            },
            me: this
        };
        
        //ctrl + shift + (
		PHKey.bindHotKey(57, true, false, true, this.showRow, scope);
		//ctrl + shift + ) --- TODO have problem to understand this ), do not know why this does not catch ...
		PHKey.bindHotKey(48, true, false, true, this.showColumn, scope);
		//ctrl+9
		PHKey.bindHotKey(57, true, false, false, this.hideRow, scope);
		//ctrl+0
		PHKey.bindHotKey(48, true, false, false, this.hideColumn, scope);
        
		//ctrl+b
        PHKey.bindHotKey(66, true, false, false, this.bold, scope);
        //ctrl+2 - bold too
        PHKey.bindHotKey(50, true, false, false, this.bold, scope);
		//ctrl+i
		PHKey.bindHotKey(73, true, false, false, this.italic, scope);
		//ctrl+3
		PHKey.bindHotKey(51, true, false, false, this.italic, scope);
		
		//ctrl+D
        PHKey.bindHotKey(68, true, false, false, this.autofillDown, scope);
        //ctrl+R
        PHKey.bindHotKey(82, true, false, false, this.autofillRight, scope);
		//ctrl+k
		PHKey.bindHotKey(75, true, false, false, this.insertHyperlink, scope);
		
		// shift+F11 same as google. Ctrl+N is not working (MS) - browser default action
		PHKey.bindHotKey(122, false, false, true, this.addNewWorkbook, scope);
				
		//ctrl+T -- Displays the Create Table dialog box. TODO - not working yet
		PHKey.bindHotKey(84, true, false, false, this.applyTable, scope);
		
		//ctrl+HOME -- Moves to the beginning of a row in a worksheet.
		PHKey.bindHotKey(36, true, false, false, this.move2TopLeft, scope);
		// HOME - move to left most cell in same row
		PHKey.bindHotKey(36, false, false, false, this.move2LeftMost, scope);
		// Page down - 34. Moves one screen down in a worksheet.
		PHKey.bindHotKey(34, false, false, false, this.movePageDown, scope);
		PHKey.bindHotKey(33, false, false, false, this.movePageUp, scope);
		// ctrl+end
		PHKey.bindHotKey(35, true, false, false, this.move2BottomRight, scope);
		
		// ctrl+shift+home - extends the selection of cells to the beginning of the worksheet.
		// TODO ... not working ... do not know why...
		PHKey.bindHotKey(103, true, false, true, this.select2TopLeft, scope);
		// ctrl+shift+up -- to top ... 
		PHKey.bindHotKey(38, true, false, true, this.select2Top, scope);
		// ctrl+shift+left -- to left ... 
		PHKey.bindHotKey(37, true, false, true, this.select2Left, scope);
		
		// ctrl+alt+M - add comments
		PHKey.bindHotKey(77, true, true, false, this.insertComment, scope);
		// ALT + F1 - creates a chart of the data in the current range.
		PHKey.bindHotKey(112, false, true, false, this.insertColumnChart, scope);
		// SHIFT + F2 - add comments
		PHKey.bindHotKey(113, false, false, true, this.insertComment, scope);
		// SHIFT + F3 - displays the Insert Function dialog box.
		PHKey.bindHotKey(114, false, false, true, this.insertFormula, scope);

        if(!SCONFIG['file_menu_hide']){
            //ctrl+O - open existing file
            PHKey.bindHotKey(79, true, false, false, this.openFile, scope, true);
            //ctrl+S - save file
            PHKey.bindHotKey(83, true, false, false, this.saveFile, scope, true);
        }
		//ctrl+u
		PHKey.bindHotKey(85, true, false, false, this.underline, scope);
		//ctrl+4 - underline ...
		PHKey.bindHotKey(52, true, false, false, this.underline, scope);
		
		// ctrl+/ - keyboard shortcuts
		PHKey.bindHotKey(191, true, false, false, this.keyboardShortcuts, scope, true);
		// ctrl+; -- Enters the current date.  semi-colon
		PHKey.bindHotKey(186, true, false, false, this.addCurrentDate, scope);
		// ctrl+shift+: - Enters the current time. semi-colon
		PHKey.bindHotKey(186, true, false, true, this.addCurrentTime, scope);		
		// alt+shift+5 - strikeAction OR ctrl+5
		PHKey.bindHotKey(53, false, true, true, this.strike, scope, true);
		PHKey.bindHotKey(53, true, false, false, this.strike, scope);		
	    // ctrl+shift+E - align center
		PHKey.bindHotKey(69, true, false, true, this.alignCenter, scope);
		// ctrl+shift+L - align left
		PHKey.bindHotKey(76, true, false, true, this.alignLeft, scope);
		// ctrl+shift+R - align right
		PHKey.bindHotKey(82, true, false, true, this.alignRight, scope);
		// ctrl+shift+@ - Applies the Time format with the hour and minute, and AM or PM.
		PHKey.bindHotKey(50, true, false, true, this.applyTimeFormat, scope);
		// ctrl+shift+$ - Applies the Currency format with two decimal places (negative numbers in parentheses).
		PHKey.bindHotKey(52, true, false, true, this.applyCurrencyFormat, scope);
		// ctrl+shift+% - Applies the Percentage format with no decimal places.
		PHKey.bindHotKey(53, true, false, true, this.applyPercentFormat, scope);
		// ctrl+shift+! - Applies the Number format with two decimal places, thousands separator, and minus sign (-) for negative values.
		PHKey.bindHotKey(49, true, false, true, this.commaFormat, scope);
		// ctrl+shift+^ - Applies the Exponential number format with two decimal places.
		PHKey.bindHotKey(54, true, false, true, this.scienceFormat, scope);
		// ctrl+shift+& - Applies the outline border to the selected cells.
		PHKey.bindHotKey(55, true, false, true, this.applyBorderFormat, scope);
		// ctrl+shift+MINUS - Remove the outline border to the selected cells.
		PHKey.bindHotKey(189, true, false, true, this.removeBorderFormat, scope);
		// ctrl+shift+PLUS - Displays the Insert dialog box
		PHKey.bindHotKey(187, true, false, true, this.insertRange, scope);
		// ctrl+MINUS - Displays the Insert dialog box
		PHKey.bindHotKey(189, true, false, false, this.deleteRange, scope);
	},

	/*
	 * detect delete
	 */
	onKeyDown : function(e) {
		var key = e.getKey();
		
		if (46 == key || 8 == key) {
			this.cleanContent();
			return false;
		}
	},

	/***************************************************************************
	 * handlers of actions
	 **************************************************************************/
	
	// for language 
	langEn : function(scope) {
	    Ext.Ajax.request({
			url: SCONFIG.urls['updateLang'],
			params: {
				lang: 'en'
			},
			success: function(response, options){
				var json = Ext.decode(response.responseText);
				if(true == json.success || "true" == json.success){                
                    window.location.reload();
				}
			},
			scope: this
		});	
	},
	
	langZh : function(scope) {
	    Ext.Ajax.request({
			url: SCONFIG.urls['updateLang'],
			params: {
				lang: 'zh_CN'
			},
			success: function(response, options){
				var json = Ext.decode(response.responseText);
				if(true == json.success || "true" == json.success){                
                    window.location.reload();
				}
			},
			scope: this
		});
	},
	
	/*
	 * for file menu functions
	 */
	newSheet : function() {
		window.location = window.location.pathname;	
	},
	
	newSheetTpl : function() {
        var sheet = this.getSheet(), me = this.me;
		// get new template file ...
		Ext.Ajax.request({
			url: SCONFIG.urls['createFile'],
			params: {
				exname: "xlt",
				initName: SLANG['sheetNewTpl']
			},
			success: function(response, options){
				var json = Ext.decode(response.responseText);
				if(true == json.success || "true" == json.success){
                    var fileId = json.fileId;
                    if(me.openFileByOnlyLoadDataFlag){
                        sheet.getStore().loadFile({
                            fileId: fileId
                        });
                    }else{
                        window.location = window.location.pathname + "?editFileId=" + fileId;
                    }
				}
			},
			failure: function(){
                         
			},
			scope: this
		});
	},
	
	// open existing file ...
	openFile : function() {
        var sheet = this.getSheet(), me = this.me;
        if(SOPEN){
            SOPEN.popup({
                callback: function(fileId){
                    if(me.openFileByOnlyLoadDataFlag){
                        sheet.getStore().loadFile({
                            fileId: fileId
                        });
                    }else{
                        window.location = window.location.pathname + "?editFileId=" + fileId;
                    }
                },
                scope: this
            });
        }
	},
	
	// save file now - only for totally new file
	saveFile : function() {
        var sheet = this.getSheet(), me = this.me;
        SSAVE.popup({
            callback: function(fileName, exname, fileId){
                sheet.saveJsonFile({
                    id: fileId,
                    name: fileName,
                    exname: exname
                }, function(newFileId){
                    if(me.openFileByOnlyLoadDataFlag){
                        sheet.getStore().loadFile({
                            fileId: newFileId
                        });
                        Ext.Msg.alert(SLANG['hint'], SLANG['all_changes_are_saved']);
                    }else{
                        window.location = window.location.pathname + "?editFileId=" + newFileId;
                    }
                }, this);
            },
            scope: this
        });
	},
           
    /**
     * share the file
     */
    shareFile : function(){
        var sheet = this.getSheet(), store = sheet.getStore(), file = store.getLoadedFile();
        /*
         * just fire event here, let the documentController to do the real job
         */
        sheet.fireEvent('sharefile', store, file, sheet, this.me);
    },
    
    /**
     * public the file
     */
    publicFile : function(){
        var sheet = this.getSheet(), me = this.me, store = sheet.getStore(), file = store.getLoadedFile();
        /*
         * just fire event here, let the documentController to do the real job
         */
        sheet.fireEvent('publicfile', store, file, sheet, this.sender);
    },
    
    importFile : function() {
        var sheet = this.getSheet(), me = this.me;
        if(SIMPORT){
            SIMPORT.popup({
                callback: function(fileId){
                    if(me.openFileByOnlyLoadDataFlag){
                        sheet.getStore().loadFile({
                            fileId: fileId
                        });
                    }else{
                        window.location = window.location.pathname + "?editFileId=" + fileId;
                    }
                },
                scope: this
            });
        }
    },
    
    exportXlsx : function() {
    	var sheet = this.getSheet(), me = this.me;
    	
    	// first we need check whether id is there. If not, give warning ..
    	if (sheet.getStore().fileId) {   	
	    	// add loading ...
	    	var loadingMask = new Ext.LoadMask({target:Ext.getBody(), msg: SLANG['waiting']});
	        loadingMask.show();
	    	document.location = SCONFIG.urls['exportExcel']+'?documentId='+sheet.getStore().fileId;
	    	// ok, TODO. At this moment, just make it last 3 seconds ...
	    	setTimeout(function(){loadingMask.hide();},3000);
    	} else {
    	    Ext.Msg.alert(SLANG['hint'], SLANG['saveBeforeExport']);
    	}
    },
	
	// create a new sheet from the existing template file 
	newSheetFromTpl : function() {
        var sheet = this.getSheet(), me = this.me;
        if(STOPEN){
            STOPEN.popup({
                callback: function(fileId){
                    if(me.openFileByOnlyLoadDataFlag){
                        sheet.getStore().loadFile({
                            fileId: fileId
                        });
                    }else{
                         window.location = window.location.pathname + "?editFileId=" + fileId;
                    }
                    
                },
                scope: this
            });
        }
	},

	/*
	 * for clipboard functions
	 */
	cut : function() {
        var sheet = this.getSheet(), me = this.me;
        var clipboard = sheet.getClipboard();
		if (clipboard) {
			clipboard.cut();
		}
	},

	copy : function() {
        var sheet = this.getSheet(), me = this.me;
        var clipboard = sheet.getClipboard();
		if (clipboard) {
			clipboard.copy();
		}
	},

	paste : function() {
        var sheet = this.getSheet(), me = this.me;
        var clipboard = sheet.getClipboard();
		if (clipboard) {
			clipboard.paste();
		}
	},

	/*
	 * functions for freeze
	 */
	doFreeze : function() {
        var ss = this.getSheet(), me = this.me;

		var freezeAction = me.doFreezeAction, splitAction = me.doSplitAction;
		if (!ss.isFreezed()) {
			if (me.freeze(ss)) {
				if (freezeAction) {
					freezeAction.setText(SLANG['cancel_freeze']);
				}				
			}
		} else {
			ss.unfreeze();
			if (freezeAction) {
				freezeAction.setText(SLANG['freeze_sheet']);
			}
		}
		if(splitAction){
			splitAction.setText(SLANG['split_sheet']);
		}
	},

	/*
	 * for freeze/split functions
	 */
	freeze : function(ss) {
        var me = this;
		if (ss.isSplited()) {
			/*
			 * if the sheet is splited, then get the rowEnd/colEnd of
			 * ulefter/lheader as the freeze point
			 */
			var row = 1, col = 1;
			if (ss.ulefter.isVisible()) {
				row = ss.ulefter.rowEnd + 1;
			}
			if (ss.lheader.isVisible()) {
				col = ss.lheader.colEnd + 1;
			}
			ss.freeze(row, col);
			/*
			 * update the pressed if need
			 */
			var splitAction = me.doSplitAction;
			if (splitAction) {
				splitAction.toggle(false, true);
			}
		} else {
			/*
			 * get the selection left-top point as the freeze point
			 */
			var sm = ss.getSelectionModel();
			var pos = sm.getMinMaxPos();
			ss.freeze(pos.minrow, pos.mincol);
		}
		return ss.freezePos;
	},

	/*
	 * freeze first row/col
	 */
	freezeFirstRow : function() {
        var ss = this.getSheet(), me = this.me;
		ss.freeze(ss.getRowStart() + 1, ss.getColStart());
		var freezeAction = me.doFreezeAction;
		if (freezeAction) {
			freezeAction.setText(SLANG['cancel_freeze']);
		}
		/*
		 * update the pressed if need
		 */
		var splitAction = me.doSplitAction;
		if (splitAction) {
			splitAction.toggle(false, true);
		}
	},

	freezeFirstColumn : function() {
        var ss = this.getSheet(), me = this.me;
		ss.freeze(ss.getRowStart(), ss.getColStart() + 1);
		/*
		 * update the pressed if need
		 */
		var splitAction = me.doSplitAction;
		if (splitAction) {
			splitAction.toggle(false, true);
		}
	},

	/*
	 * switch split function
	 */
	doSplit : function() {
        var ss = this.getSheet(), me = this.me;

		if (!ss.isSplited()) {
			if (ss.isFreezed()) {
				/*
				 * if the sheet is freezed, then get the height/width of
				 * ulefter/lheader as the split point
				 */
				var w = 0, h = 0;
				if (ss.ulefter.isVisible()) {
					h = ss.ulefter.getHeight();
				}
				if (ss.lheader.isVisible()) {
					w = ss.lheader.getWidth();
				}
				ss.split(w, h);				
			} else {
				/*
				 * get the left-top point as the split point
				 */
				var sm = ss.getSelectionModel();
				var pos = sm.getMinMaxPos();
				var row = pos.minrow, col = pos.mincol;
				var rowStart = ss.getRowStart(), colStart = ss.getColStart();
				/*
				 * if row equal rowStart then at least split one row height
				 */
				if (row > rowStart) {
					row--;
				}
				/*
				 * if col equal colStart then at least split one column width
				 */
				if (col > colStart) {
					col--;
				}
				var size = ss.getCellPosition(row, col);
				ss.split(size[0], size[1]);
			}
			/*
			 * update the pressed if need
			 */
			var splitAction = me.doSplitAction;
			if (splitAction) {
				splitAction.toggle(true, true);
				splitAction.setText(SLANG['cancel_split']);
			}
		} else {
			ss.unsplit();
			/*
			 * update the pressed if need
			 */
			var splitAction = me.doSplitAction;
			if (splitAction) {
				splitAction.toggle(false, true);
				splitAction.setText(SLANG['split_sheet']);
			}
		}
		
		/*
		 * update the freeze item text if need
		 */
		var freezeAction = me.doFreezeAction;
		if (freezeAction) {
			freezeAction.setText(SLANG['freeze_sheet']);
		}
	},

	/*
	 * insert range
	 */
	insertRange : function() {
		this.getSheet().insertRange();
	},
	
	insertSequenceNo : function(){
		this.getSheet().insertSequenceNo();
	},
	
	insertDropList : function(){
        var ss = this.getSheet(), me = this.me;
        SPOP.showDropListConfig({
            title: SLANG['setup_droplist'],
            fileId: ss.getStore().fileId,
            sheet: ss,
            applyCallback : {
                fn : function(json) {
                    ss.insertDropList(json);
                },
                scope : this
            }
        });
	},

	/*
	 * for insert cell/row/column/sheet functions
	 */
	insertCell : function() {
		this.getSheet().insertCell();
	},

	insertRow : function() {
		this.getSheet().insertRow();
	},

	insertColumn : function() {
		this.getSheet().insertColumn();
	},


	/*
	 * delete cell/row/column/sheet functions
	 */
	/*
	 * delete selected cells and the right-side cells move left
	 */
	deleteRange : function() {
		this.getSheet().deleteRange();
	},

	deleteCell : function() {
		this.getSheet().deleteCell();
	},

	deleteRow : function() {
		this.getSheet().deleteRow();
	},

	deleteColumn : function() {
		this.getSheet().deleteColumn();
	},


	/*
	 * for set row height and set column width
	 */

	setRowHeight : function() {
		SPOP.showRowHeightBox({
			applyCallback : {
				fn : function(h) {
					this.getSheet().setRowHeight(h);
				},
				scope : this
			}
		});
	},

	setColumnWidth : function() {
		SPOP.showColumnWidthBox({
			applyCallback : {
				fn : function(w) {
					this.getSheet().setColumnWidth(w);
				},
				scope : this
			}
		});
	},


	/*
	 * for hide/show row/column functions
	 */
	hideRow : function() {
		this.getSheet().hideRow();
	},

	hideColumn : function() {
		this.getSheet().hideColumn();
	},

	showRow : function() {
		this.getSheet().showRow();
	},

	showColumn : function() {
		this.getSheet().showColumn();
	},

	/*
	 * filter and sort asc/desc
	 */
	filter : function() {
        var sheet = this.getSheet();
		var filter = sheet.getFilter();
		if (filter) {
			filter.createFilterForSelecton();
		}
		sheet.focus();
	},

	sortAsc : function() {
		this.getSheet().sortSelection(null, 'asc');
	},

	sortDesc : function() {
		this.getSheet().sortSelection(null, 'desc');
	},

    /*
	 * for align functions
	 */
	alignLeft : function() {
		this.getSheet().setPropertyForSelection({
			'ta' : 'left'
		});
	},

	alignCenter : function() {
		this.getSheet().setPropertyForSelection({
			'ta' : 'center'
		});
	},

	alignRight : function() {
		this.getSheet().setPropertyForSelection({
			'ta' : 'right'
		});
	},

	alignTop : function() {
		this.getSheet().setPropertyForSelection({
			'va' : 'top'
		});
	},

	alignMiddle : function() {
		this.getSheet().setPropertyForSelection({
			'va' : 'middle'
		});
	},

	alignBottom : function() {
		this.getSheet().setPropertyForSelection({
			'va' : 'bottom'
		});
	},

	/*
	 * for increase/remove indent function
	 */
	incIndent : function() {
		var ss = this.getSheet();
		var ti = ss.getFocusCellData().ti || 0;
		ti += 5;
		ss.setPropertyForSelection({
			'ti' : ti
		});
	},

	removeIndent : function() {
		var ss = this.getSheet();
		var ti = ss.getFocusCellData().ti || 0;
		ti -= 5;
		if (0 > ti) {
			ti = 0;
		}
		ss.setPropertyForSelection({
			'ti' : ti
		});
	},

	/*
	 * for word wrap function
	 */
	doWordWrap : function(item) {
		var ss = this.getSheet();
		var data = ss.getFocusCellData();
		var ws = 'nowrap', ww = 'normal';
		if (!data.ws || data.ws == ws) {
			ws = 'normal';
			ww = 'break-word';
		}
		ss.setPropertyForSelection({
			ws : ws,
			ww : ww
		});
	},

	/*
	 * for merge functions
	 */

	mergeCellandAlignCenter : function() {
		this.getSheet().mergeCellandAlignCenter();
	},

	mergeCell : function() {
		this.getSheet().mergeSelectedCell();
	},

	mergeCellInColumn : function() {
		this.getSheet().mergeCellInColumn();
	},

	mergeCellInRow : function() {
		this.getSheet().mergeCellInRow();
	},

	cancelMergeCell : function() {
		this.getSheet().cancelMergeCell();
	},

	/*
	 * inc/desc font size
	 */
	incFontSize : function() {
		var ss = this.getSheet(), store = ss.getStore();
		var data = ss.getFocusCellData();
		var fz = parseInt(data.fz);
		if(!Ext.isNumber(fz)){
			fz = store.defaultFontSize;
		}
		fz += 2;
				
		ss.setPropertyForSelection({
			fz : fz
		});
	},

	desFontSize : function() {
		var ss = this.getSheet();
		var store = ss.getStore();
		var data = ss.getFocusCellData();
		var fz = parseInt(data.fz);
		if(!Ext.isNumber(fz)){
			fz = store.defaultFontSize;
		}
		if (fz-2 > store.minFontSize) {
			fz -= 2;
		} else {
			fz = store.minFontSize;
		}
		ss.setPropertyForSelection({
			fz : fz
		});
	},

	/*
	 * for style setting functions
	 */
	bold : function() {
		var ss = this.getSheet();
		/*
		 * get focus cell's font-weight
		 */
		var data = ss.getFocusCellData();

		var flag = 'bold' != data.fw;
		if (false !== ss.fireEvent('cmd', 'bold', flag, ss)) {
			if (flag) {
				ss.setPropertyForSelection({
					'fw' : 'bold'
				});
			} else {
				ss.setPropertyForSelection({
					'fw' : ''
				});
			}
		}
	},

	italic : function() {
		var ss = this.getSheet();
		var data = ss.getFocusCellData();
		var flag = 'italic' != data.fs;
		if (false !== ss.fireEvent('cmd', 'italic', flag, ss)) {
			if (flag) {
				ss.setPropertyForSelection({
					'fs' : 'italic'
				});
			} else {
				ss.setPropertyForSelection({
					'fs' : ''
				});
			}
		}
	},

	underline : function() {
		var ss = this.getSheet();
		var data = ss.getFocusCellData();
		var flag = 'underline' != data.u;
		if (false !== ss.fireEvent('cmd', 'underline', flag, ss)) {
			if (flag) {
				ss.setPropertyForSelection({
					'u' : 'underline'
				});
			} else {
				ss.setPropertyForSelection({
					'u' : ''
				});
			}
		}
	},

	overline : function() {
		var ss = this.getSheet();
		var data = ss.getFocusCellData();
		var flag = 'overline' != data.o;
		if (false !== ss.fireEvent('cmd', 'overline', flag, ss)) {
			if (flag) {
				ss.setPropertyForSelection({
					'o' : 'overline'
				});
			} else {
				ss.setPropertyForSelection({
					'o' : ''
				});
			}
		}
	},

	strike : function() {
		var ss = this.getSheet();
		var data = ss.getFocusCellData();
		var flag = 'line-through' != data.s;
		if (false !== ss.fireEvent('cmd', 'strikethrough', flag, ss)) {
			if (flag) {
				ss.setPropertyForSelection({
					's' : 'line-through'
				});
			} else {
				ss.setPropertyForSelection({
					's' : ''
				});
			}
		}
	},
	
	// add currently date to the selected cell
	addCurrentDate : function() {
		this.getSheet().addCurrentDateOrTime(SCONST.FORMAT_DATE, SCONST.DEFAULT_DATE_FORMAT);
	},
	
	addCurrentTime : function() {
		this.getSheet().addCurrentDateOrTime(SCONST.FORMAT_TIME, SCONST.HIA_TIME_FORMAT);
	}, 
	
	
	// Applies the Currency format with two decimal places (negative numbers in parentheses).
	applyCurrencyFormat : function() {
		var format = "money|$|2|negative3";
		this.getSheet().setTextFormatForSelection(format);
	},
	
	// CTRL+SHIFT+% -- Applies the Percentage format with no decimal places.
	applyPercentFormat : function() {
		this.getSheet().setPercentFormatForSelection(SCONST.NO_DECIMAL_PERCENT_FORMAT);
	},
	
	// CTRL+SHIFT+@ -- Applies the Time format with the hour and minute, and AM or PM.
	applyTimeFormat : function() {
		this.getSheet().setTimeFormatForSelection(SCONST.HIA_TIME_FORMAT);
	},
	
	// CTRL+SHIFT+& -- Applies the outline border to the selected cells.
	applyBorderFormat : function() {
		this.getSheet().setRangeBorder('outside', 'black', 1, 'solid');	
	},
	
	// CTRL+SHIFT+MINUS -- Remove the outline border to the selected cells.
	removeBorderFormat : function() {
		this.getSheet().setRangeBorder('all', '', 1, 'solid');
	},

	/*
	 * for percent format, make the selection become percent format
	 */
	percentFormat : function() {
		this.getSheet().setPercentFormatForSelection(SCONST.DEFAULT_PERCENT_FORMAT);
	},

	commaFormat : function() {
		this.getSheet().setTextFormatForSelection(SCONST.FORMAT_COMMA);
	},
	
	scienceFormat : function() {
		this.getSheet().setTextFormatForSelection(SCONST.FORMAT_SCIENCE);
	},

	/*
	 * move the decimal point to left or right
	 */
	moveDot2Left : function() {
		this.getSheet().moveDecimalPoint(1);
	},

	moveDot2Right : function() {
		this.getSheet().moveDecimalPoint(-1);
	},

	/*
	 * clean content/format
	 */
	clean : function() {
		this.getSheet().cleanSelection();
	},

	cleanContent : function() {
		this.getSheet().cleanSelection('content');
	},

	cleanStyle : function() {
		this.getSheet().cleanSelection('style');
	},

	/*
	 * for formulas
	 */
	sum : function() {		
		this.me.insertGeneralFunction.call(this, 'sum');
	},

	average : function() {
		this.me.insertGeneralFunction.call(this, 'average');
	},

	count : function() {
		this.me.insertGeneralFunction.call(this, 'count');
	},

	maxValue : function() {
		this.me.insertGeneralFunction.call(this, 'max');
	},

	minValue : function() {
		this.me.insertGeneralFunction.call(this, 'min');
	},
	
	insertFormula : function() {
		if(!this.insertFormulaWin){
    		this.insertFormulaWin = Ext.create("EnterpriseSheet.sheet.pop.FormulaFunctionWin", {
    			title: SLANG['insert_function'],
    			closeAction: 'hide',
    			spreadsheet: this.getSheet()
    		});
    	}
        this.insertFormulaWin.popup();
	},

	autofillDown : function() {
		var sheet = this.getSheet();
		var autofill = sheet.getAutofill();
		if (autofill) {
			var sm = sheet.getSelectionModel();
			var pos = sm.getMinMaxPos();
			if (pos.minrow != pos.maxrow) {
				pos.maxrow = pos.minrow;
				pos.sheet = sheet.getSheetId();
				autofill.doAutofill(pos, null, sm);
			}
		}
	},

	autofillUp : function() {
        var sheet = this.getSheet();
        var autofill = sheet.getAutofill();
		if (autofill) {
			var sm = sheet.getSelectionModel();
			var pos = sm.getMinMaxPos();
			if (pos.minrow != pos.maxrow) {
				pos.minrow = pos.maxrow;
				pos.sheet = sheet.getSheetId();
				autofill.doAutofill(pos, null, sm);
			}
		}
	},

	autofillLeft : function() {
        var sheet = this.getSheet();
        var autofill = sheet.getAutofill();
		if (autofill) {
			var sm = sheet.getSelectionModel();
			var pos = sm.getMinMaxPos();
			if (pos.mincol != pos.maxcol) {
				pos.mincol = pos.maxcol;
				pos.sheet = sheet.getSheetId();
				autofill.doAutofill(pos, null, sm);
			}
		}
	},

	autofillRight : function() {
        var sheet = this.getSheet();
        var autofill = sheet.getAutofill();
		if (autofill) {
			var sm = sheet.getSelectionModel();
			var pos = sm.getMinMaxPos();
			if (pos.mincol != pos.maxcol) {
				pos.maxcol = pos.mincol;
				pos.sheet = sheet.getSheetId();
				autofill.doAutofill(pos, null, sm);
			}
		}
	},

	/*
	 * insert a picture contained in a floating element
	 */
	insertPictureByURL : function() {
		SPOP.showLinkBox({
			sheet: this.getSheet(),
			width : 400,
			height : 150,
			applyCallback : {
				fn : function(url) {
					this.getSheet().createPicture(url);
				},
				scope : this
			}
		});
	},

	/*
	 * insert a column chart
	 */
	insertColumnChart : function() {
		this.getSheet().createColumnChart();
	},
	
	insertPieChart : function() {
		this.getSheet().createPieChart();
	},
	
	insertAreaChart : function() {
		this.getSheet().createAreaChart();
	},
	
	insertLineChart : function() {
		this.getSheet().createLineChart();
	},
	
	insertBarChart : function() {
		this.getSheet().createBarChart();
	},
	
	insertScatterChart : function() {
		this.getSheet().createScatterChart();
	},
	
	insertRadarChart : function(){
		this.getSheet().createRadarChart();
	},
	
	// this is for function insert data range for formulas
	insertGeneralFunction : function(name) {
        Ext.Function.defer(function(){
            var ss = this.getSheet();
            var editor = ss.editor;
            editor.setValue("="+name.toUpperCase()+"(");
            var region = ss.getCurrentRegion();
            var sm = region.getSelectionModel();
            var fc = sm.getFocusCell();
            editor.startEdit(fc.row, fc.col, region, null, false, true);
        }, 100, this);
	},
	
	insertColumnMiniChart : function(){
        var ss = this.getSheet(), sm = ss.getSelectionModel(), sheetId = ss.getSheetId();
        var pos = sm.getMinMaxPos();
        var span = [sheetId, pos.minrow, pos.mincol, pos.maxrow, pos.maxcol];
		SPOP.showConditionRange({
			sheet: ss,
			title: SLANG['data_range_for_mini_chart'],
			label: SLANG['select_range_for_mini_chart'],
			width : 400,
			height : 150,			
			simpleSelect: true,
			applyCallback : {
				fn : function(param) {
					param['type'] = 'column';
					param['pc'] = 'rgb(0,0,128)';
					param['nc'] = 'rgb(0,0,128)';				
					ss.setConditionForRange([span], 'minichart', param);
				},
				scope : this
			}
		});
	},
	
    insertLineMiniChart : function(){
        var ss = this.getSheet();
        SPOP.showConditionRange({
            sheet: ss,
            title: SLANG['data_range_for_mini_chart'],
            label: SLANG['select_range_for_mini_chart'],
            width : 400,
            height : 150,
            simpleSelect: true,
            applyCallback : {
                fn : function(param) {
                    param['type'] = 'line';
                    param['sc'] = 'rgb(0,0,128)';
                    ss.setConditionForSelection('minichart', param);
                },
                scope : this
            }
        });
    },
	
	insertGainLossMiniChart : function(){
		var sheet = this.getSheet(), sm = sheet.getSelectionModel(), store = sheet.getStore();
		var focusCell = sm.getFocusCell();
		var sheetId = sheet.getSheetId();
		var cd = store.getCellData(sheetId, focusCell.row, focusCell.col);
		var value;
		if(sheet.isMiniChartCell(sheetId, focusCell.row, focusCell.col)){
			var span = sheet.getMiniChartRange(sheetId, focusCell.row, focusCell.col);
			value = [span];
		}
		SPOP.showConditionRange({
			sheet: sheet,
			title: SLANG['data_range_for_mini_chart'],
			label: SLANG['select_range_for_mini_chart'],
			width : 400,
			height : 150,			
			simpleSelect: true,
			value: value,
			applyCallback : {
				fn : function(param) {
					param['type'] = 'gainloss';
					param['pc'] = 'rgb(248,105,107)';
					param['nc'] = 'rgb(90,190,123)';
					sheet.setConditionForSelection('minichart', param);					
				},
				scope : this
			}
		});
	},
	
	
	/*
	 * insert shapes
	 */
	insertCircleShape : function(){		
		this.getSheet().createCircleShape();
	},
	
	/*
	 * insert hyperlink
	 */
	insertHyperlink : function(){
		
		// check to see whether this link will be in same sheet ...
		var sheetId = this.getSheet().sheetId;		
		var sm = this.getSheet().getSelectionModel();
		var focusCell = sm.getFocusCell();
		var row = focusCell.row, col = focusCell.col;
		
		SPOP.showLinkBox({
			sheet: this.getSheet(),
			title: SLANG['insert_hyperlink'],
			width : 400,
			height : 150,
			applyCallback : {
				fn : function(url) {
					// I need pass sheet to the hyperlink - in case it is on other page ...
					this.getSheet().createHyperlink(url, sheetId, row, col);
					// if sheetId is not equal, we need go back to pre-sheet ...navigate back
					if (sheetId !== this.getSheet().sheetId) {
						this.getSheet().go2Sheet(sheetId, null, this);
					}
				},
				scope : this
			},
            urlValidator : function(val){
                if(SCONST['urlReg'].test(val)){
                    return true;
                }else if(EnterpriseSheet.sheet.calculate.Coordinate.prototype.isCoordSpan(val)){
                    return true;
                }else if('=' === val.charAt(0)){
                    val = val.slice(1);
                    
                }
                return false;
			}
		});		
	},
	
	// ctrl + N -- Creates a new, blank workbook. 
	addNewWorkbook : function() {
		var sheet = this.getSheet(), store = sheet.getStore();
        store.addSheet(null, function(data){
            var sheetId = data.id;
            sheet.loadSwitchSheet(sheetId);
        }, this);
	},
	
	// ctrl+T -- show table side bar ...
	applyTable : function() {
		// TODO -- not working yet
		// this.fireEvent('showTables', this);
	},
	
	// ctrl+home
	move2TopLeft : function() {
		this.getSheet().go2Pos();
	},
	
	// ctrl+end
	move2BottomRight : function() {
		var sheet = this.getSheet(), store = sheet.getStore();
		var maxRow = 1, maxCol = 1;
		store.each(function(rd){			
			if (rd.data.row >= maxRow) {
				maxRow = rd.data.row;
				if (rd.data.col > maxCol) maxCol = rd.data.col;
			}
		}, this);
		
		this.getSheet().go2Pos(maxRow, maxCol);
	},
	
	// home
	move2LeftMost : function() {
		var sm = this.getSheet().getSelectionModel();
		var focusCell = sm.getFocusCell();
		var row = focusCell.row, col = focusCell.col;
		this.getSheet().go2Pos(row, 1);
	},
	
	// page down
	movePageDown : function() {
		var sm = this.getSheet().getSelectionModel();
		var focusCell = sm.getFocusCell();
		var row = focusCell.row, col = focusCell.col;
		this.getSheet().go2Pos(row+25, col);
	},
	
	movePageUp : function() {
		var sm = this.getSheet().getSelectionModel();
		var focusCell = sm.getFocusCell();
		var row = focusCell.row, col = focusCell.col;
		var row = row-25;
		if (row < 1) row = 1;
		this.getSheet().go2Pos(row, col);
	},
	
	// ctrl+shift+home
	select2TopLeft : function() {
		var sm = this.getSheet().getSelectionModel();
		var focusCell = sm.getFocusCell();
		var row = focusCell.row, col = focusCell.col;
		sm.selectRange({row: 1, col: 1}, {row: row, col: col});
	},
	
	// ctrl+shift+ up arrow key
	select2Top : function() {
		var sm = this.getSheet().getSelectionModel();
		var focusCell = sm.getFocusCell();
		var row = focusCell.row, col = focusCell.col;
		sm.selectRange({row: 1, col: col}, {row: row, col: col});
	},
	
	select2Left : function() {
		var sm = this.getSheet().getSelectionModel();
		var focusCell = sm.getFocusCell();
		var row = focusCell.row, col = focusCell.col;
		sm.selectRange({row: row, col: 1}, {row: row, col: col});
	},
	
	/*
	 * insert comment
	 */
	insertComment : function(){
		SPOP.showCommentBox({
			title: SLANG['insert_comment'],
			applyCallback : {
				fn : function(comment) {
					this.getSheet().insertComment(comment);
				},
				scope : this
			}
		});	
	},
	
	/**
	 * insert the variable for the focus cell
	 */
	insertVariable : function(){
		var sheet = this.getSheet(), sm = sheet.getSelectionModel();
		var focusCell = sm.focusCell, sheetId = sheet.getSheetId();
		var str = sheet.coord2StringWithSheetName([[sheetId, focusCell.row, focusCell.col, focusCell.row, focusCell.col]], '');
		SPOP.showVarTextBox({
			title: SLANG['add_variable_for']+str,
			fieldLabel: SLANG['input_variable_name'],
			applyCallback : {
				fn : function(name) {
					if(sheet.isValidVariable(name)){
						sheet.insertVariable(sheetId, focusCell.row, focusCell.col, name);
					}else{
						Ext.Msg.alert(SLANG['hint'], SLANG['var_already_defined']);
						return true;
					}
				},
				scope : this
			}
		});	
	},
	
	deleteComment : function(){
		this.getSheet().deleteComment();
	},
	
	/*
	 * add group and cancel group
	 */
	addGroup : function(){
		this.getSheet().addGroupForSelection();
	},
	
	cancelGroup : function(){
		this.getSheet().cancelGroupForSelection();
	},
	
	/*
	 * insert checkbox
	 */
	insertCheckbox : function(){
		this.getSheet().setItemForSelection('checkbox', SCOM.genTimeStamp());
	},
	
	insertRadio : function(){
		this.getSheet().setItemForSelection('radio', SCOM.genTimeStamp());
	},
	
	/*
	 * clear item
	 */
	clearItem : function(){
		this.getSheet().clearItemForSelection();
	},
	
	/*
	 * mark a range
	 */
	markRange : function(){
		this.getSheet().markSelection();
	},
	
	/*
	 * insert copied stuff
	 */
	insertCopied : function(){
        var ss = this.getSheet(), clipboard = ss.getClipboard();
		if (clipboard) {
			clipboard.insertCopyRange();
		}
	},
	
	/**
	 * show validation option window 
	 */
	showValidation : function(){
		if(SPOP){
            var sheet = this.getSheet();
			var coord = sheet.getSelectionModel().selection2Coord();
			
			SPOP.showValidationBox({
				sheet: sheet,
				rangeValue: coord
			});
		}
	},
	
	toggleEditable : function(){
		var ss = this.getSheet();
		/*
		 * get focus cell's font-weight
		 */
		var data = ss.getFocusCellData();
		if('ed' === data.dsd){
			ss.setPropertyForSelection({
				'dsd': ''
			});
		}else{
			ss.setPropertyForSelection({
				'dsd' : 'ed'
			});
		}		
		var sm = ss.getSelectionModel();
		var focusCell = sm.getFocusCell();
		ss.fireEvent('focuschange', focusCell.row, focusCell.col, sm);
	},
	
	toggleEditableForOther : function(){
		var ss = this.getSheet(), store = ss.getStore();
		/*
		 * get focus cell's font-weight
		 */
		var data = ss.getFocusCellData();
		var userId = store.getUserInfo().id;
		if(data.dsd && '['+userId+']' === data.dsd){
			ss.setPropertyForSelection({
				'dsd': ''
			});
		}else{			
			ss.setPropertyForSelection({
				'dsd' : Ext.encode([userId])
			});
		}		
		var sm = ss.getSelectionModel();
		var focusCell = sm.getFocusCell();
		ss.fireEvent('focuschange', focusCell.row, focusCell.col, sm);
	},
	
	/**
	 * toggle grid line
	 */
	toggleGridLine : function(){
		var ss = this.getSheet(), me = this.me;

		if(ss.withGridLine()) {
			ss.hideGridLine();
			me.toggleGridLineAction.setText(SLANG['show_grid_line']);
		} else {
			ss.showGridLine();
			me.toggleGridLineAction.setText(SLANG['hide_grid_line']);
		}
	},
	
	toggleRowName : function(){
		var ss = this.getSheet(), store = ss.getStore(), me = this.me;

		if(!store.rowNameHidden) {
			ss.setRowNameVisible(false);
			me.toggleRowNameAction.setText(SLANG['hide_row_name']);
		} else {
			ss.setRowNameVisible(true);
			me.toggleRowNameAction.setText(SLANG['show_row_name']);
		}
	}, 

	toggleColName : function(){
		var ss = this.getSheet(), store = ss.getStore(), me = this.me;

		if(!store.colNameHidden) {
			ss.setColNameVisible(false);
			me.toggleColNameAction.setText(SLANG['hide_col_name']);
		} else {
			ss.setColNameVisible(true);
			me.toggleColNameAction.setText(SLANG['show_col_name']);
		}
	}, 
	
    /**
     * toggle title region
     */
    toggleTitleRegion : function(){
        var ss = this.getSheet(), me = this.me;
           
        if(ss.isTitleRegionVisible()) {
            //ss.hideTitleRegion();
            me.toggleTitleRegionAction.setText(SLANG['show_title_region']);
        } else {
            //ss.showTitleRegion();
            me.toggleTitleRegionAction.setText(SLANG['hide_title_region']);
        }
    },
	
    createPivotTable : function(){
        this.getSheet().createPivotTable();
    },
           
    setHeaderTitle : function(){
        this.getSheet().setSelectedRowAsHeaderTitle();
    },
	
	// add keyboard popup window ...
	keyboardShortcuts : function() {
		window.open('http://www.enterprisesheet.com/api/docs/features/keyboard.html');
		/**
        var me = this.me;
		if(!me.keyWin){
			me.keyWin = Ext.create('EnterpriseSheet.sheet.pop.KeyShortcuts', {
				width: 500,
				height: 350
			});
		}
		me.keyWin.popup();
		**/
	},
	
	aboutSheetWin : function() {
        if(window['SABOUT']){
           SABOUT.popup();
		}
	},
           
    /**
     * delete repeat items
     */
    deleteRepeatItem : function(){
        this.getSheet().deleteRepeatItem();
	},
           
    insertDatePicker : function(){
        this.getSheet().insertDropList({drop:'date'});
	}
	
}, function() {
	/*
	 * the global action box
	 */

	SABOX = function() {
		var actionbox = new EnterpriseSheet.sheet.action.ActionBox();
		return {
            bind2Box : function(name, ref, overwrite) {
				if (!actionbox[name] || overwrite) {
					actionbox[name] = ref;
				}
			},

			/*
			 * return a EnterpriseSheet.common.action.Action by name @param {string} name:
			 * the name of the action you want to get @param {object}
			 * onceConfig: the onceConfig ref, only use for one time, see
			 * EnterpriseSheet.common.action.Action for more details
			 */
			get : function(name, onceConfig) {
				if (actionbox) {
					var action = actionbox[name + 'Action'];
					if (action) {
                        onceConfig = onceConfig || {};
                        var sender = onceConfig.sender;
                        onceConfig.scope = {
                            me: actionbox,
                            getSheet: function(){
                                return sender.sheet;
                            },
                            sender: sender
                        };

						Ext.apply(action.initialConfig, onceConfig);
						action.onceConfig = onceConfig;
						return action;
					}
				}
			},
           
            updateConfig : function(config){
                Ext.apply(actionbox, config);
            },
           
            addHotKey : function(sheet){
                actionbox.addHotKey(sheet);
            }
		}
	}();
});
Ext.define('EnterpriseSheet.sheet.floating.Arrow', {
	
	/* Begin Definitions */
		
	extend : 'Ext.util.Observable',
	
	requires: [
	    'EnterpriseSheet.common.Common',
	    'Ext.menu.Menu',
	    'EnterpriseSheet.sheet.pop.Popup',
	    'EnterpriseSheet.sheet.pop.DataTypeConfigWin'
	],
	
	// itemsInMenu : ['config', '-', 'sortAsc', 'sortDesc', 'filter', 'columnWidth', 'rowHeight', '-', 'hide', 'delete', 'colTitle', 'icon', 'hideTitle', 'showTitle'],
	/* End Definitions */
						
	constructor : function(config){
		
		this.callParent(arguments);
		
		
		/*
		 * hide arrow and menu
		 */
		this.mon(Ext.getBody(), 'mousewheel', function(){
			if(this.disabled){
				if(this.arrowEl && this.arrowEl.isVisible()){
					this.arrowEl.hide();
					if(this.menu && this.menu.isVisible()){
						this.menu.hide();
					}
				}
				this.disabled = false;
			}			
		}, this);
	},
           
    afterSheetRender : function(){
        var el = this.sheet.getEl();
        this.arrowEl = Ext.core.DomHelper.append(el, '<div class="ss-arrow-box" style="z-index:'+SCONST['TOP_Z_INDEX']+';"><div class="ss-arrow"></div></div>', true);
           
        this.arrowEl.hide();
           
        this.mon(this.arrowEl, {
            scope: this,
            'click': this.onArrowClick
        });
    },
	
	/*
	 * bind with sheet and listener cellmouseenter/cellmouseout event
	 */
	init : function(sheet){
		this.sheet = sheet;		
		this.mon(this.sheet, {
			scope: this,
			'cellmousemove': this.cellMouseMove,
			'switchsheet': this.hideArrow,
            'afterrender': this.afterSheetRender
		});
		this.mon(sheet.getStore(), {
			scope: this,
			'afterload': this.hideArrow
		});
	},
	
	/*
	 * hide arrow el
	 */
	hideArrow : function(){
		if(this.arrowEl){
			this.arrowEl.hide();
		}
	},
	
	cellMouseMove : function(row, col, region, e){		
		if(0 === e.button && 1 === e.button){
			/*
			 * if mouse down then hide
			 */
			if(this.arrowEl.isVisible()){
				this.arrowEl.hide();
			}		
		}else if(!this.disabled){
            if(this.sheet.isReadOnly()){
                this.arrowEl.hide();
                return;
            }
			var cellEl = region.getCellEl(row, col), pEl = this.arrowEl.parent();
			if(cellEl){
                var w = this.arrowEl.getWidth(), hw = w/2, h = cellEl.getHeight(), hh = h/2;
				/*
				 * save cell position
				 */
				this.cellPos = [row, col];
				if(0 == col && 0 != row){					
					this.arrowEl.setTop(cellEl.getTop()+hh-pEl.getTop()-this.arrowEl.getHeight()/2);
					this.arrowEl.setLeft(cellEl.getRight()-hw-pEl.getLeft());
					this.arrowEl.show();
				}else if(0 == row && 0 != col){
					var top = cellEl.getBottom()-hw-pEl.getTop();
					this.arrowEl.setTop(top);
					var left = Math.round((cellEl.getRight()+cellEl.getLeft())/2-hw)-pEl.getLeft();
					this.arrowEl.setLeft(left);					
					this.arrowEl.show();
				}else if(this.arrowEl.isVisible()){
					this.arrowEl.hide();
				}						
			}
		}		
	},
	
	/*
	 * click on arrow
	 */
	onArrowClick : function(e){
		/*
		 * get menu first, will create one if don't have
		 */
		var menu = this.getMenu();	
		if (menu == null) return;
		
		if(0 === this.cellPos[0]){
			this.sortAscItem.show();
			this.sortDescItem.show();
			this.columnWidthItem.show();
			this.filterItem.show();
			this.rowHeightItem.hide();
			this.configItem.show();	
			this.colTitleItem.show();
			this.iconItem.show();
			this.hideTitleItem.show();
			this.showTitleItem.show();
		}else{
			this.sortAscItem.hide();
			this.sortDescItem.hide();
			this.filterItem.hide();
			this.columnWidthItem.hide();
			this.rowHeightItem.show();
			this.configItem.hide();
			this.colTitleItem.hide();
			this.iconItem.hide();
			this.hideTitleItem.hide();
			this.showTitleItem.hide();
		}
		
		var col = this.cellPos[1];
		var cell = this.sheet.getStore().getCell(this.sheet.getSheetId(), 0, col);
		if (0 === this.cellPos[0]) {
			if(cell.hideTitle){
				this.hideTitleItem.hide();
				this.showTitleItem.show();
			}else{
				this.hideTitleItem.show();
				this.showTitleItem.hide();
			}
		}
		menu.showBy(this.arrowEl);
	},
	
	/*
	 * get menu
	 */
	getMenu : function(){
		if(!this.menu){
			this.sortAscItem = new Ext.menu.Item({
				iconCls:'icon-sort-asc',
				text:SLANG['sort_asc'],
				handler: this.sortAsc,
				scope: this
			});
			this.sortDescItem = new Ext.menu.Item({
				iconCls:'icon-sort-desc',
				text:SLANG['sort_desc'],
				handler: this.sortDesc,
				scope: this
			});
			this.filterItem = new Ext.menu.Item({
				iconCls: 'icon-filter',
				text:SLANG['filtering']+'...',
				handler: this.doFilter,
				scope: this
			});
			
			this.columnWidthItem = new Ext.menu.Item({
				iconCls : 'icon-column-width',
				text: SLANG['column_width'],
				handler: this.changeColumnWidth,
				scope: this
			});
			this.rowHeightItem = new Ext.menu.Item({
				iconCls : 'icon-row-height',
				text: SLANG['row_height'],
				handler: this.changeRowHeight,
				scope: this
			});
			
			this.hideItem = new Ext.menu.Item({
				text: SLANG['hide'],
				handler: this.hideRange,
				scope: this
			});
			
			this.deleteItem = new Ext.menu.Item({
				iconCls: 'icon-delete',
				text:SLANG['delete'],
				handler: this.deleteRange,
				scope: this
			});
			
			this.colTitleField = new Ext.form.field.Text({
				width: 200,
				enableKeyEvents: true
			});
			this.mon(this.colTitleField, {
				scope: this,
				'keydown': this.onColTitleFieldKeyDown			
			});
			this.colTitleItem = new Ext.menu.Item({
				text: SLANG['column_title'],
				menu: {
					plain: true,
					items: [{
						xtype: 'label',
						cls: 'sc-menu-label',
						text: SLANG['input_column_title']
					}, this.colTitleField],
					listeners: {
						'show': {
							fn: this.onColTitleFieldShow,
							scope: this
						}
					}
				}	
			});
	           
	        this.iconView = Ext.create('Ext.view.View', {
	            store: SCOM.titleIconStore,
	            tpl: SCOM.titleIconTpl,
	            width: 150,
	            itemSelector: 'div.ss-title-icon',
	            overItemCls: 'ss-iconset-over'
	        });
	        this.iconView.on('itemclick', this.onIconClick, this);
	        
			this.iconItem = new Ext.menu.Item({
				text: SLANG['col_icon'],
				menu: {
					xtype: 'menu',
					plain: true,
					items: [{
						xtype: 'container',
						padding: 10,
						items: [this.iconView]
					}]
				}
			});
			
			this.configItem = new Ext.menu.Item({
				iconCls:'icon-wrench',
				text: SLANG['dataTypeConf'],
				handler: this.configColumn,
				scope: this
			});
			
			this.hideTitleItem = new Ext.menu.Item({
				text: SLANG['hide_title'],
				handler: this.hideTitle,
				scope: this
			});
			
			this.showTitleItem = new Ext.menu.Item({
				text: SLANG['show_title'],
				handler: this.showTitle,
				scope: this
			});
			
			// add item to the menu based on config ...
			this.items = [];
			var deafultList = SCONFIG.arrowmenu_items;		
			for (var i=0; i<deafultList.length; i++) {
				var item = deafultList[i];
				if (Ext.isObject(item)) {
					// do extra things ...
					this.items.push(item);
				} else {
	                if (item == "-"){
	                    this.items.push('-');
	                }else {
	                    if(this[item+'Item']){
	                        this.items.push(this[item+'Item']);
	                    }
	                }
				}
			}
			
			if (this.items.length == 0) return null;
			
			this.menu = new Ext.menu.Menu({
				items: this.items
			});
			this.mon(this.menu, {
				scope: this,
				'show': function(){
					this.disabled = true;					
				},
				'hide': function(){
					delete(this.disabled);
				}
			});
		}
		
		return this.menu;
	},
	
	/*
	 * rename the sheet when press enter
	 */
	onColTitleFieldKeyDown : function(field, e){
		if(e.ENTER == e.getKey()){
			e.stopEvent();
			var title = this.colTitleField.getValue();
			this.sheet.setColumnTitle(this.sheet.getSheetId(), this.cellPos[1], title);
			this.menu.hide();
		}
	},
	
	onColTitleFieldShow : function(){
		var menu = this.menu;
		var col = this.cellPos[1];
		var title = this.sheet.getStore().getCell(this.sheet.getSheetId(), 0, col).data;
		this.colTitleField.setValue(title);
	},
	
	/**
     * set the iconset for the selection
     */
    onIconClick : function(view, rec){
        var data = rec.data;                       
        var col = this.cellPos[1];
        this.sheet.setColumnIcon(col, data['idx']);
        this.menu.hide();        
    },
	
	/*
	 * sort the column
	 */
	sortAsc : function(){
		var pos = this.cellPos;
		if(pos){
			var col = pos[1];
			var sheet = this.sheet, sheetId = sheet.getSheetId();
			sheet.checkSortSpan([sheetId, 0, col, 0, col], null, 'asc');
		}
	},
	
	sortDesc : function(){
		var pos = this.cellPos;
		if(pos){
			var col = pos[1];
			var sheet = this.sheet, sheetId = sheet.getSheetId();
			sheet.checkSortSpan([sheetId, 0, col, 0, col], null, 'desc');
		}
	},
	
	doFilter : function(){
		var pos = this.cellPos;
		if(pos){
			var col = pos[1];
			var sheet = this.sheet, sheetId = sheet.getSheetId();
			var span = [sheetId, 0, col, 0, col];
			var filter = sheet.getFilter();
			if (filter) {
				filter.createFilterForSpan(span);
			}			
		}
	},
	
	/*
	 * hide/delete row/col
	 */
	hideRange : function(){
		var pos = this.cellPos;
		if(pos){			
			var sheet = this.sheet, sheetId = sheet.getSheetId();
			var row = pos[0], col = pos[1];
			if(0 == row){
				sheet.hideColumn({
					mincol: col,
					maxcol: col
				});
			}else if(0 == col){
				sheet.hideRow({
					minrow: row,
					maxrow: row
				});
			}
		}
	},
	
	deleteRange : function(){
		var pos = this.cellPos;
		if(pos){			
			var sheet = this.sheet, sheetId = sheet.getSheetId();
			var row = pos[0], col = pos[1];
			if(0 == row){
				sheet.deleteColumn({
					mincol: col,
					maxcol: col
				});
			}else if(0 == col){
				sheet.deleteRow({
					minrow: row,
					maxrow: row
				});
			}
		}
	},
	
	/*
	 * change column width or row height
	 */
	changeColumnWidth : function(){
		var pos = this.cellPos;
		if(pos){			
			var sheet = this.sheet, sheetId = sheet.getSheetId();
			var row = pos[0], col = pos[1];
			SPOP.showColumnWidthBox({
				applyCallback : {
					fn : function(w) {
						this.sheet.setColumnWidth(w, {mincol:col, maxcol:col});
					},
					scope : this
				}
			});
		}		
	},
	
	changeRowHeight : function(){
		var pos = this.cellPos;
		if(pos){			
			var sheet = this.sheet, sheetId = sheet.getSheetId();
			var row = pos[0], col = pos[1];
			SPOP.showRowHeightBox({
				applyCallback : {
					fn : function(h) {
						this.sheet.setRowHeight(h, {minrow:row, maxrow:row});
					},
					scope : this
				}
			});
		}		
	},
	
	/**
	 * show column configuration options
	 */
	configColumn : function(){
		if(!this.configWin){
			this.configWin = Ext.create('EnterpriseSheet.sheet.pop.DataTypeConfigWin', {
				title: SLANG['column_data_type_config'],
				sheet: this.sheet,
				applyCallback : {
					fn: function(param){
						var pos = this.cellPos;
						var col = pos[1], coord = [[this.sheet.getSheetId(), 0, col, 0, col]];
						var range = new EnterpriseSheet.sheet.range.Range({
							sheet: this.sheet,
							coord: coord
						});		
						range.setProperty({
							'dcfg': Ext.encode(param)							
						}, ['it', 'itn', 'itchk', 'fm', 'dfm'], true);	
						this.sheet.clearCdtValueForCoord(coord);
						
						// set for icon in the title ...
						if (param.titleIcon) this.sheet.setColumnIcon(col, param.titleIcon);
						else this.sheet.cleanColumnIcon(col);
						
						range.refresh();
						/*
						 * refresh focus
						 */
						this.sheet.refreshFocus();
					},
					scope: this
				},
				cleanCallback : {
					fn : function(){
						var pos = this.cellPos;
						var col = pos[1], coord = [[this.sheet.getSheetId(), 0, col, 0, col]];
						var range = new EnterpriseSheet.sheet.range.Range({
							sheet: this.sheet,
							coord: coord
						});		
						range.setProperty(undefined, ['dcfg', 'it', 'itn', 'itchk', 'fm', 'dfm'], true);
						this.sheet.clearCdtValueForCoord(coord);
						this.sheet.cleanColumnIcon(col);						
						range.refresh();
						/*
						 * refresh focus
						 */
						this.sheet.refreshFocus();
					},
					scope: this
				}
			});
		}
		var pos = this.cellPos;
		var cell = this.sheet.getStore().getCell(this.sheet.getSheetId(), 0, pos[1]);
		var dcfg;
		if(cell.dcfg){
			dcfg = Ext.decode(cell.dcfg);
		}
		this.configWin.popup(dcfg);
	},
	
	hideTitle : function(){
		var pos = this.cellPos;
		this.sheet.setColumnTitleVisible(false, pos[1], pos[1]);
	},
	
	showTitle : function(){
		var pos = this.cellPos;
		this.sheet.setColumnTitleVisible(true, pos[1], pos[1]);
	}
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.floating.CalculateHint', {
	
	/* Begin Definitions */
	
	extend : 'Ext.util.Observable',
	
	requires: [
	    'EnterpriseSheet.common.Common',
	    'Ext.view.View'
	],
	
	/* End Definitions */
	
	constructor : function(){
		/*
		 * create the picker first
		 */
		var picker = this.getPicker();
        picker.store.loadData(this.hintData);
		
		this.callParent(arguments);
		
		this.mon(Ext.getBody(), 'mousedown', function(e){
			var el = picker.getEl();
			var rmEl = this.readmeComp.getEl();
			if(!e.within(el.dom) && !e.within(rmEl.dom)){
				picker.hide();
				this.readmeComp.hide();
			}			
		}, this);
		
		this.mon(picker, {
			scope: this,
			'itemclick': this.onHintItemClick,
			'highlightitem': this.onHintItemHighlight,
			'selectionchange': this.onHintSelectionChange
		});
        this.on('hintdatachange', function(){alert('hintdatachange')});
	},	
	
	/*
	 * bind with sheet and listener cellmouseenter/cellmouseout event
	 */
	init : function(sheet){
		this.sheet = sheet, store = sheet.getStore();		
		
		this.mon(sheet, 'editorkeyup', this.onEditorKeyup, this, {buffer: 50});
		this.mon(sheet, {
			scope: this,
			'afterloadsheet': this.onAfterLoadSheet,
			'quitedit': this.onQuitEdit,
			'editornavigatedown': this.onEditorNavigateDown,
			'editornavigateup': this.onEditorNavigateUp,
			'beforeeditorspecialkey': this.beforeEditorSpecialKey
		});
		
		this.mon(store, {
			scope: this,
			'refconfigchange': this.onRefConfigChange
		});
	},
	
	onAfterLoadSheet : function(){
		var store = this.sheet.getStore();
		this.onRefConfigChange(null, store);
	},
	
	/**
	 * when reference config is change, need update the hint list
	 */
	onRefConfigChange : function(refConfigStr, store){
		var picker = this.getPicker();
		var hintStore = picker.store;
		var refConfigs = store.getRefConfig(), curSheetId = store.getActivedSheetId();
		
        var map = {}, data = [];
		for(var i = 0, len = refConfigs.length; i < len; i++){
			var it = refConfigs[i];
            map[it.name] = it;
		}
        for(var p in map){
            if(map.hasOwnProperty(p)){
                var it = map[p], ctype = it.ctype;
                var str = '', json, cal;
                try{
                    json = Ext.decode(it.json);
                    if(Ext.isArray(json)){
                        var match;
                        for(var i = 0, len = json.length; i < len; i++){
                            var o = json[i], scope = o.scope;
                            if(!Ext.isDefined(match)){
                                match = o;
                            }
                            if(scope === curSheetId){
                                match = o;
                                break;
                            }
                        }
                    }else{
                        match = json;
                    }
                    cal = !Ext.isString(match.cal) ? Ext.encode(match.cal) : match.cal;
                }catch(e){
                    json = it.json;
                    cal = json;
                }
                if('ref' === ctype){
                    str = EnterpriseSheet.sheet.calculate.Coordinate.prototype.transferCoordInStr(cal, function(coord){
                        var span = coord.span;
                        span[0] = store.getSheetNameById(span[0]);
                        var res = EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String([coord], undefined, true);
                        return res;
                    }, this);
                }else{
                    str = cal;
                }
                data.push([it.name, it.name, str, 'var']);
            }
        }
		data = data.concat(this.hintData);
		hintStore.loadData(data);
	},
	
	/*
	 * guess the function name 
	 */
	guessFunName : function(str, pos){		
		var name = [];
		var len = str.length; 
		if(pos >= len){
			pos = len-1;
		}
		
		var index = 0;
		for(var i = pos; 0 <= i; i--){
			var ch = str.charAt(i);
			if(/[\,\=\(\[\{\s\+\-\*\/\%]/g.test(ch)){
				index = i+1;
				break;
			}
			name.unshift(ch);
		}
		name = name.join('');				
		/*
		 * save the pos of the name in editor
		 */
		this.startPos = index;
		this.endPos = pos;
		
		return name;
	},
	
	/*
	 * when the sheet start to edit
	 */
	onEditorKeyup : function(e, row, col, region, editor, isCal){
		var key = e.getKey();
		if(e.ENTER == key || e.ESC == key || e.TAB == key){
			return;
		}
		/*
		 * save the current editor
		 */
		this.editor = editor;		
		if(editor.isAvailable()){
			var cursorPos = editor.getCursorPos()-1;
			if(Ext.isGecko){
				cursorPos++;
			}
			var value = editor.getRawTextValue();		
			
			var picker = this.getPicker();
			var showFlag = false;
			var store = picker.store;
	
			if(isCal){
				store.clearFilter();
				/*
				 * guess the current function name based on the cursor position in editor
				 */			
				var fname = this.guessFunName(value, cursorPos);
				if(fname){
					var reg = new RegExp('^'+Ext.String.escapeRegex(fname), 'i');					
					store.filterBy(function(rec, id){
						if(reg.test(rec.data.id)){
							showFlag = true;							
							return true;
						}							
					}, this);
				}				
			}
			/*
			 * decide to show/hide hint
			 */
			if(showFlag){
				if(!picker.isVisible()){
					var el = editor.getEl();	
					if(picker.getNodes().length){
						var sm = picker.getSelectionModel();
						sm.deselectAll();
						picker.show();
						/*
						 * locate the right position to align to
						 */
						var prePiece = value.slice(0, cursorPos);
						var w = this.measureWidthInCell(this.sheet.getSheetId(), row, col, prePiece);
						
						picker.alignTo(el, undefined, [w, 0]);
						this.readmeComp.show();
						this.readmeComp.alignTo(picker.getEl(), 'tl-tr?');						
					}									
				}
				this.highlightFirstHint();
			}else{				
				if(picker.isVisible()){					
					picker.hide();					
					this.readmeComp.hide();
				}					
				picker.setPosition(-1000, -1000);
			}
		}		
	},
	
	/**
	 * _private, to get the txt width in a cell
	 */
	measureWidthInCell : function(sheetId, row, col, txt){
		var store = this.sheet.getStore();
		var cellTpl = SLAYOUT.cell;
		var cell = store.getCellData(sheetId, row, col);
		cell.width = 'auto';
		cell.data = txt;
		var measureEl = Ext.core.DomHelper.append(document.body, '<div class="ss-guess-measure"></div>', true);
		var mel = cellTpl.overwrite(measureEl, cell, true);
		var w = mel.getWidth();
		measureEl.remove();
		return w;
	},
	
	/*
	 * when navigate arrow down in editor
	 */
	onEditorNavigateDown : function(editor){
		var picker = this.getPicker(); 		
		if(picker.isVisible()){	
			this.highlightNext();
			return false;
		}
	},
	
	onEditorNavigateUp : function(editor){
		var picker = this.getPicker(); 		
		if(picker.isVisible()){	
			this.highlightLast();
			return false;
		}
	},
	
	/*
	 * before press special key in editor, such as enter, tab and esc 
	 */
	beforeEditorSpecialKey : function(key, editor, sheet){
		var picker = this.getPicker();
		if(picker.isVisible()){	
			var keyObj = Ext.EventObject ? Ext.EventObject : Ext.event.Event;
			if(keyObj.ENTER == key){
				var nodes = picker.getSelectedNodes();
				if(0 < nodes.length){
					var node = nodes[0];
					var rec = picker.getRecord(node);
					this.selectCalculate(rec.data.id, rec.data.rtype);
					return false;
				}
			}else if(keyObj.ESC == key){
				/*
				 * hide picker
				 */
				this.getPicker().hide();
				this.readmeComp.hide();
				return false;
			}
		}
	},
	
	/*
	 * highlight the first hint in list
	 */
	highlightFirstHint : function(){
		var picker = this.getPicker();
		var node = picker.getNodes(0, 0)[0];
		var sm = picker.getSelectionModel();
		sm.select(node);		
	},
	
	/*
	 * highlight the next one
	 */
	highlightNext : function(){
		var picker = this.getPicker();
		var el = picker.getEl();
		var sm = picker.getSelectionModel();
		var sels = picker.getSelectedNodes();
		var node;
		if(0 < sels.length){
			var index = picker.indexOf(sels[0]);
			index++;
			var nodes = picker.getNodes();
			var count = nodes.length;
			if(index < count){
				node = nodes[index];
				sm.select(index);							
			}			
		}else{
			var nodes = picker.getNodes();
			node = nodes[0];
			sm.select(0);			
		}
		if(node){
			var offset = Ext.get(node).getBottom()-el.getBottom();
			if(0 < offset){				
				picker.scrollBy({
					x: 0,
					y: 30
				});
			}
		}
	},
	
	/*
	 * highlight the last one
	 */
	highlightLast : function(){
		var picker = this.getPicker();
		var el = picker.getEl();
		var sm = picker.getSelectionModel();
		var sels = picker.getSelectedNodes();
		var node;
		if(0 < sels.length){
			var index = picker.indexOf(sels[0]);
			index--;
			var nodes = picker.getNodes();
			var count = nodes.length;
			if(0 <= index){
				node = nodes[index];
				sm.select(index);							
			}			
		}else{
			var nodes = picker.getNodes();
			var index = nodes.length-1;
			node = nodes[index];
			sm.select(index);			
		}
		if(node){
			var offset = Ext.get(node).getTop()-el.getTop();
			if(0 > offset){
				picker.scrollBy({
					x: 0,
					y: -30
				});
			}
		}
	},
	
	/*
	 * when quit edit, need hide the hint
	 */
	onQuitEdit : function(){
		var picker = this.getPicker();
		picker.hide();
		this.readmeComp.hide();
	},
	
	/*
	 * get picker
	 */
	getPicker : function(){
		if(!this.picker){			
			
			var hintStore = this.hintStore;
			
			var hintTpl = new Ext.XTemplate(
			    '<tpl for=".">',
			        '<div class="ss-cal-hint-item">',			          
			          '<span class="{["var"==values.rtype?"ss-var-hint":"ss-fun-hint"]}">{calculate}</span>',
			        '</div>',
			    '</tpl>'
			);
			this.picker = new Ext.view.View({
				cls: 'ss-cal-hint',
				autoWidth: true,				
				singleSelect: false,
				multiSelect: false,
	            trackOver: true,
	            overItemCls: 'x-item-over',
	            itemSelector: 'div.ss-cal-hint-item',
	            style: 'z-index:'+SCONST['TOP_Z_INDEX']+';',
			    store: hintStore,
			    scrollable: 'y',
			    tpl: hintTpl,		
			    selModel: {
			    	preventFocus: true
			    },
			    renderTo: Ext.getBody()
			});
			this.picker.hide();
			this.readmeComp = new Ext.Component({
				cls: 'ss-cal-readme',
                style: 'z-index:'+SCONST['TOP_Z_INDEX']+';',
				renderTo: Ext.getBody()
			});
			this.readmeComp.hide();
		}
		return this.picker;
	},
	
	/*
	 * select a calculate in hint list
	 */
	onHintItemClick : function(view, rec, node, index){		
		var fname = rec.data.id;
		this.selectCalculate(fname, rec.data.rtype);
	},
	
	/*
	 * select a calculate
	 */
	selectCalculate : function(fname, rtype){
		var editor = this.editor;
		var value = editor.getRawTextValue();		
		var pre = value.slice(0, this.startPos), pos = value.slice(this.endPos+1, value.length);
		var nv;
		if('var' == rtype){
			nv = pre+fname;
		}else{
			nv = pre+fname+'(';
		}
		
		var cursorPos = nv.length;
		nv += pos;
		editor.setValue(nv, true);
		/*
		 * focus editor and set the cursor pos
		 */
		editor.focus();
		editor.setCursorPos(cursorPos, true);
		/*
		 * hide picker
		 */
		this.getPicker().hide();
		this.readmeComp.hide();
	},
	
	/*
	 * when highlight an item, we will update the summary
	 */
	onHintItemHighlight : function(view, node){
		var picker = this.getPicker();
		var rec = picker.getRecord(node);
		var summary = rec.data.summary;
		this.readmeComp.getEl().update(summary);		
	},
	
	onHintSelectionChange : function(view, nodes){
		var picker = this.getPicker();
		var nodes = picker.getSelectedNodes();
		if(0 < nodes.length){
			var rec = picker.getRecord(nodes[0]);			
			var summary = rec.data.summary;
			this.readmeComp.getEl().update(summary);			
		}		
	}
	
}, function(){
    Ext.apply(EnterpriseSheet.sheet.floating.CalculateHint.prototype, {
        addHint : function(hint){
            this.hintData.push(hint);
            this.hintStore.loadData(this.hintData);
        },
        
        hintStore : new Ext.data.ArrayStore({
            fields:[
                'id',
                'calculate',
                'summary',
                'rtype'
            ]
        }),
              
        hintData : [
            ['ABS', 'ABS(number1)', '<b>Syntax:</b> ABS(number)<br><br>Returns the absolute value of the given number','numeric'],
            ['ACOS', 'ACOS(number)', '<b>Syntax:</b> ACOS(number)<br><br>Returns the arccosine, or inverse cosine, of a number. The arccosine is the angle whose cosine is number. The returned angle is given in radians in the range 0 (zero) to pi. Number is the cosine of the angle and must be from -1 to 1.','numeric'],
            ['ACOSH', 'ACOSH(number)', '<b>Syntax:</b> ACOSH(number)<br><br>Returns the inverse hyperbolic cosine of a number. Number must be greater than or equal to 1.','numeric'],
            ['ACOT', 'ACOT(number)', '<b>Syntax:</b> ACOT(number)<br><br>Returns the principal value of the arccotangent, or inverse cotangent, of a number.','numeric'],
            ['AND', 'AND(logical1,logical2,...)', '<b>Syntax:</b> AND(logical1, logical2, ...)<br><br>Returns TRUE if all of its arguments are TRUE','logic'],
            ['AREAS', 'AREAS(reference)', '<b>Syntax:</b> AREAS(reference)<br><br>This function returns the number of ranges in a reference. Reference is a range of cells.','lookup'],
            ['ASIN', 'ASIN(number)', '<b>Syntax:</b> ASIN(number)<br><br>Returns the arcsine, or inverse sine, of a number. The arcsine is the angle whose sine is number. The returned angle is given in radians in the range -pi/2 to pi/2. Number is the sine of the angle and must be from -1 to 1.','numeric'],
            ['ASINH', 'ASINH(number)', '<b>Syntax:</b> ASINH(number)<br><br>Returns the inverse hyperbolic sine of a number.','numeric'],
            ['ATAN', 'ATAN(number)', '<b>Syntax:</b> ATAN(number)<br><br>Returns the arctangent, or inverse tangent, of a number. The arctangent is the angle whose tangent is number. The returned angle is given in radians in the range -pi/2 to pi/2. Number is the tangent of the angle and must be from -1 to 1.','numeric'],
            ['ATAN2', 'ATAN2(x_num, y_num)', '<b>Syntax:</b> ATAN2(x_num, y_num)<br><br>Returns the arctangent, or inverse tangent, of the specified x- and y-coordinates.','numeric'],
            ['ATANH', 'ATANH(number)', '<b>Syntax:</b> ATANH(number)<br><br>Returns the inverse hyperbolic tangent of a number. Number must be between -1 and 1.','numeric'],
            ['AVEDEV', 'AVEDEV(number1, [number2], ...)', '<b>Syntax:</b> AVEDEV(number1, [number2], ...)<br><br>Returns the average of the absolute deviations of data points from their mean.','statistical'],
            ['AVERAGE', 'AVERAGE(number1, number2, ...)', '<b>Syntax:</b> AVERAGE(number1, number2, ...)<br><br>Returns the average of the arguments. Number1, number2, ... are numerical values or ranges. Text is ignored.','statistical'],
            ['AVERAGEIF', 'AVERAGEIF(range, criteria, average_range)', '<b>Syntax:</b> AVERAGEIF(range, criteria, average_range)<br><br>Returns the average (arithmetic mean) of all the cells in a range that meet a given criteria.','statistical'],
            ['AVERAGEIFS', 'AVERAGEIFS(average_range, criteria_range1, criteria1, [criteria_range2, criteria2, ...])', '<b>Syntax:</b> AVERAGEIFS(average_range, criteria_range1, criteria1, [criteria_range2, criteria2, ...])<br><br>Returns the average (arithmetic mean) of all cells that meet multiple criteria.','statistical'],
            ['BESSELI', 'BESSELI(X, N)', '<b>Syntax:</b> BESSELI(X, N) <br><br>Returns the modified Bessel function In(x), which is equivalent to the Bessel function evaluated for purely imaginary arguments.','engineering'],
            ['BESSELJ', 'BESSELJ(X, N)', '<b>Syntax:</b> BESSELJ(X, N) <br><br>Returns the Bessel function Jn(x)','engineering'],
            ['BESSELK', 'BESSELK(X, N)', '<b>Syntax:</b> BESSELK(X, N) <br><br>Returns the modified Bessel function Kn(x)','engineering'],
            ['BESSELY', 'BESSELY(X, N)', '<b>Syntax:</b> BESSELY(X, N) <br><br>Returns the Bessel function Yn(x)','engineering'],            
            ['BIN2DEC', 'BIN2DEC(number)', '<b>Syntax:</b> BIN2DEC(number1) <br><br>Converts a binary number to decimal.','engineering'],
            ['BIN2HEX', 'BIN2HEX(number, [places])', '<b>Syntax:</b> BIN2HEX(number, [places]) <br><br>Converts a binary number to hexadecimal.','engineering'],
            ['BIN2OCT', 'BIN2OCT(number, [places])', '<b>Syntax:</b> BIN2OCT(number, [places]) <br><br>Converts a binary number to octal.','engineering'],           
            ['BINOM.DIST', 'BINOM.DIST (number_s,trials,probability_s,cumulative)', '<b>Syntax:</b> BINOM.DIST (number_s,trials,probability_s,cumulative)<br><br>Returns the individual term binomial distribution probability.','statistical'],
            ['BINOMDIST', 'BINOMDIST (number_s,trials,probability_s,cumulative)', '<b>Syntax:</b> BINOMDIST (number_s,trials,probability_s,cumulative)<br><br>Returns the individual term binomial distribution probability.','compatibility'],
            ['BITAND', 'BITAND(number1, number2)', '<b>Syntax:</b> BITAND( number1, number2) <br><br>Returns a bitwise \'AND\' of two numbers.','engineering'],
            ['BITXOR', 'BITXOR(number1, number2)', '<b>Syntax:</b> BITXOR(number1, number2) <br><br>Returns a bitwise \'XOR\' of two numbers.','engineering'],
            ['BITOR', 'BITOR(number1, number2)', '<b>Syntax:</b> BITOR( number1, number2) <br><br>Returns a bitwise \'OR\' of two numbers.','engineering'],
            ['BITRSHIFT', 'BITRSHIFT(number, shift_amount)', '<b>Syntax:</b> BITRSHIFT(number, shift_amount) <br><br>Returns a number shifted right by the specified number of bits.','engineering'],
            ['BITLSHIFT', 'BITLSHIFT(number, shift_amount)', '<b>Syntax:</b> BITLSHIFT(number, shift_amount) <br><br>Returns a number shifted left by the specified number of bits.','engineering'],
            ['CEILING', 'CEILING(number, significance)', '<b>Syntax:</b> CEILING(number, significance)<br><br>Returns number rounded up, away from zero, to the nearest multiple of significance.','numeric'],
            ['CHAR', 'CHAR(ascii_value)', '<b>Syntax:</b> CHAR(ascii_value)<br><br>CHAR function returns the character based on the ASCII value.<br><br>ascii_value is the ASCII value used to retrieve the character.','string'],
            ['CHOOSE', 'CHOOSE(position, value1, value2, ...)', '<b>Syntax:</b> Choose(position, value1, value2, ...)<br><br>Choose a value from a list of values. Position is position number in the list of values to return. It must be a number between 1 and 29.','lookup'],
            ['CLEAN', 'CLEAN(text)', '<b>Syntax:</b> CLEAN(text)<br><br>Removes all nonprintable characters from text.','string'],
            ['CODE', 'CODE(text)', '<b>Syntax:</b> CODE(text)<br><br>Returns a numeric code for the first character in a text string.','string'],
            ['COLUMN', 'COLUMN(reference)', '<b>Syntax:</b> COLUMN(reference)<br><br>Column function returns the column number of a cell reference.','lookup'],
            ['COLUMNS', 'COLUMNS(reference)', '<b>Syntax:</b> COLUMNS(reference)<br><br>Columns function returns the number of columns in a cell reference.','lookup'],
            ['COMBIN', 'COMBIN(number, CHOOSE)', '<b>Syntax:</b> COMBIN(number, CHOOSE)<br><br>Returns the number of combinations for a given number of items. Use COMBIN to determine the total possible number of groups for a given number of items. <br><br>Number is the number of items. <br><br>Number_chosen is the number of items in each combination.','numeric'],
            ['COMBINA', 'COMBINA(number, CHOOSE)', '<b>Syntax:</b> COMBINA(number, CHOOSE)<br><br>Returns the number of combinations (with repetitions) for a given number of items.','numeric'],
            ['CONCATENATE', 'CONCATENATE(arg1,arg2,...)', '<b>Syntax:</b> CONCATENATE(text1, text2, ...)<br><br>Combines several text strings into one string. Text_1, text_2, ... are text passages that are to be combined into one string.','string'],
            ['CONVERT', 'CONVERT(number, from_unit, to_unit)', '<b>Syntax:</b> CONVERT(number, from_unit, to_unit)<br><br>Converts a number from one measurement system to another.','engineering'],
            ['CORREL', 'CORREL(array1, array2)', '<b>Syntax:</b> CORREL(array1, array2)<br><br>Returns the correlation coefficient of the array1 and array2 cell ranges. Use the correlation coefficient to determine the relationship between two properties.','statistical'],
            ['COS', 'COS(number)', '<b>Syntax:</b> COS(number)<br><br>Returns a Double specifying the cosine of an angle. Number is a Double or any valid numeric expression that expresses an angle in radians.','numeric'],
            ['COSH', 'COSH(number)', '<b>Syntax:</b> COSH(number)<br><br>Returns the hyperbolic cosine of a number.','numeric'],
            ['COT', 'COT(number)', '<b>Syntax:</b> COT(number)<br><br>Return the cotangent of an angle specified in radians.','numeric'],
            ['COTH', 'COTH(number)', '<b>Syntax:</b> COTH(number)<br><br>Return the hyperbolic cotangent of a hyperbolic angle.','numeric'],
            ['COUNT', 'COUNT(value1, [value2], ...)', '<b>Syntax:</b> COUNT(value1, value2, ...)<br><br>Counts how many numbers are in the list of arguments. Text entries are ignored. Value1, value2, ... value30 are values or ranges which are to be counted.','statistical'],
            ['COUNTA', 'COUNTA(value1, [value2], ...)', '<b>Syntax:</b> COUNTA(value1, [value2], ...)<br><br>Counts the number of cells that are not empty in a range.','statistical'],
            ['COUNTIF', 'COUNTIF(range,criteria)', '<b>Syntax:</b> COUNTIF(range,criteria)<br><br>Counts the number of cells within a range that meet the given criteria.<br><br>range is the range of cells that you want to count based on the criteria.<br><br>criteria is used to determine which cells to count.','statistical'],
            ['COUNTIFS', 'COUNTIFS(criteria_range1, criteria1, [criteria_range2, criteria2, ...])', '<b>Syntax:</b>COUNTIFS(criteria_range1, criteria1, [criteria_range2, criteria2, ...])<br><br>Applies criteria to cells across multiple ranges and counts the number of times all criteria are met.','statistical'],
            ['COUNTBLANK', 'COUNTBLANK(range)', '<b>Syntax:</b> COUNTBLANK(range)<br><br>Counts empty cells in a specified range of cells.','statistical'],
            ['COUPDAYS', 'COUPDAYS(settlement, maturity, frequency, [basis])', '<b>Syntax:</b> COUPDAYS(settlement, maturity, frequency, [basis])<br><br>Returns the number of days in the coupon period that contains the settlement date.','finicial'],
            ['COUPNCD', 'COUPNCD(settlement, maturity, frequency, [basis])', '<b>Syntax:</b> COUPNCD(settlement, maturity, frequency, [basis])<br><br>Returns a number that represents the next coupon date before the settlement date.','finicial'],
            ['COUPNUM', 'COUPNUM(settlement, maturity, frequency, [basis])', '<b>Syntax:</b> COUPNUM(settlement, maturity, frequency, [basis])<br><br>Returns the number of coupons payable between the settlement date and maturity date, rounded up to the nearest whole coupon.','finicial'],
            ['COUPPCD', 'COUPPCD(settlement, maturity, frequency, [basis])', '<b>Syntax:</b> COUPPCD(settlement, maturity, frequency, [basis])<br><br>Returns a number that represents the previous coupon date before the settlement date.','finicial'],
            ['CSC', 'CSC(number)', '<b>Syntax:</b> CSC(number)<br><br>Returns the cosecant of an angle specified in radians.','numeric'],
            ['CSCH', 'CSCH(number)', '<b>Syntax:</b> CSCH(number)<br><br>Return the hyperbolic cosecant of an angle specified in radians.','numeric'],           
            ['DAY', 'DAY(date_value)', '<b>Syntax:</b> DAY(date_value)<br><br>This function returns the day of the month (a number from 1 to 31) given a date value.','date'],
            ['DATE', 'DATE(year, month, day)', '<b>Syntax:</b> DATE(year, month, day)<br><br>Converts a date written as year, month, day to an internal serial number and displays it in the cell\'s formatting. Year is an integer between 1583 and 9956 or 0 and 99. Month is an integer between 1 and 12. Day is an integer between 1 and 31.','date'],
            ['DATEVALUE', 'DATEVALUE(date_text)', '<b>Syntax:</b> DATEVALUE(date_text)<br><br>Converts a date that is stored as text to a serial number that it recognizes as a date.','date'],
            ['DAYS', 'DAYS(end_date, start_date)', '<b>Syntax:</b> DAYS(end_date, start_date)<br><br>This function returns the number of days between two dates.','date'],
            ['DAYS360', 'DAYS360(start_date, end_date, [method])', '<b>Syntax:</b> DAYS360(start_date, end_date, [method])<br><br>This function returns the number of days between two dates based on a 360-day year. <br><br>start_date and end_date are the two dates to calculate the difference between.<br><br>method is optional. It is a boolean value - either TRUE or FALSE. If TRUE is entered, the DAYS360 function will use the US method. If FALSE is entered, the DAYS360 function will use the European method.','date'],
            ['DB', 'DB(cost, salvage, life, period, [number_months])', '<b>Syntax:</b> DB(cost, salvage, life, period, [number_months])<br><br>Returns the depreciation of an asset for a given time period based on the fixed-declining balance method. <br><br>cost is the original cost of the asset. <br><br>salvage is the salvage value after the asset has been fully depreciated. <br><br>life is the useful life of the asset or the number of periods that you will be depreciating the asset. <br><br>period is the period that you wish to calculate the depreciation for. Use the same units as for the life. <br><br>number_months is optional. It is the number of months in the first year of depreciation. If this parameter is omitted, the DB function will assume that there are 12 months in the first year.','finicial'],
            ['DDB', 'DDB(cost, salvage, life, period, [factor])', '<b>Syntax:</b> DDB(cost, salvage, life, period, [factor])<br><br>Returns the depreciation of an asset for a given time period based on the fixed-declining balance method. <br><br>cost is the original cost of the asset. <br><br>salvage is the salvage value after the asset has been fully depreciated. <br><br>life is the useful life of the asset or the number of periods that you will be depreciating the asset. <br><br>period is the period that you wish to calculate the depreciation for. Use the same units as for the life. <br><br>factor is optional. It is the rate at which the balance declines. If this parameter is omitted, the DDB function will assume the factor to be 2.','finicial'],
            ['DEC2BIN', 'DEC2BIN(number, [places])', '<b>Syntax:</b> DEC2BIN(number, [places]) <br><br>Converts a decimal number to binary.','engineering'],
            ['DEC2HEX', 'DEC2HEX(number, [places])', '<b>Syntax:</b> DEC2HEX(number, [places]) <br><br>Converts a decimal number to hexadecimal.','engineering'],
            ['DEC2OCT', 'DEC2OCT(number, [places])', '<b>Syntax:</b> DEC2OCT(number, [places]) <br><br>Converts a decimal number to octal.','engineering'],
            ['DEGREES', 'DEGREES(number)', '<b>Syntax:</b> DEGREES(number)<br><br>This function converts radians into degrees.','numeric'],
            ['DELTA', 'DELTA(number1, [number2])', '<b>Syntax: DELTA(number1, [number2])</b> <br><br>Tests whether two values are equal. Returns 1 if number1 = number2; returns 0 otherwise. If omitted, number2 is assumed to be zero.','engineering'],
            ['DEVSQ', 'DEVSQ(number1, [number2], ...)', '<b>Syntax: DEVSQ(number1, [number2], ...)</b> <br><br>Returns the sum of squares of deviations of data points from their sample mean.','statistical'],
            ['DOLLAR', 'DOLLAR(number, [Decimals])', '<b>Syntax:</b> DOLLAR(number, [Decimals])<br><br>Convert a number to text using currency format with the decimals round to the specified place.','string'],
            ['DOLLARDE', 'DOLLARDE(fractional_dollar, fraction)', '<b>Syntax:</b> DOLLARDE(fractional_dollar, fraction)<br><br>Converts a dollar price expressed as an integer part and a fraction part, such as 1.02, into a dollar price expressed as a decimal number.','finicial'],
            ['DOLLARFR', 'DOLLARFR(decimal_dollar, fraction)', '<b>Syntax:</b> DOLLARFR(decimal_dollar, fraction)<br><br>Converts a dollar price expressed as a decimal number into a dollar price expressed as a fraction.','finicial'],
            ['EDATE', 'EDATE(start_date, months)', '<b>Syntax:</b> EDATE(start_date, months)<br><br>Returns the serial number that represents the date that is the indicated number of months before or after a specified date (the start_date)','date'],
            ['EFFECT', 'EFFECT(nominal_rate, npery)', '<b>Syntax:</b> EFFECT(nominal_rate, npery)<br><br>Returns the effective annual interest rate, given the nominal annual interest rate and the number of compounding periods per year.','finicial'],
            ['EOMONTH', 'EOMONTH(start_date, months)', '<b>Syntax:</b> EOMONTH(start_date, months)<br><br>Returns the serial number for the last day of the month that is the indicated number of months before or after start_date.','date'],           
            ['ERF', 'ERF(lower_limit,[upper_limit])', '<b>Syntax: ERF(lower_limit,[upper_limit])</b> <br><br>Returns the error function integrated between lower_limit and upper_limit. If upper_limit omitted, ERF integrates between zero and lower_limit.','engineering'],
            ['ERFC', 'ERFC(lower_limit,[upper_limit])', '<b>Syntax: ERFC(lower_limit,[upper_limit])</b> <br><br>Returns the complementary error function integrated between lower_limit and upper_limit. If upper_limit omitted, ERFC integrates between lower_limit and infinity.','engineering'],
            ['ES_CHECKED', 'ES_CHECKED(cell)', '<b>Syntax: ES_CHECKED(cell)</b> <br><br>This is EnterpriseSheet defined formula. It is used to check whether this cell checkbox is checked. If checked, return true, otherwise return false. If cell is not checkbox, throw #N/A.','enterpriseSheet'],
            ['EXACT', 'EXACT(text1, text2)', '<b>Syntax:</b> EXACT(text1, text2)<br><br>This function compares two strings and returns TRUE if both values are the same. And it is case-sensitive.','string'],
            ['EXP', 'EXP(number)', '<b>Syntax:</b> EXP(number)<br><br>Returns a Double specifying e (the base of natural logarithms) raised to a power.','numeric'],
            ['EXPON.DIST', 'EXPON.DIST(number)', '<b>Syntax:</b> EXPON.DIST(number)<br><br>Returns the exponential distribution.','statistical'],
            ['EVEN', 'EVEN(number)', '<b>Syntax:</b> EVEN(number)<br><br>Returns number rounded up to the nearest even integer.','numeric'],
            ['FACT', 'FACT(number)', '<b>Syntax:</b> FACT(number)<br><br>Returns the factorial of a number. The factorial of a number is equal to 1*2*3*...* number.','numeric'],
            ['FACTDOUBLE', 'FACTDOUBLE(number)', '<b>Syntax:</b> FACTDOUBLE(number)<br><br>Returns the double factorial of a number.','numeric'],
            ['FALSE', 'FALSE()', '<b>Syntax:</b> FALSE()<br><br>Returns the logical value FALSE','logic'],
            ['FIND', 'FIND(find_text, within_text, [start_num])', '<b>Syntax:</b> FIND(find_text, within_text, [start_num])<br><br>This function returns the location of a substring in a string. The search is case-sensitive. <br><br>Find_text is the text you want to find. <br><br>Within_text is the text containing the text you want to find. <br><br>Start_num(Optional) Specifies the character at which to start the search. The first character in within_text is character number 1. If you omit start_num, it is assumed to be 1.','string'],
            ['FISHER', 'FISHER(x)', '<b>Syntax:</b> FISHER(x)<br><br>Returns the Fisher transformation at x','statistical'],
            ['FISHERINV', 'FISHERINV(x)', '<b>Syntax:</b> FISHERINV(x)<br><br>Returns the inverse of the Fisher transformation.','statistical'],
            ['FIXED', 'FIXED(number, [decimal_places], [no_commas])', '<b>Syntax:</b> FIXED(number, [decimal_places], [no_commas])<br><br>This function returns a text representation of a number rounded to a specified number of decimal places.','string'],
            ['FLOOR', 'FLOOR(number, significance)', '<b>Syntax:</b> FLOOR(number, significance)<br><br>Rounds number down, toward zero, to the nearest multiple of significance.','numeric'],
            ['FV', 'FV(interest_rate, number_payments, payment, [PV], [Type])', '<b>Syntax:</b> FV(interest_rate, number_payments, payment, [PV], [Type])<br><br>This function returns the future value of an investment based on an interest rate and a constant payment schedule.<br><br>interest_rate is the interest rate for the investment.<br><br>number_payments is the number of payments for the annuity. <br><br>payment is the amount of the payment for each period. This should be entered as a negative value.<br><br>PV is optional. It is the present value of the payments.<br><br>Type is optional. It indicates when the payments are due. Type can be one of the following values: 0 - Payments are due at the end of the period. (default), 1 - Payments are due at the beginning of the period.','finicial'],
            ['GAMMA', 'GAMMA(number)', '<b>Syntax:</b> GAMMA(number)<br><br>Return the gamma function value.','statistical'],
            ['GAMMALN', 'GAMMALN(number)', '<b>Syntax:</b> GAMMALN(number)<br><br>Returns the natural logarithm of the gamma function.','statistical'],
            ['GCD', 'GCD(arg1,arg2,...)', '<b>Syntax:</b> GCD(number1, number2, ...)<br><br>Returns the greatest common divisor of two or more integers. The greatest common divisor is the largest integer that divides both number1 and number2 without a remainder.','numeric'],
            ['GEOMEAN', 'GEOMEAN(number1, [number2], ...)', '<b>Syntax:</b> GEOMEAN(number1, [number2], ...)<br><br>Returns the geometric mean of an array or range of positive data.','statistical'],
            ['HARMEAN', 'HARMEAN(number1, [number2], ...)', '<b>Syntax:</b> HARMEAN(number1, [number2], ...)<br><br>Returns the harmonic mean of an array or range of positive data.','statistical'],
            ['GESTEP', 'GESTEP(number, [step])', '<b>Syntax:</b> GESTEP(number, [step]) <br><br>Returns 1 if number >= step; returns 0 (zero) otherwise. Use this function to filter a set of values.','engineering'],
            ['HEX2BIN', 'HEX2BIN(number, [places])', '<b>Syntax:</b> HEX2BIN(number, [places]) <br><br>Converts a hexadecimal number to binary.','engineering'],
            ['HEX2DEC', 'HEX2DEC(number)', '<b>Syntax:</b> HEX2DEC(number) <br><br>Converts a hexadecimal number to decimal.','engineering'],
            ['HEX2OCT', 'HEX2OCT(number, [places])', '<b>Syntax:</b> HEX2OCT(number, [places]) <br><br>Converts a hexadecimal number to octal.','engineering'],
            ['HLOOKUP', 'HLOOKUP(lookup_value, tabe_array, row_index, [not_exact_match])', '<b>Syntax:</b> HLOOKUP(lookup_value, tabe_array, row_index, [not_exact_match])<br><br>Search for value in the top row of tabe_array and returns the value in the same column based on the row_index.','lookup'],
            ['HOUR', 'HOUR(arg1)', '<b>Syntax:</b> Hour(serial_number)<br><br>This function returns the hour of a time value (from 0 to 23).','date'],
            ['HYPERLINK', 'HYPERLINK(link_location,friendly_name)', '<b>Syntax:</b> HYPERLINK(link_location,friendly_name)<br><br>Creates a shortcut or jump that opens a document stored on a network server, an intranet, or the Internet.','lookup'],
            ['IF', 'IF(test, then_value, otherwise_value)', '<b>Syntax:</b> IF(test, then_value, otherwise_value)<br><br>Returns one value if a condition evaluates to TRUE and another value if it evaluates to FALSE. <br><br>Test is any value or expression that can be TRUE or FALSE. <br><br>Then_value is the value that is returned if the logical test is TRUE. <br><br>Otherwise_value is the value that is returned if the logical test is FALSE.','logic'],
            ['IFERROR', 'IFERROR(test, value)', '<b>Syntax:</b> IFERROR(test, value)<br><br>If the first argument is an error, then the second argument will be returned. If the first argument is not an error, then it will be returned.','logic'],
            ['IFNA', 'IFNA(test, value)', '<b>Syntax:</b> IFNA(test, value)<br><br>If the first argument is an not available, then the second argument will be returned. Otherwise it will be returned.','logic'],
            ['IMABS', 'IMABS(inumber)', '<b>Syntax:</b> IMABS(inumber)<br><br>Returns the absolute value (modulus) of a complex number in x + yi or x + yj text format. <br/><br/>Inumber is a complex number for which you want the absolute value.','engineering'],
            ['IMAGINARY', 'IMAGINARY(inumber)', '<b>Syntax:</b> IMAGINARY(inumber)<br><br>Returns the imaginary coefficient of a complex number in x + yi or x + yj text format. <br/><br/>Inumber is a complex number for which you want the imaginary coefficient.','engineering'],
            ['IMARGUMENT', 'IMARGUMENT(inumber)', '<b>Syntax:</b> IMARGUMENT(inumber)<br><br>Returns the argument Theta (theta), an angle expressed in radians. <br/><br/>Inumber is a complex number for which you want the argument Theta.','engineering'],
            ['IMCOS', 'IMCOS(inumber)', '<b>Syntax:</b> IMCOS(inumber)<br><br>Returns the cosine of a complex number in x + yi or x + yj text format. <br/><br/>Inumber is a complex number for which you want the cosine.','engineering'],
            ['IMCOSH', 'IMCOSH(inumber)', '<b>Syntax:</b> IMCOSH(inumber)<br><br>Returns the hyperbolic cosine of a complex number in x+yi or x+yj text format. <br/><br/>Inumber is a complex number for which you want the hyperbolic cosine.','engineering'],
            ['IMCOT', 'IMCOT(inumber)', '<b>Syntax:</b> IMCOT(inumber)<br><br>Returns the cotangent of a complex number in x+yi or x+yj text format. <br/><br/>Inumber is a complex number for which you want the cotangent.','engineering'],
            ['IMCSC', 'IMCSC(inumber)', '<b>Syntax:</b> IMCSC(inumber)<br><br>Returns the cosecant of a complex number in x+yi or x+yj text format. <br/><br/>Inumber is a complex number for which you want the cosecant.','engineering'],
            ['IMCSCH', 'IMCSCH(inumber)', '<b>Syntax:</b> IMCSCH(inumber)<br><br>Returns the hyperbolic cosecant of a complex number in x+yi or x+yj text format. <br/><br/>Inumber is a complex number for which you want the hyperbolic cosecant.','engineering'],
            ['IMCONJUGATE', 'IMCONJUGATE(inumber)', '<b>Syntax:</b> IMCONJUGATE(inumber)<br><br>Returns the complex conjugate of a complex number in x + yi or x + yj text format. <br/><br/>Inumber is a complex number for which you want the conjugate.','engineering'],
            ['IMDIV', 'IMDIV(inumber1, inumber2)', '<b>Syntax:</b> IMDIV(inumber1, inumber2)<br><br>Returns the quotient of two complex numbers in x + yi or x + yj text format. <br/><br/>Inumber1 is the complex numerator or dividend. Inumber2 is the complex denominator or divisor.','engineering'],
            ['IMEXP', 'IMEXP(inumber)', '<b>Syntax:</b> IMEXP(inumber)<br><br>Returns the exponential of a complex number in x + yi or x + yj text format. <br/><br/>Inumber is a complex number for which you want the exponential.','engineering'],
            ['IMLN', 'IMLN(inumber)', '<b>Syntax:</b> IMLN(inumber)<br><br>Returns the natural logarithm of a complex number in x + yi or x + yj text format. <br/><br/>Inumber is a complex number for which you want the natural logarithm.','engineering'],
            ['IMLOG2', 'IMLOG2(inumber)', '<b>Syntax:</b> IMLOG2(inumber)<br><br>Returns the base-2 logarithm of a complex number in x + yi or x + yj text format. <br/><br/>Inumber is a complex number for which you want the base-2 logarithm.','engineering'],
            ['IMLOG10', 'IMLOG10(inumber)', '<b>Syntax:</b> IMLOG10(inumber)<br><br>Returns the common logarithm (base 10) of a complex number in x + yi or x + yj text format. <br/><br/>Inumber is a complex number for which you want the common logarithm.','engineering'],
            ['IMPOWER', 'IMPOWER(inumber, number)', '<b>Syntax:</b> IMPOWER(inumber, number)<br><br>Returns a complex number in x + yi or x + yj text format raised to a power. <br/><br/>Inumber is a complex number for which you want to raise to a power. Number is the power to which you want to raise the complex number.','engineering'],
            ['IMPRODUCT', 'IMPRODUCT(inumber1,inumber2...)', '<b>Syntax:</b> IMPRODUCT(inumber1,inumber2...)<br><br>Returns the product of 2 to 29 complex numbers in x + yi or x + yj text format. <br/><br/>Inumber1,inumber2,... are 1 to 29 complex numbers to multiply.','engineering'],
            ['IMREAL', 'IMREAL(inumber)', '<b>Syntax:</b> IMREAL(inumber)<br><br>Returns the real coefficient of a complex number in x + yi or x + yj text format. <br/><br/>Inumber is a complex number for which you want the real coefficient.','engineering'],
            ['IMSEC', 'IMSEC(inumber)', '<b>Syntax:</b> IMSEC(inumber)<br><br>Returns the secant of a complex number in x+yi or x+yj text format. <br/><br/>Inumber is a complex number for which you want the secant.','engineering'],
            ['IMSECH', 'IMSECH(inumber)', '<b>Syntax:</b> IMSECH(inumber)<br><br>Returns the hyperbolic secant of a complex number in x+yi or x+yj text format. <br/><br/>Inumber is a complex number for which you hyperbolic secant.','engineering'],
            ['IMSIN', 'IMSIN(inumber)', '<b>Syntax:</b> IMSIN(inumber)<br><br>Returns the sine of a complex number in x + yi or x + yj text format. <br/><br/>Inumber is a complex number for which you want the sine.','engineering'],
            ['IMSINH', 'IMSINH(inumber)', '<b>Syntax:</b> IMSINH(inumber)<br><br>Returns the hyperbolic sine of a complex number in x+yi or x+yj text format. <br/><br/>Inumber is a complex number for which you want the hyperbolic sine.','engineering'],
            ['IMSQRT', 'IMSQRT(inumber)', '<b>Syntax:</b> IMSQRT(inumber1)<br><br>Returns the square root of a complex number in x + yi or x + yj text format. <br/><br/>Inumber is a complex number for which you want the square root.','engineering'],
            ['IMSUM', 'IMSUM(inumber1,inumber2...)', '<b>Syntax:</b> IMSUM(inumber1,inumber2...)<br><br>Returns the sum of two or more complex numbers in x + yi or x + yj text format. <br/><br/>Inumber1,inumber2,... are 1 to 29 complex numbers to add.','engineering'],
            ['IMSUB', 'IMSUB(inumber1,inumber2)', '<b>Syntax:</b> IMSUB(inumber1,inumber2)<br><br>Returns the difference of two complex numbers in x + yi or x + yj text format. <br/><br/>Inumber1,inumber2, the complex number from which to subtract.','engineering'],
            ['IMTAN', 'IMTAN(inumber)', '<b>Syntax:</b> IMTAN(inumber)<br><br>Returns the tangent of a complex number in x + yi or x + yj text format. <br/><br/>Inumber is a complex number for which you want the tangent.','engineering'],
            ['INDEX', 'INDEX(array, row_num, column_num)', '<b>Syntax:</b> INDEX(reference, row, column)<br><br>This function returns either the value or the reference to a value from a table or range.<br><br>array is a range of cells or table.<br><br>row is the row number in the array to use to return the value.<br><br>column is optional. It is the column number in the array to use to return the value.','lookup'],
            ['INDIRECT', 'INDIRECT(string)', '<b>Syntax:</b> INDIRECT(string)<br><br>translate the passed string to a range reference','info'],       
            ['INT', 'INT(arg1)', '<b>Syntax:</b> INT(number)<br><br>Rounds a number down to the nearest integer','numeric'],
            ['IPMT', 'IPMT(interest_rate, period, number_payments, PV, [FV], [Type])', '<b>Syntax:</b> IPMT(interest_rate, period, number_payments, PV, [FV], [type])<br><br>Returns the interest payment for an investment based on an interest rate and a constant payment schedule. <br><br>period is the period to calculate the interest rate. It must be a value between 1 and number_payments. <br><br>interest_rate is the interest rate for the loan. <br><br>number_payments is the number of payments for the loan. <br><br>PV is the present value or principal of the loan. <br><br>FV is optional. It is the future value or the loan amount outstanding after all payments have been made. If this parameter is omitted, the PMT function assumes a FV value of 0. <br><br>Type (optional) defines whether the payment is due at the beginning (1) or the end (0) of a period.','finicial'],
            ['IRR', 'IRR(range, [estimated_irr])', '<b>Syntax:</b> IRR(range, [estimated_irr])<br><br>This function returns the internal rate of return for a series of cash flows represented by the numbers in values. The cash flows must occur at regular intervals, but do not have to be the same amounts for each interval. <br><br>range is a range of cells that represent the series of cash flows. <br><br>estimated_irr is optional. It is the your guess at the internal rate of return.','finicial'],
            ['ISBLANK', 'ISBLANK(value)', '<b>Syntax:</b> ISBLANK(value)<br><br>This function is used to check for blank or null values.','info'],
            ['ISERROR', 'ISERROR(value)', '<b>Syntax:</b> ISERROR(value)<br><br>Returns TRUE if value is an error value (#N/A, #VALUE!, #REF!, #DIV/0!, #NUM!, #NAME? or #NULL).','info'],
            ['ISERR', 'ISERR(value)', '<b>Syntax:</b> ISERR(value)<br><br>Returns TRUE if value is an error value (except #N/A).','info'],
            ['ISEVEN', 'ISEVEN(number)', '<b>Syntax:</b> ISEVEN(number)<br><br>Returns TRUE if number is even, or FALSE if number is odd.','info'],
            ['ISLOGICAL', 'ISLOGICAL(value)', '<b>Syntax:</b> ISLOGICAL(value)<br><br>This function is used to check for a logical value (ie: TRUE or FALSE).','info'],
            ['ISNA', 'ISNA(value)', '<b>Syntax:</b> ISNA(value)<br><br>Returns TRUE if value is not available.','info'],
            ['ISNUMBER', 'ISNUMBER(value)', '<b>Syntax:</b> ISNUMBER(value)<br><br>Returns TRUE if value is number, or FALSE if value is not number.','info'],
            ['ISODD', 'ISODD(number)', '<b>Syntax:</b> ISODD(number)<br><br>Returns TRUE if number is odd, or FALSE if number is even.','info'],
            ['ISOWEEKNUM', 'ISOWEEKNUM(date)', '<b>Syntax:</b> ISOWEEKNUM(date)<br><br>Returns number of the ISO week number of the year for a given date.','date'],
            ['ISTEXT', 'ISTEXT(value)', '<b>Syntax:</b> ISTEXT(value)<br><br>Returns TRUE if value is a text value, or FALSE if value is not a text value.','info'],
            ['LARGE', 'LARGE(array, nth_position)', '<b>Syntax:</b> LARGE(array, nth_position)<br><br> Returns the nth largest value from a set of values.','statistical'],
            ['LCM', 'LCM(number1, number2, ...)', '<b>Syntax:</b> LCM(number1, number2, ...)<br><br>Calculate the Least Common Multiple, which is the smallest number that can be divided by each of the given numbers','numeric'],
            ['LEFT', 'LEFT(text, number)', '<b>Syntax:</b> LEFT(text, number)<br><br>Returns the first character or characters in a text string. Text is the text where the initial partial words are to be determined. Number (optional) is the number of characters for the start text. If this parameter is not defined, one character is returned.','string'],
            ['LEN', 'LEN(text)', '<b>Syntax:</b> LEN(text)<br><br>Len function returns the length of the specified string.','string'],
            ['LN', 'LN(number)', '<b>Syntax:</b> LN(number)<br><br>Returns the natural logarithm of a number. Natural logarithms are based on the constant e (2.71828182845904).','numeric'],
            ['LOG', 'LOG(number, [base])', '<b>Syntax:</b> LOG(number, [base])<br><br>Returns the logarithm of a number to the base you specify.','numeric'],
            ['LOG10', 'LOG10(number)', '<b>Syntax:</b> LOG10(number)<br><br>Returns the base-10 logarithm of a number.','numeric'],
            ['LOOKUP', 'LOOKUP(lookup_value,  lookup_vector,  [result_vector])', '<b>Syntax:</b> LOOKUP(lookup_value,  lookup_vector,  [result_vector])<br><br>The LOOKUP function returns a value either from a one-row or one-column range or from an array. The LOOKUP function has two syntax forms: the vector form and the array form.','lookup'],
            ['LOWER', 'LOWER(text)', '<b>Syntax:</b>  LOWER(text)<br><br>This function converts all letters in the specified string to lowercase. If there are characters in the string that are not letters, they are unaffected by this function.','string'],
            ['MATCH', 'MATCH(lookup_value, lookup_array, [match_type])', '<b>Syntax:</b> MATCH(lookup_value, lookup_array, [match_type])<br><br>Search for a specified item in a range of cells, and then returns the relative position of that item in the range. The match_type can be 1 (default), 0, -1.','lookup'],
            ['MAX', 'MAX(number1, number2, ...)', '<b>Syntax:</b> MAX(number1, number2, ...)<br><br>Returns the maximum value in a list of arguments. Ignores logic values and text.','statistical'],
            ['MEDIAN', 'MEDIAN(number1, number2, ...)', '<b>Syntax:</b> MEDIAN(number1, number2, ...)<br><br>Median function returns the median of the numbers provided.','statistical'],
            ['MID', 'MID(arg1,arg2,arg3)', '<b>Syntax:</b> MID(text, start_position, number_of_characters)<br><br>This function extracts a substring from a string (starting at any position)','string'],
            ['MIN', 'MIN(number1, number2, ...)', '<b>Syntax:</b> MIN(number1, number2, ...)<br><br>Returns the minimum value in a list of arguments. Ignores logic values and text.','statistical'],
            ['MINUTE', 'MINUTE(arg1)', '<b>Syntax:</b> MINUTE(serial_number)<br><br>This function returns the minute of a time value (from 0 to 59).','date'],
            ['MIRR', 'MIRR(range, finance_rate, reinvestment_rate)', '<b>Syntax:</b> MIRR(range, finance_rate, reinvestment_rate)<br><br>This function returns the modified internal rate of return for a series of cash flows. The internal rate of return is calculated by using both the cost of the investment and the interest received by reinvesting the cash. <br><br>range is a range of cells that represent the series of cash flows. <br><br>finance_rate is the interest rate that you pay on the cash flow amounts. <br><br>reinvestment_rate is the interest rate that you receive on the cash flow amounts as they are reinvested.','finicial'],
            ['MOD', 'MOD(number,divisor)', '<b>Syntax:</b> MOD(number,divisor)<br><br>Mode returns the remainder after number is divided by divisor. The result has the same sign as divisor.','numeric'],
            ['MODE', 'MODE(number1, number2, ...)', '<b>Syntax:</b> MODE(number1, number2, ...)<br><br>Mode return the most frequently occurring value in a list of numbers.','statistical'],
            ['MODE.SNGL', 'MODE.SNGL(number1, number2, ...)', '<b>Syntax:</b> MODE.SNGL(number1, number2, ...)<br><br>Mode return the most frequently occurring value in a list of numbers.','statistical'],
            ['MONTH', 'MONTH(date_value)', '<b>Syntax:</b> MONTH(date_value)<br><br>This function returns the month (a number from 1 to 12) given a date value.','date'],
            ['MROUND', 'MROUND(number,multiple)', '<b>Syntax:</b> MROUND(number,multiple)<br><br>Returns a number rounded to the desired multiple.<br/><br/>Number is the value to round. <br/><br/>Multiple is the multiple to which you want to round number.','numeric'],
            ['N', 'N(value)', '<b>Syntax:</b> N(value)<br><br>This function converts a value to a number. <br><br>If value is a date, the N function returns the date as a serial number.<br><br>If value is boolean - true/false, the N function returns 1/0.','info'],
            ['NA', 'NA()', '<b>Syntax:</b> NA()<br><br>This function returns the error value #N/A.','info'],
            ['NETWORKDAYS', 'NETWORKDAYS(start_date,end_date,[holidays])', '<b>Syntax:</b> NETWORKDAYS(start_date,end_date,[holidays])<br><br>This function returns the number of whole working days between start_date and end_date. Working days exclude weekends and any dates identified in holidays.','date'],
            ['NETWORKDAYS.INTL', 'NETWORKDAYS.INTL(start_date,end_date,[weekend],[holidays])', '<b>Syntax:</b> NETWORKDAYS.INTL(start_date,end_date,[weekend],[holidays])<br><br>This function returns the number of whole working days between start_date and end_date. Working days exclude weekends and any dates identified in holidays.','date'],
            ['NORMSDIST', 'NORMSDIST(z)', '<b>Syntax:</b> NORMSDIST(z)<br><br>Returns the standard normal cumulative distribution function. The distribution has a mean of 0 (zero) and a standard deviation of one. Use this function in place of a table of standard normal curve areas.','compatibility'],           
            ['NOT', 'NOT(arg1)', '<b>Syntax:</b> NOT(logical)<br><br>Reverses the logic of its argument','logic'],
            ['NOW', 'NOW()', '<b>Syntax:</b> NOW()<br><br>Returns the current computer system date time. NOW is a function without arguments.','date'],
            ['NPER', 'NPER(interest_rate, payment, PV, [FV], [Type])', '<b>Syntax:</b> NPER(interest_rate, payment, PV, [FV], [Type])<br><br>This function returns the number of periods for an investment based on an interest rate and a constant payment schedule.<br><br>interest_rate is the interest rate for the investment.<br><br>payment is the amount of the payment for each period. This should be entered as a negative value.<br><br>PV is the present value of the payments.<br><br>FV is optional. It is the future value that you\'d like the investment to be after all payments have been made. If this parameter is omitted, the NPER function will assume a FV of 0. <br><br>Type is optional. It indicates when the payments are due. Type can be one of the following values: 0 - Payments are due at the end of the period. (default), 1 - Payments are due at the beginning of the period.','finicial'],
            ['NPV', 'NPV(discount_rate, value1, value2, ... value_n )', '<b>Syntax:</b> NPV(discount_rate, value1, value2, ... value_n)<br><br>This function returns the net present value of an investment.<br><br>discount_rate is the discount rate for the period.<br><br>value1, value2, ... value_n are the future payments and income for the investment (ie: cash flows).','finicial'],
            ['OCT2BIN', 'OCT2BIN(number, [places])', '<b>Syntax:</b> OCT2BIN(number, [places]) <br><br>Converts an Octal (Base 8) number into a Binary (Base 2) number.','engineering'],
            ['OCT2DEC', 'OCT2DEC(number)', '<b>Syntax:</b> OCT2DEC(number) <br><br>Converts an octal number to decimal.','engineering'],
            ['OCT2HEX', 'OCT2HEX(number, [places])', '<b>Syntax:</b> OCT2HEX(number, [places]) <br><br>Converts an octal number to hexadecimal.','engineering'],
            ['ODD', 'ODD(number)', '<b>Syntax:</b> ODD(number)<br><br>Returns number rounded up to the nearest odd integer.','numeric'],
            ['OFFSET', 'OFFSET(reference, rows, cols, [height], [width])', '<b>Syntax:</b> OFFSET(reference, rows, cols, [height], [width])<br><br>Returns a reference to a range that is a specified number of rows and columns from a cell or range of cells. The reference that is returned can be a single cell or a range of cells. You can specify the number of rows and the number of columns to be returned.','lookup'],
            ['OR', 'OR(arg1,arg2,...)', '<b>Syntax:</b> OR(logical1, logical2, ...)<br><br>Returns TRUE if any argument is TRUE','logic'],
            ['PERCENTILE.INC', 'PERCENTILE.INC(array,k)', '<b>Syntax:</b> PERCENTILE.INC(array,k)<br><br>Returns the k-th percentile of values in a range, where k is in the range 0..1, inclusive.','statistical'],
            ['PERCENTILE.EXC', 'PERCENTILE.EXC(array,k)', '<b>Syntax:</b> PERCENTILE.EXC(array,k)<br><br>Returns the k-th percentile of values in a range, where k is in the range 0..1, exclusive.','statistical'],
            ['PEARSON', 'PEARSON(array1, array2)', '<b>Syntax:</b> PEARSON(array1, array2)<br><br>Returns the Pearson product moment correlation coefficient, r, a dimensionless index that ranges from -1.0 to 1.0 inclusive and reflects the extent of a linear relationship between two data sets.','statistical'],
            ['PI', 'PI()', '<b>Syntax:</b> PI()<br><br>Returns the value of Pi, 3.14159265358979.','numeric'],
            ['PMT', 'PMT(interest_rate, number_payments, PV, [FV], [type])', '<b>Syntax:</b> PMT(interest_rate, number_payments, PV, [FV], [type])<br><br>Returns the payment amount for a loan based on an interest rate and a constant payment schedule. <br><br>interest_rate is the interest rate for the loan. <br><br>number_payments is the number of payments for the loan. <br><br>PV is the present value or principal of the loan. <br><br>FV is optional. It is the future value or the loan amount outstanding after all payments have been made. If this parameter is omitted, the PMT function assumes a FV value of 0. <br><br>Type (optional) defines whether the payment is due at the beginning (1) or the end (0) of a period.','finicial'],
            ['PPMT', 'PPMT(interest_rate, period, number_payments, PV, [FV], [type])', '<b>Syntax:</b> PPMT(interest_rate, period, number_payments, PV, [FV], [type])<br><br>Returns the payment on the principal for a particular payment based on an interest rate and a constant payment schedule. <br><br>interest_rate is the interest rate for the loan. <br><br>period is the period used to determine how much principal has been repaid. Period must be a value between 1 and number_payments. <br><br>number_payments is the number of payments for the loan. <br><br>PV is the present value or principal of the loan. <br><br>FV is optional. It is the future value or the loan amount outstanding after all payments have been made. If this parameter is omitted, the PPMT function assumes a FV value of 0. <br><br>Type (optional) defines whether the payment is due at the beginning (1) or the end (0) of a period.','finicial'],
            ['POWER', 'POWER(base,power)', '<b>Syntax:</b> POWER(base, power)<br><br>Returns the result of a number raised to a power. Base is the number that is to be raised to the given power. Power is the exponent by which the base is to be raised.','numeric'],
            ['PRODUCT', 'PRODUCT(number1, number2, ...)', '<b>Syntax:</b> PRODUCT(number1, number2, ...)<br><br>Multiplies its arguments','numeric'],
            ['PROPER', 'PROPER(text)', '<b>Syntax:</b> PROPER(text)<br><br>This function sets the first character in each word to uppercase and the rest to lowercase. If there are characters in the string that are not letters, they are unaffected by this function.','string'],
            ['PV', 'PV(interest_rate, number_payments, payment, [FV], [Type])', '<b>Syntax:</b> PV(interest_rate, number_payments, payment, [FV], [Type])<br><br>This function returns the present value of an investment based on an interest rate and a constant payment schedule. <br><br>interest_rate is the interest rate for the investment. <br><br>number_payments is the number of payments for the annuity. <br><br>payment is the amount of the payment made each period. <br><br>FV (optional) is the desired value (future value) to be reached at the end of the periodic payments. <br><br>Type (optional) defines whether the payment is due at the beginning (1) or the end (0) of a period.','finicial'],
            ['QUARTILE.INC', 'QUARTILE.INC(array,quart)', '<b>Syntax:</b> QUARTILE.INC(array,quart)<br><br>Returns the quartile of a data set, based on percentile values from 0..1, inclusive.','statistical'],
            ['QUARTILE.EXC', 'QUARTILE.EXC(array,quart)', '<b>Syntax:</b> QUARTILE.EXC(array,quart)<br><br>Returns the quartile of a data set, based on percentile values from 0..1, exclusive.','statistical'],
            ['QUOTIENT', 'QUOTIENT(numerator,denominator)', '<b>Syntax:</b> QUOTIENT(numerator,denominator)<br><br>Returns the integer portion of a division. Use this function when you want to discard the remainder of a division.','numeric'],
            ['RATE', 'RATE(NPER, PMT, PV, [FV], [type], [guess])', '<b>Syntax:</b> RATE(NPER, PMT, PV, [FV], [type], [guess])<br><br>Returns the constant interest rate per period of an annuity. <br><br>NPER is the total number of periods, during which payments are made (payment period). <br><br>PMT is the constant payment (annuity) paid during each period. <br><br>PV is the cash value in the sequence of payments. <br><br>FV (optional) is the future value, which is reached at the end of the periodic payments. <br><br>Type (optional) defines whether the payment is due at the beginning (1) or the end (0) of a period. <br><br>Guess (optional) determines the estimated value of the interest with iterative calculation.','finicial'],
            ['RAND', 'RAND()', '<b>Syntax:</b> RAND()<br><br>Returns a random number between 0 and 1.','numeric'],
            ['RADIANS', 'RADIANS(angle)', '<b>Syntax:</b> RADIANS(angle)<br><br>Converts degrees to radians.','numeric'],
            ['RANDBETWEEN', 'RANDBETWEEN(bottom,top)', '<b>Syntax:</b> RANDBETWEEN(bottom,top)<br><br>Returns a random number between the numbers you specify.','numeric'],
            ['RANK', 'RANK(number,ref,[order])', '<b>Syntax:</b> RANK(number,ref, [order])<br><br>Returns the rank of a number in a list of numbers. The rank of a number is its size relative to other values in a list.','compatibility'],
            ['RANK.AVG', 'RANK.AVG(number,ref,[order])', '<b>Syntax:</b> RANK.AVG(number,ref, [order])<br><br>Returns the rank of a number in a list of numbers: its size relative to other values in the list; if more than one value has the same rank, the average rank is returned.','statistical'],
            ['RANK.EQ', 'RANK.EQ(number,ref,[order])', '<b>Syntax:</b> RANK.EQ(number,ref, [order])<br><br>Returns the rank of a number in a list of numbers. The rank of a number is its size relative to other values in a list.','statistical'],
            ['REPLACE', 'REPLACE(text, start, number_of_chars, new_text)', '<b>Syntax:</b> REPLACE(text, start, number_of_chars, new_text)<br><br>This function replaces a sequence of characters in a string with another set of characters.','string'],
            ['REPT', 'REPT(text, number)', '<b>Syntax:</b> REPT(text, number)<br><br>Repeats a character string by the given number of copies.','string'],
            ['RIGHT', 'RIGHT(text, number)', '<b>Syntax:</b> RIGHT(text, number)<br><br>Defines the last character or characters in a text string. Text is the text of which the right part is to be determined. Number (optional) is the number of characters from the right part of the text.','string'],
            ['ROUND', 'ROUND(number, count)', '<b>Syntax:</b> ROUND(number, count)<br><br>Rounds the given number to a certain number of decimal places according to valid mathematical criteria. Count (optional) is the number of the places to which the value is to be rounded. If the count parameter is negative, only the whole number portion is rounded. It is rounded to the place indicated by the count.','numeric'],
            ['ROUNDDOWN', 'ROUNDDOWN(number, count)', '<b>Syntax:</b> ROUNDDOWN(number, count)<br><br>Rounds the given number to a certain number of decimal places according to valid mathematical criteria (toward zero). Count is the number of the places to which the value is to be rounded. ','numeric'],
            ['ROUNDUP', 'ROUNDUP(number, count)', '<b>Syntax:</b> ROUNDUP(number, count)<br><br>Rounds the given number to a certain number of decimal places according to valid mathematical criteria (away zero). Count is the number of the places to which the value is to be rounded.','numeric'],
            ['ROW', 'ROW(reference)', '<b>Syntax:</b> ROW(reference)<br><br>Row function returns the row number of a cell reference.','lookup'],
            ['ROWS', 'ROWS(reference)', '<b>Syntax:</b> ROWS(reference)<br><br>Rows function returns the number of rows in a cell reference.','lookup'],
            ['RSQ', 'RSQ(known_y\'s, known_x\'s)', '<b>Syntax:</b> RSQ(known_y\'s, known_x\'s)<br><br>Returns the square of the Pearson product moment correlation coefficient through data points in known_y\'s and known_x\'s.','statistical'],
            ['SEC', 'SEC(number)', '<b>Syntax:</b> SEC(number)<br><br>Returns the secant of an angle. Number is a Double or any valid numeric expression that expresses an angle in radians.','numeric'],
            ['SECH', 'SECH(number)', '<b>Syntax:</b> SECH(number)<br><br>Returns the hyperbolic secant of an angle.','numeric'],           
            ['SECOND', 'SECOND(number)', '<b>Syntax:</b>  SECOND(serial_number)<br><br>This function returns the second of a time value (from 0 to 59).','date'],
            ['SIGN', 'SIGN(number)', '<b>Syntax:</b> SIGN(number)<br><br>Returns 1 if the number is positive, zero (0) if the number is 0, and -1 if the number is negative.','numeric'],
            ['SIN', 'SIN(number)', '<b>Syntax:</b> SIN(number)<br><br>Returns a Double specifying the sine of an angle. Number is a Double or any valid numeric expression that expresses an angle in radians.','numeric'],
            ['SINH', 'SINH(number)', '<b>Syntax:</b> SINH(number)<br><br>Returns the hyperbolic sine of a number.','numeric'],
            ['SLN', 'SLN(cost, salvage, life)', '<b>Syntax:</b> SLN(cost, salvage, life)<br><br>This function returns the depreciation of an asset for a period based on the straight-line depreciation method. <br><br>cost is the original cost of the asset. <br><br>salvage is the salvage value after the asset has been fully depreciated. <br><br>life is the useful life of the asset or the number of periods that you will be depreciating the asset.','finicial'],
            ['SLOPE', 'SLOPE(known_y\'s, known_x\'s)', '<b>Syntax:</b> SLOPE(known_y\'s, known_x\'s)<br><br>Returns the slope of the linear regression line through data points in known_y\'s and known_x\'s. The slope is the vertical distance divided by the horizontal distance between any two points on the line, which is the rate of change along the regression line.','statistical'],
            ['SMALL', 'SMALL(array, nth_position)', '<b>Syntax:</b> SMALL(array, nth_position)<br><br> Returns the nth smallest value from a set of values.','statistical'],
            ['SQRT', 'SQRT(number)', '<b>Syntax:</b> SQRT(number)<br><br>Returns a positive square root','numeric'],
            ['SQRTPI', 'SQRTPI(number)', '<b>Syntax:</b> SQRTPI(number)<br><br>Returns a positive square root of (number * pi).','numeric'],
            ['STDEV', 'STDEV(number1,[number2],...])', '<b>Syntax:</b> STDEV(number1,[number2],...])<br><br>Estimates standard deviation based on a sample. The standard deviation is a measure of how widely values are dispersed from the average value (the mean).','compatibility'],
            ['STDEVP', 'STDEVP(number1,[number2],...])', '<b>Syntax:</b> STDEVP(number1,[number2],...])<br><br>Calculates standard deviation based on the entire population given as arguments (ignores logical values and text).','compatibility'],
            ['STDEV.S', 'STDEV.S(number1,[number2],...])', '<b>Syntax:</b> STDEV.S(number1,[number2],...])<br><br>Estimates standard deviation based on a sample. The standard deviation is a measure of how widely values are dispersed from the average value (the mean).','statistical'],
            ['STDEV.P', 'STDEV.P(number1,[number2],...])', '<b>Syntax:</b> STDEV.P(number1,[number2],...])<br><br>Calculates standard deviation based on the entire population given as arguments (ignores logical values and text).','statistical'],
            ['STEYX', 'STEYX(known_y\'s, known_x\'s)', '<b>Syntax:</b> STEYX(known_y\'s, known_x\'s)<br><br>Returns the standard error of the predicted y-value for each x in the regression. The standard error is a measure of the amount of error in the prediction of y for an individual x.','statistical'],
            ['SUBSTITUTE', 'SUBSTITUTE(text, old_text, new_text, [nth_appearance])', '<b>Syntax:</b> SUBSTITUTE(text, old_text, new_text, [nth_appearance])<br><br>This function replaces a set of characters with another. Use SUBSTITUTE when you want to replace specific text in a text string.','string'],
            ['SUBTOTAL', 'SUBTOTAL(function_num, ref1, ref2, ...)', '<b>Syntax:</b> SUBTOTAL(function_num, ref1, ref2, ...)<br><br>Returns a subtotal in a list or database. <BR/><BR/>Function_num is the number 1 to 11 (includes hidden values) that specifies which function to use in calculating subtotals within a list.','numeric'],
            ['SUM', 'SUM(number1, number2, ...)', '<b>Syntax:</b> SUM(number1, number2, ...)<br><br>Returns the sum of corresponding array numbers',   'numeric'],
            ['SUMIF', 'SUMIF(range, criteria, [sum_range])', '<b>Syntax:</b> SUMIF(range, criteria, [sum_range])<br><br>Adds all numbers in a range of cells, based on a given criteria. Range is the range of cells that you want to apply the criteria against. Criteria is used to determine which cells to add. Sum_range are the cells to sum.','numeric'],
            ['SUMIFS', 'SUMIFS(range, criteria_range1, criteria1, [criteria_range2, criteria2], ...)', '<b>Syntax:</b> SUMIFS(range, criteria_range1, criteria1, [criteria_range2, criteria2], ...)<br><br>Adds the cells in a range that meet multiple criteria.','numeric'],
            ['SUMPRODUCT', 'SUMPRODUCT(array1,array2, ...)', '<b>Syntax:</b> SUMPRODUCT(array1, array2, ...)<br><br>Returns the sum of the products of corresponding array components','numeric'],
            ['SUMSQ', 'SUMSQ(number1, number2, ...)', '<b>Syntax:</b> SUMSQ(number1, number2, ...)<br><br>Calculates the sum of the squares of numbers.','numeric'],
            ['SUMXMY2', 'SUMXMY2(array1, array2)', '<b>Syntax:</b> SUMXMY2(array1, array2)<br><br>This function calculates the sum of the squares of the differences between values in two arrays and returns the sum of the results. <br><br>array1 and array2 are two ranges or arrays.','numeric'],
            ['SUMX2PY2', 'SUMX2PY2(array1, array2)', '<b>Syntax:</b> SUMX2PY2(array1, array2)<br><br>This function calculates the sum of the squares of corresponding values in two arrays and returns the sum of the results. <br><br>array1 and array2 are two ranges or arrays.','numeric'],
            ['SUMX2MY2', 'SUMX2MY2(array1, array2)', '<b>Syntax:</b> SUMX2MY2(array1, array2)<br><br>This function calculates the difference of squares of corresponding values in two arrays and returns the sum of the results. <br><br>array1 and array2 are two ranges or arrays.','numeric'],
            ['SYD', 'SYD(cost, salvage, life, period)', '<b>Syntax:</b> SYD(cost, salvage, life, period)<br><br>This function returns the depreciation of an asset for a given time period based on the sum-of-years digits depreciation method. <br><br>cost is the original cost of the asset. <br><br>salvage is the salvage value after the asset has been fully depreciated. <br><br>life is the useful life of the asset or the number of periods that you will be depreciating the asset. <br><br>period is the period that you wish to calculate the depreciation for. Use the same units as for the life.','finicial'],
            ['TAN', 'TAN(number)', '<b>Syntax:</b> TAN(number)<br><br>Returns a Double specifying the tangent of an angle. The required number is a Double or any valid numeric expression that expresses an angle in radians.','numeric'],
            ['TANH', 'TANH(number)', '<b>Syntax:</b> TANH(number)<br><br>Returns the hyperbolic tangent of a number.','numeric'],
            ['TEXT', 'TEXT(value, format)', '<b>Syntax:</b> TEXT(value, format)<br><br>Text function returns a value converted to text with a specified format.','string'],
            ['TIME', 'TIME(hour, minute, second)', '<b>Syntax:</b> TIME(hour, minute, second)<br><br>This function returns the decimal number for a particular time.','date'],
            ['TIMEVALUE', 'TIMEVALUE(date_text)', '<b>Syntax:</b> TIMEVALUE(date_text)<br><br>Returns the decimal number of the time represented by a text string. The decimal number is a value ranging from 0 (zero) to 0.99988426, representing the times from 0:00:00 (12:00:00 AM) to 23:59:59 (11:59:59 P.M.).','date'],
            ['TODAY', 'TODAY()', '<b>Syntax:</b> TODAY()<br><br>Returns the current computer system date. TODAY is a function without arguments.','date'],
            ['TRIM', 'TRIM(text)', '<b>Syntax:</b> TRIM(text)<br><br>Returns a text value with the leading and trailing spaces removed.','string'],
            ['TRUE', 'TRUE()', '<b>Syntax:</b> TRUE()<br><br>Returns the logical value TRUE','logic'],
            ['TRUNC', 'TRUNC(number)', '<b>Syntax:</b> TRUNC(number)<br><br>Truncates a number to an integer','numeric'],
            ['TYPE', 'TYPE(value)', '<b>Syntax:</b> TYPE(value)<br><br>Returns the type of value. Use TYPE when the behavior of another function depends on the type of value in a particular cell.','info'],
            ['UPPER', 'UPPER(text)', '<b>Syntax:</b> UPPER(text)<br><br>This function allows you to convert text to all uppercase. If there are characters in the string that are not letters, they are unaffected by this function.','string'],
            ['VALUE', 'VALUE(text)', '<b>Syntax:</b> VALUE(text)<br><br>Converts a text string into a number. Text is the text to be converted to a number.','string'],
            ['VAR', 'VAR(number1,[number2],...])', '<b>Syntax:</b> VAR(number1,[number2],...])<br><br>Estimates variance based on a sample.','compatibility'],
            ['VARP', 'VARP(number1,[number2],...])', '<b>Syntax:</b> VARP(number1,[number2],...])<br><br>Calculates variance based on the entire population.','compatibility'],
            ['VAR.S', 'VAR.S(number1,[number2],...])', '<b>Syntax:</b> VAR.S(number1,[number2],...])<br><br>Estimates variance based on a sample (ignores logical values and text in the sample).','statistical'],
            ['VAR.P', 'VAR.P(number1,[number2],...])', '<b>Syntax:</b> VAR.P(number1,[number2],...])<br><br>Calculates variance based on the entire population (ignores logical values and text in the population).','statistical'],
            ['WEEKDAY', 'WEEKDAY(serial_number, [type])', '<b>Syntax:</b> WEEKDAY(serial_number, [type])<br><br>Returns the day of the week for the given serial_number (date value). The day is returned as an integer based on the type. <br><br>Type is option. It can be any of the following values: <br><br>type = 1 (default), the weekdays are counted starting from Sunday (Monday = 2). <br><br>type = 2, the weekdays are counted starting from Monday (Monday = 1). <br><br>type = 3, the weekdays are counted starting from Monday (Monday = 0).','date'],
            ['WEEKNUM', 'WEEKNUM(serial_number, [type])', '<b>Syntax:</b> WEEKNUM(serial_number, [type])<br><br>Returns a number that indicates where the week falls numerically within a year. The WEEKNUM function considers the week containing January 1 to be the first week of the year. <br><br>Type is option. It can be any of the following values: <br><br>type = 1 (default), Week begins on Sunday. <br>type = 2, Week begins on Monday.','date'],
            ['WORKDAY', 'WORKDAY(start_date, days, [holidays])', '<b>Syntax:</b> WORKDAY(start_date, days, [holidays])<br><br>Returns a number that represents a date that is the indicated number of working days before or after a date (the starting date). Working days exclude weekends and any dates identified as holidays. Holidays is optional.','date'],
            ['WORKDAY.INTL', 'WORKDAY.INTL(start_date, days, [weekend], [holidays])', '<b>Syntax:</b> WORKDAY.INTL(start_date, days, [weekend], [holidays])<br><br>Returns a number that represents a date that is the indicated number of working days before or after a date (the starting date). Working days exclude weekends and any dates identified as holidays. Holidays and weekends are optional.','date'],
            ['YEAR', 'YEAR(date_value)', '<b>Syntax:</b> YEAR(date_value)<br><br>This function returns a four-digit year (a number from 1900 to 9999) given a date value.','date'],
            ['YEARFRAC', 'YEARFRAC(start_date, end_date, basis)', '<b>Syntax:</b> YEARFRAC(start_date, end_date, basis)<br><br>Calculates the fraction of the year represented by the number of whole days between two dates (the start_date and the end_date). Use the YEARFRAC worksheet function to identify the proportion of a whole year\'s benefits or obligations to assign to a specific term.','date'],
            ['VDB', 'VDB(cost, salvage, life, start_period, end_period, [factor], [no_switch])', '<b>Syntax:</b> VDB(cost, salvage, life, start_period, end_period, [factor], [no_switch])<br><br>Returns the depreciation of an asset for any period you specify, including partial periods, using the double-declining balance method or some other method you specify. VDB stands for variable declining balance.<br/><br/>Cost: The initial cost of the asset.<br/><br/>Salvage: The value at the end of the depreciation. This value can be 0.<br/><br/>Life: the number of periods over which the asset is depreciated.<br/><br/>Start_period: The starting period for which you want to calculate the depreciation. Start_period must use the same units as life.<br/><br/>End_period: The ending period for which you want to calculate the depreciation. End_period must use the same units as life.<br/><br/>Factor: The rate at which the balance declines. If factor is omitted, it is assumed to be 2.<br/><br/>No_switch: A logical value specifying whether to switch to straight-line depreciation when depreciation is greater than the declining balance calculation.','finicial'],
            ['VLOOKUP', 'VLOOKUP(lookup_value, tabe_array, col_index, [not_exact_match])', '<b>Syntax:</b> VLOOKUP(lookup_value, tabe_array, col_index, [not_exact_match])<br><br>Search for value in the left-most column of tabe_array and returns the value in the same row based on the col_index.','lookup']
                    
           // ['TRANSPOSE', 'TRANSPOSE(range)', '<b>Syntax:</b> TRANSPOSE(range)<br><br>Transpose the passed range','array']
                       
    ]
    });
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.floating.chart.ChartFloor', {
	
	/* Begin Definitions */
	
	extend : 'EnterpriseSheet.sheet.floating.Floor',
	
	requires: [
	    'EnterpriseSheet.sheet.pop.Popup', 
	    'Ext.chart.*'
	],
	
	/* End Definitions */
	
	constructor : function(chartType, config, suspendPulling){
		var store = config.store;		
		var yFields = [];
		for(var i = 0, len = store.cacheFields.length; i < len; i++){
			var field = store.cacheFields[i];
			var name = field.name;
			if('category' != name){
				yFields.push(name);
			}			
		}
		if(config.source && config.source.series){
			var slen = config.source.series.length;
			yFields.splice(slen, yFields.length-slen);
		}
		config.yFields = yFields;
		
		/*
		 * prepare config for different chart type
		 */
		config = this.prepareConfig(chartType, config);
		
		var sheet = config.sheet;
		var floatingConfig = {
			'resizeConfig' : {
				dynamic: false,
				pinned: false,
				handles: 'all'
			},
			xtype: 'container',
			cls: 'ss-chart-ct',
			layout: 'fit',
			withTool: true
		};
		
		/*
		 * save a ref for chart store and sheet
		 */
		this.rangeStore = config.store;
		this.yFields = [].concat(yFields);
		this.sheet = sheet;
		
		var arr = ['x', 'y', 'width', 'height', 'resizeConfig', 'ddConfig'];
		Ext.copyTo(floatingConfig, config, arr);
		arr.push('sheet');
		Ext.each(arr, function(it){
			delete(config[it]);
		});
		
		config.xtype = config.xtype || 'chart';
		
		if(!SCOM.nullOrUndefined(config.id)){
			/*
			 * save id to floorId
			 */
			config.floorId = config.id;
			delete(config.id);
		}		
		
		floatingConfig.items = [config];		
		this.callParent([{
			floorId: config.floorId,
			sheet: sheet,
			floatingConfig: floatingConfig
		}, suspendPulling]);
		
		
		/*
		 * add listeners for rangeStore
		 */		
		
		this.mon(this.rangeStore, {
			scope: this,
			'fieldtitlechange': this.onFieldTitleChange,
			'relatedcoordchange': this.onRelatedCoordChange
		});
		
		/*
		 * add listener for floatings
		 */
		this.addListenerForFloatings('showfloorsetting', this.showChartSetting, this);
		this.addListenerForFloatings('elmousedown', this.onFloorMouseDown, this);
	},	
	
	/*
	 * prepare config for different chart type
	 */
	prepareConfig : function(chartType, config){
		this.chartType = chartType;
		var getConfig = 'get'+Ext.util.Format.capitalize(chartType)+'Config';
		if(this[getConfig]){
			return Ext.applyIf(config, this[getConfig](config.yFields, config));
		}			
	},
	
	getColumnConfig : function(yFields, config){	
		config = config || {};
		if(Ext.checkVersion && Ext.checkVersion('6.0.0+')){			
			return {				
				style : 'background:white;',
				animate : true,
				shadow : true,				
				legend: {
					docked: config.legendPosition || 'right'
	            },
				axes : [{
					type : 'numeric',
					position : 'left',				
					title: config.yTitle,
					fields : yFields,				
					label : {
						renderer : Ext.util.Format.numberRenderer('0,0.0')
					},				
					grid : true
				}, {
					type : 'category',
					position : 'bottom',
					title: config.xTitle,
					fields : 'category'
				}],
				series : [{				
					type : 'bar',
					stacked: false,
					highlight : true,								
					xField : 'category',
					yField : yFields,
					style: {
	                    lineWidth: 1,
	                    stroke: '#666',
	                    opacity: 0.86
	                }
				}]
			};
		}else{
			return {
				style : 'background:white;',
				animate : true,
				shadow : true,				
				legend: {
	                position: config.legendPosition || 'right'
	            },
				axes : [{
					type : 'Numeric',
					position : 'left',				
					title: config.yTitle,
					fields : yFields,				
					label : {
						renderer : Ext.util.Format.numberRenderer('0,0.0')
					},				
					grid : true
				}, {
					type : 'Category',
					position : 'bottom',
					title: config.xTitle,
					fields : [ 'category' ]
				}],
				series : [{				
					type : 'column',				
					highlight : true,								
					xField : 'category',
					yField : yFields,
					style: {
	                    lineWidth: 1,
	                    stroke: '#666',
	                    opacity: 0.86
	                }
				}]
			};
		}		
	},
	
	getAreaConfig : function(yFields, config){
		config = config || {};
		if(Ext.checkVersion && Ext.checkVersion('6.0.0+')){			
			return {				
				style : 'background:white;',
				animate : true,
				shadow : true,				
				legend: {
					docked: config.legendPosition || 'right'
	            },
				axes : [{
					type : 'numeric',
					position : 'left',				
					title: config.yTitle,
					fields : yFields,				
					label : {
						renderer : Ext.util.Format.numberRenderer('0,0.0')
					},				
					grid : true
				}, {
					type : 'category',
					position : 'bottom',
					title: config.xTitle,
					fields : 'category'
				}],
				series : [{				
					type : 'area',					
					highlight : true,								
					xField : 'category',
					yField : yFields,
					style: {
	                    lineWidth: 1,
	                    stroke: '#666',
	                    opacity: 0.86
	                }
				}]
			};
		}else{
			return {
				style : 'background:white;',
				animate : true,
				shadow : true,				
				legend: {
	                position: config.legendPosition || 'right'
	            },
				axes : [{
					type : 'Numeric',
					position : 'left',
					title: config.yTitle,
					fields : yFields,
					label : {
						renderer : Ext.util.Format.numberRenderer('0,0.0')
					},				
					grid : true
				}, {
					type : 'Category',
					position : 'bottom',
					title: config.xTitle,
					fields : [ 'category' ]
				}],
				series : [{				
					type : 'area',				
					highlight : true,								
					xField : 'category',				
					yField : yFields,
					style: {
	                    lineWidth: 1,
	                    stroke: '#666',
	                    opacity: 0.86
	                }
				}]
			};
		}
	},
	
	getPieConfig : function(yFields, config){
		config = config || {};
		if(Ext.checkVersion && Ext.checkVersion('6.0.0+')){		
			return {
				xtype: 'polar',
				style : 'background:white;',			
				animate : true,
				shadow : true,					
				legend: {
	                docked: config.legendPosition || 'right'
	            },	           
				series : [{				
					type : 'pie',						
					highlight : true,												
					angleField : yFields[0],
					title: config.yTitle,
					showInLegend: true,                
	                highlight: {
	                	segment: {
	                		margin: 20
	                    }
	                },                
	                label: {
	                    field: 'category',
	                    display: 'rotate',
	                    contrast: true,
	                    font: '18px Arial'
	                }
				}]
			};
		}else{
			return {
				style : 'background:white;',			
				animate : true,
				shadow : true,					
				legend: {
	                position: config.legendPosition || 'right'
	            },	           
				series : [{				
					type : 'pie',						
					highlight : true,												
					field : yFields[0],
					title: config.yTitle,
					showInLegend: true,                
	                highlight: {
	                	segment: {
	                		margin: 20
	                    }
	                },                
	                label: {
	                    field: 'category',
	                    display: 'rotate',
	                    contrast: true,
	                    font: '18px Arial'
	                }
				}]
			};
		}		
	},
	
	getLineConfig : function(yFields, config){
		config = config || {};
		var series = [], colors = SCOM.colors, clen = colors.length, mlen = SCONST['MARKER_SHAPES'].length;		
		
		if(Ext.checkVersion && Ext.checkVersion('6.0.0+')){	
			for(var i = 0, len = yFields.length; i < len; i++){
				var c = i%clen, m = i%mlen, marker = SCONST['MARKER_SHAPES'][m]
				series.push({				
					type : 'line',
					marker: {
						type: markers[i%markers.length]
			        },
			        style: {
			        	opacity: 0.9,
			        	'stroke-width': 2
			        },
			        showMarkers: true,
					axis : 'left',
					highlight : true,								
					xField : 'category',				
					yField : yFields[i]
				});
			}
			/*
			 * apply some default settings
			 */
			return {
				style : 'background:white;',
				animate : true,
				shadow : true,				
				legend: {
	                docked: config.legendPosition || 'right'
	            },
				axes : [{
					type : 'numeric',
					position : 'left',
					title: config.yTitle,
					fields : yFields,
					label : {
						renderer : Ext.util.Format.numberRenderer('0,0.0')
					},				
					grid : true
				}, {
					type : 'category',
					position : 'bottom',
					title: config.xTitle,
					fields : [ 'category' ]
				}],
				series : series
			};
		}else{
			for(var i = 0, len = yFields.length; i < len; i++){
				var c = i%clen;
				series.push({				
					type : 'line',
					markerConfig: {
						type: markers[i%markers.length],
			            radius: 3,
			            size: 3
			        },
			        style: {
			        	opacity: 0.9,
			        	'stroke-width': 2,
			        	fill: colors[c]
			        },
			        showMarkers: false,
					axis : 'left',
					highlight : true,								
					xField : 'category',				
					yField : yFields[i]
				});
			}
			/*
			 * apply some default settings
			 */
			return {
				style : 'background:white;',
				animate : true,
				shadow : true,				
				legend: {
	                position: config.legendPosition || 'right'
	            },
				axes : [{
					type : 'Numeric',
					position : 'left',
					title: config.yTitle,
					fields : yFields,
					label : {
						renderer : Ext.util.Format.numberRenderer('0,0.0')
					},				
					grid : true
				}, {
					type : 'Category',
					position : 'bottom',
					title: config.xTitle,
					fields : [ 'category' ]
				}],
				series : series
			};
		}
	},
	
	getBarConfig : function(yFields, config){
		config = config || {};
		
		if(Ext.checkVersion && Ext.checkVersion('6.0.0+')){	
			return {				
				xtype: 'cartesian',
				style : 'background:white;',
				animate : true,
				shadow : true,				
				legend: {
					docked: config.legendPosition || 'right'
	            },
				axes : [{
					type : 'numeric',
					position : 'left',				
					title: config.yTitle,
					fields : yFields,				
					label : {
						renderer : Ext.util.Format.numberRenderer('0,0.0')
					},				
					grid : true
				}, {
					type : 'category',
					position : 'bottom',
					title: config.xTitle,
					fields : 'category'
				}],
				series : [{				
					type : 'bar',											
					highlight : true,								
					xField : 'category',
					yField : yFields,
					style: {
	                    lineWidth: 1,
	                    stroke: '#666',
	                    opacity: 0.86
	                }
				}]
			};
		}else{
			return {
				style : 'background:white;',
				animate : true,
				shadow : true,				
				legend: {
	                position: config.legendPosition || 'right'
	            },
				axes : [{
					type : 'Numeric',
					position : 'bottom',
					fields : yFields,
					title: config.yTitle,
					label : {
						renderer : Ext.util.Format.numberRenderer('0,0.0')
					},				
					grid : true
				}, {
					type : 'Category',
					position : 'left',
					title: config.xTitle,
					fields : [ 'category' ]
				}],
				series : [{				
					type : 'bar',				
					highlight : true,								
					xField : 'category',
					yField : yFields,
					style: {
	                    lineWidth: 1,
	                    stroke: '#666',
	                    opacity: 0.86
	                }
				}]
			};
		}		
	},
	
	getScatterConfig : function(yFields, config){
		config = config || {};
		var series = [], mlen = SCONST['MARKER_SHAPES'].length, colors = SCOM.colors, clen = colors.length;
		
		if(Ext.checkVersion && Ext.checkVersion('6.0.0+')){	
			for(var i = 0, len = yFields.length; i < len; i++){
				var m = i%mlen, marker = SCONST['MARKER_SHAPES'][m];
				var c = i%clen;
				series.push({				
					type : 'scatter',	
					marker: {
						type: marker,
			            radius: 5,
			            size: 5
			        },			        
					highlight : true,								
					xField : 'category',				
					yField : yFields[i]
				});
			}
			/*
			 * apply some default settings
			 */
			return {
				style : 'background:white;',
				animate : true,
				shadow : true,				
				legend: {
	                docked: config.legendPosition || 'right'
	            },
				axes : [{
					type : 'numeric',
					position : 'left',
					title: config.yTitle,
					fields : yFields,
					label : {
						renderer : Ext.util.Format.numberRenderer('0,0.0')
					},				
					grid : true
				}, {
					type : 'category',
					position : 'bottom',
					title: config.xTitle,
					fields : [ 'category' ]
				}],
				series : series
			};
		}else{
			for(var i = 0, len = yFields.length; i < len; i++){
				var m = i%mlen, marker = SCONST['MARKER_SHAPES'][m];
				var c = i%clen;
				series.push({				
					type : 'scatter',	
					markerConfig: {
						type: marker,
			            radius: 5,
			            size: 5
			        },
			        style: {                    		       
			        	fill: colors[c]
			        },
					highlight : true,								
					xField : 'category',				
					yField : yFields[i]
				});
			}
			/*
			 * apply some default settings
			 */
			return {
				style : 'background:white;',
				animate : true,
				shadow : true,				
				legend: {
	                position: config.legendPosition || 'right'
	            },
				axes : [{
					type : 'Numeric',
					position : 'left',
					title: config.yTitle,
					fields : yFields,
					label : {
						renderer : Ext.util.Format.numberRenderer('0,0.0')
					},				
					grid : true
				}, {
					type : 'Category',
					position : 'bottom',
					title: config.xTitle,
					fields : [ 'category' ]
				}],
				series : series
			};
		}			
	},
	
	getRadarConfig : function(yFields, config){
		config = config || {};
		var series = [], colors = SCOM.colors, clen = colors.length;
		if(Ext.checkVersion && Ext.checkVersion('6.0.0+')){	
			for(var i = 0, len = yFields.length; i < len; i++){
				var c = i%clen;
				series.push({				
					type : 'radar',									
					xField : 'category',				
					yField : yFields[i],
					showInLegend: true,   
					showMarkers: false,
	                marker: {
	                	type: 'circle',
	                    radius: 3,
	                    size: 3
	                },
	                style: {
	                    opacity: 0.4,                    
	                    'stroke-width': 2,                    
	                    fill: colors[c]
	                }
				});
			}
			/*
			 * apply some default settings
			 */
			return {
				xtype: 'polar',
				style : 'background:white;',
				animate : true,
				shadow : true,					
				insetPadding: 20,
				legend: {
					docked: config.legendPosition || 'right'
	            },
	            axes: [{
	            	type: 'numeric',
	                position: 'radial',
	                title: config.yTitle,
	                label: {
	                    display: true
	                }
	            }, {
	                type: 'category',
	                position: 'angular',
	                grid: true
	            }],
				series : series
			};
		}else{
			for(var i = 0, len = yFields.length; i < len; i++){
				var c = i%clen;
				series.push({				
					type : 'radar',									
					xField : 'category',				
					yField : yFields[i],
					showInLegend: true,   
					showMarkers: false,
	                markerConfig: {
	                	type: 'circle',
	                    radius: 3,
	                    size: 3
	                },
	                style: {
	                    opacity: 0.4,                    
	                    'stroke-width': 2,                    
	                    fill: colors[c]
	                }
				});
			}
			/*
			 * apply some default settings
			 */
			return {
				style : 'background:white;',
				animate : true,
				shadow : true,					
				insetPadding: 20,
				legend: {
	                position: config.legendPosition || 'right'
	            },
	            axes: [{
	                type: 'Radial',
	                position: 'radial',
	                title: config.yTitle,
	                label: {
	                    display: true
	                }
	            }],
				series : series
			};
		}		
	},
	
	/*
	 * get a ref of the range store
	 */
	getRangeStore : function(){
		return this.rangeStore;
	},			
	
	getChartSettingWin : function(){
		var win = SPOP.getChartSettingWin({
			width: 250,
			autoHeight: true,
			autoScroll: true,			
			sheet: this.sheet
		});
		return win;
	},
	
	/*
	 * mouse down on this floor
	 */
	onFloorMouseDown : function(){
		var win = this.getChartSettingWin();
		if(win.isVisible()){
			win.bindChart(this);
		}		
	},
	
	/*
	 * show chart setting to the floating
	 */
	showChartSetting : function(target, floating){
		
		var sheet = this.sheet;
		var win = this.getChartSettingWin();	
		/*
		 * render the window first
		 */
		if(!win.rendered){
			win.render(Ext.getBody());
		}
		
		var compEl = floating.getComp().getEl();
		var right = compEl.getRight()+5, top = compEl.getTop();
		
		var el = sheet.getEl();
		var width = win.getWidth(), height = win.getHeight(), 
			rightLimit = el.getRight(),
			bottomLimit = el.getBottom();
		if(right+width > rightLimit){
			right = rightLimit-width;
		}
		if(top+height > bottomLimit){
			top = bottomLimit-height;
		}
		/*
		 * popup the window in the right position
		 */
		win.popup({
			xy: [right, top],
			chart: this
		});		
	},			
	
	/*
	 * override
	 * focus on the floating
	 */
	onFocus : function(e){
        if(this.sheet && this.sheet.isReadOnly()){
           return;
        }
		if(!this.pinned){
			for(var p in this.lookup){
				var comp = this.lookup[p].comp;
				var el = comp.getEl();
				if(el){
					el.addCls('x-resizable-pinned');
				}
			}		
			/*
			 * fire chartfocus event
			 */
			this.sheet.fireEvent('chartfocus', this.getCoordReference(), this);		
			this.pinned = true;
			/*
			 * monitor move reference 
			 */
			this.rangeStore.monitorMoveReference(true);			
		}				
	},
	
	/*
	 * override
	 * when the focus blur, we will remove the resizable-pinned
	 */
	onBlur : function(){		
		if(this.pinned){
			var rm = this.sheet.getReferenceModel();
			rm.disableSelect();
			rm.hide();
			for(var p in this.lookup){
				var comp = this.lookup[p].comp;
				var el = comp.getEl();
				if(el){
					el.removeCls('x-resizable-pinned');
				}
			}
			delete(this.pinned);
			/*
			 * cancel monitor move reference 
			 */
			this.rangeStore.monitorMoveReference(false);			
		}
	},
	
	/*
	 * get the related coord
	 */
	getCoordReference : function(){
		if('pie' == this.chartType){
			var series = this.rangeStore.series;
			var arr = [];
			if(this.rangeStore.labels){
				for(var i = 0, len = this.rangeStore.labels.length; i < len; i++){
					arr.push({
						span: [].concat(this.rangeStore.labels[i]),
						cls: 'ss-rm-nodot'
					});
				}			
			}
			arr.push([].concat(series[0]));
						
			return arr;
		}else{
			return this.rangeStore.getCoordReference();
		}		
	},	
	
	/*
	 * when title of field is changed, need change the title property of series
	 */
	onFieldTitleChange : function(fields){		
		var arr = [], names = [];
		for(var i = 0, len = fields.length; i < len; i++){
			var name = fields[i].name;
			if('category' != name){
				arr.push(fields[i]);
				names.push(name);
			}
		}
		
		
		fields = arr;
		this.yFields = [].concat(names);	
		
		this.rangeStore.removeAll();
	
		if('pie' == this.chartType){
			var getConfig = 'get'+Ext.util.Format.capitalize(this.chartType)+'Config';
			if(this[getConfig]){
				var config = this[getConfig](this.yFields);
								
				for(var p in this.lookup){
					var comp = this.lookup[p].comp;
					var chart = comp.items.first();
					
					chart.series.removeAll();
					chart.series.addAll(config.series);
						
				}
			}
		}else if('line' == this.chartType || 'scatter' == this.chartType || 'radar' == this.chartType){
			var getConfig = 'get'+Ext.util.Format.capitalize(this.chartType)+'Config';
			if(this[getConfig]){
				var config = this[getConfig](this.yFields);
				var titles = [];
				for(var i = 0, len = fields.length; i < len; i++){
					var name = fields[i].name;
					titles.push(fields[i].title || name);			
				}
				
				for(var p in this.lookup){
					var comp = this.lookup[p].comp;
					var chart = comp.items.first();
					
					chart.series.removeAll();
					chart.series.addAll(config.series);
										
					var index = 0;
					if(Ext.isArray(chart.series)){
						for(var i = 0, len = chart.series.length; i < len; i++){
							var it = chart.series[i];
							it.title = titles[index++];
						}
					}else{
						chart.series.each(function(it){
							it.title = titles[index++];						
						}, this);
					}							
				}
			}
		}else{		
			
			var titles = [], len = fields.length;
			for(var i = 0; i < len; i++){
				var name = fields[i].name;
				titles.push(fields[i].title || name);		
			}
			for(var p in this.lookup){
				var comp = this.lookup[p].comp;
				var chart = comp.items.first();
				if(Ext.isArray(chart.series)){
					for(var i = 0, len = chart.series.length; i < len; i++){
						var it = chart.series[i];
						it.yField = [].concat(names);
						it.title = titles;
					}
				}else{
					chart.series.each(function(it){
						it.yField = [].concat(names);
						it.title = titles;		
					}, this);
				}								
			}
		}			
	},	
	
	/*
	 * get current chart setting
	 */
	getChartSetting : function(){
		var seriesPosition = this.rangeStore.getSeriesPosition();
		var legendPosition, xTitle, yTitle;
		for(var p in this.lookup){
			var comp = this.lookup[p].comp;
			var chart = comp.items.first();
			legendPosition = chart.legend.position;
			if(chart.axes){
				if(Ext.isArray(chart.axes)){
					for(var i = 0, len = chart.axes.length; i < len; i++){
						var it = chart.axes[i];
						if('left' == it.position || 'right' == it.position){
							yTitle = it.title;
						}else{
							xTitle = it.title;
						}
					}
				}else{
					chart.axes.each(function(it){
						if('left' == it.position || 'right' == it.position){
							yTitle = it.title;
						}else{
							xTitle = it.title;
						}
					})
				}							
			}
			break;
		}
		var setting = {
			seriesPosition: seriesPosition,
			legendPosition: legendPosition,
			chartType: this.chartType,
            firstRowLabel: this.rangeStore.firstRowLabel,
            firstColLabel: this.rangeStore.firstColLabel,
			xTitle: xTitle,
			yTitle: yTitle
		};		
		return setting;
	},
	
	/*
	 * get info of this chart
	 */
	getFloorInfo : function(){
		var info = this.getChartSetting();
		info['floorType'] = 'chart';
		info['source'] = this.rangeStore.getSourceConfig();
		Ext.apply(info, this.getPositionSize());
		info['id'] = this.getName();
		info['sheetId'] = this.sheetId;
		return info;
	},
	
	/*
	 * change chart type 
	 */
	changeChartType : function(chartType, forceChange, suspendEvent){
		if(this.chartType !== chartType || forceChange){
			/*
			 * old setting
			 */
			var setting = this.getChartSetting();
			var config, rangeStore = this.rangeStore, series, axes;
			this.chartType = chartType;
			var flag = false;
			if('radar' == chartType || 'pie' == chartType || 'area' == chartType){
				if(!rangeStore.useAbs){
					rangeStore.useAbs = true;
					flag = true;
				}				
			}else if(rangeStore.useAbs){				
				rangeStore.useAbs = false;
				flag = true;
			}
			
			var getConfig = 'get'+Ext.util.Format.capitalize(chartType)+'Config';
			if(this[getConfig]){
				config = this[getConfig](this.yFields);		
				config.store = rangeStore;
				/*
				 * sync setting
				 */
				config.legend = {
					position: setting.legendPosition,
					docked: setting.legendPosition
				};	
				if(config.axes){
					for(var i = 0, len = config.axes.length; i < len; i++){
						var it = config.axes[i];
						if('left' == it.position || 'right' == it.position){
							it.title = setting.yTitle;
						}else{
							it.title = setting.xTitle;
						}
					}					
				}
			}
			if(config){
				for(var p in this.lookup){
					var ct = this.lookup[p].comp;
					var chart = ct.items.first();
					ct.remove(chart);
					chart = new Ext.chart.Chart(Ext.apply({}, config));
					ct.add(chart);
					var region = this.sheet[p];
					if(region && region.isVisible()){
						if(Ext.isFunction(ct.doLayout)){
							ct.doLayout();
						}else if(Ext.isFunction(ct.updateLayout)){
							ct.updateLayout();						
						}
					}
				}
			}
			/*
			 * let it refresh the categories title 
			 */
			this.onFieldTitleChange(rangeStore.cacheFields);
			rangeStore.regenerateData();
            if(!suspendEvent){
                /*
                 * fire chart change event through sheet
                 */
                this.sheet.fireEvent('chartchange', this, this.sheet);
            }
		}
	},
	
	changeLegendPosition : function(pos){
		for(var p in this.lookup){
			var ct = this.lookup[p].comp;
			var chart = ct.items.first();
			if(chart.legend){				
				chart.legend.position = pos;
				chart.legend.dock = pos;
				chart.legend.docked = pos;
				chart.legend.isVertical = ("left|right|float".indexOf(pos) !== -1);				
			}
			if(Ext.checkVersion && Ext.checkVersion('6.0.0+')){	
				this.changeChartType(this.chartType, true);
			}else{
				if(Ext.isFunction(chart.refresh)){
					chart.refresh();
				}else{
					chart.redraw();
				}
			}							
		}		
		/*
		 * fire chart change event through sheet
		 */
		this.sheet.fireEvent('chartchange', this, this.sheet);
	},
	
	onRelatedCoordChange : function(rangeStore){
		var win = this.getChartSettingWin();
		if(win.isVisible()){
			win.switchSeriesPosition();
			win.switchTitleField();
		}
	},
	
	/*
	 * update the x axes title
	 */
	updateXTitle : function(title){
		for(var p in this.lookup){
			var ct = this.lookup[p].comp;
			var chart = ct.items.first();
			if(chart.axes){	
				if(Ext.isArray(chart.axes)){
					for(var i = 0, len = chart.axes.length; i < len; i++){
						var it = chart.axes[i];
						if('bottom' == it.position || 'top' == it.position){
							it.title = title;
							break;
						}
					}
				}else{
					chart.axes.each(function(it){
						if('bottom' == it.position || 'top' == it.position){
							it.title = title;
							return false;
						}
					}, this);
				}
				
				if(Ext.isFunction(chart.refresh)){
					chart.refresh();
				}else{
					chart.redraw();
				}	
			}
		}	
		/*
		 * fire chart change event through sheet
		 */
		this.sheet.fireEvent('chartchange', this, this.sheet);
	},
	
	/*
	 * update the y axes title
	 */
	updateYTitle : function(title){
		for(var p in this.lookup){
			var ct = this.lookup[p].comp;
			var chart = ct.items.first();
			if(chart.axes){		
				if(Ext.isArray(chart.axes)){
					for(var i = 0, len = chart.axes.length; i < len; i++){
						var it = chart.axes[i];
						if('left' == it.position || 'right' == it.position){
							it.title = title;
							break;
						}
					}
				}else{
					chart.axes.each(function(it){
						if('left' == it.position || 'right' == it.position){
							it.title = title;
							return false;
						}
					}, this);
				}
				
				if(Ext.isFunction(chart.refresh)){
					chart.refresh();
				}else{
					chart.redraw();
				}	
			}
		}	
		/*
		 * fire chart change event through sheet
		 */
		this.sheet.fireEvent('chartchange', this, this.sheet);
	},
           
    redrawChart : function(){
        for(var p in this.lookup){
            var ct = this.lookup[p].comp;
            var chart = ct.items.first();
            chart.redraw();
        }
    },
	
	/*
	 * destroy this floor and comp 
	 */
	destroy : function(suspendUpdate, suspendEvent){		
		var posize = this.getPositionSize();
		this.callParent(arguments);
		this.rangeStore.monitorMoveReference(false);
		var rm = this.sheet.getReferenceModel();
		rm.clearSelection();
		rm.disableSelect();
		rm.hide();
		if(!suspendEvent){			
			/*
			 * fire delete chart event
			 */
			this.sheet.fireEvent('deletechart', this.chartType, this, this.rangeStore, posize, this.sheet);
		}		
	}
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.floating.picture.PictureFloor', {
	
	/* Begin Definitions */
	
	extend : 'EnterpriseSheet.sheet.floating.Floor',		
	
	/* End Definitions */
	
	constructor : function(url, config, suspendPulling){
		this.pictureUrl = url;
		
		config.floatingConfig = config.floatingConfig || {};
		if(!SCOM.nullOrUndefined(config.floatingConfig.id) && SCOM.nullOrUndefined(config.floatingConfig.floorId)){
			config.floatingConfig.floorId = config.floatingConfig.id;
		}
		var width = config.floatingConfig.width || 200, height = config.floatingConfig.height || 200;

        config.floatingConfig.html = '<img class="inner-ct" src="'+url+'" style="width:'+(width-10)+'px;height:'+(height-10)+'px;">';
        
		Ext.applyIf(config.floatingConfig, {
			style : 'background:white;',
			'resizeConfig' : {
				dynamic: false,
				pinned: false,
				handles: 'all'
			},
			x : 100,
			y : 100,
			width : width,
			height : height
		});
				
		this.callParent([config, suspendPulling]);
		
		this.on({
			scope: this,
			'resized': this.onPictureFloorResize
		});
	},
	
	/*
	 * get info of this picture
	 */
	getFloorInfo : function(){		
		var info = Ext.apply({}, this.getPositionSize());
		info['id'] = this.getName();
		info['url'] = this.pictureUrl;
		info['floorType'] = 'picture';
		info['sheetId'] = this.sheetId;
		return info;
	},
	
	/*
	 * destroy this floor and comp 
	 */
	destroy : function(suspendUpdate, suspendEvent){
		var posize = this.getPositionSize();
		this.callParent(arguments);
		if(!suspendEvent){			
			/*
			 * fire delete chart event
			 */
			this.sheet.fireEvent('deletepicture', this.pictureUrl, this, posize, this.sheet);
		}
	},
	
	onPictureFloorResize : function(){
		this.eachFloating(function(comp){
			if(comp){				
				var el = comp.getEl();
				if(el){
					var w = comp.getWidth(), h = comp.getHeight();
					w -= 10;
					h -= 10;
					var innerCt = el.down('.inner-ct');
					innerCt.setWidth(w);
					innerCt.setHeight(h)
				}
			}			
		}, this);
	}
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.floating.wedgit.WedgitFloor', {
	
	/* Begin Definitions */
	
	extend : 'EnterpriseSheet.sheet.floating.Floor',		
	
	/* End Definitions */
	
	constructor : function(url, config, suspendPulling){
		this.wedgitUrl = url;
		
		config.floatingConfig = config.floatingConfig || {};
		if(!SCOM.nullOrUndefined(config.floatingConfig.id) && SCOM.nullOrUndefined(config.floatingConfig.floorId)){
			config.floatingConfig.floorId = config.floatingConfig.id;
		}
		var width = config.floatingConfig.width || 200, height = config.floatingConfig.height || 200;
        height -= 25;
        config.floatingConfig.html = ['<iframe class="inner-ct" src="', url, '" style="border-left:none;border-right:none;border-bottom:none;border-top:25px solid rgb(60,60,60);width:', (width-10), 'px;height:', (height-10), 'px;"></iframe>',
            '<div class="tool-refresh" style="margin-right:35px;">', SLANG['refresh'], '</div>',
            '<div class="tool-close" style="margin-right:10px;margin-top:8px;"></div>'
        ].join('');
        
		Ext.applyIf(config.floatingConfig, {
			style : 'background:white;',
			'resizeConfig' : {
				dynamic: false,
				pinned: false,
				handles: 'all'
			},
			x : 100,
			y : 100,
			width : width,
			height : height
		});
				
		this.callParent([config, suspendPulling]);
		
		this.on({
			scope: this,
			'resized': this.onWedgitFloorResize
		});
        
        this.addListenerForFloatings('elmousedown', this.onFloorMouseDown, this);
	},
	
	/*
	 * get info of this wedgit
	 */
	getFloorInfo : function(){		
		var info = Ext.apply({}, this.getPositionSize());
		info['id'] = this.getName();
		info['url'] = this.wedgitUrl;
		info['floorType'] = 'wedgit';
		info['sheetId'] = this.sheetId;
		return info;
	},
	
	/*
	 * destroy this floor and comp 
	 */
	destroy : function(suspendUpdate, suspendEvent){
		var posize = this.getPositionSize();
		this.callParent(arguments);
		if(!suspendEvent){			
			/*
			 * fire delete chart event
			 */
			this.sheet.fireEvent('deletewedgit', this.wedgitUrl, this, posize, this.sheet);
		}
	},
	
	onWedgitFloorResize : function(){
		this.eachFloating(function(comp){
			if(comp){				
				var el = comp.getEl();
				if(el){
					var w = comp.getWidth(), h = comp.getHeight();
					w -= 10;
					h -= 35;
					var innerCt = el.down('.inner-ct');
					innerCt.setWidth(w);
					innerCt.setHeight(h)
				}
			}			
		}, this);
	},
           
    /*
     * mouse down on this floor
     */
    onFloorMouseDown : function(e){
        var target = Ext.get(e.getTarget());
        if(target.hasCls('tool-refresh')){
            this.eachFloating(function(comp){
                if(comp){
                    var el = comp.getEl();
                    if(el){
                        var innerCt = el.down('.inner-ct');
                        innerCt.dom.src = innerCt.dom.src;
                    }
                }
            }, this);
        }else if(target.hasCls('tool-close')){
            this.destroy();
        }
    }
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.floating.DeleteRepeatOption', {
	
	/* Begin Definitions */
	
	extend : 'Ext.util.Observable',
	
	requires: [
	    'EnterpriseSheet.common.Common',
	    'Ext.view.View'
	],
	
	/* End Definitions */
    width: 200,
           
    height: 300,
	
	constructor : function(){
        
        this.initPane();
		
		this.callParent(arguments);
		
        this.mon(Ext.getBody(), 'mousedown', function(e){
            var el = this.optionPane.getEl();
            if(!e.within(el.dom)){
                this.optionPane.hide();
            }
        }, this);
	},	
		   
    initPane : function(){
        this.columnStore = Ext.create('Ext.data.Store', {
            fields: ['col', 'display']
        });
        this.columnView = Ext.create('Ext.view.View', {
            cls: 'ss-delete-repeat-view',
            region: 'center',
            store: this.columnStore,
            allowDeselect: true,
            simpleSelect: true,
            tpl: Ext.create('Ext.XTemplate', [
                '<tpl for=".">',
                    '<div class="ss-col-item">{display}</div>',
                '</tpl>'
            ].join('')),
            itemSelector: 'div.ss-col-item'
        });
        this.deleteRepeatBtn = Ext.create('Ext.button.Button', {
            text: SLANG['delete_repeat_item'],
            handler: this.onDeleteRepeat,
            scope: this
        });
        this.infoBox = Ext.create('Ext.Component', {
            cls: 'delete-repeat-info-box'
        });
        /*
         * create the picker first
         */
        this.optionPane = Ext.create('Ext.container.Container', {
            cls: 'ss-delete-repeat-pane',
            floating: true,
            renderTo: Ext.getBody(),
            zIndex: SCONST['TOP_Z_INDEX'],
            width: this.width,
            height: this.height,
            layout: 'border',
            items: [{
                xtype: 'toolbar',
                cls: 'delete-repeat-toolbar',
                region: 'north',
                items: [{
                    text: SLANG['check_all'],
                    handler: this.selectAll,
                    scope: this
                }, {
                    text: SLANG['uncheck_all'],
                    handler: this.deselectAll,
                    scope: this
                }]
            }, this.columnView, {
                xtype: 'container',
                style: 'padding-top:20px;',
                region: 'south',
                items: [this.infoBox, this.deleteRepeatBtn]
            }]
        });
        var sm = this.columnView.getSelectionModel();
        sm.on({
            scope: this,
            'selectionchange': this.onSelectionChange
        });
    },
           
    /**
     * show by the option
     */
    showBy : function(el, align){
        this.optionPane.showBy(el, align);
    },
           
    /**
     * prepare the option
     */
    prepare : function(data){
        this.columnStore.loadData(data);
        this.columnView.getSelectionModel().selectAll(true);
        this.syncInfoBox();
    },
           
    selectAll : function(){
        this.columnView.getSelectionModel().selectAll();
    },
        
    deselectAll : function(){
        this.columnView.getSelectionModel().deselectAll();
    },
           
    onSelectionChange : function(){
        this.syncInfoBox();
    },
           
    /**
     * sync the info box
     */
    syncInfoBox : function(){
        var sm = this.columnView.getSelectionModel();
        var sels = sm.getSelection(), cols = {};
        for(var i = 0, len = sels.length; i < len; i++){
            var it = sels[i];
            cols[it.data.col] = true;
        }
           var rows = {}, flags = {};
        var sheet = this.sheet, sheetSM = sheet.getSelectionModel(), coord = sheetSM.selection2Coord(), store = sheet.getStore();
        var span = coord[0], minRow = span[1], maxRow = span[3], minCol = span[2], maxCol = span[4];
        store.walkRange(coord, function(rd){
            var row = rd.data.row, col = rd.data.col, json = rd.data.json;
            rows[row] = rows[row] || {};
            var rowMap = rows[row];
            if(cols[col]){
                if(json.data){
                    var o = sheet.getCellValue(rd.data.sheet, row, col);
                    rowMap[col] = o.data;
                }
            }
        }, this, true);
        for(var k in cols){
            if(cols.hasOwnProperty(k)){
                var lookup = {};
                for(var i = minRow; i <= maxRow; i++){
                    var row = rows[i] || {};
                    var val = row[k] || '';
                    flags[i] = flags[i] || {};
                    if(lookup[val]){
                        flags[i][k] = true;
                    }else{
                        flags[i][k] = false;
                        lookup[val] = true;
                    }
                }
            }
        }
        var deleted = [];
        for(var p in flags){
            if(flags.hasOwnProperty(p)){
                var flag = flags[p], repeated = true;
                for(var q in flag){
                    if(flag.hasOwnProperty(q)){
                        if(!flag[q]){
                            repeated = false;
                            break;
                        }
                    }
                }
                if(repeated){
                    deleted.push(p);
                }
            }
        }
        var count = maxRow-minRow+1, dlen = deleted.length;
        this.infoBox.update(Ext.String.format(SLANG['found_repeat_value'], dlen, count-dlen));
           
        this.repeatInfo = {
            minRow: minRow,
            maxRow: maxRow,
            minCol: minCol,
            maxCol: maxCol,
            deleted: deleted
        }
    },
           
    /**
     * do the delete repeat action
     */
    onDeleteRepeat : function(){
        var info = this.repeatInfo, deleted = info.deleted;
        if(0 < deleted.length){
            var range = [];
            for(var i = 0, len = deleted.length; i < len; i++){
                var r = Number(deleted[i]), rlen = range.length;
                var last = 0 < rlen ? range[rlen-1] : false;
                if(last && last.maxrow+1 == r){
                    last.maxrow = r;
                }else{
                    range.push({
                        minrow: r,
                        maxrow: r,
                        mincol: info.minCol,
                        maxcol: info.maxCol
                    });
                }
            }
            this.sheet.deleteCellRangesMoveTop(range);
            //this.sheet.deleteRows(deleted);
        }
        this.optionPane.hide();
    }
});
Ext.define('EnterpriseSheet.sheet.autofill.Sequence', {
	
	/* Begin Definitions */
	requires: ['EnterpriseSheet.common.CONST'],
	
	/* End Definitions */
	
	constructor : function(config){		
		Ext.apply(this, config);
		
		this.callParent();		
	},
	
	checkDataType : function(o){
		if(SCOM.canbeNumber(o.data)){
			return 'number';
		}else if(Ext.isDate(o.date)){
			return 'datetime';
		}else{
			return 'text';
		}
	},
	
	tryMatch : function(arr){		
		/*
		 * pass the seeds by the scope
		 */				
		return Ext.Function.bind(this.grow, {seeds:arr});
	}, 
	
	grow : function(o, index){
		var len = this.seeds.length;		
		var i = index%len;
		var s = this.seeds[i];
		if(SCOM.canbeNumber(s.data)){
			var count = Math.floor(index/len);
			/*
			 * grow the number part
			 */
			o.data = Number(s.data)+count;
		}
		return o;
	}
}, function(){
	/*
	 * create a golobal sequence box
	 */
	SQBOX = (function(){
		var loop = new EnterpriseSheet.sheet.autofill.Sequence();
		var me = {};
		me.anyLookup = {}, me.numberLookup = {'arithmetic': false, 'geometric': false}, me.textLookup = {}, me.datetimeLookup = {};
		
		var checkDataType = loop.checkDataType;
		return {
			/*
			 * register the sequence, notice the name need be unique or it will be overwrote
			 * @param {string} name: the name of the sequence to register
			 * @param {string} type: could be one of {'text', 'number', 'any'}, default as any
			 */
			reg : function(name, type, ref){
				type = type || 'any';
				var lookup = me.anyLookup;
				if('text' == type){
					lookup = me.textLookup;
				}else if('number' == type){
					lookup = me.numberLookup;
				}else if('datetime' == type){
					lookup = me.datetimeLookup;
				}
				lookup[name] = ref;
			},
			
			/*
			 * try to match with any register sequence
			 */
			tryMatch : function(arr){
				var obj = {'number': false, 'datetime': false, 'text': false, 'any': false};
				var seeds = SCOM.copy(arr);
				
				for(var p in obj){
					if(obj.hasOwnProperty(p)){
						var lookup = me[p+'Lookup'];
						for(var q in lookup){		
							if(lookup.hasOwnProperty(q)){
								var sq = lookup[q];	
								if(sq){
									var fn = sq.tryMatch(seeds);
									if(fn){
										obj[p] = fn;
										break;
									}
								}						
							}
						}
					}
				}
				
				var matchFn = function(o, index){
					var i = index % seeds.length;
					var seed = seeds[i];
					var stype = checkDataType(seed);
					var foundFn = obj[stype];
					
					if(!foundFn){
						foundFn = loop.tryMatch(seeds);
					}
					
					return foundFn(o, index);
				}
				
				return matchFn;
			}
		};
	})();
});
Ext.define('EnterpriseSheet.sheet.autofill.ArithmeticSequence', {
	
	/* Begin Definitions */
		
	extend : 'EnterpriseSheet.sheet.autofill.Sequence',
	
	/* End Definitions */
	
	tryMatch : function(arr){				
		var num = 0, pre = false, cur = false, offset = false;
		
		for(var i = 0, len = arr.length; i < len; i++){
			if(SCOM.canbeNumber(arr[i].data)){
				num++;
				pre = cur;
				cur = Number(arr[i].data);
				if(false !== pre){
					if(false !== offset){
						if(offset !== cur-pre){
							return;
						}
					}else{
						offset = cur-pre;
					}
				}
			}
		}		
		if(1 <= num){
			offset = offset || 0;	
			/*
			 * pass the seeds by the scope
			 */	
			return Ext.Function.bind(this.grow, {seeds:arr, offset:offset, num:num});
		}
	}, 
	
	grow : function(o, index){
		if(0 !== this.offset){
			var len = this.seeds.length;		
			var i = index%len;
			var s = this.seeds[i];
			if(SCOM.canbeNumber(s.data)){
				var count = Math.floor(index/len);
				/*
				 * grow the number part
				 */
				o.data = Number(s.data)+count*this.num*this.offset;
			}
		}		
		return o;
	}
}, function(){	
	SQBOX.reg('arithmetic', 'number', new EnterpriseSheet.sheet.autofill.ArithmeticSequence());
});
Ext.define('EnterpriseSheet.sheet.autofill.DateSequence', {
	
	/* Begin Definitions */
		
	extend : 'EnterpriseSheet.sheet.autofill.Sequence',
	
	requires : [
	    'EnterpriseSheet.sheet.data.Format'
	],
	
	/* End Definitions */
	
	tryMatch : function(arr){				
		var num = 0, pre = false, cur = false, offset = false;
		
		for(var i = 0, len = arr.length; i < len; i++){
			var date = SFORMAT.checkingDate(arr[i].data);
			if(date){
				/*
				 * save the date
				 */
				arr[i].date = date;
				num++;
				pre = cur;
				cur = date;
				if(false !== pre){
					if(false !== offset){
						if(offset !== Ext.Date.getElapsed(cur, pre)){
							return;
						}
					}else{
						offset = Ext.Date.getElapsed(cur, pre);
					}
				}
			}
		}		
		if(1 < num){
			offset = offset || 0;	
			/*
			 * pass the seeds by the scope
			 */	
			return Ext.Function.bind(this.grow, {seeds:arr, offset:offset, num:num});
		}
	}, 
	
	grow : function(o, index){
		if(0 !== this.offset){
			var len = this.seeds.length;		
			var i = index%len;
			var s = this.seeds[i];
			if(Ext.isDate(s.date)){
				var count = Math.floor(index/len);
				/*
				 * grow the date
				 */
				var date = Ext.Date.add(s.date, Ext.Date.MILLI, count*this.num*this.offset);
				if(-1 == s.data.toString().indexOf(':')){
					o.data = Ext.Date.format(date, 'Y-m-d');
				}else{
					o.data = Ext.Date.format(date, 'Y-m-d H:i:s');
				}
			}
		}		
		return o;
	}
}, function(){	
	SQBOX.reg('date', 'datetime', new EnterpriseSheet.sheet.autofill.DateSequence());
});
Ext.define('EnterpriseSheet.sheet.autofill.GeometricSequence', {
	
	/* Begin Definitions */
		
	extend : 'EnterpriseSheet.sheet.autofill.Sequence',
	
	/* End Definitions */
	
	tryMatch : function(arr){		
		/*
		 * pass the seeds by the scope
		 */		
		var num = 0, pre = false, cur = false, offset = false;
		for(var i = 0, len = arr.length; i < len; i++){
			if(SCOM.canbeNumber(arr[i].data)){
				num++;
				pre = cur;
				cur = Number(arr[i].data);
				if(false !== pre){
					if(false !== offset){
						if(offset !== cur/pre){
							return;
						}
					}else{
						offset = cur/pre;
					}
				}
			}
		}		
		offset = offset || 1;		
		if(1 <= num){
			return Ext.Function.bind(this.grow, {seeds:arr, offset:offset, num:num});
		}		
	}, 
	
	grow : function(o, index){
		if(0 !== this.offset){
			var len = this.seeds.length;		
			var i = index%len;
			var s = this.seeds[i];
			if(SCOM.canbeNumber(s.data)){
				var count = Math.floor(index/len);
				/*
				 * grow the number part
				 */
				o.data = Number(s.data)*Math.pow(this.offset, this.num*count);
			}
		}		
		return o;
	}
}, function(){
	SQBOX.reg('geometric', 'number', new EnterpriseSheet.sheet.autofill.GeometricSequence());
});
Ext.define('EnterpriseSheet.sheet.autofill.TextSequence', {
	
	/* Begin Definitions */
		
	extend : 'EnterpriseSheet.sheet.autofill.Sequence',
	
	
	
	/* End Definitions */
	
	constructor : function(config){
		Ext.apply(this, config);
		
		this.stack = this.stack || [];
		
		this.setupWeek();
		
		this.setupMonth();
		
		this.callParent();		
	},
	
	/*
	 * add series for week
	 */
	setupWeek : function(){
		this.stack.push(SCONST.fullWeekNames);
		
		this.stack.push(SCONST.shortWeekNames);
	},
	
	/*
	 * add series for month
	 */
	setupMonth : function(){				
		this.stack.push(SCONST.fullMonthNames);
		
		this.stack.push(SCONST.shortMonthNames);
	},
	
	tryMatch : function(arr){			
		/*
		 * pass the seeds by the scope
		 */			
		for(var cursor = 0, size = this.stack.length; cursor < size; cursor++){
			var series = this.stack[cursor];
			var num = 0, texts = [], map = {}, start = false;
			for(var i = 0, len = arr.length; i < len; i++){
				if('text' == this.checkDataType(arr[i])){
					var str = arr[i].data || '';
					texts.push(str);
					if(false === start){
						for(var k = 0, count = series.length; k < count; k++){
							if(series[k].toLocaleLowerCase() == str.toLocaleLowerCase()){
								start = k;
								break;
							}
						}
						if(false === start){
							/*
							 * means no match
							 */
							break;
						}
					}
					map[i] = num;
					num++;
				}
			}	
			if(false === start){
				/*
				 * means no match
				 */
				continue;
			}
			var slen = series.length;
			if(num < slen){
				var st;
				if(start+num-1 < slen){
					st = series.slice(start, start+num);
				}else{
					st = series.slice(start, slen);
					st = st.concat(series.slice(0, num-slen+start));
				}
				
				if(st.join('&').toLocaleLowerCase() == texts.join('&').toLocaleLowerCase()){				
					return Ext.Function.bind(this.grow, {seeds:arr, series:series, map:map, num:num, start:start, me: this});
				}else{		
					/*
					 * it could be reversed
					 */
					if(start+1 >= num){
						st = series.slice(start-num+1, start+1);
						st.reverse();		
					}else{
						st = series.slice(0, start+1);
						st.reverse();
						st = st.concat(series.slice(slen-num+start+1, slen).reverse());
					}																	
					if(st.join('&').toLocaleLowerCase() == texts.join('&').toLocaleLowerCase()){		
						/*
						 * if it's match, then we set reverse to true
						 */
						return Ext.Function.bind(this.grow, {seeds:arr, series:series, map:map, num:num, start:start, reverse:true, me:this});
					}
				}
			}
		}		
	}, 
	
	grow : function(o, index){
		var me = this.me;
		var len = this.seeds.length;
		var count = Math.floor(index/len);
		var i = index%len;
		var s = this.seeds[i];
		var series = this.series;
		if('text' == me.checkDataType(s)){			
			if(this.reverse){
				index = this.start-(count*this.num+this.map[i]);
				index = index%series.length;
				if(0 > index){
					index += series.length;
				}
			}else{
				index = count*this.num+this.map[i]+this.start;
				index = index%series.length;
			}			
			o.data = series[index];
		}
		return o;
	}
}, function(){
	SQBOX.reg('textloop', 'text', new EnterpriseSheet.sheet.autofill.TextSequence());
});
Ext.define('EnterpriseSheet.sheet.autofill.TimeSequence', {
	
	/* Begin Definitions */
		
	extend : 'EnterpriseSheet.sheet.autofill.Sequence',
	
	requires : [
	    'EnterpriseSheet.sheet.data.Format'
	],
	
	/* End Definitions */
	
	tryMatch : function(arr){				
		var num = 0, pre = false, cur = false, offset = false;
		
		for(var i = 0, len = arr.length; i < len; i++){
			var date = SFORMAT.checkingTime(arr[i].data);
			if(date){
				/*
				 * save the date
				 */
				arr[i].date = date;
				num++;
				pre = cur;
				cur = date;
				if(false !== pre){
					if(false !== offset){
						if(offset !== Ext.Date.getElapsed(cur, pre)){
							return;
						}
					}else{
						offset = Ext.Date.getElapsed(cur, pre);
					}
				}
			}
		}		
		if(1 < num){
			offset = offset || 0;	
			/*
			 * pass the seeds by the scope
			 */	
			return Ext.Function.bind(this.grow, {seeds:arr, offset:offset, num:num});
		}
	}, 
	
	grow : function(o, index){
		if(0 !== this.offset){
			var len = this.seeds.length;		
			var i = index%len;
			var s = this.seeds[i];
			if(Ext.isDate(s.date)){
				var count = Math.floor(index/len);
				/*
				 * grow the date
				 */
				var date = Ext.Date.add(s.date, Ext.Date.MILLI, count*this.num*this.offset);
				if(-1 == s.data.toString().indexOf(':')){
					o.data = Ext.Date.format(date, 'Y-m-d');
				}else{
					o.data = Ext.Date.format(date, 'Y-m-d H:i:s');
				}
			}
		}		
		return o;
	}
}, function(){	
	SQBOX.reg('time', 'datetime', new EnterpriseSheet.sheet.autofill.TimeSequence());
});
Ext.define('EnterpriseSheet.sheet.autofill.Autofill', {
	
	/* Begin Definitions */
	
	requires : [
	    'Ext.button.Button',
	    'EnterpriseSheet.sheet.range.Range',
	    'EnterpriseSheet.sheet.floating.Floor',
	    'EnterpriseSheet.sheet.autofill.ArithmeticSequence',
	    'EnterpriseSheet.sheet.autofill.DateSequence',
	    'EnterpriseSheet.sheet.autofill.GeometricSequence',
	    'EnterpriseSheet.sheet.autofill.TextSequence',
	    'EnterpriseSheet.sheet.autofill.TimeSequence'
	],	
	
	/* End Definitions */
	
	kitOffset : [5, 5],
	
	constructor : function(config){
		
		this.initAutofilMenu();
		
		this.callParent();		
	},
	
	monitorChanging : true,
	
	init : function(sheet){
		if(!this.sheet){
			this.sheet = sheet;						
			
			sheet.on({
				scope:this,
				/*
				 * handler autofill
				 */
				'autofilldragend':this.doAutofill,
				'changing':this.hideAutofillKit,
                'changereadonly': this.onChangeReadOnly
			});
			sheet.on('beforestartedit', this.hideAutofillKit, this);		
		}		
	},
	
	/*
	 * _private, put the data in an array
	 */	
	prepareArray : function(span, dir, bottomup){		
		var sheet = this.sheet, store = sheet.getStore();
		var sheetId = span[0], minrow = span[1], mincol = span[2], maxrow = span[3], maxcol = span[4];
		var lookup = {}, o = {};
		if('col' == dir){
			store.walkRange([span], function(rd){
				var row = rd.data.row, col = rd.data.col;
				var cd = store.getCellData(rd.data.sheet, row, col);
				lookup[row] = lookup[row] || {};
				lookup[row][col] = cd;
			}, this, true);
			if(bottomup){				
				for(var r in lookup){
					if(lookup.hasOwnProperty(r)){
						o[r] = o[r] || [];
						var rowObj = lookup[r];
						for(var j = maxcol; j >= mincol; j--){
							o[r].push(rowObj[j] || {});
						}
					}
				}
			}else{
				for(var r in lookup){
					if(lookup.hasOwnProperty(r)){
						o[r] = o[r] || [];
						var rowObj = lookup[r];
						for(var j = mincol; j <= maxcol; j++){
							o[r].push(rowObj[j] || {});
						}
					}
				}
			}			
		}else{
			store.walkRange([span], function(rd){
				var row = rd.data.row, col = rd.data.col;
				var cd = store.getCellData(rd.data.sheet, row, col);
				lookup[col] = lookup[col] || {};
				lookup[col][row] = cd;
			}, this, true);
			if(bottomup){
				for(var c in lookup){
					if(lookup.hasOwnProperty(c)){
						o[c] = o[c] || [];
						var colObj = lookup[c];
						for(var i = maxrow; i >= minrow; i--){
							o[c].push(colObj[i] || {});
						}
					}
				}
			}else{				
				for(var c in lookup){
					if(lookup.hasOwnProperty(c)){
						o[c] = o[c] || [];
						var colObj = lookup[c];
						for(var i = minrow; i <= maxrow; i++){
							o[c].push(colObj[i] || {});
						}
					}
				}
			}					
		}
		return o;
	},
	
	/*
	 * do autofill on the selection
	 */
	doAutofill : function(originPos, region, sm){
		var flag = originPos.flag;
		var fromSpan = [originPos.sheet, originPos.minrow, originPos.mincol, originPos.maxrow, originPos.maxcol];								
		var toSpan = sm.selection2Span();
		/*
		 * check whether there is some merged cell in fromSpan
		 */
		//toSpan = sm.adjustToSpanForMerged(fromSpan, toSpan);
		
		if(toSpan){
			this.autofilling(fromSpan, toSpan, flag);	
			
			/*
			 * default to fill sequence, we need show it on UI
			 */
			if(this.autofillKit){
				this.autofillMenu.items.get(1).setChecked(true, true);
			}
		}else{
			Ext.Msg.alert(SLANG['hint'], SLANG['target_range_shouldbe_same_size']);
		}			
	},
	
	/*
	 * autofill fromSpan to toSpan
	 */
	autofilling : function(fromSpan, toSpan, dotFlag, fillType){			
		var sheet = this.sheet, store = sheet.getStore();
		/*
		 * check the valid
		 */
		
		if(store.withBrokenMergedCell([fromSpan, toSpan])){
			Ext.Msg.alert(SLANG['hint'], SLANG['can_not_change_part_merged_cell']);
			return;
		}
		/*
		 * save it
		 */
		this.fromSpan = SCOM.copy(fromSpan);		
		this.toSpan = SCOM.copy(toSpan);
		
		this.dotFlag = ('lt' == dotFlag);
		
		var frowLen = fromSpan[3]-fromSpan[1]+1, fcolLen = fromSpan[4]-fromSpan[2]+1;
		var trowLen = toSpan[3]-toSpan[1]+1, tcolLen = toSpan[4]-toSpan[2]+1;
		var fromCoord = [fromSpan], toCoord = [toSpan];
				
		/*
		 * if the toCoord is not the same as fromCoord then do the autofill
		 */
		if(frowLen != trowLen || fcolLen != tcolLen){
			var dir = frowLen != trowLen ? 'row' : 'col';
			/*
			 * a flag to check whether the fromSpan include the toSpan
			 */
			var includeFlag = fromSpan[0] === toSpan[0]
				&& fromSpan[1] <= toSpan[1] && fromSpan[3] >= toSpan[3]
				&& fromSpan[2] <= toSpan[2] && fromSpan[4] >= toSpan[4];
				
			var range = new EnterpriseSheet.sheet.range.Range({
				sheet:sheet,
				coord:includeFlag ? fromCoord : toCoord
			});
			var originCdts = sheet.getCdtsFromCoord(fromCoord);
			
			if(false !== sheet.fireEvent('beforeautofill', range, fromCoord, sheet, originCdts)){
				/*
				 * get the cells need recalculated
				 */
				var reCalCells = sheet.getRecalculateCellsByCoord(toCoord);				
				
				var changedHeights = {};
				sheet.fireEvent('prepareautofill', range, fromCoord, sheet, originCdts, reCalCells, changedHeights);
				if(includeFlag){
					/*
					 * if the fromSpan include the toSpan, then need clean the offset part
					 */
					var offsetSpan;
					var minrow = fromSpan[1], mincol = fromSpan[2], maxrow = fromSpan[3], maxcol = fromSpan[4];
					if(fromSpan[1] == toSpan[1] && fromSpan[2] == toSpan[2]){
						if(fromSpan[4] == toSpan[4]){
							minrow = toSpan[3]+1;				
						}else{
							mincol = toSpan[4]+1;
						}			
					}else{
						if(fromSpan[2] == toSpan[2]){
							maxrow = toSpan[1]-1;
						}else{
							maxcol = toSpan[2]-1;
						}
					}
					offsetSpan = [fromSpan[0], minrow, mincol, maxrow, maxcol];					
					
					var offsetRange = new EnterpriseSheet.sheet.range.Range({
						sheet:sheet,
						coord:[offsetSpan]
					});					
					/*
					 * clean the offset range and suspend the clean event
					 */
					offsetRange.cleanContent(true);
					this.hideAutofillKit();
				}else{
					if(fillType && this[fillType]){
						this[fillType](fromSpan, toSpan, dir, this.dotFlag, reCalCells);					
					}else{
						this.fillSequence(fromSpan, toSpan, dir, this.dotFlag, reCalCells);
					}				
					this.showAutofillKit(range);
				}		
				
				/*
				 * check autoHeight change
				 */
				if(range.isCellCoord()){
					Ext.apply(changedHeights, sheet.checkAutoHeightForCoord(fromCoord, range.getCoord(), false, true));
				}
				sheet.fireEvent('autofill', range, fromCoord, sheet, originCdts, reCalCells);
			}
		}
	},
	
	initAutofilMenu : function(){
		this.autofillMenu = this.autofillMenu || new Ext.menu.Menu({
			defaults:{
				group:'autofill-type',
				scope:this
			},
			items:[{		
				checked:false,
				text:SLANG['copy_cell'],
				handler:function(){
					if('copyCell' != this.curFillType){			
						/*
						 * hold the refresh and changing event
						 */
						this.sheet.fireEvent('undo', true, true);
						/*
						 * disable the changing listener temporary
						 */
						this.monitorChanging = false;
						this.autofilling(this.fromSpan, this.toSpan, this.dotFlag, 'copyCell');
						this.monitorChanging = true;
					}
				}					
			}, {
				checked:true,
				text:SLANG['fill_sequence'],
				handler:function(){
					if('fillSequence' != this.curFillType){
						/*
						 * hold the refresh and changing event
						 */
						this.sheet.fireEvent('undo', true, true);
						/*
						 * disable the changing listener temporary
						 */
						this.monitorChanging = false;
						this.autofilling(this.fromSpan, this.toSpan, this.dotFlag, 'fillSequence');
						this.monitorChanging = true;
					}
				}
			}, {
				checked:false,
				text:SLANG['only_fill_style'],
				handler:function(){
					if('fillStyle' != this.curFillType){
						/*
						 * hold the refresh and changing event
						 */
						this.sheet.fireEvent('undo', true, true);
						/*
						 * disable the changing listener temporary
						 */
						this.monitorChanging = false;
						this.autofilling(this.fromSpan, this.toSpan, this.dotFlag, 'fillStyle');
						this.monitorChanging = true;
					}
				}
			}, {
				checked:false,
				text:SLANG['fill_without_style'],
				handler:function(){
					if('fillContent' != this.curFillType){
						/*
						 * hold the refresh and changing event
						 */
						this.sheet.fireEvent('undo', true, true);
						/*
						 * disable the changing listener temporary
						 */
						this.monitorChanging = false;
						this.autofilling(this.fromSpan, this.toSpan, this.dotFlag, 'fillContent');
						this.monitorChanging = true;
					}
				}
			}, , {
				checked:false,
				text:SLANG['copy_without_style'],
				handler:function(){
					if('copyContent' != this.curFillType){
						/*
						 * hold the refresh and changing event
						 */
						this.sheet.fireEvent('undo', true, true);
						/*
						 * disable the changing listener temporary
						 */
						this.monitorChanging = false;
						this.autofilling(this.fromSpan, this.toSpan, this.dotFlag, 'copyContent');
						this.monitorChanging = true;
					}
				}
			}]			
		}); 
	},
	
	/*
	 * show a autofill tool kit on the UI
	 */
	showAutofillKit : function(range){		
		var maxPos = range.getMaxPos();
		var store = this.sheet.getStore(), sheetId = this.sheet.getSheetId();
		var x = store.getRangeWidth(sheetId, 1, maxPos.col)+this.kitOffset[0];
		var y = store.getRangeHeight(sheetId, 1, maxPos.row)+this.kitOffset[1];
		if(!this.autofillKit){						
			this.autofillKit = new EnterpriseSheet.sheet.floating.Floor({
				sheet:this.sheet,
                localKit: true,
				floatingConfig:{
					xtype:'button',
					iconCls:'icon-autofill',
					x:x,
					y:y,
					ddConfig:false,
					destroyMenu: false,
					resizeConfig:false,
					menu: true,
                    handler: function(btn){
                        this.autofillMenu.showBy(btn);
                    },
                    scope: this
				}
			});
		}else{			
			this.autofillKit.setXY([x, y]);
		}		
		this.autofillKit.show();
	},
	
	/*
	 * hide the clipKit and destory related comp
	 */
	hideAutofillKit : function(){		
		if(this.monitorChanging && this.autofillKit){			
			//this.autofillKit.destroy();
			//delete(this.autofillKit);
			this.autofillKit.hide();
		}
	},
	
	/*********************************
	 * below are few different types of fill
	 **********************************/
	copyCell : function(fromSpan, toSpan, dir, dotFlag, reCalCells){
		this.curFillType = 'copyCell';		
				
		/*
		 * copy the data from the fromCoord to the toCoord,
		 * grow the value based on the matched sequence 
		 */
		this.sheet.apply2Span(fromSpan, toSpan, null, null, dotFlag, undefined, undefined, reCalCells);
	},
	
	fillSequence : function(fromSpan, toSpan, dir, dotFlag, reCalCells){		
		this.curFillType = 'fillSequence';
		var frowLen = 0 == fromSpan[3] ? 0 : fromSpan[3]-fromSpan[1]+1, 
			fcolLen = 0 == fromSpan[4] ? 0 : fromSpan[4]-fromSpan[2]+1;
		var trowLen = 0 == toSpan[3] ? 0 : toSpan[3]-toSpan[1]+1, 
			tcolLen = 0 == toSpan[4] ? 0 : toSpan[4]-toSpan[2]+1;
		var sheet = this.sheet;
		var ftflag = dotFlag ? ('row' == dir ? 'b2t' : 'r2l') : false;
		/*
		 * prepare the data
		 */		
		
		var arrObj = this.prepareArray(fromSpan, dir, dotFlag), grows = {};
		
		for(var p in arrObj){
			if(arrObj.hasOwnProperty(p)){
				/*
				 * try to match with the sequence, save the returned grow function
				 */
				grows[p] = SQBOX.tryMatch(arrObj[p]);				
			}			
		}		
		var tmpFn = function(){
			return arguments[0];
		}
		/*
		 * copy the data from the fromCoord to the toCoord,
		 * grow the value based on the matched sequence 
		 */
		sheet.apply2Span(fromSpan, toSpan, null, function(cd, row, col){
			if('row' == dir){
				
				if(0 != fcolLen){					
					col = (col-fromSpan[2])%fcolLen;
					if(0 > col){
						col += grows.length;
					}
					col += fromSpan[2];
				}				
				if(row >= fromSpan[1]){
					row = row-fromSpan[1];
				}else{
					row = fromSpan[3]-row;
				}			
				var fn = grows[col] || tmpFn;
				return fn(cd, row);
			}else{
				if(0 != frowLen){
					row = (row-fromSpan[1])%frowLen;
					if(0 > row){
						row += grows.length;
					}
					row += fromSpan[1];
				}				
				if(col >= fromSpan[2]){
					col = col-fromSpan[2];
				}else{
					col = fromSpan[4]-col;
				}			
				var fn = grows[row] || tmpFn;
				return fn(cd, col);
			}
		}, ftflag, undefined, undefined, reCalCells);
	},
	
	fillStyle : function(fromSpan, toSpan, dir, dotFlag, reCalCells){
		this.curFillType = 'fillStyle';		
		
		/*
		 * copy the data from the fromCoord to the toCoord,
		 * grow the value based on the matched sequence 
		 */
		this.sheet.apply2Span(fromSpan, toSpan, 'style', null, dotFlag, undefined, undefined, reCalCells);
	},
	
	fillContent : function(fromSpan, toSpan, dir, dotFlag, reCalCells){
		this.curFillType = 'fillContent';		
		
		var frowLen = 0 == fromSpan[3] ? 0 : fromSpan[3]-fromSpan[1]+1, 
				fcolLen = 0 == fromSpan[4] ? 0 : fromSpan[4]-fromSpan[2]+1;
			var trowLen = 0 == toSpan[3] ? 0 : toSpan[3]-toSpan[1]+1, 
				tcolLen = 0 == toSpan[4] ? 0 : toSpan[4]-toSpan[2]+1;
			var sheet = this.sheet;
			var ftflag = dotFlag ? ('row' == dir ? 'b2t' : 'r2l') : false;
			/*
			 * prepare the data
			 */		
			
			var arrObj = this.prepareArray(fromSpan, dir, dotFlag), grows = {};
			
			for(var p in arrObj){
				if(arrObj.hasOwnProperty(p)){
					/*
					 * try to match with the sequence, save the returned grow function
					 */
					grows[p] = SQBOX.tryMatch(arrObj[p]);				
				}			
			}		
			var tmpFn = function(){
				return arguments[0];
			}
			/*
			 * copy the data from the fromCoord to the toCoord,
			 * grow the value based on the matched sequence 
			 */
			sheet.apply2Span(fromSpan, toSpan, 'data', function(cd, row, col){
				if('row' == dir){
					
					if(0 != fcolLen){					
						col = (col-fromSpan[2])%fcolLen;
						if(0 > col){
							col += grows.length;
						}
						col += fromSpan[2];
					}				
					if(row >= fromSpan[1]){
						row = row-fromSpan[1];
					}else{
						row = fromSpan[3]-row;
					}			
					var fn = grows[col] || tmpFn;
					return fn(cd, row);
				}else{
					if(0 != frowLen){
						row = (row-fromSpan[1])%frowLen;
						if(0 > row){
							row += grows.length;
						}
						row += fromSpan[1];
					}				
					if(col >= fromSpan[2]){
						col = col-fromSpan[2];
					}else{
						col = fromSpan[4]-col;
					}			
					var fn = grows[row] || tmpFn;
					return fn(cd, col);
				}
			}, ftflag, undefined, undefined, reCalCells);
	},
	
	copyContent : function(fromSpan, toSpan, dir, dotFlag, reCalCells){
		this.curFillType = 'copyContent';		
		
		/*
		 * copy the data from the fromCoord to the toCoord,
		 * grow the value based on the matched sequence 
		 */
		this.sheet.apply2Span(fromSpan, toSpan, 'data', null, dotFlag, undefined, undefined, reCalCells);
	},
           
    onChangeReadOnly : function(readOnly, sheet){
        if(readOnly){
            this.hideAutofillKit();
        }
    }
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.resize.ColumnResizer', {
	
	/* Begin Definitions */
	
	extend: 'Ext.util.Observable',
	
	requires : ['EnterpriseSheet.common.Tip'],
			
	/* End Definitions */
	
	constructor : function(config){
		Ext.apply(this, config);
		
		this.callParent(arguments);
		
		
	},
	
	/*
	 * the width of the col resizer element
	 */
	colResizerWidth : 5,
	
	init : function(region){
		this.region = region;
		this.mon(region, 'afterrender', this.prepareResizer, this);
		this.mon(region, 'cellmousemove', this.onCellMouseMove, this);
	},
	
	/*
	 * render the resizer and init it
	 */
	prepareResizer : function(p){	
		var el = p.getEl();
		this.cel = Ext.core.DomHelper.append(el, '<div class="ss-crz ss-crzx" style="width:'+this.colResizerWidth+'px;"></div>', true);	
		this.mon(this.cel, 'dblclick', this.onDblClick, this);
		this.cel.addClsOnOver('ss-crzx-over');
		this.cel.hide();
		
		this.cdd = new Ext.dd.DD(this.cel.id, 'swift', {
			scroll:false				
		});
		
		this.cdd.b4MouseDown = Ext.Function.createSequence(Ext.dd.DD.prototype.b4MouseDown, this.b4MouseDown, this);
		this.cdd.onDrag = Ext.Function.bind(this.onColResizing, this);
		this.cdd.endDrag = Ext.Function.bind(this.onColResized, this);
		
		/*
		 * define proxy
		 */
		if('string' == SCOM.typeOf(this.proxy)){				
			this.proxy = Ext.get(this.proxy);
		}
		if(!this.proxy instanceof Ext.Element){
			this.proxy = Ext.core.DomHelper.append(document.body, '<div class="ss-crz-xproxy" style="z-index:'+SCONST['TOP_Z_INDEX']+';"></div>', true);
		}
	},		
	
	onDblClick : function(e){
		var region = this.getRegion(), store = region.getStore(), 
			sheetId = region.getSheetId();	
		/*
		 * get the max width could be for this column
		 */
		var col = this.col; 
		var w = region.guessMaxColumnWidth(sheetId, col)+20;
		
		/*
		 * old width
		 */
		var sw = store.getColWidth(sheetId, col);
		if(w && w != sw){	
			var old = {}, cur = {};
			old[col] = sw;
			cur[col] = w;
			region.resizeColumn(col, w, true);	
			this.cel.hide();			
			/*
			 * fire columnresized event
			 */			
			this.fireEvent('columnresized', col, old, cur, region, this);
			this.resetFlag();
		}else{
			delete(this.disableMouseOver);
			/*
			 * resume the trackMouseOver flag when finished resize
			 */
			this.region.resumeTrackMouseOver();
			this.cel.removeCls('ss-crzx-drag');	
		}	
	},
	
	resetFlag : function(){
		/*
		 * reset flags
		 */
		delete(this.pos);
		delete(this.spos);
		delete(this.row);
		delete(this.col);
		delete(this.disableMouseOver);
		/*
		 * resume the trackMouseOver flag when finished resize
		 */
		this.region.resumeTrackMouseOver();
		this.cel.removeCls('ss-crzx-drag');
	},
		
	onColResized : function(e){					
		var region = this.getRegion(), store = region.getStore(), sm = region.getSelectionModel();
		var sheetId = region.getSheetId();
		var row = this.row, col = this.col, flag = false, cellEl, cw;
		var mincol, maxcol, old = {}, cur = {};		
		var span = sm.selection2Span();
		if(span[2] <= col && col <= span[4]){
			cellEl = region.getCellEl(row, col);
			cw = cellEl.getWidth();
			if(false === this.fireEvent('selectedcolumnresized', cw, span[2], span[4], this)){
				this.cel.hide();
				this.proxy.hide();
				SQTIP.hide();
				/*
				 * reset flags
				 */
				this.resetFlag();
				return;
			}
		}
		/*
		 * loop from "low" to "col-1" to find out which columns changed, because it could be more than 1 column are changed
		 */
		for(var i = region.colStart; i < col; i++){			
			cellEl = region.getCellEl(row, i);
			/*
			 * only check the existed cell element, so it means we don't need care about hidden column
			 */
			if(cellEl){				
				cw = cellEl.getWidth();				
				if(0 == cw){
					/*
					 * if width is 0, then means this column will be hidden,
					 * we use mincol and maxcol to record the span of columns need be hidden
					 */
					if(!flag){
						mincol = i;
					}
					maxcol = i;
					flag = true;					
				}else{					
					var sw = store.getColWidth(sheetId, i);
					if(sw != cw){
						/*
						 * save the old width
						 */	
						old[i] = sw;
						cur[i] = cw;
						/*
						 * if the width of the element is not equal the width in store, then means this column is changed,
						 * we need update the width to store
						 */						
						store.setColumnWidth(sheetId, i, cw, true, true);
					}
				}
			}
		}
		/*
		 * below will check the "col" column, because it's special
		 */
		cellEl = region.getCellEl(row, col);
		cw = cellEl.getWidth();
		if(0 == cw){
			/*
			 * means we need hide the "col" column
			 */
			if(flag){
				maxcol++;
			}else{
				old[col] = true;
				cur[col] = false;
				/*
				 * hide the "col" column
				 */
				store.hideColumn(sheetId, col, col);
			}
		}else{	
			var sw = store.getColWidth(sheetId, col);
			if(sw != cw){
				/*
				 * save the old width
				 */			
				old[col] = sw;
				cur[col] = cw;
				store.setColumnWidth(sheetId, col, cw, true, flag);
			}
		}
		if(flag){		
			for(var k = mincol; k <= maxcol; k++){
				old[k] = true;
				cur[k] = false;
			}
			store.hideColumn(sheetId, mincol, maxcol);
		}
		/*
		 * hide the element, proxy and tip
		 */
		this.cel.hide();
		this.proxy.hide();
		SQTIP.hide();
		/*
		 * fire columnresized event
		 */				
		this.fireEvent('columnresized', this.col, old, cur, region, this);
		/*
		 * reset flags
		 */
		this.resetFlag();
	},
	
	b4MouseDown : function(x, y){
		/*
		 * disable trackMouseOver for region when resizing
		 */		
		this.region.switchTrackMouseOver(false);
		this.disableMouseOver = true;
		this.cel.addCls('ss-crzx-drag');
	},
	
	onColResizing : function(e){
		var region = this.getRegion(), store = region.getStore();
		var sheetId = region.getSheetId();
		var row = this.row, col = this.col;
		var r = this.cel.getRight(), offset = r-this.pos[0];	
		this.pos[0] = r;	
		if(0 != offset){
			var xy = region.getCellEl(row, col).getXY();
			var woff = offset, w = 0;
			if(0 < woff){
				var i;
				for(i = region.colStart; i < col; i++){										
					var cellEl = region.getCellEl(row, i);
					if(cellEl){						
						var cw = cellEl.getWidth();
						var sw = store.getColWidth(sheetId, i);
						woff += cw-sw;
						if(0 >= woff){
							region.setCellElSize(row, i, sw+woff);
							woff = 0;
							break;
						}else{
							region.setCellElSize(row, i, sw);
						}
					}
				}
				if(i == col){
					var cellEl = region.getCellEl(row, col);
					w = cellEl.getWidth()+woff;
					region.setCellElSize(row, col, w);	
				}				
			}else{
				for(var i = col, low = region.colStart; i >= low; i--){					
					var cellEl = region.getCellEl(row, i);
					if(cellEl){						
						var cw = cellEl.getWidth();
						woff += cw;
						if(0 <= woff){
							if(i == col){
								w = woff;
							}
							region.setCellElSize(row, i, woff);
							break;
						}else{
							region.setCellElSize(row, i, 0);
						}
					}
				}
			}	
			region.updateOffsetWidth(offset);
			/*
			 * defer to show the tip and proxy
			 */
			var pEl = Ext.get(this.proxy.dom.parentNode);
			this.proxy.setLeft(0);
			this.proxy.setWidth(r-pEl.getLeft()-1);		
			this.proxy.show();
			SQTIP.show(SLANG['column_width']+': '+w+'px', this.cel, xy);
		}
	},	
	
	onCellMouseMove : function(row, col, region, e){
		if(!this.disableMouseOver && !region.isAutofillPress() && !region.isReadOnly()){
			var cEl = region.getCellEl(row, col);
			if(cEl){				
				if(this.cel){	
					if(row != this.row || col != this.col){
						
						var xy = e.getXY();
						var r = cEl.getRight();												
						var h = cEl.getHeight();
						var rEl = region.getEl();
						var minx = rEl.getLeft(), maxx = Ext.getBody().getWidth();
						var left = r-minx-this.colResizerWidth;
						var right = maxx-r;
						if(Math.abs(xy[0]-r) <= this.colResizerWidth){
							this.cel.setHeight(h-1);
							this.cel.setLeft(left);
							this.cel.setTop(0);
							this.cel.show();
							/*
							 * set it as the initial position for the DD 
							 */
							this.cdd.setInitPosition();
							this.cdd.resetConstraints();
							/*
							 * set the constarint, the dd should not out of region element
							 */
							this.cdd.setXConstraint(left+this.colResizerWidth, right);
							this.cdd.setYConstraint(0, 0);
							/*
							 * save the row, col index and the position
							 */
							this.row = row;
							this.col = col;
							right = this.cel.getRight();
							var bottom = this.cel.getBottom();
							/*
							 * pos will change when resizing, but spos only change at mouseover
							 */
							this.pos = [right, bottom];
							this.spos = [right, bottom];
							return;
						}
					}
				}					
			}
		}
	},
	
	getRegion : function(){
		return this.region;
	},
	
	destroy: function(){
		var r = this.getRegion();
		r.un('afterrender', this.prepareResizer, this);
		r.un('cellmouseover', this.onCellMouseOver, this);
        this.clearListeners();
    }
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.resize.RowResizer', {
	
	/* Begin Definitions */
	
	extend: 'Ext.util.Observable',
	
	requires : ['EnterpriseSheet.common.Tip'],
			
	/* End Definitions */
	
	constructor : function(config){
		Ext.apply(this, config);
		
		this.callParent(arguments);
		
		
	},
	
	/*
	 * the height of the row resizer handler
	 */	
	rowResizerHeight : 5,
	
	init : function(region){
		this.region = region;
		this.mon(region, 'afterrender', this.prepareResizer, this);
		this.mon(region, 'cellmousemove', this.onCellMouseMove, this);
	},
	
	/*
	 * render the resizer and init it
	 */
	prepareResizer : function(p){	
		var el = p.getEl();		
		this.rel = Ext.core.DomHelper.append(el, '<div class="ss-crz ss-crzy" style="height:'+this.rowResizerHeight+'px;"></div>', true);	
		this.mon(this.rel, 'dblclick', this.onDblClick, this);
		this.rel.addClsOnOver('ss-crzy-over');
		this.rel.hide();
		
		this.rdd = new Ext.dd.DD(this.rel.id, 'swift', {
			scroll:false				
		});
		this.rdd.b4MouseDown = Ext.Function.createSequence(Ext.dd.DD.prototype.b4MouseDown, this.b4MouseDown, this);
		this.rdd.onDrag = Ext.Function.bind(this.onRowResizing, this);
		this.rdd.endDrag = Ext.Function.bind(this.onRowResized, this);
		this.rdd.setXConstraint(0, 0);
		
		/*
		 * define proxy
		 */
		if('string' == SCOM.typeOf(this.proxy)){					
			this.proxy = Ext.get(this.proxy);
		}
		if(!(this.proxy instanceof Ext.Element)){
			this.proxy = Ext.core.DomHelper.append(document.body, '<div class="ss-crz-yproxy" style="z-index:'+SCONST['TOP_Z_INDEX']+';"></div>', true);
		}
	},		
	
	onDblClick : function(e){
		var region = this.getRegion(), store = region.getStore(), 
			sheetId = region.getSheetId();		
		/*
		 * get the max height could be for this row
		 */
		var row = this.row; 
		var h = region.guessMaxRowHeight(sheetId, row);
		if(SCOM.nullOrUndefined(h)){
			h = store.defaultProperty.height+store.cellHeightOffset;
		}
		/*
		 * old height
		 */
		var sh = store.getRowHeight(sheetId, row);
		if(h && h != sh){	
			var rowPro = store.getCell(sheetId, row, 0);
			var old = {
				'height': rowPro.height,
				'autoHeight': rowPro.autoHeight,
				'hoff': rowPro.hoff
			};						
			region.resizeRowAutoHeight(row, h, true);
			rowPro = store.getCell(sheetId, row, 0);
			var cur = {
				'height': rowPro.height,
				'autoHeight': rowPro.autoHeight,
				'hoff': rowPro.hoff
			};	
			this.rel.hide();
			/*
			 * fire rowautoresized event
			 */
			this.fireEvent('rowautoresized', row, old, cur, region, this);
			this.resetFlag();
		}else{
			delete(this.disableMouseOver);
			/*
			 * resume the trackMouseOver flag when finished resize
			 */
			this.region.resumeTrackMouseOver();
			this.rel.removeCls('ss-crzy-drag');
		}	
	},
	
	onRowResized : function(e){	
		var region = this.getRegion(), store = region.getStore(), sm = region.getSelectionModel();
		var sheetId = region.getSheetId();
		var row = this.row, col = this.col, flag = false, rowEl, ch;
		var minrow, maxrow, old = {}, cur = {};		
		var span = sm.selection2Span();
		if(span[1] <= row && row <= span[3]){
			rowEl = region.getRowEl(row);
			ch = rowEl.getHeight();
			if(false === this.fireEvent('selectedrowresized', ch, span[1], span[3], this)){
				this.rel.hide();
				this.proxy.hide();
				SQTIP.hide();
				/*
				 * reset flags
				 */
				this.resetFlag();
				return;
			}
		}
		/*
		 * loop from "low" to "row-1" to find out which rows changed, because it could be more than 1 row are changed
		 */
		for(var i = region.rowStart; i < row; i++){			
			rowEl = region.getRowEl(i);
			if(rowEl){				
				ch = rowEl.getHeight();				
				if(0 == ch){
					/*
					 * if height is 0, then means this row will be hidden,
					 * we use minrow and maxrow to record the span of rows need be hidden
					 */
					if(!flag){
						minrow = i;
					}
					maxrow = i;
					flag = true;					
				}else{					
					var sh = store.getRowHeight(sheetId, i);					
					if(sh != ch){
						/*
						 * save the old width
						 */	
						var rowPro = store.getCell(sheetId, i, 0);
						old[i] = {
							'height': rowPro.height,
							'autoHeight': rowPro.autoHeight,
							'hoff': rowPro.hoff
						};
						cur[i] = ch;
						/*
						 * if the height of the element is not equal the height in store, then means this height is changed,
						 * we need update the height to store
						 */												
						store.setRowHeight(sheetId, i, ch, true, true);						
					}
				}
			}
		}
		/*
		 * below will check the "row" row, because it's special
		 */
		rowEl = region.getRowEl(row);
		ch = rowEl.getHeight();
		if(0 == ch){
			if(flag){
				maxrow++;
			}else{
				old[row] = true;
				cur[row] = false;
				/*
				 * hide the "row" row
				 */
				store.hideRow(sheetId, row, row);
			}
		}else{			
			var sh = store.getRowHeight(sheetId, row);
			if(sh != ch){
				/*
				 * save the old width
				 */		
				var rowPro = store.getCell(sheetId, row, 0);
				old[row] = {
					'height': rowPro.height,
					'autoHeight': rowPro.autoHeight,
					'hoff': rowPro.hoff	
				};
				cur[row] = ch;
				store.setRowHeight(sheetId, row, ch, true, flag);
			}					
		}
		if(flag){
			for(var k = minrow; k <= maxrow; k++){
				old[k] = true;
				cur[k] = false;
			}
			store.hideRow(sheetId, minrow, maxrow);
		}
		/*
		 * hide the element, proxy and tip
		 */
		this.rel.hide();
		this.proxy.hide();
		SQTIP.hide();
		/*
		 * fire rowresized event
		 */
		this.fireEvent('rowresized', this.row, old, cur, region, this);
		/*
		 * reset flags
		 */
		this.resetFlag();
	},
	
	resetFlag : function(){
		/*
		 * reset flags
		 */
		delete(this.pos);
		delete(this.spos);
		delete(this.row);
		delete(this.col);
		delete(this.disableMouseOver);
		/*
		 * resume the trackMouseOver flag when finished resize
		 */
		this.region.resumeTrackMouseOver();
		this.rel.removeCls('ss-crzy-drag');
	},
	
	onRowResizing : function(e){		
		var region = this.getRegion(), store = region.getStore();
		var sheetId = region.getSheetId();
		var row = this.row, col = this.col;
		var b = this.rel.getBottom(), offset = b-this.pos[1];	
		this.pos[1] = b;	
		if(0 != offset){
			var xy = region.getCellEl(row, col).getXY();
			var hoff = offset, h = 0;
			if(0 < hoff){
				var i;
				for(i = region.rowStart; i < row; i++){										
					var rowEl = region.getRowEl(i);
					if(rowEl){
						/*
						 * only process the visible row
						 */						
						var ch = rowEl.getHeight();
						var sh = store.getRowHeight(sheetId, i);
						hoff += ch-sh;
						if(0 >= hoff){
							region.setRowElHeight(i, sh+hoff);
							hoff = 0;
							break;
						}else{
							region.setRowElHeight(i, sh);
						}
					}
				}
				if(i == row){
					var rowEl = region.getRowEl(row);
					h = rowEl.getHeight()+hoff;
					region.setRowElHeight(row, h, true);
				}				
			}else{
				for(var i = row, low = region.rowStart; i >= low; i--){					
					var rowEl = region.getRowEl(i);
					if(rowEl){						
						var ch = rowEl.getHeight();
						hoff += ch;
						if(0 <= hoff){
							if(i == row){
								h = hoff;
							}
							region.setRowElHeight(i, hoff);
							break;
						}else{
							region.setRowElHeight(i, 0);
						}
					}
				}
			}	
			region.updateOffsetHeight(offset);
			/*
			 * defer to show the tip and proxy
			 */
			var pEl = Ext.get(this.proxy.dom.parentNode);
			this.proxy.setTop(0);
			this.proxy.setHeight(b-pEl.getTop()-1);		
			this.proxy.show();
			SQTIP.show(SLANG['row_height']+': '+h+'px', this.rel);
		}
	},		
	
	b4MouseDown : function(x, y){
		/*
		 * disable trackMouseOver for region when resizing
		 */		
		this.region.switchTrackMouseOver(false);
		this.disableMouseOver = true;
		this.rel.addCls('ss-crzy-drag');
	},			
	
	onCellMouseMove : function(row, col, region, e){
		if(!this.disableMouseOver && !region.isAutofillPress() && !region.isReadOnly()){
			var cEl = region.getCellEl(row, col);
			if(cEl){					
				if(this.rel){				
					var xy = e.getXY();
					if(row != this.row || col != this.col){
						var b = cEl.getBottom();												
						var w = cEl.getWidth();
						var rEl = region.getEl();
						var miny = rEl.getTop(), maxy = Ext.getBody().getHeight();
						var top = b-miny-this.rowResizerHeight;
						var bottom = maxy-b;
						if(Math.abs(xy[1]-b) <= this.rowResizerHeight){
							this.rel.setWidth(w-1);
							this.rel.setTop(top);
							this.rel.setLeft(0);
							this.rel.show();
							/*
							 * set it as the initial position for the DD 
							 */
							this.rdd.setInitPosition();
							this.rdd.resetConstraints();
							/*
							 * set the constarint, the dd should not out of region element
							 */
							this.rdd.setYConstraint(top+this.rowResizerHeight, bottom);
							this.rdd.setXConstraint(0, 0);
							/*
							 * save the row, col index and the position
							 */
							this.row = row;
							this.col = col;
							right = this.rel.getRight();
							var bottom = this.rel.getBottom();
							/*
							 * pos will change when resizing, but spos only change at mouseover
							 */
							this.pos = [right, bottom];
							this.spos = [right, bottom];
						}
					}
				}
			}			
		}
	},
	
	getRegion : function(){
		return this.region;
	},
	
	destroy: function(){
		var r = this.getRegion();
		r.un('afterrender', this.prepareResizer, this);
		r.un('cellmouseover', this.onCellMouseOver, this);
        this.clearListeners();
    }
});
Ext.define('EnterpriseSheet.sheet.sm.AbstractSelectionModel', {
	/* Begin Definitions */
	
	extend : 'Ext.util.Observable',
	
	/* End Definitions */
	
	autofillCls : 'ss-autofill',
	
	constructor: function(config) {
		Ext.apply(this, config);
		
		this.callParent([config]);
		
		
		
		Ext.getDoc().on('mouseup', this.resetAutofill, this);
	},
	
	init : function(region){
		this.region = region;
		this.mon(region, 'afterrender', this.prepareAfterRender, this);
		
		this.bindListener2Region(region);	
	},
	
	/*
	 * calculate the row/col span based on the passed span
	 */
	calculateRowColSpan : function(fromSpan){
		var rowSpan = 1, colSpan = 1;
		var hasMerged = false;
		var store = this.getRegion().getStore(), sm = this, tmpCache = {};
		store.walkRange([fromSpan], function(rd, span, store){
			var json = rd.data.json;
			if(store.isMergedCell(json, rd.data.sheet, rd.data.row, rd.data.col)){
				var arr = [json.maxrow-json.minrow+1, json.maxcol-json.mincol+1];
				var id = arr.join('$');
				tmpCache[id] = arr;				
			}else{
				tmpCache['single'] = true;
			}
			if(1 < SCOM.countObjMember(tmpCache)){
				hasMerged = true;
				return false;
			}
		}, this);
		
		if(hasMerged){
			rowSpan = fromSpan[3]-fromSpan[1]+1;
			colSpan = fromSpan[4]-fromSpan[2]+1;
		}else if(1 == SCOM.countObjMember(tmpCache) && !tmpCache['single']){
			hasMerged = true;			
			for(var p in tmpCache){
				if (tmpCache.hasOwnProperty(p)) {
					var arr = tmpCache[p];
					rowSpan = arr[0];
					colSpan = arr[1];
				}
			}			
		}
		return {
			hasMerged: hasMerged,
			rowSpan: rowSpan,
			colSpan: colSpan
		}
	},
	
	/*
	 * adjust toSpan based on fromSpan
	 */
	adjustToSpanForMerged : function(fromSpan, toSpan, config){
		var me = this;
		config = config || this.calculateRowColSpan(fromSpan);
		var hasMerged = config.hasMerged, rowSpan = config.rowSpan, colSpan = config.colSpan;
		/*
		 * if has merged cell, then need reshape toSpan
		 */
		if(hasMerged){			
			if(fromSpan[3] == toSpan[3] && fromSpan[4] == toSpan[4]){
				toSpan[1] = toSpan[3]-Math.ceil((toSpan[3]-toSpan[1]+1)/rowSpan)*rowSpan+1;
				toSpan[2] = toSpan[4]-Math.ceil((toSpan[4]-toSpan[2]+1)/colSpan)*colSpan+1;
			}else{
				toSpan[3] = Math.ceil((toSpan[3]-toSpan[1]+1)/rowSpan)*rowSpan+toSpan[1]-1;
				toSpan[4] = Math.ceil((toSpan[4]-toSpan[2]+1)/colSpan)*colSpan+toSpan[2]-1;
			}
			if(0 == toSpan[1] || 0 == toSpan[3]){
				toSpan[1] = 0;
				toSpan[3] = 0;
			}
			if(0 == toSpan[2] || 0 == toSpan[4]){
				toSpan[2] = 0;
				toSpan[4] = 0;
			}
			/*
			 * refresh the selection
			 */
			me.selectRange({row:toSpan[1], col:toSpan[2]}, {row:toSpan[3], col:toSpan[4]});
		}
		
		return toSpan;
	},
	
	prepareForAutofill : function(suspendEvent){
		if(this.el){
			this._clone = this.cloneSelection();
			Ext.get(this._clone).setStyle('z-index', '');
			this.el.addCls(this.autofillCls);
		}
		if(!suspendEvent){
			this.fireEvent('prepareautofillstyle', this);
		}		
	},
	
	bindListener2Region : function(region){
		/*
		 * listen mouse events
		 */
		this.mon(region, 'cellmousedown', function(){			
			/*
			 * check whether disabled
			 */
			if(!this.disabled){
				if(Ext.isChrome && this.el){
					/*
					 * fix the weird issue of Chrome17, sometimes the last selection 
					 * won't hide when the selection change
					 */
					var pEl = Ext.get(this.el.dom.parentNode);
					pEl.hide();
					pEl.show();
				}
				this.onCellMouseDown.apply(this, arguments);
			}
		}, this);
		/*
		 * mouse down on the autofill dot
		 */
		this.mon(region, 'autofillmousedown', function(row, col, region, e, flag){
			/*
			 * check whether disabled
			 */
			if(!this.disabled){
				this.prepareForAutofill();
				/*
				 * cache the autofill initial selection
				 */
				this.autofillPos = this.getMinMaxPos();				
				var res = this.calculateRowColSpan(this.selection2Span());
				this.autofillPos.rowSpan = res.rowSpan;
				this.autofillPos.colSpan = res.colSpan;
				this.autofillPos.sheet = this.getRegion().getSheetId();
				/*
				 * flag can be 'lt' or 'rb', lt means the left-top dot, rb for right-bottom dot
				 */
				this.autofillPos.flag = flag;
			}
		}, this);
		
		/*
		 * mouse drag, update the selection
		 */
		this.mon(region, 'cellmousedrag', function(){
			/*
			 * check whether disabled
			 */
			if(!this.disabled){
				this.onCellMouseDrag.apply(this, arguments);
			}			
		}, this);		
		
		this.mon(region, 'autofillmousedrag', function(){
			/*
			 * check whether disabled
			 */
			if(!this.disabled){
				this.onAutofillDrag.apply(this, arguments);
			}			
		}, this);
		
		this.mon(region, 'cellmouseup', function(){
			/*
			 * check whether disabled
			 */
			if(!this.disabled){
				this.onCellMouseUp.apply(this, arguments);
			}								
		}, this);
		
		this.mon(region, 'autofillmouseup', function(){					
			/*
			 * check whether disabled
			 */
			if(!this.disabled){
				this.onAutofillMouseUp.apply(this, arguments);
			}								
		}, this);
	},
	
	initDD : function(){
		
	},
	
	getHtmlStr : function(){
		return '';
	},
	
	/*
	 * clone the el
	 */
	cloneSelection : function(){
		if(this.el){
			/*
			 * clone the el
			 */
			var ifbody = this.getRegion().ifbodyEl.dom;		
			
			var clone = Ext.core.DomHelper.append(ifbody, this.getHtmlStr(), true);

			var width = this.el.getWidth();
			if(width){
				clone.setWidth(width);
			}else{
				clone.setStyle('width', this.el.getStyle('width'));
			}	
			var height = this.el.getHeight();
			if(height){
				clone.setHeight(this.el.getHeight());
			}else{
				clone.setStyle('height', this.el.getStyle('height'));
			}			
			
			clone.setStyle('left', this.el.getStyle('left'));
			clone.setStyle('top', this.el.getStyle('top'));
			clone.setStyle('z-index', this.el.getStyle('z-index'));
			
			return clone.dom;
		}		
	},
	
	/*
	 * remove the autofill css
	 */
	resetAutofill : function(suspendEvent){
		if(this.el){
			this.el.removeCls(this.autofillCls);
		}
		if(this._clone){
			Ext.removeNode(this._clone);
		}
		if(!suspendEvent){
			this.fireEvent('resetautofillstyle', this);
		}				
	},
	
	/*
	 * add/remove class for this.el
	 */
	addCls : function(cls){
		if(this.el){
			this.el.addCls(cls);
		}
	},
	
	removeCls : function(cls){
		if(this.el){
			this.el.removeCls(cls);
		}
	},
	
	/*
	 * set working mode of the selection model
	 */
	setMode : function(mode){
		if(mode){
			this.mode = mode;
		}else{
			delete(this.mode);
		}
	},
	/*
	 * return true if the target is within sm
	 */
	within : function(target){
		return target.hasCls('ss-sm-inner') || target.hasCls('ss-sm') || target.hasCls('ss-sm-border2') || target.hasCls('ss-colorbar') || (!target.hasCls('ss-trigger') && !target.hasCls('ss-tpl-rz') && target.up('.ss-cell'));
	},
	
	/*
	 * return true if the target is on the dot
	 */
	atDot : function(target){
		/*
		 * for chart element, avoid the exception
		 */
		if(Ext.supports.ClassList && !target.dom.classList){
			return null;
		}
		if(this.el.contains(target)){
			var ltdot = target.hasCls('ss-sm-ltdot');
			if(!ltdot){
				rbdot = target.hasCls('ss-sm-rbdot')
				return rbdot ? 'rb' : null;
			}else{
				return 'lt';
			}
		}		
	},
	
	/*
	 * find the left-top and right-bottom positoion from 2 points
	 */
	transfer2MinMaxPos : function(startPos, endPos){
		var minrow = startPos.row, mincol = startPos.col, maxrow = endPos.row, maxcol = endPos.col;
		if(minrow > maxrow){
			var tmp = minrow;
			minrow = maxrow;
			maxrow = tmp;
		}
		if(mincol > maxcol){
			var tmp = mincol;
			mincol = maxcol;
			maxcol = tmp;
		}
		/*
		 * special case for column/row selection
		 */
		if(0 == minrow && 0 < maxrow){
			minrow = maxrow;
			maxrow = 0;
		}
		if(0 == mincol && 0 < maxcol){
			mincol = maxcol;
			maxcol = 0;
		}
		return {
			minrow:minrow,
			mincol:mincol,
			maxrow:maxrow,
			maxcol:maxcol
		};
	},		
	/********************************
	 * these empty function below need be implement by subclass
	 *******************************/		
	/*
	 * process mouse dragging, update the selection and scrolling the region if need
	 */
	onCellMouseDrag : function(row, col, position, region, e){
		
	},
	
	onAutofillDrag : function(row, col, position, region, e){
		
	},
	
	onCellMouseDown : function(row, col, region, e){		
		
	},
	
	onCellMouseUp : function(region, e){
		
	},
	
	onAutofillMouseUp : function(region, e){		
		this.onCellMouseUp(region, e);
		var autofillPos = Ext.apply({}, this.autofillPos);
		delete(this.autofillPos);
		this.fireEvent('autofilldragend', autofillPos, region, this);
	},
	
	prepareAfterRender : function(){
		this.prepareSelectionModel.apply(this, arguments);
		
		if(this.el && !this.skipZIndex){
			this.el.setStyle('z-index', SCONST['SM_Z_INDEX']);
		}
		if(this.enableDD){
			this.initDD();
		}
	},
	
	/*
	 * render selection model element if need
	 */
	prepareSelectionModel : function(region){
		
	},
	
	processPosForSimpleSelect : function(startPos, endPos){
		if(0 == startPos.row){
			startPos.row = 1;
		}
		if(0 == startPos.col){
			startPos.col = 1;
		}
		if(0 == endPos.row){
			endPos.row = 1;
		}
		if(0 == endPos.col){
			endPos.col = 1;
		}
		if(Math.abs(endPos.row-startPos.row) > Math.abs(endPos.col-startPos.col)){
			endPos.col = startPos.col;
		}else{
			endPos.row = startPos.row;
		}
	},
	
	hideSelection : function(){
		
	},
	
	pushSelection : function(){
		
	},
	
	/**
	 * select the range based on the passed params if the selection model is not diabled
	 * @param {object} startPos: the start pos of the selection
	 * @param {object} endPos: the end pos of the selection
	 * @param {boolean} suspendEvent: true to not fire selectionchange event
	 */
	selectRange : function(startPos, endPos, suspendEvent){
		if(!this.skipHideFlag){
			if(!EnterpriseSheet.sheet.sm.AbstractSelectionModel.prototype.holdClearFlag){
				this.hideSelection();
			}
		}
		
		if(startPos){
			/*
			 * if singleSelect is true, then we force the endPos equal the startPos,
			 * so every time user can only select one cell
			 */
			if(this.singleSelect){
				if(startPos){
					if(0 == startPos.row){
						startPos.row = 1;
					}
					if(0 == startPos.col){
						startPos.col = 1;
					}
				}
				if(endPos){
					Ext.apply(endPos, startPos);
				}			
			}		
										
			/*
			 * if endpos is null/undefined, means it's the same as startPos
			 */
			endPos = endPos || Ext.apply({}, startPos);
			/*
			 * for simple select, can only select cells
			 */
			if(this.simpleSelect){
				this.processPosForSimpleSelect(startPos, endPos);
			}
			if(false !== this.fireEvent('beforeselectionchange', startPos, endPos, this)){
				this.doSelect(startPos, endPos, suspendEvent);				
				this.startPos = Ext.apply({}, startPos);
				this.endPos = Ext.apply({}, endPos); 		
				/*
				 * fire selection change event
				 */
				if(!suspendEvent){			
					this.fireEvent('selectionchange', startPos, endPos, this.getRegion(), this);
				}
			}
		}else{
			this.clearSelection(suspendEvent);
		}		
	},
	
	/*
	 * the function actually do the selection work
	 */
	doSelect : function(startPos, endPos, suspendEvent, el){
		
	},
	
	isSelected : function(row, col){
		
	},
	
	/*
	 * refresh the selection
	 */
	refreshSelection : function(){		
		if(this.startPos && this.endPos){			
			this.selectRange(this.startPos, this.endPos, true);
		}
	},
	
	/******************************************************/
	
	/*
	 * this function will return the focus cell, but it won't guarantee the focusCell is the really focus one
	 */
	getFocusCell : function(){
		if(this.focusCell){
			return Ext.apply({}, this.focusCell);
		}
	},
	
	/*
	 * @param {int} row: the row index
	 * @param {int} col: the column index
	 * @param {boolean} suspendEvent: true to suspend the "focuschange" event
	 * @param {boolean} skipMergeCheck: true to not check merged cell
	 */
	setFocusCell : function(row, col, suspendEvent, skipMergeCheck){
		var region = this.getRegion(), store = region.getStore();
		var sheetId = region.getSheetId();
		var cd = store.getCell(sheetId, row, col);
		//console.log(cd)
		if(!skipMergeCheck){									
			if(store.isMergedCell(cd, sheetId, row, col)){
				row += cd.minrow;
				col += cd.mincol;
				cd = store.getCell(sheetId, row, col);
			}
		}
		var oldFocus = Ext.apply({}, this.focusCell);
		this.focusCell = {
			row:row,
			col:col
		};
		if(!suspendEvent){
			if(oldFocus.row != row || oldFocus.col != col){
				this.fireEvent('focuschange', row, col, this, cd);
			}
		}
	},
	
	getRegion : function(){
		return this.region;	
	},	
	
	/*
	 * transfer the selectrange from startpos/endpos to minpos/maxpos
	 */
	getMinMaxPos : function(){
		if(this.startPos){
			return this.transfer2MinMaxPos(this.startPos, this.endPos);
		}
	},
	
	/*
	 * return a copy of startpos/endpos
	 */		
	getSelection : function(){
		return {
			startPos:Ext.apply({}, this.startPos),
			endPos:Ext.apply({}, this.endPos)
		};
	},
	
	/*
	 * get multi selections
	 */
	getMultiSelections : function(){
		var sels = [];
		for(var p in this.stack){
			var it = this.stack[p];
			var coord = it.coord;
			sels.push(coord);		
		}	
		
		/*
		 * get the coord
		 */
		if(!this.isEmpty()){
			var coord = this.selection2Span();				
			var id = coord.join('$');
			if(!this.stack || !this.stack[id]){
				sels.push(coord);						
			}
		}		
		
		return sels;		
	},
	
	/*
	 * clear the selection
	 */
	clearSelection : function(suspendEvent){
		delete(this.startPos);
		delete(this.endPos);
		if(!suspendEvent){
			this.fireEvent('selectionchange', this.startPos, this.endPos, this.getRegion(), this);
		}		
	},
	
	/*
	 * check whether the selection is empty
	 */
	isEmpty : function(){
		return !this.startPos;
	},
	
	/*
	 * select previous cell in x or y axis
	 * @param {string} dir: the direction for the previous cell, could be {'row', 'col'}
	 * @param {boolean} expand: true to expand the selection like press the shift key
	 * @param {boolean} suspendEvent: true to suspend 'selectionchange' event
	 */
	selectPrevious : function(dir, expand, suspendEvent){
		if(this.disabled){
			/*
			 * return if disabled
			 */
			return;
		}
		if('col' !== dir){
			dir = 'row';
		}
		var r = this.region;
		var sheetId = r.getSheetId();
		var store = r.getStore();
		var pos, minMaxPos, focusCell = this.getFocusCell(), posFlag;
		if(expand){
			minMaxPos = this.getMinMaxPos();
			posFlag = (minMaxPos.minrow == focusCell.row && 'row' == dir)
				|| (minMaxPos.mincol == focusCell.col && 'col' == dir);
			if(posFlag){
				pos = {row: minMaxPos.maxrow, col: minMaxPos.maxcol};
			}else{
				pos = {row: minMaxPos.minrow, col: minMaxPos.mincol};
			}			
		}else{
			pos = focusCell;
		}
		if(pos){
			var row, col, cell = store.getCell(sheetId, pos.row, pos.col, true); 
			var merged = store.isMergedCell(cell, sheetId, pos.row, pos.col);
			if('row' == dir){
				if(merged){
					row = pos.row+cell.minrow;
				}else{
					row = pos.row;
				}					
				/*
				 * find proevious visible row
				 */
				for(var i = row-1; 1 <= i; i--){
					if(store.isVisibleRow(sheetId, i)){
						break;
					}
				}
				if(1 <= i){
					row = i;
				}				
				col = pos.col;				
			}else{
				row = pos.row;
				if(merged){
					col = pos.col+cell.mincol;
				}else{
					col = pos.col;
				}
				/*
				 * find proevious visible row
				 */
				for(var i = col-1; 1 <= i; i--){
					if(store.isVisibleColumn(sheetId, i)){
						break;
					}
				}
				if(1 <= i){
					col = i;
				}
			}
			if(expand){
				if(posFlag){
					this.selectRange({
						row: minMaxPos.minrow,
						col: minMaxPos.mincol
					}, {
						row:row,
						col:col
					}, suspendEvent);
				}else{
					this.selectRange({
						row:row,
						col:col
					}, {
						row: minMaxPos.maxrow,
						col: minMaxPos.maxcol
					}, suspendEvent);
				}							
			}else{
				this.selectRange({
					row:row,
					col:col
				}, {
					row:row,
					col:col
				}, suspendEvent);
				this.setFocusCell(row, col, suspendEvent);
			}			
			return {
				row:row,
				col:col
			};
		}		
	},
	
	/*
	 * select next cell in x or y axis
	 * @param {string} dir: the direction for the next cell, could be {'row', 'col'}
	 * @param {boolean} expand: true to expand the selection like press the shift key
	 * @param {boolean} suspendEvent: true to suspend 'selectionchange' event
	 */
	selectNext : function(dir, expand, suspendEvent){
		if(this.disabled){
			/*
			 * return if disabled
			 */
			return;
		}
		if('col' !== dir){
			dir = 'row';
		}
		var r = this.region;
		var sheetId = r.getSheetId();
		var store = r.getStore();
		var pos, minMaxPos, focusCell = this.getFocusCell(), posFlag;
		if(expand){
			minMaxPos = this.getMinMaxPos();
			posFlag = (minMaxPos.minrow == focusCell.row && 'row' == dir)
				|| (minMaxPos.mincol == focusCell.col && 'col' == dir);
			if(posFlag){
				pos = {row: minMaxPos.maxrow, col: minMaxPos.maxcol};
			}else{
				pos = {row: minMaxPos.minrow, col: minMaxPos.mincol};
			}			
		}else{
			pos = focusCell;
		}	
		if(pos){
			var row, col, cell = store.getCell(sheetId, pos.row, pos.col, true); 
			var merged = store.isMergedCell(cell, sheetId, pos.row, pos.col);
			if('row' == dir){
				if(merged){				
					row = pos.row+cell.maxrow;
				}else{
					row = pos.row;
				}
				if(row >= SCONST['MAX_ROW_NUMBER']){
					return {
						row: row,
						col: col
					};
				}
				row++;
				col = pos.col;		
				/*
				 * find next visible row
				 */
				for(var i = row; true; i++){
					if(store.isVisibleRow(sheetId, i)){
						break;
					}
				}
				row = i;
			}else{
				row = pos.row;				
				if(merged){				
					col = pos.col+cell.maxcol;
				}else{
					col = pos.col;
				}
				if(col >= SCONST['MAX_COLUMN_NUMBER']){
					return {
						row: row,
						col: col
					};
				}
				col++;
				/*
				 * find next visible column
				 */
				for(var i = col; true; i++){
					if(store.isVisibleColumn(sheetId, i)){
						break;
					}
				}
				col = i;
			}
			if(expand){
				if(posFlag){
					this.selectRange({
						row: minMaxPos.minrow,
						col: minMaxPos.mincol
					}, {
						row:row,
						col:col
					}, suspendEvent);
				}else{
					this.selectRange({
						row:row,
						col:col
					}, {
						row: minMaxPos.maxrow,
						col: minMaxPos.maxcol
					}, suspendEvent);
				}			
			}else{
				this.selectRange({
					row:row,
					col:col
				}, {
					row:row,
					col:col
				}, suspendEvent);
				this.setFocusCell(row, col, suspendEvent);
			}			
			return {
				row:row,
				col:col
			};
		}		
	},
	
	/*
	 * define a default selection
	 */
	getDefaultSelection : function(){
		return {
			startPos:{row:1, col:1},
			endPos:{row:1, col:1}
		};
	},
	
	/*
	 * define a default focus cell
	 */
	getDefaultFocusCell : function(){
		return {row:1, col:1};
	},
	
	/*
	 * enable and disable
	 * @param {boolean} clear: true to clear the selection before enable it
	 * @param {boolean} single: true to only select a single cell one time
	 * @param {boolean} simple: true to enable simple select mode
	 */
	enableSelect : function(clear, single, simple){
		this.disabled = false;
		
		if(clear){
			this.clearSelection(true);
		}
		this.setSingleSelect(single);
		this.setSimpleSelect(simple);		
	},
	
	disableSelect : function(clear, single, simple){
		this.disabled = true;
		
		if(clear){
			this.clearSelection(true);
		}
		this.setSingleSelect(single);
		this.setSimpleSelect(simple);
	},
	
	/*
	 * set single select
	 * @param {boolean} single: true then only select a single cell one time, can not drag select
	 */
	setSingleSelect : function(single){
		this.singleSelect = single;
	},
	
	setSimpleSelect : function(simple){
		this.simpleSelect = simple;
	},
	
	/*
	 * transfer the startpos/endpos to the coord array
	 */
	selection2Coord : function(){
		return this.getMultiSelections();				
	},
	
	/*
	 * transfer the startpos/endpos to the coord span
	 */
	selection2Span : function(){
		var sheetId = this.getRegion().getSheetId();
		var mm = this.transfer2MinMaxPos(this.startPos, this.endPos);
		return [sheetId, mm.minrow, mm.mincol, mm.maxrow, mm.maxcol];
	},
	
	destroy: function(){
		var r = this.getRegion();
		r.un('afterrender', this.prepareAfterRender, this);
		/*
		 * unplugin listen mouse events
		 */
		r.un('cellmousedown', this.onCellMouseDown, this);
		r.un('cellmousedrag', this.onCellMouseDrag, this);
		r.un('cellmouseup', this.onCellMouseUp, this);
        this.clearListeners();
    },
    
    /*
     * hide this selection model
     * @param {boolean} suspendEvent: true to not fire event
     */
    hide : function(suspendEvent){
    	if(this.el){
    		this.el.hide();
    	}
    	if(!suspendEvent){
    		this.fireEvent('hide', this);
    	}
    },
           
    getEl : function(){
        return this.el;
    },
    
    /*
     * show this selection model
     * @param {boolean} suspendEvent: true to not fire event
     */
    show : function(suspendEvent){
    	if(this.el){
    		this.el.show();
    	}
    	if(!suspendEvent){
    		this.fireEvent('show', this);
    	}    	
    },
    
    isVisible : function(){
    	if(this.el){
    		return this.el.isVisible();
    	}
    	return false;
    }
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.sm.CellSelectionModel', {
	/* Begin Definitions */
	
	extend : 'EnterpriseSheet.sheet.sm.AbstractSelectionModel',
	
	requires: [
	    'Ext.util.Point',
	    'Ext.dd.DDProxy'
	],
	
	/* End Definitions */
	
	constructor: function(config) {
		Ext.apply(this, config);
		
		this.callParent([config]);
		
		
	},
	
	/*
	 * enable/disable drag scrolling function
	 */
	allowDragScrolling : true,
	
	/*
	 * this is a private varibe using as a flag of is it drag scrolling now or not
	 */
	dragScrolling : false,
	
	/*
	 * this is for the drag scrolling s
	 */
	dragScrollingStep : Ext.isIE?1:2,
	
	/*
	 * the padding space between the selection and cells
	 */
	paddingOffset : 0,
	
	/*
	 * the border offset of selection element, need it to calculate width and height
	 */
	borderOffset : 1,
	
	borderWidth: 1,
	
	/*
	 * when the offset between mouse and the border of Region is less than this varible, it will start to drag scrolling
	 */
	start2ScrollOffset : 16,	
	
	/*
	 * define the Interval of scrolling
	 */
	dragScrollingInterval : Ext.isIE? 100 : 50,
	
	enableDD : true,
	
	getHtmlStr : function(){		
	   return ['<div class="ss-sm ', (this.cls || ''), '" style="border-width:', this.borderWidth, 'px;', (this.style || ''), '">',				
	           '<div class="ss-sm-inner"></div>',
		    	'<div class="ss-sm-ltdot" style="', (this.ltDotStyle || ''), '"></div>',
		    	'<div class="ss-sm-rbdot" style="', (this.rbDotStyle || ''), '"></div>',				
		    '</div>'
		].join('');
	},
	
	init : function(region){
		this.callParent([region]);			
		
		this.mon(region, {
			scope: this,
			'columnchange': this.refreshSelection,
			'rowchange': this.refreshSelection,
			'rowremoved': this.onRowRemoved,
			'columnremoved': this.onColumnRemoved,
			
			'cellinserted': this.refreshSelection,
			'rowinserted': this.refreshSelection,
			'columninserted': this.refreshSelection,
			'hiderow': this.refreshSelection,
			'hidecolumn': this.refreshSelection,
			'showrow': this.refreshSelection,
			'showcolumn': this.refreshSelection
		});		
	},		
		
	/*
	 * create and render the selection model element when the binded region is rendered
	 */		
	prepareSelectionModel : function(region){		
		var ifbody = region.ifbodyEl.dom;				
		this.el = Ext.core.DomHelper.append(ifbody, this.getHtmlStr(), true);		
		this.inel = this.el.down('.ss-sm-inner');		
		this.ltdot = this.el.down('.ss-sm-ltdot');
		this.rbdot = this.el.down('.ss-sm-rbdot');		
	},
	
	/*
	 * init the drag proxy
	 */
	initDD: function(){
		
		var me = this, region = me.region, store = region.getStore(), sheetId = region.getSheetId();
		
		if(this.el){	
			this.ddProxy = new Ext.dd.DDProxy(this.el.id, '', {
				moveOnly: true,
				scroll: false
			});
			Ext.apply(this.ddProxy, {			
				moveOnly: true,
				scroll: false
			});
			var topZIndex = SCONST['TOP_Z_INDEX'];
			/*
			 * add invalid handdle class to avoid inner and dots
			 */
			this.ddProxy.addInvalidHandleClass('ss-sm-inner');
			this.ddProxy.addInvalidHandleClass('ss-sm-ltdot');
			this.ddProxy.addInvalidHandleClass('ss-sm-rbdot');
			
			var curSpan, minrow, mincol, maxrow, maxcol, rlen, clen, near, insertDir, valid = true;
			
			this.ddProxy.startDrag = function(x, y){
				if(me.disabled){
					return false;
				}
				/*
				 * set the constrain the region can be dragged
				 */
			    this.constrainTo(me.el.dom.parentNode);
			    var el = Ext.get(this.getDragEl());
			    el.addCls('ss-sm-proxy');
			    el.setStyle('border', 'none');			    
			    el.setStyle('z-index', topZIndex);
			    /*
			     * reset the proxy to the right position
			     */
			    var info = me.getPageXYFromPos([me.startPos.row, me.startPos.col], [me.endPos.row, me.endPos.col]);
				el.setXY([info[0], info[1]]);
			    
			    curSpan = me.selection2Span();
				minrow = curSpan[1];
				mincol = curSpan[2]; 
				maxrow = curSpan[3];
				maxcol = curSpan[4];
				rlen = maxrow-minrow+1;
				clen = maxcol-mincol+1;
			};
			this.ddProxy.onDrag = function(e){
				if(me.disabled){
					return false;
				}
				var el = Ext.get(this.getDragEl());
				if(el){
					if(e.shiftKey){
						el.addCls('ss-sm-insert-proxy');
					}else{
						el.removeCls('ss-sm-insert-proxy');
					}
					var xy = e.getXY();
					var pos = region.getRowColFromPos(xy);
					if(0 == me.startPos.row && 0 == me.startPos.col){
						pos[0] = 0;
						pos[1] = 0;
					}else if(0 == me.startPos.row){
						pos[0] = 0;
					}else if(0 == me.startPos.col){
						pos[1] = 0;
					}
					/*
					 * update the startPos and endPos
					 */
					me.startPos.row = pos[0];
					me.startPos.col = pos[1];
					me.endPos.row = pos[0]+rlen-1;
					me.endPos.col = pos[1]+clen-1;
					/*
					 * sync the position of the proxy
					 */
					var info = me.getPageXYFromPos(pos, [me.endPos.row, me.endPos.col]);
					el.setXY([info[0], info[1]]);
					if(e.shiftKey && 0 !== me.startPos.row && 0 !== me.startPos.col){
						near = 'y';
						if(xy[0]-info[0] < xy[1]-info[1]){
							near = 'x';
						}
					}
					insertDir = 'x' === near ? 'right' : ('y' === near ? 'down' : undefined);
					/*
					 * sync the width and height
					 */
					if(0 == me.startPos.row && 0 == me.startPos.col){
						
					}else if(0 == me.startPos.row){
						if(el.hasCls('ss-sm-insert-proxy')){
							el.setWidth(0);
						}else{
							el.setWidth(info[2]-1);
						}
					}else if(0 == me.startPos.col){
						if(el.hasCls('ss-sm-insert-proxy')){
							el.setHeight(0);
						}else{
							el.setHeight(info[3]-1);
						}						
					}else{						
						if(e.shiftKey){					
							var fromSpan = curSpan, toSpan = me.selection2Span();
							valid = false;
							if('right' === insertDir){
								if(toSpan[2] > fromSpan[4]){
									valid = true;
								}else if(fromSpan[1] === toSpan[1] && fromSpan[3] === toSpan[3] && toSpan[2] <= fromSpan[2]){										
									valid = true;
								}else if(fromSpan[1] > toSpan[3] || fromSpan[3] < toSpan[1]){
									valid = true;
								}
							}else{
								if(toSpan[1] > fromSpan[3]){
									valid = true;
								}else if(fromSpan[2] === toSpan[2] && fromSpan[4] === toSpan[4] && toSpan[1] <= fromSpan[1]){										
									valid = true;
								}else if(fromSpan[2] > toSpan[4] || fromSpan[4] < toSpan[2]){
									valid = true;
								}						
							}
							if(!valid){
								el.setStyle('display', 'none');
							}else{
								el.setStyle('display', 'block');
							}
						}
						if(el.hasCls('ss-sm-insert-proxy') && 'x' == near){
							el.setWidth(0);
						}else{
							el.setWidth(info[2]-1);
						}
						if(el.hasCls('ss-sm-insert-proxy') && 'y' == near){
							el.setHeight(0);
						}else{
							el.setHeight(info[3]-1);
						}
					}
				}
			}
			this.ddProxy.endDrag = function(e){
				if(me.disabled){
					return false;
				}
				var toSpan = me.selection2Span();				
				if(valid){
					me.fireEvent('selectionmoving', [].concat(curSpan), [].concat(toSpan), this, e.shiftKey, insertDir);
					me.selectRange(me.startPos, me.endPos);
					me.setFocusCell(me.startPos.row, me.startPos.col);
				}else{
					me.selectRange({
						row: curSpan[1],
						col: curSpan[2]
					}, {
						row: curSpan[3],
						col: curSpan[4]
					});
					me.setFocusCell(curSpan[1], curSpan[2]);
				}				
			}
		}
	},
	
	onCellMouseUp : function(){		
		if(this.task){
			Ext.TaskManager.stop(this.task);
		}		
		delete(EnterpriseSheet.sheet.sm.AbstractSelectionModel.prototype.holdClearFlag);
		this.dragScrolling = false;		
		delete(this.task);			
	},				
	
	/*
	 * start a task to auto scrolling the region to select
	 */
	startDragScrolling : function(position){		
		/*
		 * keep the position for trace in the running task
		 */
		this.position = position;
		/*
		 * if true means there is already a task running
		 */
		if(!this.task){			
			this.task = {
			    run: function(){
			    	var pos = Ext.apply({}, this.endPos), movePos = Ext.apply({}, pos);			    	
				    /*
				     * if dragScrolling is true then make the region auto move and update the selection
				     */
				    if(this.dragScrolling && this.checkDragScrolling(this.position, pos, movePos)){
				    	this.dragScrolling = this.region.autoMoving(movePos);			    		
				    }else{
				    	this.dragScrolling = false;
				    }
				    if(this.dragScrolling){
				    	this.selectRange(this.startPos, pos);
				    }else{				    	
				    	delete(this.task);
				    }
			    	return this.dragScrolling;
			    },
			    interval: this.dragScrollingInterval,
			    scope:this
			}
			Ext.TaskManager.start(this.task);
		}
	},

	
	/**
	 * _private
	 * check the position whether fit the scrolling condition, if yes, change the pos varible
	 */
	checkDragScrolling : function(position, pos, movePos){
		movePos = movePos || {};
		var rowBoundMax = SCONST.MAX_ROW_NUMBER, colBoundMax = SCONST.MAX_COLUMN_NUMBER;
		var r = this.getRegion();		
		var x = position.x, y = position.y, w = position.w, h = position.h;
		var flag = false;
		/*
		 * if the offset is less than start2ScrollOffset then scrolling
		 */		
		if(0 != pos.row){
			if(this.start2ScrollOffset > y){
			//if(pos.row <= r.rowStart){
				if(pos.row > r.rowBound.low || r.rowStart > r.rowBound.low){
					var row = pos.row-this.dragScrollingStep;			
					if(row > r.rowBound.low){				
						pos.row = row;
					}else{
						pos.row = r.rowBound.low;
					}
					flag = true;
					movePos.row = pos.row;
				}
			}else if(y > h-this.start2ScrollOffset){
			//}else if(pos.row >= r.rowEnd){
				if(!r.rowBound.high){
					pos.row += this.dragScrollingStep;					
					if(pos.row <= r.rowEnd){
						pos.row = r.rowEnd+1;
					}
					if(rowBoundMax && pos.row > rowBoundMax){
						pos.row = rowBoundMax;
						movePos.row = rowBoundMax+1;
					}else{
						movePos.row = pos.row;
					}
					flag = true;
				}else{
					this.fireEvent('dragscrollinglimited', 'row', 'high', pos, this, r);
				}
			}
		}		
		/*
		 * for IE we don't support scorll both x and y at the same time
		 * so if it's draging scrolling y then we return 
		 */
		if(flag && Ext.isIE){
			return flag;
		}
		if(0 != pos.col){
			if(this.start2ScrollOffset > x){
			//if(pos.col <= r.colStart){
				/*
				 * can not beyond the row/col bound
				 */
				if(pos.col > r.colBound.low || r.colStart > r.colBound.low){
					var col = pos.col-this.dragScrollingStep; 
					if(col > r.colBound.low){
						pos.col = col;
					}else{
						pos.col = r.colBound.low;
					}
					flag = true;
					movePos.col = pos.col;
				}
			}else if(x > w-this.start2ScrollOffset){
			//}else if(pos.col >= r.colEnd){	
				if(!r.colBound.high){
					pos.col += this.dragScrollingStep;
					if(pos.col <= r.colEnd){
						pos.col = r.colEnd+1;
					}
					if(colBoundMax && pos.col > colBoundMax){
						pos.col = colBoundMax;
						movePos.col = colBoundMax+1;
					}else{
						movePos.col = pos.col;
					}
					flag = true;
				}else{
					this.fireEvent('dragscrollinglimited', 'col', 'high', pos, this, r);
				}
			}	
		}		
		return flag;
	},
	
	/*
	 * process mouse dragging, update the selection and scrolling the region if need
	 */
	onCellMouseDrag : function(row, col, position, region, e){
		e.stopEvent();
		if(this.startPos){	
			if(this.mode){
				var type = this.mode.type, maxrow = this.mode.maxrow, maxcol = this.mode.maxcol, 
					minrow = this.mode.minrow, mincol = this.mode.mincol;
				if('bottom-right' == type){
					if(Math.abs(row-maxrow) > Math.abs(col-maxcol)){
						col = maxcol;
					}else{
						row = maxrow;
					}
					if(col < mincol){
						col = mincol;
					}
					if(row < minrow){
						row = minrow;
					}
				}
			}
			if(0 == this.startPos.row){
				row = 0;
			}
			if(0 == this.startPos.col){
				col = 0;
			}
			this.selectRange(this.startPos, {
				row:row,
				col:col
			});		
			if(this.allowDragScrolling && 0 === e.button){
				/*
				 * check whether need scrolling the region and auto select
				 */			
				if(this.checkDragScrolling(position, {row:row, col:col})){
					this.dragScrolling = true;
					this.startDragScrolling(position);
				}else{
					this.dragScrolling = false;
				}
			}else{
				this.dragScrolling = false;
			}
		}
	},
	
	/*
	 * process autofill dragging, update the selection and scrolling the region if need
	 */
	onAutofillDrag : function(row, col, position, region, e){
		e.stopEvent();
		if(this.startPos){				
			var startPos;
			var flag = this.autofillPos.flag, 
				minrow = this.autofillPos.minrow, 
				mincol = this.autofillPos.mincol, 
				maxrow = this.autofillPos.maxrow, 
				maxcol = this.autofillPos.maxcol
				rowSpan = this.autofillPos.rowSpan,
				colSpan = this.autofillPos.colSpan;
			
			/*
			 * flag tell us it's autofill by the left-top dot or right-bottom
			 */			
			if('rb' == flag){	
				if(0 == minrow){
					row = maxrow;
				}else if(0 == mincol){
					col = maxcol;
				}else if(Math.abs(row-maxrow) > Math.abs(col-maxcol)){
					col = maxcol;
				}else{
					row = maxrow;
				}
				startPos = {
					row:minrow,
					col:mincol
				};
				/*
				 * if drag rbdot up/left over the minrow/mincol, will change the flag to 'lt'
				 */
				if(row < minrow){
					startPos.row = maxrow;
					this.autofillPos.flag = 'lt'; 
				}
				if(col < mincol){
					startPos.col = maxcol;
					this.autofillPos.flag = 'lt';
				}
			}else{
				if(0 == maxrow){
					row = minrow;
				}else if(0 == maxcol){
					col = mincol;
				}else if(Math.abs(row-minrow) > Math.abs(col-mincol)){
					col = mincol;
				}else{
					row = minrow;
				}
				startPos = {
					row:maxrow,
					col:maxcol
				};
				if(row > maxrow){
					startPos.row = minrow;
					this.autofillPos.flag = 'rb';
				}
				if(col > maxcol){
					startPos.col = mincol;
					this.autofillPos.flag = 'rb';
				}
			}
			
			/*
			 * make sure the actually selection row/column span is integer times of rowSpan/colSpan
			 */
			if(row < startPos.row){
				row = startPos.row-Math.ceil((startPos.row-row+1)/rowSpan)*rowSpan+1;				
			}else{
				row = startPos.row+Math.ceil((row-startPos.row+1)/rowSpan)*rowSpan-1;
			}
			if(col < startPos.col){
				col = startPos.col-Math.ceil((startPos.col-col+1)/colSpan)*colSpan+1;				
			}else{
				col = startPos.col+Math.ceil((col-startPos.col+1)/colSpan)*colSpan-1;
			}
			
			this.selectRange(startPos, {
				row:row,
				col:col
			});		
			if(this.allowDragScrolling && 0 === e.button){
				/*
				 * check whether need scrolling the region and auto select
				 */			
				if(this.checkDragScrolling(position, {row:row, col:col})){
					this.dragScrolling = true;
					this.startDragScrolling(position);
				}else{
					this.dragScrolling = false;
				}
			}
		}
	},
	
	isSelected : function(row, col){
		if(this.startPos && this.endPos){
			if(row >= this.startPos.row && row <= this.endPos.row
				&& col >= this.startPos.col && col <= this.endPos.col){
				return true;
			}
		}
		return false;
	},		
		
	cloneSelection : function(){
		var dom = this.callParent(arguments);
		if(dom){
			Ext.get(dom).addCls('ss-sm-multi');
		}		
		return dom;
	},
	
	/**
	 * save the current selection, push it in the stack
	 * @param {boolean} withoutClone: true to not clone the reference element
	 */
	pushSelection : function(withoutClone){
		if(!this.isEmpty()){
			this.stack = this.stack || {};
			
			/*
			 * get the coord
			 */
			var coord = this.selection2Span();
			
			var id = coord.join('$');
			/*
			 * check whether it's a repeat selection
			 */
			if(!this.stack[id]){				
				this.stack[id] = {
					coord:coord
				};
				
				if(!withoutClone){					
					if(this.el){
						this.stack[id].el = this.cloneSelection();
					}					
				}
			}
		}
	},
	
	hideSelection : function(){
		if(this.stack){
			/*
			 * process the stack, if there is more than one selection
			 */
			for(var p in this.stack){
				var it = this.stack[p];
				/*
				 * remove the nodes
				 */
				if(it.el){
					Ext.removeNode(it.el);
				}
			}
			delete(this.stack);
		}			
		if(this.el){
			this.el.removeCls('ss-sm-multi');
			this.el.hide();
		}
	},
	
	/*
	 * clear the selection
	 */
	clearSelection : function(suspendEvent){		
		this.hideSelection();
		delete(this.startPos);
		delete(this.endPos);
		if(!suspendEvent){
			this.fireEvent('selectionchange', this.startPos, this.endPos, this.getRegion(), this);
		}	
	},	
	
	onCellMouseDown : function(row, col, region, e){
        var startPos = {
            row: row,
            col: col
        }, endPos = {
            row: row,
            col: col
        };
		if(e){
			if(e.ctrlKey && !this.singleSelect && !this.simpleSelect){
				EnterpriseSheet.sheet.sm.AbstractSelectionModel.prototype.holdClearFlag = true;
				this.fireEvent('pushcurrentselection', this);				
			}else{
				delete(EnterpriseSheet.sheet.sm.AbstractSelectionModel.prototype.holdClearFlag);
                if(e.shiftKey && !e.ctrlKey  && !this.singleSelect && !this.simpleSelect){
                    if(this.startPos){
                        startPos = Ext.apply({}, this.startPos);
                    }
                }
			}
		}		
		/*
		 * save the mouse down cell as the focus cell
		 * which will be edit automatically when key press
		 */	
        //console.log(region.getStore().getCell(region.getSheetId(), row, col));
		this.selectRange(startPos, endPos);
	},				
	
	/*
	 * this function will check the range defined by startPos and endPos, whether cover the merged cell
	 * and adjust the startPos and endPos to cover combined cell if need
	 * btw, this function is not very efficient 
	 */
	coverMergedCell : function(startPos, endPos){
		var r = this.getRegion();
		var sheetId = r.getSheetId();
		var s = r.getStore();
		/*
		 * change startPos and endPos to left-top pos and right-bottom pos
		 */
		var span = this.transfer2MinMaxPos(startPos, endPos);
		var minrow = span.minrow, mincol = span.mincol, maxrow = span.maxrow, maxcol = span.maxcol;
		var tminrow, tmincol, tmaxrow, tmaxcol, mergeLookup = s.getMergeFloatings();
        while(!(minrow == tminrow && mincol == tmincol && maxrow == tmaxrow && maxcol == tmaxcol)){
            tminrow = minrow, tmaxrow = maxrow, tmincol = mincol, tmaxcol = maxcol;
            for(var p in mergeLookup){
                if(mergeLookup.hasOwnProperty(p)){
                    var it = mergeLookup[p], json = it.jsonObj, sid = it.sheet;
                    if(sheetId === sid){
                        if(
                           ((json[0] <= tminrow && json[2] >= tmaxrow) || (json[0] >= tminrow && json[0] <= tmaxrow) || (json[2] >= tminrow && json[2] <= tmaxrow)) &&
                           ((json[1] <= tmincol && json[3] >= tmaxcol) || (json[1] >= tmincol && json[1] <= tmaxcol) || (json[3] >= tmincol && json[3] <= tmaxcol))
                           
                        ){
                            if(minrow > json[0]){
                                minrow = json[0];
                            }
                            if(maxrow < json[2]){
                                maxrow = json[2];
                            }
                            if(mincol > json[1]){
                                mincol = json[1];
                            }
                            if(maxcol < json[3]){
                                maxcol = json[3];
                            }
                        }
                    }
                }
            }
        }
        if(minrow < 1){
        	minrow = 1;
        }
        if(mincol < 1){
        	mincol = 1;
        }
        
        if(startPos.row <= endPos.row){
            startPos.row = minrow;
            endPos.row = maxrow;
        }else{            
            startPos.row = maxrow;
            endPos.row = minrow;
        }
        if(startPos.col <= endPos.col){
            startPos.col = mincol;
            endPos.col = maxcol;
        }else{            
            startPos.col = maxcol;
            endPos.col = mincol;
        }        
		span = {
        	minrow:minrow,
        	mincol:mincol,
        	maxrow:maxrow,
        	maxcol:maxcol
        };
        return span;
	},
	
	setPosForElement : function(startPos, endPos, suspendEvent, el){
		if(startPos && endPos){
			el = el || this.el;
			
			if(el){
				el.show();
				/*
				 * set start position and end position
				 */						
				var r = this.getRegion();
				var sheetId = r.getSheetId();
				var s = r.getStore();
				var boffset = this.borderOffset, poffset = this.paddingOffset;
				
				var offset = boffset+poffset;						
				if(0 === startPos.row && 0 === startPos.col){
					endPos.row = 0;
					endPos.col = 0;
					/*
					 * for select all
					 */
					var w = SCONST.MAX_LENGTH; 
					var h = SCONST.MAX_LENGTH;
					var lt = -2*offset-poffset;
					/*
					 * need adjust for the margin offset
					 */
					el.setStyle('left', lt+'px');
					el.setStyle('top', lt+'px');
					el.setSize(w, h);
					if(this.ltdot){
						this.ltdot.hide();
					}				
				}else if(0 === startPos.row || 0 === endPos.row){
					
					/*
					 * column selection
					 */

					/*
				 	 * for column selection, need set the height of selection to max length
				 	 */
					var span = this.transfer2MinMaxPos(startPos, endPos);					
					startPos.row = span.minrow;
					endPos.row = span.maxrow;
					var minrow = span.minrow, mincol = span.mincol, maxrow = span.maxrow, maxcol = span.maxcol;				
					var l = s.getRangeWidth(sheetId, r.colBound.min, mincol-1)-offset-poffset;
					var t;
					if(0 == minrow){
						t = -2*offset-poffset;
					}else{
						t = s.getRangeHeight(sheetId, r.rowBound.min, minrow-1)-offset-poffset;
					}
					
					var xoffset = 2*offset;
					
					var w = s.getRangeWidth(sheetId, mincol, maxcol)+xoffset+poffset-this.borderWidth;
					var h = SCONST.MAX_LENGTH;				
					el.setStyle('left', l+'px');
					el.setStyle('top', t+'px');
					el.setSize(w, h);	
					if(this.ltdot){
						this.ltdot.hide();
					}
				}else if(0 == startPos.col || 0 === endPos.col){
					/*
				 	 * for row selection, need set the width of selection to max length
				 	 */
					var span = this.transfer2MinMaxPos(startPos, endPos);		
					startPos.col = span.mincol;
					endPos.col = span.maxcol;
					var minrow = span.minrow, mincol = span.mincol, maxrow = span.maxrow, maxcol = span.maxcol;
					var l;
					if(0 == mincol){
						l = -2*offset-poffset;
					}else{
						l = s.getRangeWidth(sheetId, r.colBound.min, mincol-1)-offset-poffset;
					}
					
					var t = s.getRangeHeight(sheetId, r.rowBound.min, minrow-1)-offset-poffset;
					var yoffset = 2*offset;				
					
					var w = SCONST.MAX_LENGTH;
					var h = s.getRangeHeight(sheetId, minrow, maxrow)+yoffset+poffset-this.borderWidth;				
					el.setStyle('left', l+'px');
					el.setStyle('top', t+'px');
					el.setSize(w, h);	
					if(this.ltdot){
						this.ltdot.hide();
					}
				}else{						
					var span;
					if(!this.skipCoverMergedCell){
						span = this.coverMergedCell(startPos, endPos);						
					}else{
						span = this.transfer2MinMaxPos(startPos, endPos)
					}							
					
					var minrow = span.minrow, mincol = span.mincol, maxrow = span.maxrow, maxcol = span.maxcol;
           
                    var rl = s.getRangeWidth(sheetId, r.colBound.min, mincol-1), rt = s.getRangeHeight(sheetId, r.rowBound.min, minrow-1);
					var l = rl-offset-poffset;
					var t = rt-offset-poffset;
					
					var xoffset = yoffset = 2*offset+poffset, w, h;
           
                    //w = s.getRangeWidth(sheetId, mincol, maxcol)+xoffset-this.borderWidth;
                    //h = s.getRangeHeight(sheetId, minrow, maxrow)+yoffset-this.borderWidth;
                    w = s.getRangeWidth(sheetId, r.colBound.min, maxcol)-rl+xoffset-this.borderWidth;
                    h = s.getRangeHeight(sheetId, r.rowBound.min, maxrow)-rt+yoffset-this.borderWidth;
           
					if(this.ltdot){
						if(mincol == r.colBound.min || minrow == r.rowBound.min){
							this.ltdot.hide();
						}else{
							this.ltdot.show();
						}
					}

					
					el.setStyle('left', l+'px');
					el.setStyle('top', t+'px');
					el.setSize(w, h);							
				}									
			}	
		}		
	},		
	
	/*
	 * select a range
	 */
	doSelect : function(startPos, endPos, suspendEvent, el){	
		
		this.setPosForElement(startPos, endPos, suspendEvent, el);
	},			
	
	/*
	 * get the page XY based on the passed [row, col]
	 */
	getPageXYFromPos : function(pos, endPos){
		/*
		 * set start position and end position
		 */						
		var r = this.getRegion();
		var rxy = r.getEl().getXY();
		var sheetId = r.getSheetId();
		var s = r.getStore();
		var boffset = this.borderOffset, poffset = this.paddingOffset;
		
		var offset = boffset+poffset;		
		
		var row = pos[0], col = pos[1];
		
		var l = s.getRangeWidth(sheetId, r.colStart, col-1)-offset-poffset;
		var t = s.getRangeHeight(sheetId, r.rowStart, row-1)-offset-poffset;				
		var xoffset = yoffset = 2*offset+poffset;
		
		l += rxy[0];
		t += rxy[1];
		
		var maxcol = endPos[1], maxrow = endPos[0];
		var w = s.getRangeWidth(sheetId, col, maxcol)+xoffset, h = s.getRangeHeight(sheetId, row, maxrow)+yoffset;
		
		return [l, t, w, h];
	},
	
	/*
	 * when row is removed, need update the selection, and then refresh it
	 */
	onRowRemoved : function(minrow, maxrow){
		if(this.startPos && this.endPos){
			/*
			 * don't change on this.startPos and this.endPos directly, always call selectRange to change
			 */
			var startPos = Ext.apply({}, this.startPos), endPos = Ext.apply({}, this.endPos);
			var srow = startPos.row, erow = endPos.row;
			if(srow <= erow){
				if(minrow < srow){
					if(maxrow < srow){
						var span = maxrow-minrow+1;
						startPos.row -= span;
						endPos.row -= span;	
					}else if(maxrow < erow){
						startPos.row = minrow;
						endPos.row = minrow+(erow-maxrow-1);
					}					
				}else if(minrow < erow){
					if(maxrow < erow){
						var span = maxrow-minrow+1;
						endPos.row -= span;
					}else{
						endPos.row = minrow;
					}
				}
			}else{
				if(minrow < erow){
					if(maxrow < erow){
						var span = maxrow-minrow+1;
						startPos.row -= span;
						endPos.row -= span;	
					}else if(maxrow < srow){
						startPos.row = minrow+(srow-maxrow-1);
						endPos.row = minrow;
					}					
				}else if(minrow < srow){
					if(maxrow < srow){
						var span = maxrow-minrow+1;
						startPos.row -= span;
					}else{
						startPos.row = minrow;
					}
				}				
			}			
			this.selectRange(startPos, endPos, true);
		}
		if(this.focusCell){
			var focusRow = this.focusCell.row;
			if(focusRow > maxrow){
				focusRow -= span;
				this.setFocusCell(focusRow, this.focusCell.col, true, true);
			}
		}
	},
	
	/*
	 * when column is removed, need update the selection, and then refresh it
	 */
	onColumnRemoved : function(mincol, maxcol){
		var span = maxcol-mincol+1;
		if(this.startPos && this.endPos){
			/*
			 * don't change on this.startPos and this.endPos directly, always call selectRange to change
			 */
			var startPos = Ext.apply({}, this.startPos), endPos = Ext.apply({}, this.endPos);
			var scol = startPos.col, ecol = endPos.col;
			if(scol <= ecol){
				if(mincol < scol){
					if(maxcol < scol){
						startPos.col -= span;
						endPos.col -= span;	
					}else if(maxcol < ecol){
						startPos.col = mincol;
						endPos.col = mincol+(ecol-maxcol-1);
					}					
				}else if(mincol < ecol){
					if(maxcol < ecol){
						endPos.col -= span;
					}else{
						endPos.col = mincol;
					}
				}
			}else{
				if(mincol < ecol){
					if(maxcol < ecol){
						startPos.col -= span;
						endPos.col -= span;	
					}else if(maxcol < scol){
						startPos.col = mincol+(scol-maxcol-1);
						endPos.col = mincol;
					}					
				}else if(mincol < scol){
					if(maxcol < scol){
						startPos.col -= span;
					}else{
						startPos.col = mincol;
					}
				}				
			}
			this.selectRange(startPos, endPos, true);
		}
		if(this.focusCell){
			var focusCol = this.focusCell.col;
			if(focusCol > maxcol){
				focusCol -= span;
				this.setFocusCell(this.focusCell.row, focusCol, true, true);
			}
		}
	},
	
	/**
	 * set selection and refresh the reference mode UI if need
	 * @param {array} refs: the refs coord to set
	 * @param {boolean} forceRefresh: true to refresh the element
	 * @param {boolean} suspendEvent: true to not fire the related event
	 * 
	 */
	setSelections : function(sels, forceRefresh, supsendEvent){		
		
		/* 
		 * clear the selection first
		 */		
		this.stack = this.stack || {};				
		
		var visited = {};
		var region = this.getRegion();
		var sheetId = region.getSheetId();
		var len = sels.length;
		if((0 == len || forceRefresh) && this.el){
			this.el.setStyle('left', '-10000px');
		}
				
		for(var i = 0; i < len; i++){
			var sel = sels[i];
			
			var coord = [].concat(sel);
			if(SCOM.nullOrUndefined(coord[0]) || '' === coord[0]){
				coord[0] = sheetId;
			}
			var id = coord.join('$');
			visited[id] = true;			
			if(sheetId == coord[0]){
				/*
				 * refresh the reference element in current sheet
				 */
				if(!this.stack[id] || !this.stack[id].el){																
					this.selectRange({
						row:coord[1],
						col:coord[2]
					}, {
						row:coord[3],
						col:coord[4]
					}, true);
					if(i !== len-1){
						/*
						 * push to save
						 */
						this.pushSelection();
					}					
				}
			}else{				
				/*
				 * remove the reference element not in current sheet 
				 */
				if(!this.stack[id]){
					this.stack[id] = {
						coord:coord
					}					
				}else{					
					if(this.stack[id].el){
						Ext.removeNode(this.stack[id].el);
					}
				}						
			}
		}					
		for(var p in this.stack){
			if(!visited[p]){	
				if(this.stack[p].el){					
					Ext.removeNode(this.stack[p].el);
				}
				delete(this.stack[p]);
			}
		}		
		if(0 == len){
			delete(this.stack);
			/*
			 * if no selections the clear the startPos and endPos too
			 */
			delete(this.startPos);
			delete(this.endPos);
		}
		
		if(!supsendEvent){						
			
			this.fireEvent('selectionchange', this.startPos, this.endPos, region, this);			
		}
	},
	
	/*
	 * refresh the selection
	 */
	refreshSelection : function(){		
		var sels = this.getMultiSelections();
		
		if(sels.length){
			/*
			 * clear first
			 */
			this.clearSelection(true);
			EnterpriseSheet.sheet.sm.AbstractSelectionModel.prototype.holdClearFlag = true;
			this.setSelections(sels, undefined, true);
			delete(EnterpriseSheet.sheet.sm.AbstractSelectionModel.prototype.holdClearFlag);
		}
	}
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.sm.ColumnSelectionModel', {
	/* Begin Definitions */
	
	extend : 'EnterpriseSheet.sheet.sm.CellSelectionModel',
	
	/* End Definitions */
	
	getHtmlStr : function(){
		return ['<div class="ss-csm ', (this.cls || ''), '" style="display:none;">',				
				'<div class="ss-sm-inner"></div>',	
				'<div class="ss-sm-ltdot"></div>',
		    	'<div class="ss-sm-rbdot"></div>',	
			'</div>'
		].join('');
	},
	
	autofillCls : 'ss-autofill-col',
	
	enableDD : false,
	
	skipZIndex : true,
	
	init : function(region){
		this.callParent([region]);		
		/*
		 * add listener to process cell data before it render
		 */
		this.mon(region, 'processdata', this.processData, this);
	},
	
	/**
	 * save the current selection, push it in the stack
	 * @param {boolean} withoutClone: true to not clone the reference element
	 */
	pushSelection : function(withoutClone){
		
	},
	
	refreshSelection : function(){		
		if(this.startPos && this.endPos){			
			this.selectRange(this.startPos, this.endPos, true);
		}
	},
	
	isSelected : function(row, col){
		if(0 == row && this.startPos 
				&& this.endPos && 0 == this.startPos.row){
			var minc = this.startPos.col, maxc = this.endPos.col;
			if(minc > maxc){
				minc = maxc;
				maxc = this.startPos.col;
			}
			if(col >= minc && col <= maxc){
				return true;
			}
		}
		return false;
	},
	
	/*
	 * here we just judge whether the cell is the selected row index
	 * if yes, we bind a css to the related cell element
	 */
	processData : function(sheet, row, col, o, timestamp, r){
		o.css = o.css || '';		
	},
			
	/*
	 * create and render the selection model element when the binded region is rendered
	 */		
	prepareSelectionModel : function(p){
		var ifbody = p.ifbodyEl;		
		this.el = Ext.core.DomHelper.append(ifbody, this.getHtmlStr(), true);				
		this.inel = this.el.down('.ss-sm-inner');
		this.ltdot = this.el.down('.ss-sm-ltdot');
		this.rbdot = this.el.down('.ss-sm-rbdot');	
	},
	
	/*
	 * check the position whether fit the scrolling condition, if yes, change the pos varible
	 */
	checkDragScrolling : function(position, pos, movePos){	
		movePos = movePos || {};
		var colBoundMax = SCONST.MAX_COLUMN_NUMBER;
		var r = this.getRegion();
		var x = position.x, y = position.y, w = position.w, h = position.h;
		var flag = false;
		/*
		 * if the offset is less than start2ScrollOffset then scrolling
		 */		
		if(this.start2ScrollOffset > x){
			/*
			 * can not beyond the row/col bound
			 */
			if(pos.col > r.colBound.low || r.colStart > r.colBound.low){ 
				var col = pos.col-this.dragScrollingStep; 
				if(col > r.colBound.low){
					pos.col = col;
				}else{
					pos.col = r.colBound.low;
				}
				flag = true;
				movePos.col = pos.col;
			}
		}else if(x-w > -this.start2ScrollOffset){ 			
			if(!r.colBound.high){
				pos.col += this.dragScrollingStep;
				if(pos.col <= r.colEnd){
					pos.col = r.colEnd+1;
				}
				if(colBoundMax && pos.col > colBoundMax){
					pos.col = colBoundMax;
					movePos.col = colBoundMax+1;
				}else{
					movePos.col = pos.col;
				}
				flag = true;
			}else{
				this.fireEvent('dragscrollinglimited', 'col', 'high', pos, this, r);
			}			
		}
		/*
		 * for column selection the row should always equal 0
		 */
		pos.row = 0;
		
		return flag;
	},		
	
	
	
	/*
	 * overwrite it to do nothing
	 */
	prepareForAutofill : function(suspendEvent){
		if(this.el){			
			this.el.addCls(this.autofillCls);
		}
		if(!suspendEvent){
			this.fireEvent('prepareautofillstyle', this);
		}
	},
	
	/*
	 * select a range
	 */
	setPosForElement : function(startPos, endPos){		
		
		if(startPos){
			if(this.el){			
				/*
				 * set start position and end position
				 */
				var r = this.getRegion();
				var s = r.getStore();
				var sheetId = r.getSheetId();
				var boffset = this.borderOffset, poffset = this.paddingOffset;
				
				var offset = boffset+poffset; 
				
				if(0 == startPos.row && 0 != startPos.col){		
					this.el.removeCls('ss-sm-col');
					if(1 == startPos.col || 1 == endPos.col || this.el.hasCls(this.autofillCls)){
						this.ltdot.hide();
					}else{
						this.ltdot.show();
					}
					endPos.row = 0;		
					var span = this.transfer2MinMaxPos(startPos, endPos);
					var r = this.getRegion();
					var s = r.getStore();
					var minrow = span.minrow, mincol = span.mincol, maxrow = span.maxrow, maxcol = span.maxcol;
					var l = s.getRangeWidth(sheetId, r.colBound.min, mincol-1)-offset-poffset;
					var t = s.getRangeHeight(sheetId, r.rowBound.min, minrow-1);
					var xoffset = 2*offset;
					if(mincol == r.colBound.min){
						xoffset = offset-poffset;					
						l += offset+poffset;
					}
					var w = s.getRangeWidth(sheetId, mincol, maxcol)+xoffset+poffset-this.borderWidth, h = s.getRowHeight(sheetId, 0);				
					
					this.el.setStyle('left', l+'px');
					this.el.setStyle('top', t+'px');			
					this.el.setSize(w, h);				
					this.el.show();												
				}else{					
					this.el.addCls('ss-sm-col');				
					var span = this.transfer2MinMaxPos(startPos, endPos);
					var r = this.getRegion();
					var s = r.getStore();
					var minrow = span.minrow, mincol = span.mincol, maxrow = span.maxrow, maxcol = span.maxcol;
					var l = s.getRangeWidth(sheetId, r.colBound.min, mincol-1);				
					
					
					var w = 0 === endPos.col ? SCONST.MAX_LENGTH : s.getRangeWidth(sheetId, mincol, maxcol), h = 1;								
					this.el.setStyle('left', l+'px');		
					this.el.setStyle('top', '');
					this.el.setStyle('bottom', '0px');
					this.el.setSize(w, h);				
					this.el.show();									
					
					
				}			
			}
		}			
	}
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.sm.RowSelectionModel', {
	/* Begin Definitions */
	
	extend : 'EnterpriseSheet.sheet.sm.CellSelectionModel',
	
	/* End Definitions */
	
	getHtmlStr : function(){
		return ['<div class="ss-rsm ', (this.cls || ''), '" style="display:none;">',				
				'<div class="ss-sm-inner"></div>',	
				'<div class="ss-sm-ltdot"></div>',
		    	'<div class="ss-sm-rbdot"></div>',
			'</div>'
		].join('');
	},
	
	autofillCls : 'ss-autofill-row',
	
	enableDD : false,
	
	skipZIndex : true,
	
	init : function(region){
		this.callParent([region]);			
		/*
		 * add listener to process cell data before it render
		 */
		this.mon(region, 'processdata', this.processData, this);
	},
	
	/**
	 * save the current selection, push it in the stack
	 * @param {boolean} withoutClone: true to not clone the reference element
	 */
	pushSelection : function(withoutClone){
		
	},
	
	refreshSelection : function(){		
		if(this.startPos && this.endPos){			
			this.selectRange(this.startPos, this.endPos, true);
		}
	},
	
	isSelected : function(row, col){
		if(this.startPos && this.endPos
			&& 0 == col && 0 == this.startPos.col){
			var minr = this.startPos.row, maxr = this.endPos.row;
			if(minr > maxr){
				minr = maxr;
				maxr = this.startPos.row;
			}
			if(row >= minr && row <= maxr){
				return true;
			}
		}
		return false;
	},
	
	/*
	 * here we just judge whether the cell is the selected row index
	 * if yes, we bind a css to the related cell element
	 */
	processData : function(sheet, row, col, o, timestamp, r){
		o.css = o.css || '';		
	},		
	
	/*
	 * create and render the selection model element when the binded region is rendered
	 */		
	prepareSelectionModel : function(p){
		var ifbody = p.ifbodyEl;
		
		this.el = Ext.core.DomHelper.append(ifbody, this.getHtmlStr(), true);			
		this.inel = this.el.down('.ss-sm-inner');
		this.ltdot = this.el.down('.ss-sm-ltdot');
		this.rbdot = this.el.down('.ss-sm-rbdot');	
	},
	
	/*
	 * check the position whether fit the scrolling condition, if yes, change the pos varible
	 */
	checkDragScrolling : function(position, pos, movePos){
		movePos = movePos || {};
		var rowBoundMax = SCONST.MAX_ROW_NUMBER;
		var r = this.getRegion();
		var x = position.x, y = position.y, w = position.w, h = position.h;
		var flag = false;
		/*
		 * if the offset is less than start2ScrollOffset then scrolling
		 */		
		if(this.start2ScrollOffset > y){
			if(pos.row > r.rowBound.low || r.rowStart > r.rowBound.low){
				var row = pos.row-this.dragScrollingStep;
				if(row > r.rowBound.low){
					pos.row = row;
				}else{
					pos.row = r.rowBound.low;
				}
				flag = true;
				movePos.row = pos.row;
			}
		}else if(y-h > -this.start2ScrollOffset){
			if(!r.rowBound.high){
				pos.row += this.dragScrollingStep;
				if(pos.row <= r.rowEnd){
					pos.row = r.rowEnd+1;
				}
				if(rowBoundMax && pos.row > rowBoundMax){
					pos.row = rowBoundMax;
					movePos.row = rowBoundMax+1;
				}else{
					movePos.row = pos.row;
				}
				flag = true;
			}else{
				this.fireEvent('dragscrollinglimited', 'row', 'high', pos, this, r);
			}						
		}
		/*
		 * for column selection the row should always equal 0
		 */
		pos.col = 0;
		
		return flag;
	},
	
	
	
	/*
	 * overwrite it to do nothing
	 */
	prepareForAutofill : function(suspendEvent){
		if(this.el){			
			this.el.addCls(this.autofillCls);
		}
		if(!suspendEvent){
			this.fireEvent('prepareautofillstyle', this);
		}
	},
	
	/*
	 * select a range
	 */
	setPosForElement : function(startPos, endPos){		
		if(startPos){
			if(this.el){			
				var r = this.getRegion();
				var s = r.getStore();
				var sheetId = r.getSheetId();
				var boffset = this.borderOffset, poffset = this.paddingOffset;
				
				var offset = boffset+poffset;	
				
				/*
				 * set start position and end position
				 */			 
				if(0 == startPos.col && 0 != startPos.row){		
					this.el.removeCls('ss-sm-row');
					if(1 == startPos.row || 1 == endPos.row || this.el.hasCls(this.autofillCls)){
						this.ltdot.hide();
					}else{
						this.ltdot.show();
					}
					endPos.col = 0;		
					var span = this.transfer2MinMaxPos(startPos, endPos);								
					var minrow = span.minrow, mincol = span.mincol, maxrow = span.maxrow, maxcol = span.maxcol;				
					var l = s.getRangeWidth(sheetId, r.colBound.min, mincol-1);
					var t = s.getRangeHeight(sheetId, r.rowBound.min, minrow-1)-offset-poffset;
					var yoffset = 2*offset;				
					if(minrow == r.rowBound.min){
						yoffset = offset-poffset;
						t += offset+poffset;
						
					}
					var w = s.getColWidth(sheetId, 0), h = s.getRangeHeight(sheetId, minrow, maxrow)+yoffset+poffset-this.borderWidth;
					
					this.el.setStyle('left', l+'px');
					this.el.setStyle('top', t+'px');			
					this.el.setSize(w, h);
					this.el.show();								
				}else{
					this.el.addCls('ss-sm-row');					
					var span = this.transfer2MinMaxPos(startPos, endPos);								
					var minrow = span.minrow, mincol = span.mincol, maxrow = span.maxrow, maxcol = span.maxcol;								
					var t = s.getRangeHeight(sheetId, r.rowBound.min, minrow-1);				
					
					var h = 0 === endPos.row ? SCONST.MAX_LENGTH : s.getRangeHeight(sheetId, minrow, maxrow), w = 1;
					this.el.setStyle('left', '');
					this.el.setStyle('right', '0px');
					this.el.setStyle('top', t+'px');			
					this.el.setSize(w, h);
					this.el.show();								
					
				}			
			}
		}				
	}
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.sm.CellReferenceModel', {
	/* Begin Definitions */
	
	extend : 'EnterpriseSheet.sheet.sm.CellSelectionModel',
	
	/* End Definitions */
	
	paddingOffset : 0,
	
	borderOffset : Ext.isIE?1:0,	
			
	skipHideFlag : true,
			
	enableDD: true,
	
	//skipCoverMergedCell: true,
			
	getHtmlStr : function(){
		return ['<div class="ss-rm', (this.cls || ''), '">',	
				'<div class="ss-sm-inner ss-rm-inner">',
					//'<div class="ss-rm-left"></div>',
					//'<div class="ss-rm-right"></div>',
				'</div>',
				'<div class="ss-rm-rbdot"></div>',
			'</div>'
		].join('');
	},
	
	initComponent : function(){
		this.callParent(arguments);
		
	},
	
	/*
	 * create and render the selection model element when the binded region is rendered
	 */		
	prepareSelectionModel : function(region){
		var ifbody = region.ifbodyEl;
		
		this.el = Ext.core.DomHelper.append(ifbody, this.getHtmlStr(), true);		
		this.inel = this.el.down('.ss-rm-inner');
		this.dotel = this.el.down('.ss-rm-rbdot');		
		//this.lbel = this.el.down('.ss-rm-left');
		//this.rbel = this.el.down('.ss-rm-right');
		this.el.hide();
	},
	
	/*
	 * redefine the dd stuff, cause there is more than one element in reference
	 */
	initDD : function(){	
		if(this.region){
			/*
			 * check mousedown, save dragging coord span 
			 */
			this.region.ifbodyEl.on('mousedown', this.onRegionBodyMouseDown, this);
			/*
			 * check mousemove, on drgging
			 */
			Ext.getDoc().on('mousemove', this.onMouseMove, this);
			/*
			 * end of dragging
			 */
			Ext.getDoc().on('mouseup', this.onMouseUp, this);
		}		
	},
	
	/*
	 * start a task to auto moving the region
	 */
	startDragMoving : function(position){		
		/*
		 * keep the position for trace in the running task
		 */
		this.position = position;
		/*
		 * if true means there is already a task running
		 */
		if(!this.movingTask){			
			this.movingTask = {
			    run: function(){
			    	var which = this.draggingCoordSpan.which;				    	
					if('rbdot' == which){
						this.dragDotMoving();
					}else{
						this.dragFrameMoving();
					}
			    	return this.dragScrolling;
			    },
			    interval: this.dragScrollingInterval,
			    scope:this
			}
			Ext.TaskManager.start(this.movingTask);
		}
	},
		
	/*
	 * _private
	 * for drag the right-bottom dot moving
	 */
	dragDotMoving : function(){
		var el = this.draggingCoordSpan.coordObj.el;
		var span = this.draggingCoordSpan.currentSpan || this.draggingCoordSpan.span;   	
		span = [].concat(span);
		/*
		 * get the startPos and endPos
		 */
		var startPos = this.draggingCoordSpan.startPos, endPos = this.draggingCoordSpan.endPos;		    				   
	    /*
	     * if dragScrolling is true then make the region auto move and update the selection
	     */
	    if(this.dragScrolling && this.checkDragScrolling(this.position, endPos)){
	    	this.dragScrolling = this.region.autoMoving(endPos);			    		
	    }else{
	    	this.dragScrolling = false;	    	
	    }
	    if(this.dragScrolling){
	    	this.setPosForElement(startPos, endPos, true, el);
	    	/*
	    	 * update draggingCoordSpan
	    	 */
	    	this.draggingCoordSpan.startPos = Ext.apply({}, startPos);
	    	this.draggingCoordSpan.endPos = Ext.apply({}, endPos);
	    	var rt = this.transfer2MinMaxPos(startPos, endPos);	    	
	    	span[1] = rt.minrow;
	    	span[2] = rt.mincol;
	    	span[3] = rt.maxrow;
	    	span[4] = rt.maxcol;
	    	this.draggingCoordSpan.currentSpan = [].concat(span);	    	
	    	this.draggingCoordSpan.coordObj.coord = [].concat(span);
	    	/*
			 * fire moving event
			 */					
			this.fireEvent('movingreference', this.draggingCoordSpan, this);
	    }else{				    	
	    	delete(this.movingTask);	    	
	    }
	},
	
	/*
	 * _private 
	 * for drag the reference frame moving, which means the size of the reference won't change
	 */
	dragFrameMoving : function(){		
		var el = this.draggingCoordSpan.coordObj.el;
    	var span = this.draggingCoordSpan.currentSpan || this.draggingCoordSpan.span;
    	span = [].concat(span);
    	var startPos, endPos, x = this.position.x, y = this.position.y, w = this.position.w, h = this.position.h;
    	if(x < this.start2ScrollOffset && y < this.start2ScrollOffset){
    		endPos = {row: span[1], col: span[2]};
	    	startPos = {row: span[3], col: span[4]};
    	}else if(x < this.start2ScrollOffset){
    		endPos = {row: span[3], col: span[2]};
	    	startPos = {row: span[1], col: span[4]};
    	}else if(y < this.start2ScrollOffset){
    		startPos = {row: span[3], col: span[2]};
	    	endPos = {row: span[1], col: span[4]};
    	}else{
    		startPos = {row: span[1], col: span[2]};
	    	endPos = {row: span[3], col: span[4]};
    	}
    		
    	var rowOff = startPos.row-endPos.row, colOff = startPos.col-endPos.col;
	    /*
	     * if dragScrolling is true then make the region auto move and update the selection
	     */
    	var oldEndPos = Ext.apply({}, endPos);
	    if(this.dragScrolling && this.checkDragScrolling(this.position, endPos)){
	    	/*
	    	 * check whether the row or col change 
	    	 */
	    	var goPos = Ext.apply({}, endPos);
	    	if(oldEndPos.row == goPos.row){
	    		goPos.row = this.region.rowStart;
	    	}
	    	if(oldEndPos.col == goPos.col){
	    		goPos.col = this.region.colStart;
	    	}
	    	this.dragScrolling = this.region.autoMoving(goPos);			    		
	    }else{
	    	this.dragScrolling = false;
	    }
	    if(this.dragScrolling){
	    	startPos.row = endPos.row+rowOff;
	    	startPos.col = endPos.col+colOff;				    	
	    	this.setPosForElement(startPos, endPos, true, el);	
	    	var rt = this.transfer2MinMaxPos(startPos, endPos);
	    	span[1] = rt.minrow;
	    	span[2] = rt.mincol;
	    	span[3] = rt.maxrow;
	    	span[4] = rt.maxcol;
	    	this.draggingCoordSpan.currentSpan = [].concat(span);	    	
	    	this.draggingCoordSpan.coordObj.coord = [].concat(span);
	    	/*
			 * fire moving event
			 */					
			this.fireEvent('movingreference', this.draggingCoordSpan, this);
	    }else{				    	
	    	delete(this.movingTask);
	    }
    	return this.dragScrolling;
	},
	
	/*
	 * for mousedown, mousemove and mouseup listeners
	 */
	onRegionBodyMouseDown : function(e){
		var target = e.getTarget(), found, colorIndex, span, which;
		/*
		 * find the match element first
		 */
		for(var p in this.stack){
			var it = this.stack[p];		
			if(it.el){
				var rmEl = Ext.get(it.el); 
				if(it.el == target){
					found = rmEl;						
				}else if(rmEl.down('.ss-rm-rbdot').dom == target){
					which = 'rbdot';
					found = rmEl;
				}
				if(found){
					span = it.coord;
					colorIndex = it.colorIndex;
					break;
				}
			}			
		}
		if(!found && !this.isEmpty() && this.el){
			if(target == this.el.dom){
				found = this.el;
			}else if(this.el.down('.ss-rm-rbdot').dom == target){
				which = 'rbdot';
				found = this.el;
			}
			if(found){
				span = this.selection2Span();
			}						
		}
		if(found){			
			span[0] = this.getRegion().getSheetId();
			var obj = {
				el: found,
				coord: [].concat(span)				
			};			
			found.addCls('ss-rm-actived');			
			this.draggingCoordSpan = {
				el: found,
				/*
				 * the original coord span
				 */
				span: span,
				colorIndex: colorIndex,
				/*
				 * mouse down on rm element or the rbdot element
				 */
				which: which,
				coordObj: obj,
				/*
				 * save startPos and endPos
				 */
				startPos: {row: span[1], col: span[2]},
				endPos: {row: span[3], col: span[4]},
				rowSpan: span[3]-span[1]+1,
				colSpan: span[4]-span[2]+1
			};
			/*
			 * fire drag start event
			 */
			this.fireEvent('startmovereference', this.draggingCoordSpan, this);									
		}
	},
	
	onMouseMove : function(e){
		var region = this.region, sheetId = region.getSheetId();
		if(this.draggingCoordSpan && region){
			/*
			 * get last span
			 */
			var originSpan = [].concat(this.draggingCoordSpan.span);
			var lastSpan = [].concat(this.draggingCoordSpan.currentSpan || this.draggingCoordSpan.span);
			var which = this.draggingCoordSpan.which;
			var xy = e.getXY();
			
			var rc = region.getRowColFromPos(xy, true);
			
			var el = this.draggingCoordSpan.el;
			var startPos, endPos;
			if('rbdot' == which){
				if(!this.singleSelect){
					/*
					 * if mouse down on rbdot, then we will keep the left-top point stand
					 */
					startPos = {
						row: originSpan[1],
						col: originSpan[2]
					};
					endPos = {
						row: rc[0],
						col: rc[1]
					};
					
					if(this.simpleSelect){
						this.processPosForSimpleSelect(startPos, endPos);
					}
				}				
			}else{
				startPos = {
					row: rc[0],
					col: rc[1]
				};
				endPos = {
					row: rc[0]+this.draggingCoordSpan.rowSpan-1,
					col: rc[1]+this.draggingCoordSpan.colSpan-1
				};
			}		
			if(startPos && endPos){
				/*
				 * update the refs of startPos and endPos
				 */
				this.draggingCoordSpan.startPos = Ext.apply({}, startPos);
				this.draggingCoordSpan.endPos = Ext.apply({}, endPos);
				if(false !== this.fireEvent('beforemovingreference', startPos, endPos, originSpan, rc, this.draggingCoordSpan, which, this)){
					/*
					 * transfer startPos and endPos to minPos and maxPos
					 */
					var mm = this.transfer2MinMaxPos(startPos, endPos);
					startPos.row = mm.minrow;
					startPos.col = mm.mincol;
					endPos.row = mm.maxrow;
					endPos.col = mm.maxcol;
					var currentSpan = [sheetId, startPos.row, startPos.col, endPos.row, endPos.col];
					/*
					 * check whether it's changed
					 */
					if(!(lastSpan[1] == currentSpan[1] && lastSpan[2] == currentSpan[2] 
						&& lastSpan[3] == currentSpan[3] && lastSpan[4] == currentSpan[4])){
						/*
						 * call parent doSelect
						 */
						this.setPosForElement(startPos, endPos, true, el);
						/*
						 * save the current span
						 */
						var sheetId = this.draggingCoordSpan.coordObj.coord[0];
						this.draggingCoordSpan.currentSpan = currentSpan; 
						/*
						 * fire moving event
						 */					
						this.fireEvent('movingreference', this.draggingCoordSpan, this);
						
						if(this.allowDragScrolling && 0 === e.button){
							/*
							 * check whether need scrolling the region and auto select
							 */			
							if(this.checkDragScrolling(rc[2], {row:rc[0], col:rc[1]})){
								this.dragScrolling = true;
								this.startDragMoving(rc[2]);
							}else{
								this.dragScrolling = false;
							}
						}else{
							this.dragScrolling = false;
						}
					}
				}
			}							
		}
	},
	
	onMouseUp : function(e){
		if(this.draggingCoordSpan){
			var el = this.draggingCoordSpan.el;
			el.removeCls('ss-rm-actived');
			var coordObj = this.draggingCoordSpan.coordObj;
			/*
			 * get last span
			 */
			var lastSpan = this.draggingCoordSpan.span; 
			var currentSpan = this.draggingCoordSpan.currentSpan;
			if(currentSpan && !(lastSpan[1] == currentSpan[1] && lastSpan[2] == currentSpan[2] 
				&& lastSpan[3] == currentSpan[3] && lastSpan[4] == currentSpan[4])){
				var tmp = coordObj.coord.concat([this.draggingCoordSpan.colorIndex]);
				var id = tmp.join('$');					
				if(this.stack && this.stack[id]){
					/*
					 * delete the old one
					 */
					delete(this.stack[id]);
					id = currentSpan.join('$');						
					this.stack[id] = {
						coord: [].concat(currentSpan),
						el: el.dom
					};
				}else{						
					this.startPos = {row: currentSpan[1], col: currentSpan[2]}; 
					this.endPos = {row: currentSpan[3], col: currentSpan[4]};
				}		
				
				/*
				 * fire moving event
				 */
				this.fireEvent('endmovereference', Ext.apply({}, this.draggingCoordSpan), this);
			}					
			delete(this.draggingCoordSpan);
			
			this.dragScrolling = false;
			if(this.movingTask){
				Ext.TaskManager.stop(this.movingTask);
			}
			delete(this.movingTask);
		}
	},
	
	/*
	 * enable and disable
	 * @param {boolean} clear: true to clear the selection before enable it
	 * @param {boolean} single: true to only select a single cell one time
	 * @param {boolean} simple: true to enable simple select mode
	 * @param {boolean} suspendShown: true to not show the reference element
	 */
	enableSelect : function(clear, single, simple, suspendShown, onlyDDFlag){
		this.onlyDDFlag = onlyDDFlag;
		this.callParent(arguments);		
		
		if(!suspendShown && this.el){
			this.el.setStyle('left', '-1000px');
			this.el.removeCls('ss-rm-disabled');
			this.el.show();			
		}			
	},
	
	/*
	 * @param {boolean} clear: true to clear the selection after disable it
	 * @param {boolean} single: true to only select a single cell one time
	 * @param {boolean} suspendHidden: true to not hide the reference element
	 * @param {boolean} suspendShown: true to not show the reference element
	 */
	disableSelect : function(clear, single, simple, suspendHidden){
		delete(this.onlyDDFlag);
		
		this.callParent(arguments);
				
		if(!suspendHidden && this.el){
			this.el.addCls('ss-rm-disabled');
			this.el.hide();
		}			
	},
	
	setKeepStack : function(flag){
		this.keepStackFlag = flag;
	},
	
	/*
	 * save the current selection, push it in the stack
	 * @param {boolean} withoutClone: true to not clone the reference element
	 */
	pushSelection : function(withoutClone){
		if(!this.isEmpty()){
			this.stack = this.stack || {};
			/*
			 * get the coord
			 */
			var coord = this.selection2Span();
			/*
			 * save the coord to stack
			 */
			var tmp = coord.concat([this.colorIndex]);
			var id = tmp.join('$');
			/*
			 * check whether it's a repeat selection
			 */
			if(!this.stack[id]){				
				this.stack[id] = {
					coord:coord
				};
				this.stack[id].colorIndex = this.colorIndex;
				if(!withoutClone){					
					if(this.el){
						this.stack[id].el = this.cloneSelection();
					}					
				}
			}
		}
	},	
	
	onCellMouseDown : function(row, col, region, e){	
		if(this.onlyDDFlag){
			return;
		}
		if(!this.keepStackFlag){
			if(e.ctrlKey && !this.singleSelect && !this.simpleSelect){
				/*
				 * with ctrl, we will keep the last selection
				 */
				this.pushSelection();
			}else{
				/*
				 * clear the old selection
				 */		
				this.clearSelection();
			}
		}		
		/*
		 * save the mouse down cell as the focus cell
		 * which will be edit automatically when key press
		 */	
		this.selectRange({
			row:row,
			col:col
		}, {
			row:row,
			col:col
		});	
	},
	
	onCellMouseDrag : function(){
		if(!this.singleSelect){
			this.callParent(arguments);			
		}
	},
	
	onCellMouseUp : function(){	
		this.callParent(arguments);			
		if(this.movingTask){
			Ext.TaskManager.stop(this.movingTask);
		}
		delete(this.movingTask);
		this.fireEvent('referencemouseup', this);
	},
	
	/*
	 * clone the el
	 */
	cloneSelection : function(){
		if(this.el){
			var len = SCOM.countObjMember(this.stack);
			var colors = SCOM.colors;			
			/*
			 * clone the el
			 */
			var ifbody = this.region.ifbodyEl;
			var clone = Ext.core.DomHelper.append(ifbody, this.getHtmlStr(), true);
			/*
			 * set zindex
			 */
			clone.setStyle('z-index', SCONST['SM_Z_INDEX']);
			/*
			 * for FF sake, we need use Ext getWidth/setWidth first, width is 0, then try getStyle/setStyle
			 */
			var width = this.el.getWidth();
			if(width){
				clone.setWidth(width);
			}else{
				clone.setStyle('width', this.el.getStyle('width'));
			}	
			var height = this.el.getHeight();
			if(height){
				clone.setHeight(this.el.getHeight());
			}else{
				clone.setStyle('height', this.el.getStyle('height'));
			}			
			
			clone.setStyle('left', this.el.getStyle('left'));
			clone.setStyle('top', this.el.getStyle('top'));
			var color = this.inel.getStyle('background-color');
			clone.setStyle('border-color', color);
			Ext.get(clone.dom.firstChild).setStyle('background-color', color);
			Ext.get(clone.dom.lastChild).setStyle('background-color', color);
			clone.show();									
			/*
			 * get the colorIndex
			 */
			var index, max = -1;						
			for(var p in this.stack){
				var colorIndex = this.stack[p].colorIndex;
				if(Ext.isNumber(colorIndex)){
					if(max < colorIndex){
						max = colorIndex;
					}
				}
			}
			if(Ext.isNumber(this.colorIndex)){
				if(max < this.colorIndex){
					max = this.colorIndex;
				}
			}
			/*
			 * check whether has colorIndex
			 */
			if(-1 != max){			
				index = max+1;
			}else{
				index = len%colors.length;
			}
			this.colorIndex = index;
			index = index%colors.length;
			this.el.setStyle('border-color', colors[index]);
			this.inel.setStyle('background-color', colors[index]);
			this.dotel.setStyle('background-color', colors[index]);
			return clone.dom;
		}		
	},
	
		
	
	getCoordObjByElement : function(el){
		for(var p in this.stack){
			var it = this.stack[p];
			if(it.el == el){
				return it;
			}
		}
		if(this.el.dom == el){
			return {
				el: el,
				coord: this.selection2Span()
			};
		}
	},
	
	/*
	 * clear the selection
	 */
	clearSelection : function(suspendEvent){		
		this.callParent(arguments);
		if(this.el){
			var colors = SCOM.colors;		
			this.el.setStyle('border-color', colors[0]);
			this.inel.setStyle('background-color', colors[0]);
			this.dotel.setStyle('background-color', colors[0]);
			this.colorIndex = 0;			
		}
	},		
		
	/*
	 * get the coord from the stack	 
	 */
	getReference : function(withCls){		
		var sels = [];
		for(var p in this.stack){
			var it = this.stack[p];
			var coord = it.coord;
			var id = p;
			if(withCls && this.refCls && this.refCls[id]){
				sels.push({
					cls: this.refCls[id],
					colorIndex: it.colorIndex,
					span: coord
				})
			}else{
				sels.push({					
					colorIndex: it.colorIndex,
					span: coord
				});
			}			
		}	
		
		/*
		 * get the coord
		 */
		if(!this.isEmpty()){
			var coord = this.selection2Span();	
			var tmp = coord.concat([this.colorIndex]);
			var id = tmp.join('$');
			if(!this.stack || !this.stack[id]){
				if(withCls && this.refCls && this.refCls[id]){
					sels.push({
						colorIndex: this.colorIndex,
						cls: this.refCls[id],
						span: coord
					});
				}else{
					sels.push({
						colorIndex: this.colorIndex,						
						span: coord
					});
				}							
			}
		}		
		
		return sels;
	},
	
	/*
	 * return the reference of current element without stack
	 */
	getReferenceWithoutStack : function(){
		/*
		 * get the coord
		 */
		if(!this.isEmpty()){
			var coord = this.selection2Span();			
			return [coord];
		}
	},
	
	/*
	 * set reference and refresh the reference mode UI if need
	 * @param {array} refs: the refs coord to set
	 * @param {boolean} forceRefresh: true to refresh the element
	 * @param {boolean} suspendEvent: true to not fire the related event
	 * @param {string} cls: the css class add to the reference elements
	 * @param {int} currrentColorIndex: the colorIndex set for current reference element
	 */
	setReference : function(refs, forceRefresh, supsendEvent, cls, currentColorIndex){		
		
		var colors = SCOM.colors;
		/* 
		 * clear the selection first
		 */		
		this.stack = this.stack || {};				
		
		var visited = {}, refCls = {};
		var region = this.getRegion();
		var sheetId = region.getSheetId();
		var len = refs.length;
		if((0 == len || forceRefresh) && this.el){
			this.el.setStyle('left', '-10000px');
		}
		
		var colorLen = SCOM.colors.length;
		this.colorIndex = 0;
		for(var i = 0; i < len; i++){
			var ref = refs[i], rcls = false, colorIndex = i;
			/*
			 * colorIndex is for customer assigned color index 
			 */
			if(!Ext.isArray(ref) && ref.span){
				rcls = ref.cls;
				if(!SCOM.nullOrUndefined(ref.colorIndex)){
					colorIndex = ref.colorIndex;
				}				
				ref = ref.span;				
			}
			var coord = [].concat(ref);
			if(SCOM.nullOrUndefined(coord[0]) || '' === coord[0]){
				coord[0] = sheetId;
			}
			var id = (coord.concat([colorIndex])).join('$');
			visited[id] = true;
			refCls[id] = rcls;
			if(sheetId == coord[0]){
				/*
				 * refresh the reference element in current sheet
				 */
				if(!this.stack[id] || !this.stack[id].el){								
					if(this.el){			
						var realColorIndex = colorIndex%colorLen;
						this.el.setStyle('border-color', colors[realColorIndex]);
						this.inel.setStyle('background-color', colors[realColorIndex]);
						this.dotel.setStyle('background-color', colors[realColorIndex]);
					}		
					var skipCoverMergedCell = this.skipCoverMergedCell;
					this.skipCoverMergedCell = true;
					this.selectRange({
						row:coord[1],
						col:coord[2]
					}, {
						row:coord[3],
						col:coord[4]
					}, true);
					this.skipCoverMergedCell = skipCoverMergedCell;
					/*
					 * save colorIndex
					 */
					this.colorIndex = colorIndex;
					/*
					 * push to save
					 */
					this.pushSelection();
				}else{
					var el = Ext.get(this.stack[id].el);	
					/*
					 * save colorIndex
					 */
					this.stack[id].colorIndex = colorIndex;
					var realColorIndex = colorIndex%colorLen;
					var realColor = colors[realColorIndex];
					el.setStyle('border-color', realColor);
					el.down('.ss-rm-inner').setStyle('background-color', realColor);
					el.down('.ss-rm-rbdot').setStyle('background-color', realColor);
				}
			}else{				
				/*
				 * remove the reference element not in current sheet 
				 */
				if(!this.stack[id]){
					this.stack[id] = {
						coord:coord,
						colorIndex: colorIndex
					}					
				}else{
					this.stack[id].colorIndex = colorIndex;
					if(this.stack[id].el){
						Ext.removeNode(this.stack[id].el);
					}
				}
				/*
				 * save colorIndex
				 */
				this.colorIndex = colorIndex+1;
				if(this.el){
					var realColorIndex = this.colorIndex%colorLen;
					var realColor = colors[realColorIndex];
					this.el.setStyle('border-color', realColor);					
					this.inel.setStyle('background-color', realColor);
					this.dotel.setStyle('background-color', realColor);
				}				
			}
		}					
		for(var p in this.stack){
			if(!visited[p]){	
				if(this.stack[p].el){					
					Ext.removeNode(this.stack[p].el);
				}
				delete(this.stack[p]);
			}
		}		
		if(0 == len){
			delete(this.stack);
			/*
			 * if no referenc the clear the startPos and endPos too
			 */
			delete(this.startPos);
			delete(this.endPos);
		}
		for(var p in this.stack){
			var it = this.stack[p];
			if(it.el){				
				var el = Ext.get(it.el);
				/*
				 * reset the css
				 */
				el.dom.className = 'ss-rm';				
				if(this.disabled){
					el.addCls('ss-rm-disabled');
				}else{
					el.removeCls('ss-rm-disabled');
				}
				if(refCls[p]){
					el.addCls(refCls[p]);
				}
				if(this.curCls){
					el.removeCls(this.curCls);
				}
				if(cls){
					el.addCls(cls);
				}				
			}
		}
		this.clearEl();
		
		if(this.el){
			if(this.curCls){
				this.el.removeCls(this.curCls);
			}
			this.el.addCls(cls);
		}
		if(!SCOM.nullOrUndefined(currentColorIndex)){			
			this.colorIndex = currentColorIndex;
		}		
		/*
		 * save the cls
		 */
		this.refCls = refCls;
		this.curCls = cls;
		if(!supsendEvent){						
			
			this.fireEvent('selectionchange', this.startPos, this.endPos, region, this);			
		}
	},
	
	hasCls : function(cls){
		return cls === this.curCls;
	},
	
	/*
     * hide this selection model
     * @param {boolean} suspendEvent: true to not fire event
     */
	hide : function(suspendEvent){		
		
		for(var p in this.stack){
			var it = this.stack[p];
			//remove the nodes
			if(it.el){
				Ext.get(it.el).hide();				
			}
		}		
		
		/*
		 * just clear the selection when hide, and re-select it when it show
		 */
		this.clearSelection(true);
		this.callParent(arguments);		
	},
	
	clearEl : function(){
		if(this.el){
			this.el.setLeft(-1000);
			this.el.setTop(-1000);
			delete(this.startPos);
			delete(this.endPos);
		}
	},
	
	/*
     * show this selection model
     * @param {boolean} suspendEvent: true to not fire event
     */
	show : function(suspendEvent){				
		for(var p in this.stack){
			var it = this.stack[p];
			/*
			 * remove the nodes
			 */
			if(it.el){
				Ext.get(it.el).show();
			}
		}	
		this.callParent(arguments);		
	},
	
	/*
	 * set anchor cell
	 */
	setAnchorCell : function(row, col){
		if(Ext.isDefined(row) && Ext.isDefined(col)){
			this.anchorCell = {
				row: row,
				col: col
			};
		}else{
			delete(this.anchorCell);
		}		
		/*
		 * fire event
		 */
		this.fireEvent('anchorchange', this.anchorCell, this);
	},
	
	getAnchorCell : function(){
		if(this.anchorCell){
			return Ext.apply({}, this.anchorCell);
		}else{
			this.anchorCell = Ext.apply({}, this.startPos);
			return Ext.apply({}, this.anchorCell);
		}				
	},
	
	/*
	 * refresh the selection
	 */
	refreshSelection : function(){		
		var ref = this.getReference(true);
		var cls = this.curCls;
		var currentColorIndex = this.colorIndex;
		if(ref.length){
			/*
			 * clear first
			 */
			this.clearSelection(true);
			this.setReference(ref, null, true, cls, currentColorIndex);
		}
	},
	
	/*
	 * set active reference by add a class for that element
	 */
	activeCoordSpan : function(coord, colorIndex){		
		var store = this.getRegion().getStore();
		if(Ext.isString(coord)){
			coord = EnterpriseSheet.sheet.calculate.Coordinate.prototype.string2Coord(coord);			
			if(coord && 0 < coord.length){
				coord = coord[0].span;
				if(!Ext.isNumber(coord[0])){
					var sheetId = store.getSheetIdByName(coord[0]);
					if(SCOM.nullOrUndefined(sheetId)){
						sheetId = this.getRegion().getSheetId();
					}
					coord[0] = sheetId;
				}
			}
		}		
		var cid = (coord.concat([colorIndex])).join('$'), found = false;
		
		for(var p in this.stack){
			var el = this.stack[p].el;
			if(p == cid){
				found = p;				
				if(el){
					el = Ext.get(el);
					el.addCls('ss-rm-actived');
				}				
			}else{
				if(el){
					el = Ext.get(el);
					el.removeCls('ss-rm-actived');
				}
			}
		}
		if(this.el){			
			if(!found){
				if(!this.isEmpty()){
					var span = this.selection2Span();
					var eid = (span.concat([this.colorIndex])).join('$');				
					if(eid == cid){
						this.el.addCls('ss-rm-actived');
					}else{
						this.el.removeCls('ss-rm-actived');
					}
				}else{
					this.el.removeCls('ss-rm-actived');
				}										
			}else{									
				this.el.removeCls('ss-rm-actived');				
				this.pushSelection();
				var foundEl = Ext.get(this.stack[found].el);
				var coord = this.stack[found].coord;
				if(foundEl){
					/*
					 * remove the old node
					 */
					Ext.removeNode(this.el.dom);
					this.el = foundEl;
					this.inel = this.el.down('.ss-rm-inner');
					this.dotel = this.el.down('.ss-rm-rbdot');
				}else{
					this.clearEl();
					var colors = SCOM.colors;
					var realColor = colors[colorIndex%colors.length];
					this.el.setStyle('border-color', realColor);
					this.inel.setStyle('background-color', realColor);
					this.dotel.setStyle('background-color', realColor);
				}				
				
				this.colorIndex = colorIndex;
				this.startPos = {
					row: coord[1],
					col: coord[2]
				};
				this.endPos = {
					row: coord[3],
					col: coord[4]
				}				
				delete(this.stack[found]);
			}					
		}						
	},
	
	/*
	 * resume the selected coord span to normal
	 */
	deactiveCoordSpan : function(){				
		for(var p in this.stack){
			var el = this.stack[p].el;
			if(el){
				el = Ext.get(el);
				el.removeCls('ss-rm-actived');
			}
		}
		if(this.el){
			this.el.removeCls('ss-rm-actived');
			this.pushSelection();
			this.clearEl();
		}
		this.setAnchorCell();
	},
	
	/*
	 * select previous cell in x or y axis
	 * @param {string} dir: the direction for the previous cell, could be {'row', 'col'}
	 * @param {boolean} expand: true to expand the selection like press the shift key
	 * @param {boolean} suspendEvent: true to suspend 'selectionchange' event
	 */
	selectPrevious : function(dir, expand, suspendEvent){
		if(this.disabled){
			/*
			 * return if disabled
			 */
			//return;
		}
		if('col' !== dir){
			dir = 'row';
		}
		var r = this.region;
		var sheetId = r.getSheetId();
		var store = r.getStore();
		var pos, minMaxPos, anchorCell = this.getAnchorCell(), posFlag;
		if(expand){
			minMaxPos = this.getMinMaxPos();
			posFlag = (minMaxPos.minrow == anchorCell.row && 'row' == dir)
				|| (minMaxPos.mincol == anchorCell.col && 'col' == dir);
			if(posFlag){
				pos = {row: minMaxPos.maxrow, col: minMaxPos.maxcol};
			}else{
				pos = {row: minMaxPos.minrow, col: minMaxPos.mincol};
			}			
		}else{
			pos = anchorCell;
		}
		if(pos){
			var row, col, cell = store.getCell(sheetId, pos.row, pos.col, true); 
			var merged = store.isMergedCell(cell, sheetId, pos.row, pos.col);
			if('row' == dir){
				if(merged){
					row = pos.row+cell.minrow;
				}else{
					row = pos.row;
				}					
				/*
				 * find proevious visible row
				 */
				for(var i = row-1; 1 <= i; i--){
					if(store.isVisibleRow(sheetId, i)){
						break;
					}
				}
				if(1 <= i){
					row = i;
				}				
				col = pos.col;				
			}else{
				row = pos.row;
				if(merged){
					col = pos.col+cell.mincol;
				}else{
					col = pos.col;
				}
				/*
				 * find proevious visible row
				 */
				for(var i = col-1; 1 <= i; i--){
					if(store.isVisibleColumn(sheetId, i)){
						break;
					}
				}
				if(1 <= i){
					col = i;
				}
			}
			if(expand){
				if(posFlag){
					this.selectRange({
						row: minMaxPos.minrow,
						col: minMaxPos.mincol
					}, {
						row:row,
						col:col
					}, suspendEvent);
				}else{
					this.selectRange({
						row:row,
						col:col
					}, {
						row: minMaxPos.maxrow,
						col: minMaxPos.maxcol
					}, suspendEvent);
				}							
			}else{
				anchorCell = this.getAnchorCell();
				var rowOffset = row-anchorCell.row, colOffset = col-anchorCell.col;
				var limit = 0 < this.startPos.row ? 1 : 0;
				var newStartRow = this.startPos.row+rowOffset;
				if(limit > newStartRow){
					newStartRow = limit;
				}
				limit = 0 < this.startPos.col ? 1 : 0;
				var newStartCol = this.startPos.col+colOffset;
				if(limit > newStartCol){
					newStartCol = limit;
				}
				limit = 0 < this.endPos.row ? 1 : 0;
				var newEndRow = this.endPos.row+rowOffset;
				if(limit > newEndRow){
					newEndRow = limit;
				}
				limit = 0 < this.endPos.col ? 1 : 0;
				var newEndCol = this.endPos.col+colOffset;
				if(limit > newEndCol){
					newEndCol = limit;
				}
				this.selectRange({
					row: newStartRow,
					col: newStartCol
				}, {
					row: newEndRow,
					col: newEndCol
				}, suspendEvent);
				
				this.setAnchorCell(row, col);
			}			
			return {
				row:row,
				col:col
			};
		}		
	},
	
	/*
	 * select next cell in x or y axis
	 * @param {string} dir: the direction for the next cell, could be {'row', 'col'}
	 * @param {boolean} expand: true to expand the selection like press the shift key
	 * @param {boolean} suspendEvent: true to suspend 'selectionchange' event
	 */
	selectNext : function(dir, expand, suspendEvent){
		if(this.disabled){
			/*
			 * return if disabled
			 */
			//return;
		}
		if('col' !== dir){
			dir = 'row';
		}
		var r = this.region;
		var sheetId = r.getSheetId();
		var store = r.getStore();
		var pos, minMaxPos, anchorCell = this.getAnchorCell(), posFlag;
		if(expand){
			minMaxPos = this.getMinMaxPos();
			posFlag = (minMaxPos.minrow == anchorCell.row && 'row' == dir)
				|| (minMaxPos.mincol == anchorCell.col && 'col' == dir);
			if(posFlag){
				pos = {row: minMaxPos.maxrow, col: minMaxPos.maxcol};
			}else{
				pos = {row: minMaxPos.minrow, col: minMaxPos.mincol};
			}			
		}else{
			pos = anchorCell;
		}	
		if(pos){
			var row, col, cell = store.getCell(sheetId, pos.row, pos.col, true); 
			var merged = store.isMergedCell(cell, sheetId, pos.row, pos.col);
			if('row' == dir){
				if(merged){				
					row = pos.row+cell.maxrow+1;
				}else{
					row = pos.row+1;
				}
				col = pos.col;		
				/*
				 * find next visible row
				 */
				for(var i = row; true; i++){
					if(store.isVisibleRow(sheetId, i)){
						break;
					}
				}
				row = i;
			}else{
				row = pos.row;				
				if(merged){				
					col = pos.col+cell.maxcol+1;
				}else{
					col = pos.col+1;
				}
				/*
				 * find next visible column
				 */
				for(var i = col; true; i++){
					if(store.isVisibleColumn(sheetId, i)){
						break;
					}
				}
				col = i;
			}
			if(expand){
				if(posFlag){
					this.selectRange({
						row: minMaxPos.minrow,
						col: minMaxPos.mincol
					}, {
						row:row,
						col:col
					}, suspendEvent);
				}else{
					this.selectRange({
						row:row,
						col:col
					}, {
						row: minMaxPos.maxrow,
						col: minMaxPos.maxcol
					}, suspendEvent);
				}			
			}else{
				anchorCell = this.getAnchorCell();
				var rowOffset = row-anchorCell.row, colOffset = col-anchorCell.col;
				var limit = 0 < this.startPos.row ? 1 : 0;
				var newStartRow = this.startPos.row+rowOffset;
				if(limit > newStartRow){
					newStartRow = limit;
				}
				limit = 0 < this.startPos.col ? 1 : 0;
				var newStartCol = this.startPos.col+colOffset;
				if(limit > newStartCol){
					newStartCol = limit;
				}
				limit = 0 < this.endPos.row ? 1 : 0;
				var newEndRow = this.endPos.row+rowOffset;
				if(limit > newEndRow){
					newEndRow = limit;
				}
				limit = 0 < this.endPos.col ? 1 : 0;
				var newEndCol = this.endPos.col+colOffset;
				if(limit > newEndCol){
					newEndCol = limit;
				}
				this.selectRange({
					row: newStartRow,
					col: newStartCol
				}, {
					row: newEndRow,
					col: newEndCol
				}, suspendEvent);
						
				this.setAnchorCell(row, col);
			}			
			return {
				row:row,
				col:col
			};
		}		
	},
	
	/*
	 * override setFocusCell, just don't change the focus cell 
	 */
	setFocusCell : function(){
		return;
	}
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.sm.ColumnReferenceModel', {
	/* Begin Definitions */
	
	extend : 'EnterpriseSheet.sheet.sm.CellReferenceModel',
	
	/* End Definitions */
	
	/*
	 * create and render the selection model element when the binded region is rendered
	 */		
	prepareSelectionModel : Ext.emptyFn,	
		
	/*
	 * select a range
	 */
	doSelect : function(startPos, endPos, suspendEvent){
		/*
		 * set endPos.row to 0 
		 */
		startPos.row = 0;
		endPos.row = 0;
		
		this.callParent(arguments); 		
	},
	
	/*
	 * check the position whether fit the scrolling condition, if yes, change the pos varible
	 */
	checkDragScrolling : function(position, pos){
		var r = this.getRegion();
		var x = position.x, y = position.y, w = position.w, h = position.h;
		var flag = false;
		/*
		 * if the offset is less than start2ScrollOffset then scrolling
		 */		
		if(this.start2ScrollOffset > x){
			/*
			 * can not beyond the row/col bound
			 */
			if(pos.col > r.colBound.low || r.colStart > r.colBound.low){ 
				var col = pos.col-this.dragScrollingStep; 
				if(col > r.colBound.low){
					pos.col = col;
				}else{
					pos.col = r.colBound.low;
				}
				flag = true;
			}
		}else if(x-w > -this.start2ScrollOffset){ 
			if(!r.colBound.high){
				pos.col += this.dragScrollingStep;
				if(pos.col <= r.colEnd){
					pos.col = r.colEnd+1;
				}
			}
			flag = true;
		}
		/*
		 * for column selection the row should always equal 0
		 */
		pos.row = 0;
		
		return flag;
	}
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.sm.RowReferenceModel', {
	/* Begin Definitions */
	
	extend : 'EnterpriseSheet.sheet.sm.CellReferenceModel',
	
	/* End Definitions */
	/*
	 * create and render the selection model element when the binded region is rendered
	 */		
	prepareSelectionModel : Ext.emptyFn,	
		
	/*
	 * select a range
	 */
	doSelect : function(startPos, endPos, suspendEvent){
		/*
		 * set endPos.col to 0 
		 */
		startPos.col = 0;
		endPos.col = 0;

		this.callParent(arguments);
	}
});
Ext.define('EnterpriseSheet.sheet.regions.InfinateScroller', {
	
	/* Begin Definitions */
	extend: 'Ext.util.Observable',
		
	
	/* End Definitions */
	
	constructor : function(config){
		Ext.apply(this, config);
		
		this.scrolling = false;
		
		this.callParent([config]);		
		
		
	},
	
	visible : true,
	
	/*
	 * the width/height of the scroller
	 */
	scrollerLength : 17,
	
	lastScrollTop : 0,
		
	lastScrollLeft : 0,
	
	lastRow : 0, 
	
	lastCol : 0,
	
	scrollOffset : Ext.isChrome ? 80 : 10,
	
	scrollStep : 1,
	
	/*
	 * flag to disable mousewheel action
	 */
	disableWheel : false,
	
	init : function(ct){
		this.region = ct;		
		
		this.mon(ct, 'afterrender', this.prepareScroller, this);
		this.mon(ct, 'resize', this.onResize, this);		
	},
	
	isLocked : function(){
		return this.scrolling;
	},
		
	lockScroll : function(){
		this.scrolling = true;		
	},
	
	resizeScroller : function(w, h){
		var region = this.getRegion();
		if(this.rel && this.cel){	
			if(w){
				this.cel.setWidth(w-this.scrollerLength);
			}
			if(h){				
				h = h-this.scrollerLength;
				this.rel.setHeight(h);				
			}
		}else if(this.cel){
           if(w){
				this.cel.setWidth(w);
           }
		}else if(this.rel){
			if(h){
				this.rel.setHeight(h);
			}
		}
		
		/*
		 * set fixedRowHeight and fixedColWidth if the max property of rowBound and colBound is defined
		 */
		var rowBound = region.rowBound, colBound = region.colBound;	
		var rowBoundMax = SCONST.MAX_ROW_NUMBER, colBoundMax = SCONST.MAX_COLUMN_NUMBER;
		if(Ext.isNumber(rowBoundMax)){
			var rowSpan = region.rowEnd-region.rowStart;
			var maxHeight = h+(rowBoundMax-rowBound.min)*this.scrollOffset;			
			this.fixedRowHeight = maxHeight;
		}else{
			delete(this.fixedRowHeight);
		}		
		
		if(Ext.isNumber(colBoundMax)){
			var colSpan = region.colEnd-region.colStart;
			var maxWidth = w+(colBoundMax-colBound.min)*this.scrollOffset;			
			this.fixedColWidth = maxWidth;
		}else{
			delete(this.fixedColWidth);
		}		
	},
	
	/*
	 * when the region resize, need resize the scroller too
	 */
	onResize : function(c, aw, ah, w, h){
		this.lockScroll();
		this.resizeScroller(aw, ah);
		if(this.rel || this.cel){
			this.sysn();
		}
		this.unlockScroll();
	},
	
	unlockScroll : function(){
		this.scrolling = false;
	},
	
	prepareScroller : function(p){
		var El = p.el, el = p.el.dom;
		var arr, slen = this.scrollerLength+1;		
		/*
		 * here need prepare different html based on different scroller
		 * also for some IE reason, we need seperate the v-scroller and h-scroller in two independent div
		 * which makes this a little nest
		 */		 
		if('y' == this.dir){
			arr = [
				'<div class="ss-irct" style="width:', slen, 'px;z-index:', SCONST['TOP_Z_INDEX'], ';">', 
					'<div class="ss-irbody" style="width:1px;">',
					'</div>',
				'</div>'
			];
			this.rel = Ext.core.DomHelper.append(el, arr.join(''), true);
			this.rbody = Ext.get(this.rel.dom.firstChild);
		}else if('x' == this.dir){
			arr = [
				'<div class="ss-icct" style="height:', slen, 'px;z-index:', SCONST['TOP_Z_INDEX'], ';">', 
					'<div class="ss-icbody" style="height:1px;">',
					'</div>',
				'</div>'
			];
			Ext.core.DomHelper.append(el, arr.join(''), true);
			this.cel = Ext.core.DomHelper.append(el, arr.join(''), true);
			this.cbody = Ext.get(this.cel.dom.firstChild);
		}else if('xy' == this.dir){
			/*
			 * if it's xy direction scroller, we need cover the right-bottom hole
			 */
			var len = this.scrollerLength; 
			var pack = ('xy' == this.dir && (!Ext.isMac || Ext.isGecko))?
			//var pack = 'xy' == this.dir ?
				('<div class="ss-rbpack" style="width:'+len+'px;height:'+len+'px;z-index:'+SCONST['TOP_Z_INDEX']+';"></div>'):'';
			arr = [pack,
				'<div class="ss-irct" style="width:', slen, 'px;z-index:', SCONST['TOP_Z_INDEX'], ';">', 
					'<div class="ss-irbody" style="width:1px;">',
					'</div>',
				'</div>',
				'<div class="ss-icct" style="height:', slen, 'px;z-index:', SCONST['TOP_Z_INDEX'], ';">', 
					'<div class="ss-icbody" style="height:1px;">',
					'</div>',
				'</div>'				
			];
			Ext.core.DomHelper.append(el, arr.join(''), true);
			this.rel = El.down('.ss-irct');			
			this.rbody = Ext.get(this.rel.dom.firstChild);
			this.cel = El.down('.ss-icct');
			this.cbody = Ext.get(this.cel.dom.firstChild);
		}
		if(!this.disableWheel){
			this.mon(El, 'mousewheel', this.onMouseWheel, this);
		}
		
		if(this.rel){		
			this.mon(this.rel, 'scroll', this.onRowScroll, this);			
		}		
		if(this.cel){			
			this.mon(this.cel, 'scroll', this.onColScroll, this);
		}
		this.setVisible(this.visible);
		/*
		 * need init the size of scroller
		 */
		this.onResize(El, El.getWidth(), El.getHeight());
	},
	
	getDir : function(){
		return this.dir;
	},
	
	/**
	 * _private
	 * increase the row body height
	 */
	limitBodyHeight : function(newHeight){
		if(this.fixedRowHeight && newHeight > this.fixedRowHeight){
			newHeight = this.fixedRowHeight;
		}
		this.rbody.setHeight(newHeight);		
	},
	
	limitBodyWidth : function(newWidth){
		if(this.fixedColWidth && newWidth > this.fixedColWidth){
			newWidth = this.fixedColWidth;
		}
		this.cbody.setWidth(newWidth);
	},
	
	onRowScroll : function(e){
		if(!this.isLocked()){
			this.lockScroll();

			var r = this.getRegion();
			var el = this.rel.dom;
			var st = el.scrollTop, index;	
			
			if(st != this.lastScrollTop){
				index = Math.round(st/this.scrollOffset);
				if(index == this.lastRow){
					this.unlockScroll();
					return;					
				}
				var bh = this.rbody.getHeight();
				var offset = index-this.lastRow;	
				st = index*this.scrollOffset;
				if(0 < offset){
					offset = r.moveDown(offset);
				}else{
					offset = r.moveUp(-offset);
				}
				this.lastRow = index;
				if(0 != offset){
					this.fireEvent('rowscrolling', offset, r, this);
				}
				var eh = this.rel.getHeight();
				if(bh-el.scrollTop-eh <= this.scrollOffset){
					var newHeight = bh+this.scrollOffset;					
					this.limitBodyHeight(newHeight);									
				}
				el.scrollTop = st;
				this.lastScrollTop = el.scrollTop;											
			}
							
			this.unlockScroll();
		}
	},
	
	onColScroll : function(e){
		if(!this.isLocked()){
			this.lockScroll();
			
			var r = this.getRegion();
			var el = this.cel.dom;
			var sl = el.scrollLeft, index;						
			
			if(sl != this.lastScrollLeft){
				index = Math.round(sl/this.scrollOffset);
				if(index == this.lastCol){
					this.unlockScroll();
					return;					
				}
				var offset = index-this.lastCol;
				sl = index*this.scrollOffset;
				if(0 < offset){
					offset = r.moveRight(offset);
				}else{
					offset = r.moveLeft(-offset);
				}
				this.lastCol = index;
				if(0 != offset){
					this.fireEvent('colscrolling', offset, r, this);
				}
				var bw = this.cbody.getWidth(), ew = this.cel.getWidth();
				if(bw-el.scrollLeft-ew <= this.scrollOffset){
					this.limitBodyWidth(bw+this.scrollOffset);
				}
				el.scrollLeft = sl;
				this.lastScrollLeft = el.scrollLeft;
			}			
			this.unlockScroll();
		}
	},
	
	onMouseWheel : function(e){
		e.preventDefault();
		
		var delta = e.getWheelDeltas();	
		if(0 > delta.y){
			this.scrollRow(this.scrollStep);
		}else if(0 < delta.y){
			this.scrollRow(-this.scrollStep);
		}
		if(0 > delta.x){
			this.scrollCol(this.scrollStep);
		}else if(0 < delta.x){
			this.scrollCol(-this.scrollStep);
		}
	},
	
	setVisible : function(visible){
		/*
		 * lock the scroller when show/hide
		 */
		this.lockScroll();
		this.visible = visible;
		if(this.rel){
			this.rel.setVisible(visible);
		}
		if(this.cel){
			this.cel.setVisible(visible);
		}
		this.unlockScroll();
	},
	
	isVisible: function(){
		return this.visible;
	},
	
	sysn : function(dir){
		dir = dir || 'both';
		/*
		 * disable the scrolling action
		 */
		this.lockScroll();
		var r = this.getRegion();	
		var sheetId = r.getSheetId();
		var s = r.getStore();
		/*
		 * need make sure the body size is suit for the scroller position
		 */
		if(this.cel && ('x' == dir || 'both' == dir)){
			var cel = this.cel.dom;
			var w = this.cel.getWidth();
			/*
			 * handle hidden column, the hidden columns should not be included when
			 * calculate the scroll position
			 */
			var hiddenCol = 0;
			for(var i = r.colBound.low; i < r.colStart; i++){
				if(!s.isVisibleColumn(sheetId, i)){
					hiddenCol++;
				}
			}
			this.lastCol = r.colStart-r.colBound.low-hiddenCol;
			var sl = this.lastCol*this.scrollOffset;
			w += sl;
			var cw = this.cbody.getWidth();
			if(w >= cw){
				this.limitBodyWidth(w+this.scrollOffset);	
			}
			cel.scrollLeft = sl;		
			this.lastScrollLeft = cel.scrollLeft;
		}
		if(this.rel && ('y' == dir || 'both' == dir)){
			var rel = this.rel.dom;
			var h = this.rel.getHeight();
			/*
			 * handle hidden row, the hidden rows should not be included when
			 * calculate the scroll position
			 */
			var hiddenRow = 0;
			for(var i = r.rowBound.low; i < r.rowStart; i++){
				if(!s.isVisibleRow(sheetId, i)){
					hiddenRow++;
				}
			}		
			this.lastRow = r.rowStart-r.rowBound.low-hiddenRow;
			var st = this.lastRow*this.scrollOffset;
			h += st;
			var rh = this.rbody.getHeight();
			if(h >= rh){
				var newHeight = h+this.scrollOffset;				
				this.limitBodyHeight(newHeight);
			}			
			rel.scrollTop = st;
			this.lastScrollTop = rel.scrollTop;
		}
				
		/*
		 * enable the scrolling action
		 */
		this.unlockScroll();
	},
	
	getRegion : function(){
		return this.region;
	},
	
	/*
	 * scroll row up or down based on row offset
	 */
	scrollRow : function(offset){
		
		if(0 === offset){
			return;
		}
		/*
		 * if has row scroller, update the scrollTop
		 * else just move the region
		 */		
		var El = this.rel; 
		if(El){
			var el = this.rel.dom, bEl = this.rbody;
			/*
			 * scroll row up
			 */
			var st = el.scrollTop+offset*this.scrollOffset; 
			if(0 > st){
				st = 0;
			}else{
				var h = El.getHeight(), bh = bEl.getHeight();
				if(bh-h-st <= this.scrollOffset){
					var newHeight = bh+this.scrollOffset;
					this.limitBodyHeight(newHeight);					
				}
			}
			el.scrollTop = st;
		}else{
			/*
			 * if no scroller, need move row up/down directly and fire an event
			 */
			var r = this.getRegion();			
			/*
			 * onlyRowScrollingEvent is a flag for whether actually move the region, or just fire rowscrolling event;
			 * if true then, skip the move action, let the listener to process, default to false
			 */
			if(!this.onlyRowScrollingEvent){					
				if(0 > offset){
					offset = r.moveUp(-offset);
				}else{
					offset = r.moveDown(offset);
				}
			}
			this.fireEvent('rowscrolling', offset, r, this);
		}
	},
	
	/*
	 * scroll col left or right based on col offset
	 */
	scrollCol : function(offset){
		if(0 === offset){
			return;
		}
		/*
		 * if has col scroller, update the scrollLeft
		 * else just move the region
		 */
		var El = this.cel; 
		if(El){
			var el = this.cel.dom, bEl = this.cbody;
			/*
			 * scroll col left
			 */
			var sl = el.scrollLeft+offset*this.scrollOffset; 
			if(0 > sl){
				sl = 0;
			}else{
				var w = El.getWidth(), bw = bEl.getWidth();
				if(bw-w-sl <= this.scrollOffset){
					this.limitBodyWidth(bw+this.scrollOffset);
				}
			}
			el.scrollLeft = sl;
		}else{
			/*
			 * if no scroller, need move col left/right directly and fire an event
			 */
			var r = this.getRegion();			
			if(!this.onlyColScrollingEvent){
				/*
				 * onlyColScrollingEvent is a flag for whether actually move the region, or just fire colscrolling event;
				 * if true then, skip the move action, let the listener to process, default to false
				 */
				if(0 > offset){
					offset = r.moveLeft(-offset);
				}else{
					offset = r.moveRight(offset);
				}
			}
			this.fireEvent('colscrolling', offset, r, this);
		}
	},
	
	getScrollerLength : function(dir){
		var len = 0;
		if('col' == dir){
			if(this.rel){
				len = this.rel.getWidth();
			}
		}else{
			if(this.cel){
				len = this.cel.getHeight();
			}
		}
		return len;
	},		
	
	destroy: function(){
		var region = this.region;		
		region.un('afterrender', this.prepareScroller, this);
		region.un('resize', this.onResize, this);		
		region.getEl().un('mousewheel', this.onMouseWheel, this);
		if(this.rel){			
			this.rel.un('scroll', this.onRowScroll, this);
		}		
		if(this.cel){			
			this.cel.un('scroll', this.onColScroll, this);
		}
        this.clearListeners();
    }
});
Ext.define('EnterpriseSheet.sheet.regions.ImmerseScroller', {
	
	/* Begin Definitions */
	extend: 'Ext.util.Observable',
		
	
	/* End Definitions */
    
    pressInterval: 50,
    
    defaultRow : 100,
    
    defaultCol : 50,
    
    rowFactor: 1,
    
    colFactor: 1,
    
    alwaysVisible: false,
	
	constructor : function(config){
		Ext.apply(this, config);
		
		this.scrolling = false;
		
		this.callParent([config]);		
		
		
           
        this.on('checkingrowscrolling', function(){
            if(!this.alwaysVisible && this.visible && this.rel){
                if(!this.rel.hasCls('ss-imrct-over')){
                    this.rel.fadeOut({
                        remove: false,
                        useDisplay: true,
                        callback: function(){
                            this.rel.removeCls('ss-imrct-scrolling');
                            this.rel.setStyle('opacity', '');
                            this.rel.setStyle('display', '');
                        },
                        scope: this
                    });
                }else{
                    this.rel.removeCls('ss-imrct-scrolling');
                }
            }
        }, this, {buffer: 1000});
           
        this.on('checkingcolscrolling', function(){
            if(!this.alwaysVisible && this.visible && this.cel){
                if(!this.cel.hasCls('ss-imcct-over')){
                    this.cel.fadeOut({
                        remove: false,
                        useDisplay: true,
                        callback: function(){
                            this.cel.removeCls('ss-imcct-scrolling');
                            this.cel.setStyle('opacity', '');
                            this.cel.setStyle('display', '');
                        },
                        scope: this
                    });
                }else{
                    this.cel.removeCls('ss-imcct-scrolling');
                }
            }
        }, this, {buffer: 1000});
	},
	
	visible : true,
	
	/*
	 * the width/height of the scroller
	 */
	scrollerLength : 6,
    
	
	lastScrollTop : 0,
           
    scrollTop: 0,
		
	lastScrollLeft : 0,
           
    scrollLeft: 0,
	
	lastRow : 0, 
	
	lastCol : 0,
	
	scrollOffset : 1,
    
    minThumbLength: 20,
	
	scrollStep : 1,
	
	/*
	 * flag to disable mousewheel action
	 */
	disableWheel : false,
	
	init : function(ct){
		this.region = ct;		
		var store = this.region.getStore();
		this.mon(ct, 'afterrender', this.prepareScroller, this);
		this.mon(ct, 'resize', this.onResize, this);
		
		store.on({
			scope: this,
			'afterloadsheet': function(){
				this.sysn(undefined, true);
			},
			'changeactivedsheetid': function(){
				this.sysn(undefined, true);
			},
			'freezechange': function(){				
				this.sysn(undefined, true);
			},
			'splitchange': function(){
				this.sysn(undefined, true);
			}
		});
		
	},
	
	isLocked : function(){
		return this.scrolling;
	},
		
	lockScroll : function(){
		this.scrolling = true;		
	},
	
	resizeScroller : function(w, h){
		var region = this.getRegion();
		if(this.rel && this.cel){	
			if(w){
				this.cel.setWidth(w-this.cel.getPadding('r'));
			}
			if(h){
				this.rel.setHeight(h-this.rel.getPadding('b'));
			}
		}else if(this.cel){
           if(w){
				this.cel.setWidth(w-this.cel.getPadding('r'));
           }
		}else if(this.rel){
			if(h){
				this.rel.setHeight(h-this.rel.getPadding('b'));
			}
		}
		
		/*
		 * set fixedRowHeight and fixedColWidth if the max property of rowBound and colBound is defined
		 */
		var rowBound = region.rowBound, colBound = region.colBound;	
		var rowBoundMax = SCONST.MAX_ROW_NUMBER, colBoundMax = SCONST.MAX_COLUMN_NUMBER;
		if(Ext.isNumber(rowBoundMax)){
			var rowSpan = region.rowEnd-region.rowStart;
			var maxHeight = h+(rowBoundMax-rowBound.min)*this.scrollOffset;			
			this.fixedRowHeight = maxHeight;
		}else{
			delete(this.fixedRowHeight);
		}		
		
		if(Ext.isNumber(colBoundMax)){
			var colSpan = region.colEnd-region.colStart;
			var maxWidth = w+(colBoundMax-colBound.min)*this.scrollOffset;			
			this.fixedColWidth = maxWidth;
		}else{
			delete(this.fixedColWidth);
		}		
	},
	
	/*
	 * when the region resize, need resize the scroller too
	 */
	onResize : function(c, aw, ah, w, h){
		this.lockScroll();
		this.resizeScroller(aw, ah);
		if(this.rel || this.cel){
			this.sysn(undefined, true);
		}
		this.unlockScroll();
	},
	
	unlockScroll : function(){
		this.scrolling = false;
	},
	
	prepareScroller : function(p){
		var El = p.el, el = p.el.dom;
		var arr, slen = this.scrollerLength+1;		
		/*
		 * here need prepare different html based on different scroller
		 * also for some IE reason, we need seperate the v-scroller and h-scroller in two independent div
		 * which makes this a little nest
		 */		 
		if('y' == this.dir){
			arr = [
                '<div class="ss-imrct '+(this.alwaysVisible ? 'ss-imrct-scrolling' : '')+'" style="z-index:', SCONST['TOP_Z_INDEX'], ';">',
                   '<div class="ss-imrbody"></div>',
                   '<div class="ss-imrup"></div>',
                   '<div class="ss-imrdown"></div>',
                '</div>'
			];
            Ext.core.DomHelper.append(el, arr.join(''), true);
            this.rel = El.down('.ss-imrct');
            this.rbody = El.down('.ss-imrbody');
            this.rup = El.down('.ss-imrup');
            this.rdown = El.down('.ss-imrdown');
		}else if('x' == this.dir){
			arr = [
                '<div class="ss-imcct '+(this.alwaysVisible ? 'ss-imcct-scrolling' : '')+'" style="z-index:', SCONST['TOP_Z_INDEX'], ';">',
                   '<div class="ss-imcbody"></div>',
                   '<div class="ss-imcup"></div>',
                   '<div class="ss-imcdown"></div>',
                '</div>'
			];
            Ext.core.DomHelper.append(el, arr.join(''), true);
            this.cel = El.down('.ss-imcct');
            this.cbody = El.down('.ss-imcbody');
            this.cup = El.down('.ss-imcup');
            this.cdown = El.down('.ss-imcdown');
		}else if('xy' == this.dir){
			
			arr = [
				'<div class="ss-imrct '+(this.alwaysVisible ? 'ss-imrct-scrolling' : '')+'" style="z-index:', SCONST['TOP_Z_INDEX'], ';">',
                    '<div class="ss-imrbody"></div>',
                    '<div class="ss-imrup"></div>',
                    '<div class="ss-imrdown"></div>',
				'</div>',
				'<div class="ss-imcct '+(this.alwaysVisible ? 'ss-imcct-scrolling' : '')+'" style="z-index:', SCONST['TOP_Z_INDEX'], ';">',
					'<div class="ss-imcbody"></div>',
                    '<div class="ss-imcup"></div>',
                    '<div class="ss-imcdown"></div>',
				'</div>'				
			];
			Ext.core.DomHelper.append(el, arr.join(''), true);
			this.rel = El.down('.ss-imrct');
			this.rbody = El.down('.ss-imrbody');
            this.rup = El.down('.ss-imrup');
            this.rdown = El.down('.ss-imrdown');
           
			this.cel = El.down('.ss-imcct');
			this.cbody = El.down('.ss-imcbody');
            this.cup = El.down('.ss-imcup');
            this.cdown = El.down('.ss-imcdown');          
		}
		
		if(!this.disableWheel){
			this.mon(El, 'mousewheel', this.onMouseWheel, this);
		}
        /*
         * for row scrollbar
         */
        if(this.rel){
           this.mon(this.rel, 'mousedown', this.onMouseDownRowTrack, this);
        }
		if(this.rup){
			this.mon(this.rup, 'mousedown', this.onMouseDownRowUp, this);
		}
        if(this.rdown){
           this.mon(this.rdown, 'mousedown', this.onMouseDownRowDown, this);
        }
        /*
         * for col scrollbar
         */
        if(this.cel){
           this.mon(this.cel, 'mousedown', this.onMouseDownColTrack, this);
        }
        if(this.cup){
           this.mon(this.cup, 'mousedown', this.onMouseDownColUp, this);
        }
        if(this.cdown){
           this.mon(this.cdown, 'mousedown', this.onMouseDownColDown, this);
        }
        
		this.setVisible(this.visible);
		/*
		 * need init the size of scroller
		 */
		this.onResize(El, El.getWidth(), El.getHeight());
        
        this.initDnD();
	},
           
    /**
     * init the DnD function
     */
    initDnD : function(){
    	Ext.getDoc().on('mousedown', function(e){
            this.downFlag = true;
            var target = e.getTarget();
            if((this.rup && this.rup.dom === target) || (this.rdown && this.rdown.dom === target)){
                this.adFlag = 'row';
            }else if((this.cup && this.cup.dom === target) || (this.cdown && this.cdown.dom === target)){
                this.adFlag = 'col';
            }else{
                this.adFlag = false;
            }
        }, this);
   
        if(this.rbody){
            this.rbody.on('mousedown', function(e){
                var st = this.rbody.getMargin('t');
                var step = (0 === st || 0 === this.scrollTop) ? 1 : st/this.scrollTop;
                this.mdFlag = {
                    dir: 'row',
                    el: this.rbody,
                    st: this.scrollTop,
                    offset: e.getY()-this.rbody.getTop(),
                    bh: this.rbody.getHeight(),
                    step: step
                };
            }, this);
        }
        if(this.cbody){
            this.cbody.on('mousedown', function(e){
                var sl = this.cbody.getMargin('l');
                var step = (0 === sl || 0 === this.scrollLeft) ? 1 : sl/this.scrollLeft;
                this.mdFlag = {
                    dir: 'col',
                    el: this.cbody,
                    sl: this.scrollLeft,
                    offset: e.getX()-this.cbody.getLeft(),
                    bw: this.cbody.getWidth(),
                    step: step
                };
            }, this);
        }
        Ext.getDoc().on('mousemove', function(e){
            var region = this.getRegion(), regionEl = region.getEl();
            var xy = e.getXY(), x = xy[0], y = xy[1], target = Ext.get(e.getTarget());
            if(this.visible && !this.mdFlag && !this.downFlag && regionEl.contains(target)){
                var rowFlag, colFlag;
                if(this.rel){
                    var xoff = regionEl.getRight()-x;
                    var t = this.rel.getTop(), b = this.rel.getBottom();
                    if(0 < xoff && 16 > xoff && t <= y && y <= b){
                        rowFlag = true;
                    }else{
                        rowFlag = false;
                    }
                }
                if(this.cel){
                    var l = this.cel.getLeft(), r = this.cel.getRight();
                    var yoff = regionEl.getBottom()-y;
                    if(0 < yoff && 16 > yoff && l <= x && x <= r){
                        colFlag = true;
                    }else{
                        colFlag = false;
                    }
                }
                if(!(rowFlag && colFlag)){
                    if(this.rel){
                        if(rowFlag){
                            this.rel.addCls('ss-imrct-over');
                        }else{
                            this.rel.removeCls('ss-imrct-over');
                        }
                    }
                    if(this.cel){
                        if(colFlag){
                            this.cel.addCls('ss-imcct-over');
                        }else{
                            this.cel.removeCls('ss-imcct-over');
                        }
                    }
                }
            }else{
                if(this.rel && !(this.mdFlag && 'row' === this.mdFlag.dir) && 'row' !== this.adFlag){
                    this.rel.removeCls('ss-imrct-over');
                }
                if(this.cel && !(this.mdFlag && 'col' === this.mdFlag.dir) && 'col' !== this.adFlag){
                    this.cel.removeCls('ss-imcct-over');
                }
            }
            
            if(this.mdFlag){
                var dir = this.mdFlag.dir;
                if('row' == dir){
                    var el = this.mdFlag.el, bh = this.mdFlag.bh, h = this.rel.getHeight()-this.rel.getPadding('b'), step = this.mdFlag.step;
                    var st = y-this.rel.getTop()-this.mdFlag.offset;
                    if(0 > st){
                        st = 0;
                    }else if(st+bh > h){
                        st = h-bh;
                    }
                    el.setStyle('margin-top', st+'px');
                    this.scrollTop = Math.floor(st/step);
                    this.onRowScroll();
                }else{
                    var el = this.mdFlag.el, bw = this.mdFlag.bw, w = this.cel.getWidth()-this.cel.getPadding('r'), step = this.mdFlag.step;
                    var sl = x-this.cel.getLeft()-this.mdFlag.offset;
                    if(0 > sl){
                        sl = 0;
                    }else if(sl+bw > w){
                        sl = w-bw;
                    }
                    el.setStyle('margin-left', sl+'px');
                    this.scrollLeft = Math.floor(sl/step);
                    this.onColScroll();
                }
            }
        }, this);
        
        Ext.getDoc().on('mouseup', function(e){
            if(this.mdFlag){
            	var mdFlag = this.mdFlag;
            	delete(this.mdFlag);
                if('row' === mdFlag.dir){
                    this.syncRowThumbPos();
                    this.fireEvent('rowscrolling', 0, this.region, this);
                }else{
                    this.syncColThumbPos();
                    this.fireEvent('colscrolling', 0, this.region, this);
                }                
            }
            delete(this.bmdFlag);
            delete(this.downFlag);
        }, this);
    },
	
	getDir : function(){
		return this.dir;
	},
	
	onRowScroll : function(){
		if(!this.isLocked()){
			this.lockScroll();

			var r = this.getRegion();
			var bEl = this.rbody;
			var st = this.scrollTop, index;
			var rFactor = this.rowFactor || 1;
			if(st != this.lastScrollTop){
				var nIdx = Math.round(st/this.scrollOffset);
				index = Math.round(nIdx*rFactor);
				if(index == this.lastRow){
					this.unlockScroll();
					return;
				}
				var bh = bEl.getHeight();
				var offset = index-this.lastRow;	
				st = nIdx*this.scrollOffset;
				if(0 < offset){
					offset = r.moveDown(offset);
				}else{
					offset = r.moveUp(-offset);
				}
				this.lastRow = index;
				if(0 != offset){
                    this.rel.addCls('ss-imrct-scrolling');
                    this.fireEvent('rowscrolling', offset, r, this);
                    this.fireEvent('checkingrowscrolling', this);
				}
				
				this.lastScrollTop = st;
			}
           
			this.unlockScroll();
		}
	},
	
	onColScroll : function(e){
		if(!this.isLocked()){
			this.lockScroll();
			
			var r = this.getRegion();
            var bEl = this.cbody;
            var sl = this.scrollLeft, index;
            var cFactor = this.colFactor || 1;
            if(sl != this.lastScrollLeft){
                var nIdx = Math.round(sl/this.scrollOffset);
                index = Math.round(nIdx*cFactor);
                if(index == this.lastCol){
                    this.unlockScroll();
                    return;
                }
                var bw = bEl.getWidth();
                var offset = index-this.lastCol;
                sl = nIdx*this.scrollOffset;                
                if(0 < offset){
                    offset = r.moveRight(offset);
                }else{
                    offset = r.moveLeft(-offset);
                }                
                this.lastCol = index;
                if(0 != offset){
                    this.cel.addCls('ss-imcct-scrolling');
                    this.fireEvent('colscrolling', offset, r, this);
                    this.fireEvent('checkingcolscrolling', this);
                }
           
                this.lastScrollLeft = sl;                
            }
			this.unlockScroll();
		}
	},
	
	onMouseWheel : function(e){
		e.stopEvent();
        if(this.mdFlag || this.bmdFlag){
            return;
        }
		var delta = e.getWheelDeltas();

		if(0 > delta.y){
			this.scrollRow(this.scrollStep);
		}else if(0 < delta.y){
			this.scrollRow(-this.scrollStep);
		}

		if(0 > delta.x){
			this.scrollCol(this.scrollStep);
		}else if(0 < delta.x){
			this.scrollCol(-this.scrollStep);
		}
	},
	
	setVisible : function(visible){		
		/*
		 * lock the scroller when show/hide
		 */
		this.lockScroll();
		this.visible = visible;
		if(this.rel){
			this.rel.setVisible(visible);
		}
		if(this.cel){
			this.cel.setVisible(visible);
		}
		this.unlockScroll();
	},
	
	isVisible: function(){
		return this.visible;
	},
	
	sysn : function(dir, forceSyncThumb){
		if(this.isLocked()){
			return;
		}
		dir = dir || 'both';
		var rFactor = this.rowFactor, cFactor = this.colFactor;
		/*
		 * disable the scrolling action
		 */
		this.lockScroll();
		
		var r = this.getRegion();	
		var sheetId = r.getSheetId();
		var s = r.getStore();
		/*
		 * need make sure the body size is suit for the scroller position
		 */
		if(this.cel && ('x' == dir || 'both' == dir)){
			/*
			 * handle hidden column, the hidden columns should not be included when
			 * calculate the scroll position
			 */
			var hiddenCol = 0;
			for(var i = r.colBound.low; i < r.colStart; i++){
				if(!s.isVisibleColumn(sheetId, i)){
					hiddenCol++;
				}
			}
			this.lastCol = r.colStart-r.colBound.low-hiddenCol;
			var sl = Math.round(this.lastCol/cFactor)*this.scrollOffset;
            if(sl !== this.scrollLeft){
                this.scrollLeft = sl;
                this.lastScrollLeft = this.scrollLeft;
                this.syncColThumbPos();
                this.cel.addCls('ss-imcct-scrolling');
                this.fireEvent('checkingcolscrolling', this);
           }else if(forceSyncThumb){
        	   this.syncColThumbPos();
           }
		}
		if(this.rel && ('y' == dir || 'both' == dir)){
			/*
			 * handle hidden row, the hidden rows should not be included when
			 * calculate the scroll position
			 */
			var hiddenRow = 0;
			for(var i = r.rowBound.low; i < r.rowStart; i++){
				if(!s.isVisibleRow(sheetId, i)){
					hiddenRow++;
				}
			}		
			this.lastRow = r.rowStart-r.rowBound.low-hiddenRow;
			var st = Math.round(this.lastRow/rFactor)*this.scrollOffset;
            if(st !== this.scrollTop){
                this.scrollTop = st;
                this.lastScrollTop = this.scrollTop;
                this.syncRowThumbPos();
                this.rel.addCls('ss-imrct-scrolling');
                this.fireEvent('checkingrowscrolling', this);
            }else if(forceSyncThumb){
         	   this.syncRowThumbPos();
            }
		}
				
		/*
		 * enable the scrolling action
		 */
		this.unlockScroll();
	},
	
	getRegion : function(){
		return this.region;
	},
     
    /*
     * sync row thumb
     */
    syncRowThumbPos : function(){
        var st = this.scrollTop;
        var bEl = this.rbody, el = this.rel;
        var bh = bEl.getHeight(), h = el.getHeight()-el.getPadding('b'), mth = h*0.75;
        
        var store = this.region.getStore(), sheetId = store.getActivedSheetId();
        if(Ext.isDefined(sheetId)){
        	sheetObj = store.getSheetById(sheetId);
        	var maxRow = sheetObj.maxRow || 1;
        	if(maxRow < this.defaultRow){
        		maxRow = this.defaultRow;
        	}
            bh = h-maxRow;
            if(bh < this.minThumbLength){
                bh = this.minThumbLength;            
            }              
            this.rowFactor = maxRow/(h-bh);
            if(this.rowFactor  < 1){
            	this.rowFactor = 1;
            }
        }        
        
        if(st+bh > h){
            bh = h-st;
            if(bh < this.minThumbLength){
                bh = this.minThumbLength;
                st = h-bh;
            }            
        }/*else if(bh < mth){
            var nbh = h-st;
            if(nbh > mth){
                nbh = mth;
            }
            bEl.setHeight(nbh);
        }*/
        bEl.setHeight(bh);
        bEl.setStyle('margin-top', st+'px');
    },
           
    /*
     * sync col thumb
     */
    syncColThumbPos : function(){
        var sl = this.scrollLeft;
        var bEl = this.cbody, el = this.cel;
        var bw = bEl.getWidth(), w = el.getWidth()-el.getPadding('r'), mtw = w*0.75;
           
        var store = this.region.getStore(), sheetId = store.getActivedSheetId();
        if(Ext.isDefined(sheetId)){
        	sheetObj = store.getSheetById(sheetId);
        	var maxCol = sheetObj.maxCol || 1;
        	if(maxCol < this.defaultCol){
        		maxCol = this.defaultCol;
        	}
            bw = w-maxCol;
            if(bw < this.minThumbLength){
                bw = this.minThumbLength;            
            }
            this.colFactor = maxCol/(w-bw);
            if(this.colFactor  < 1){
            	this.colFactor = 1;
            }
        }                
        
        if(sl+bw > w){
            bw = w-sl;
            if(bw < this.minThumbLength){
                bw = this.minThumbLength;
                sl = w-bw;
            }            
        }/*else if(bw < mtw){
            var nbw = w-sl;
            if(nbw > mtw){
                nbw = mtw;
            }
            bEl.setWidth(nbw);
        }*/
        bEl.setWidth(bw);
        bEl.setStyle('margin-left', sl+'px');
    },
	
	/*
	 * scroll row up or down based on row offset
	 */
	scrollRowOld : function(offset){
		if(0 === offset){
			return;
		}
		/*
		 * if has row scroller, update the scrollTop
		 * else just move the region
		 */
		if(this.rel){
			var bEl = this.rbody;
            var originTop = this.scrollTop;
			/*
			 * scroll row up
			 */
			var st = originTop+offset*this.scrollOffset;
			if(0 > st){
				st = 0;
			}
            this.scrollTop = st;
           
            this.syncRowThumbPos();
            this.onRowScroll();
		}else{
			/*
			 * if no scroller, need move row up/down directly and fire an event
			 */
			var r = this.getRegion();			
			/*
			 * onlyRowScrollingEvent is a flag for whether actually move the region, or just fire rowscrolling event;
			 * if true then, skip the move action, let the listener to process, default to false
			 */
			if(!this.onlyRowScrollingEvent){					
				if(0 > offset){
					offset = r.moveUp(-offset);
				}else{
					offset = r.moveDown(offset);
				}
			}
			this.lastRow += offset;			
			this.fireEvent('rowscrolling', offset, r, this);
		}
	},
	
	scrollRow : function(offset){
		if(0 === offset){
			return;
		}
		/*
		 * if no scroller, need move row up/down directly and fire an event
		 */
		var r = this.getRegion(), rFactor = this.rowFactor;			
		/*
		 * onlyRowScrollingEvent is a flag for whether actually move the region, or just fire rowscrolling event;
		 * if true then, skip the move action, let the listener to process, default to false
		 */
		if(!this.onlyRowScrollingEvent){					
			if(0 > offset){
				offset = r.moveUp(-offset);
			}else{
				offset = r.moveDown(offset);
			}
		}
		this.lastRow += offset;
		var st = Math.round(this.lastRow/rFactor)*this.scrollOffset;
		this.scrollTop = st;
        this.lastScrollTop = this.scrollTop;
		if(this.rel){
			this.syncRowThumbPos();
            this.rel.addCls('ss-imrct-scrolling');
            this.fireEvent('rowscrolling', offset, r, this);
            this.fireEvent('checkingrowscrolling', this);
		}else{
			this.fireEvent('rowscrolling', offset, r, this);
		}	
	},
	
	/*
	 * scroll col left or right based on col offset
	 */
	scrollColOld : function(offset){
        if(0 === offset){
            return;
        }
        /*
         * if has row scroller, update the scrollTop
         * else just move the region
         */
        if(this.cel){
            var bEl = this.cbody;
            var originLeft = this.scrollLeft;
            /*
             * scroll col
             */
            var sl = originLeft+offset*this.scrollOffset;
            if(0 > sl){
                sl = 0;
            }
            this.scrollLeft = sl;
           
            this.syncColThumbPos();
            this.onColScroll();
        }else{
            /*
             * if no scroller, need move row up/down directly and fire an event
             */
            var r = this.getRegion();
            /*
             * onlyColScrollingEvent is a flag for whether actually move the region, or just fire rowscrolling event;
             * if true then, skip the move action, let the listener to process, default to false
             */
            if(!this.onlyColScrollingEvent){
                if(0 > offset){
                    offset = r.moveLeft(-offset);
                }else{
                    offset = r.moveRight(offset);
                }
            }
            this.fireEvent('colscrolling', offset, r, this);
        }
	},
	
	scrollCol : function(offset){
		if(0 === offset){
			return;
		}
		/*
		 * if no scroller, need move row up/down directly and fire an event
		 */
		var r = this.getRegion(), cFactor = this.colFactor;			
		/*
		 * onlyRowScrollingEvent is a flag for whether actually move the region, or just fire rowscrolling event;
		 * if true then, skip the move action, let the listener to process, default to false
		 */
		if(!this.onlyColScrollingEvent){
            if(0 > offset){
                offset = r.moveLeft(-offset);
            }else{
                offset = r.moveRight(offset);
            }
        }
		this.lastCol += offset;
		var sl = Math.round(this.lastCol/cFactor)*this.scrollOffset;
		this.scrollLeft = sl;
        this.lastScrollLeft = this.scrollLeft;
		if(this.cel){
			this.syncColThumbPos();
			this.cel.addCls('ss-imcct-scrolling');
            this.fireEvent('colscrolling', offset, r, this);
            this.fireEvent('checkingcolscrolling', this);
		}else{
			this.fireEvent('colscrolling', offset, r, this);
		}	
	},
	
	getScrollerLength : function(dir){
		var len = 0;
		if('col' == dir){
			if(this.rel){
				len = this.rel.getWidth();
			}
		}else{
			if(this.cel){
				len = this.cel.getHeight();
			}
		}
		return len;
	},		
	
	destroy: function(){
		var region = this.region;		
		region.un('afterrender', this.prepareScroller, this);
		region.un('resize', this.onResize, this);		
		region.getEl().un('mousewheel', this.onMouseWheel, this);
		
        this.clearListeners();
    },
           
    /**
     * mousedown on the row up button
     */
    onMouseDownRowUp : function(e){
        this.bmdFlag = {
            dir: 'row',
            step: -1
        }
        this.startPressTask();
    },
           
    onMouseDownRowDown : function(e){
        this.bmdFlag = {
           dir: 'row',
           step: 1
        }
        this.startPressTask();
    },
           
    onMouseDownRowTrack : function(e){
        var y = e.getY();
        var target = Ext.get(e.getTarget());
        if(target === this.rel){
            var top = this.rel.getTop(), bottom = this.rel.getBottom()-this.rel.getPadding('b');
            if(top <= y && y <= bottom){
                var bTop = this.rbody.getTop(), bBottom = this.rbody.getBottom();
                var yoff;
                if(y > bBottom){
                    yoff = y-bBottom+bTop-top;
                }else{
                    yoff = y-top;
                }
                var st = this.rbody.getMargin('t');
                var step = (0 === st || 0 === this.scrollTop) ? 1 : this.scrollTop/st;
                this.scrollTop = Math.floor(yoff*step);
                this.onRowScroll();
                this.syncRowThumbPos();
            }
        }
    },
           
    /**
     * mousedown on the col up button
     */
    onMouseDownColUp : function(e){
        this.bmdFlag = {
            dir: 'col',
            step: -1
        }
        this.startPressTask();
    },
           
    onMouseDownColDown : function(e){
        this.bmdFlag = {
            dir: 'col',
            step: 1
        }
        this.startPressTask();
    },
           
    onMouseDownColTrack : function(e){
        var x = e.getX();
        var target = Ext.get(e.getTarget());
        if(target === this.cel){
            var left = this.cel.getLeft(), right = this.cel.getRight()-this.cel.getPadding('r');
            if(left <= x && x <= right){
                var bLeft = this.cbody.getLeft(), bRight = this.cbody.getRight();
                var xoff;
                if(x > bRight){
                    xoff = x-bRight+bLeft-left;
                }else{
                    xoff = x-left;
                }
                var sl = this.cbody.getMargin('l');
                var step = (0 === sl || 0 === this.scrollLeft) ? 1 : this.scrollLeft/sl;
                this.scrollLeft = Math.floor(xoff*step);
                this.onColScroll();
                this.syncColThumbPos();
           }
        }
    },
           
    startPressTask : function(){
        if(!this.pressTask){
            this.pressTask = Ext.TaskManager.start({
                run: function(){                	
                    if(this.bmdFlag){
                        var dir = this.bmdFlag.dir, step = this.bmdFlag.step;
                        if('row' == dir){
                            this.scrollRow(step);
                        }else{
                            this.scrollCol(step);                            
                        }
                    }else{
                        this.pressTask.stop();
                    }
                },
                scope: this,
                interval: this.pressInterval
            })
        }else{
            Ext.TaskManager.start(this.pressTask);
        }
    }
});
Ext.define('EnterpriseSheet.sheet.regions.Region', {
	
	/* Begin Definitions */
	
	extend: 'Ext.Component',
	
	requires: [	    
	    'EnterpriseSheet.sheet.data.Store',
	    
		'EnterpriseSheet.sheet.resize.RowResizer',
		'EnterpriseSheet.sheet.resize.ColumnResizer',
		
	    'EnterpriseSheet.sheet.editor.CellEditor',
	    'EnterpriseSheet.sheet.regions.InfinateScroller',
	    'EnterpriseSheet.sheet.regions.ImmerseScroller',
	    
	    'EnterpriseSheet.sheet.sm.CellSelectionModel', 
	    'EnterpriseSheet.sheet.sm.RowSelectionModel', 
	    'EnterpriseSheet.sheet.sm.ColumnSelectionModel',
	    'EnterpriseSheet.sheet.sm.CellReferenceModel', 
	    'EnterpriseSheet.sheet.sm.ColumnReferenceModel', 
	    'EnterpriseSheet.sheet.sm.RowReferenceModel'
	],
	
	/* End Definitions */
	
	//skipZIndex: true,
    
    skipCanvas: true,
	
	resizeCheckBuffer : 0,
	/*
	 * default sheet Id
	 */
	sheetId : 0,
	
	/*
	 * the current cell span width in this region, it should be larger or equal to the 
	 * width of the component
	 */
	currentWidth : 0,
	
	defaultReferenceModel : 'CellReferenceModel',
	
	defaultSelectionModel : 'CellSelectionModel',
	
	defaultResizerType : 'CellResizer',
	
	/*
	 * enable/disable cell mouse over event
	 */
	enableCellMouseOver : false,
	enableCellMouseMove : true,
	
	/*
	 * the config of cell resize
	 * if null or undefined then no cell resizer will be generated
	 */
	/*resizerConfig : {		
 	 	// the dir could be one of ['x', 'y']		
 	 	rtype : 'RowResizer',
		dir : 'y'
	}, */
	
	/*
	 * enable/disable row resize function
	 */
	allowRowResize : true,
	
	/*
	 * whether show a css when mouse over a cell
	 */
	trackMouseOver : false,
		
	/*
	 * init the row and col span start/end
	 * @param {boolean} noApply: true to not apply to this
	 */
	initSpan : function(noApply){
		var defaultSpan = {
			/*
			 * the start index of row span
			 */
			rowStart : 1,
			/*
			 * the end index of row span
			 */
			rowEnd : 0,
			/*
			 * the start index of column span
			 */
			colStart : 1,
			/*
			 * the end index of column span
			 */
			colEnd : 0	
		};
		if(!noApply){
			Ext.applyIf(this, defaultSpan);
		}
		
		return defaultSpan;
	},
	
	/*
	 * init the row and column bound for this region, the bound will define the low and high limit for the region,
	 * @param {boolean} noApply: true to not apply to this.rowBound/this.colBound
	 */
	initBound : function(noApply){
		/*
		 * rowBound and colBound define the limit of the region can move to
		 * @low means the lowest row/col index this region can move to
		 * @high means the highest row/col index this region can move to,
		 * if it's false, then means no limit, if true or a number then means the region can not move down/right
		 */
		var defaultRowBound = {
			low : 1,
			min : 1,			
			high: false
		};
		
		var defaultColBound = {
			low : 1,
			min : 1,
			high: false
		};
		
		if(!noApply){
			this.rowBound = Ext.apply(this.rowBound || {}, defaultRowBound);			
			this.colBound = Ext.apply(this.colBound || {}, defaultColBound);
		}
		
		return {
			rowBound : defaultRowBound,
			colBound : defaultColBound
		};
	},
	
	/*
	 * for plugins
	 */
	preparePlugins : function(){
		/*
		 * define whether this region has infinate scroller
		 */
		this.plugins = this.plugins || []; 
		
		if(!this.infinateScroller && this.scrollConfig){
			this.infinateScroller = new EnterpriseSheet.sheet.regions.ImmerseScroller(this.scrollConfig);
		}
		if(this.infinateScroller){			
			this.plugins.push(this.infinateScroller);			
			this.relayEvents(this.infinateScroller, ['rowscrolling', 'colscrolling']);
		}
		/*
		 * for selection model, if disableSelectionModel is not true then init 
		 * selection model
		 */
		if(!this.sm && !this.disableSelectionModel){
			this.sm = new (EnterpriseSheet.sheet.sm[this.defaultSelectionModel])();			
		}
		
		if(this.sm){
			this.plugins.push(this.sm);
			this.relayEvents(this.sm, ['selectionchange', 'pushcurrentselection', 'focuschange', 'dragscrollinglimited', 'autofilldragend', 'selectionmoving', 'prepareautofillstyle', 'resetautofillstyle']);
		}
		
		/*
		 * prepare range reference selection, which is for cut/copy status, formula related range etc. 
		 */
		this.prepareReferenceModel();
		
		/*
		 * for resizer
		 */
		if(!this.resizer && this.resizerConfig){
			this.resizer = new EnterpriseSheet.sheet.resize[this.resizerConfig.rtype || this.defaultResizerType](this.resizerConfig);			
		}
		
		if(this.resizer){
			this.enableCellMouseOver = true;
			this.plugins.push(this.resizer);
			this.relayEvents(this.resizer, ['columnresized', 'rowresized', 'rowautoresized', 'selectedcolumnresized', 'selectedrowresized']);
		}
		
		if(0 == this.plugins.length){
			delete(this.plugins);
		}
	},
	
	/*
	 * prepare range reference selection, which is for cut/copy status, formula related range etc. 
	 */
	prepareReferenceModel : function(){
		if(!this.rm && !this.disableReferenceModel){
			this.rm = new (EnterpriseSheet.sheet.sm[this.defaultReferenceModel])({
				disabled:true
			});			
		}
		
		if(this.rm){
			this.plugins = this.plugins || [];
			this.plugins.push(this.rm);
			this.relayEvents(this.rm, ['showmodel', 'hidemodel', 'startmovereference', 'beforemovingreference', 'movingreference', 'endmovereference', 'referencemouseup']);
			this.mon(this.rm, {
				scope:this,
				'selectionchange':function(startPos, endPos, region, sm){					
					this.fireEvent('referencechange', region, sm);
				},
				'show':function(rm){					
					this.fireEvent('showreference', this, rm);
				},
				'hide':function(rm){					
					this.fireEvent('hidereference', this, rm);
				}
			});			
		}
	},
	
	initComponent : function(){
		
		this.initSpan();
		
		this.initBound();
		
		this.cls = this.cls || '';
		
		this.cls += ' ss-region-ct'; 
		
		this.regionTpl = this.regionTpl || SLAYOUT['region'];
		
		this.rowTpl = this.rowTpl || SLAYOUT['row'];
		
		this.cellTpl = this.cellTpl || SLAYOUT['cell'];	
		
		this.preparePlugins();
		
		this.callParent();					
		
		
		var store = this.getStore();		
		this.mon(store, {
			scope:this,			
			'cellchange':this.onCellChange,
			'columnchange':this.onColumnChange,
			'rowchange':this.onRowChange,
			'removecell':this.onRemoveCell,
			'cellremoved':this.onCellRemoved,
			'removerow':this.onRemoveRow,
			'rowremoved':this.onRowRemoved,
			'removecolumn':this.onRemoveColumn,
			'columnremoved':this.onColumnRemoved,
			'insertcell':this.onInsertCell,
			'cellinserted':this.onCellInserted,
			'insertrow':this.onInsertRow,
			'rowinserted':this.onRowInserted,
			'insertcolumn':this.onInsertColumn,
			'columninserted':this.onColumnInserted,
			'hiderow':this.onHideRow,
			'hidecolumn':this.onHideColumn,
			'showrow':this.onShowRow,
			'showcolumn':this.onShowColumn			
		});	
		
		/*
		 * listener for resize
		 */		
		this.on('resizing', this.processAfterResize, this, {buffer: this.resizeCheckBuffer});
		this.on('resize', function(comp, width, height){
			this.getEl().setWidth(width);
			this.fireEvent('resizing', comp, width, height);
		}, this);
	},				
	
	/*
	 * test whether the row/col ordinate is in or not in the region
	 */
	isInRange : function(row, col){
		if(0 == row){
			return this.colStart <= col && col <= this.colEnd;
		}else if(0 == col){
			return this.rowStart <= row && row <= this.rowEnd;
		}else{
			return this.rowStart <= row && row <= this.rowEnd && this.colStart <= col && col <= this.colEnd;
		}		
	},
	
	isRowOverlap : function(minrow, maxrow){
		return (this.rowStart <= minrow && minrow <= this.rowEnd) || (this.rowStart <= maxrow && maxrow <= this.rowEnd)
			|| (this.rowStart > minrow && maxrow > this.rowEnd);
	},
	
	isColumnOverlap : function(mincol, maxcol){
		return (this.colStart <= mincol && mincol <= this.colEnd) || (this.colStart <= maxcol && maxcol <= this.colEnd)
			|| (this.colStart > mincol && maxcol > this.colEnd);
	},
	
	isInColumnRange : function(col){
		return this.colStart <= col && col <= this.colEnd;
	},
	
	isInRowRange : function(row){
		return this.rowStart <= row && row <= this.rowEnd;
	},
	
	/*
	 * when we need resize the width of region element, always call this function
	 * cause we need also update the currentWidth, which is use for resize and move function
	 */
	updateRegionElWidth : function(w){
		var s = this.getStore();
		if(false == SCOM.typeOf(w)){			
			w = s.getRangeWidth(this.getSheetId(), this.colStart, this.colEnd);
		}
		this.regionEl.setWidth(w);
		this.currentWidth = w;
	},
	
	/*
	 * get the cell element
	 */
	getCellEl : function(row, col){
		try{
			var s = this.getStore();
			var sheetId = this.getSheetId();
			if(s.isVisibleRow(sheetId, row) && s.isVisibleColumn(sheetId, col)){
                var cid = [row, col].join(s.separateChar);
                var found = Ext.DomQuery.jsSelect('div[cid='+cid+']', this.regionEl.dom);
                if(0 < found.length){
                    return Ext.get(found[0]);
                }
            }
			return null;
		}catch(e){
			return null;
		}
	},
	
	/*
	 * set the cell element's width, won't change the record in store;
	 * this function is for handling the padding and border issue, when try to set a very small size, for example 1px
	 * @param {int} row: the row index
	 * @param {int} col: the column index
	 * @param {int} width: a integer number which should be >= 0
	 * @param {int} height: a integer number which should be >= 0
	 * @return {boolean}: true for set the size successfully, or failure
	 */
	setCellElSize : function(row, col, width, height){
		var store = this.getStore();
		var cellEl = this.getCellEl(row, col);
		if(cellEl){
			if(false != SCOM.typeOf(width)){
				var woff = width-store.cellWidthOffset;
				/*
				 * get the setting and data about this cell from store
				 */
				var o = Ext.apply({}, store.defaultProperty);
				if(0 > woff){								
					/*
					 * if woff < 0, then we need change the padding and border to make the cell to the width,
					 * call store.processOffset to calculate the new padding and border
					 */		
					o.woff = woff;
					o = store.processOffset(o);
					woff = 0;
				}
				/*
				 * update the styles to change the cell's width
				 */
				cellEl.setStyle('padding-left', o.pl+'px');
				cellEl.setStyle('padding-right', o.pr+'px');
				cellEl.setStyle('border-left-width', o.blw+'px');
				cellEl.setStyle('border-right-width', o.brw+'px');
				cellEl.setStyle('width', woff+'px');
			}			
			if(false != SCOM.typeOf(height)){
				var hoff = height-store.cellHeightOffset;
				/*
				 * get the setting and data about this cell from store
				 */
				var o = Ext.apply({}, store.defaultProperty);
				if(0 > hoff){								
					/*
					 * if hoff < 0, then we need change the padding and border to make the cell to the width,
					 * call store.processOffset to calculate the new padding and border
					 */		
					o.hoff = hoff;
					o = store.processOffset(o);
					hoff = 0;
				}
				/*
				 * update the styles to change the cell's width
				 */
				cellEl.setStyle('padding-top', o.pt+'px');
				cellEl.setStyle('padding-bottom', o.pb+'px');
				cellEl.setStyle('border-top-width', o.btw+'px');
				cellEl.setStyle('border-bottom-width', o.bbw+'px');
				cellEl.setStyle('height', hoff+'px');
			}
			return true;
		}
		return false;
	},
	
	/*
	 * set the row element's height, won't change the record in store;
	 * this function is for handling the padding and border issue, when try to set a very small size, for example 1px
	 * @param {int} row: the row index
	 * @param {int} height: a integer number which should be >= 0
	 * @param {boolean} sysnCellHeight: if true then also update the height of cells in this row
	 * @return {boolean}: true for set the size successfully, or failure
	 */
	setRowElHeight : function(row, height, sysnCellHeight){
		var store = this.getStore();
		var rowEl = this.getRowEl(row);
		if(rowEl){
			if(false != SCOM.typeOf(height)){
				var hoff = height-store.cellHeightOffset;
				var wpb = store.defaultProperty.wpb;
				if(0 > hoff){
					wpb += hoff;
					hoff = 0;
				}
				/*
				 * update the styles to change the cell's width
				 */
				rowEl.setStyle('padding-bottom', wpb+'px');
				rowEl.setStyle('height', hoff+'px');
				if(sysnCellHeight){
					for(var i = this.colStart; i <= this.colEnd; i++){
						this.setCellElSize(row, i, null, height);
					}
				}
			}			
			return true;
		}
		return false;
	},
	
	updateRowHeight : function(row){
		var rowEl = this.getRowEl(row);
		if(rowEl){
			var s = this.getStore();
			cell = s.getCellData(this.getSheetId(), row, 0);
			var h = cell.height;			
			var wpb = cell.wpb;
			rowEl.setStyle('height', h+'px');
			rowEl.setStyle('padding-bottom', wpb+'px');
		}
	},		
	
	/*
	 * get the row element
	 */
	getRowEl : function(row){
		try{
			var s = this.getStore();
			var sheetId = this.getSheetId();
			if(s.isVisibleRow(sheetId, row)){
				var roffset = row-this.rowStart;
				for(var i = this.rowStart; i < row; i++){
					if(!s.isVisibleRow(sheetId, i)){
						roffset--;
					}
				}
				var row = this.regionEl.dom.childNodes[roffset];			
				return Ext.get(row);
			}
			return null;
		}catch(e){
			return null;
		}
	},
	
	/*
	 * update the region width based on the offset, if the offset < 0, then maybe need render more columns at right side
	 * @param {int} offset: the width offset
	 */		
	updateOffsetWidth : function(offset){
		if(0 < offset){
			/*
	     	 * if the column width is growing, then need increase region element width, 
			 * or it could not container all cells
			 */
			this.updateRegionElWidth(this.currentWidth+offset);
		}else if(0 > offset){
			/*
			 * if the column width is narrower, means we need render more col at right
			 * but remember we need update the currentWidth with offset first,
			 * because in adjustCols function it will add the width of the new columns
			 * less is the shorter length at right
			 */			
			var less = offset+this.currentWidth-this.getEl().getWidth();
			if(0 <= less){
				/*
				 * if less > 0 then no need render at right, because there is no empty part
				 */
				this.updateRegionElWidth(this.currentWidth+offset);
			}else if(!this.colBound.high){
				this.currentWidth += offset; 	
				/*
				 * need render more col at the right empty part
				 */
				this.adjustCols(-less);
			}
		}
	},
	
	/*
	 * update the region height based on the offset, if the offset < 0, then maybe need render more rows at bottom side
	 * @param {int} offset: the width offset
	 */		
	updateOffsetHeight : function(offset){
		if(0 > offset){	
			/*
			 * if the row height is narrower, means we need render more col at bottom
			 */	
			var less = this.regionEl.getHeight()-this.getEl().getHeight();
			if(0 > less && !this.rowBound.high){
				/*
				 * less is the empty part at bottom, we need render more rows at bottom
				 */
				this.adjustRows(-less);
			}
		}
	},
			
	/*
	 * resize the column width
	 */
	resizeColumn : function(col, w, suspendCellChange, suspendColChange){
		var sheetId = this.getSheetId();
		var s = this.getStore();
		var cw = s.getColWidth(sheetId, col);
		var offset = w-cw;		
		s.setColumnWidth(sheetId, col, w, suspendCellChange, suspendColChange);
		/*
		 * if suspendColChange is false then it will cause columnchange event 
		 * so we don't need resize column here, it will handle by onColumnChange function;
		 * if suspendCellChange is false then it will cause cellchange event
		 * which will change the size of [0, col] cell's size, so we need judge whether [0, col] is in this region,
		 * if not in this region, we don't need update the region width
		 */
		if((!suspendCellChange && this.isInRange(0, col)) && suspendColChange){		
			this.updateOffsetWidth(offset);
		}
	},
	
	/*
	 * resize the row height
	 */
	resizeRow : function(row, h, suspendCellChange, suspendRowChange){
		var s = this.getStore();
		var sheetId = this.getSheetId();
		var rh = s.getRowHeight(sheetId, row);
		var offset = h-rh;
		if(0 != offset){
			s.setRowHeight(sheetId, row, h, suspendCellChange, suspendRowChange);
			/*
			 * if suspendRowChange is false then it will cause rowchange event 
			 * so we don't need resize row here, it will handle by onRowChange function
			 */
			if(suspendRowChange){
				/*
				 * if suspend row change event, we need update the height by ourself
				 */
				this.updateRowHeight(row);
				this.updateOffsetHeight(offset);
			}
		}		
	},
	
	/*
	 * resize the row auto height
	 */
	resizeRowAutoHeight : function(row, h, suspendCellChange, suspendRowChange){
		var s = this.getStore();
		var sheetId = this.getSheetId();
		var rh = s.getRowHeight(sheetId, row);
		var offset = h-rh;
		if(0 != offset){
			s.setRowAutoHeight(sheetId, row, h, suspendCellChange, suspendRowChange);
			/*
			 * if suspendRowChange is false then it will cause rowchange event 
			 * so we don't need resize row here, it will handle by onRowChange function
			 */
			if(suspendRowChange){
				/*
				 * if suspend row change event, we need update the height by ourself
				 */
				this.updateRowHeight(row);
				this.updateOffsetHeight(offset);
			}
		}		
	},
	
	
	/*
	 * get cell data from store and process it before pass to render function
	 * @param {int} row: the row index of the cell
	 * @param {int} col: the column index of the cell	 
	 * @param {boolean} suspendEvent: true to cancel the event
	 * @param {string} timestamp: the timestamp to check the calculate value is valid or not
	 */
	getData : function(row, col, suspendEvent, timestamp){
		var sheetId = this.getSheetId();
		var store = this.getStore();
		var cell = store.getCellData(sheetId, row, col);			
		/*
		 * fire a event for others to process cell data, this function will be called before render or refresh a cell element
		 * so you can override it to add your own css or some other stuff		
		 * in the listener, you can add stuff or change stuff in var o, and it will affect the render
		 * also, too much action in this function will make render slower
	 	 * so be sure of what you're going to do	 
		 */		 
		if(!suspendEvent){ 
			this.fireEvent('processdata', sheetId, row, col, cell, timestamp, this);
		}
		/*
		 * add px for template 
		 */
		cell.width += 'px';
		cell.height += 'px';
        cell.ri = row;
        cell.ci = col;
		return cell;
	},		
	
	/*
	 * get the cell data from store and rerender this cell
	 * @param {int} row: the row index for the cell
	 * @param {int} column: the col index for the cell
	 * @param {object} cell: the cell data object, if undefined, it will get from the store
	 */
	refreshCell : function(row, col, cell){
		var cellEl = this.getCellEl(row, col);
		
		if(cellEl){
			cell = cell || this.getData(row, col);		
			var html = this.cellTpl.apply(cell);
			Ext.core.DomHelper.insertBefore(cellEl, html);		
			Ext.removeNode(cellEl.dom);
			this.fireEvent('refreshcell', row, col, this);
		}
	},	
	
	/*
	 * get the cell data from store and rerender this cell, if it's a merged cell, then rerender all cells belong to that merged cell
	 * @param {int} row: the row index for the cell
	 * @param {int} column: the col index for the cell 
	 * @param {object} cell: the cell data object, if undefined, it will get from the store
	 */
	refreshMergedCell : function(row, col, cell){
		var store = this.getStore();
		var sheetId = this.getSheetId();
		var c = store.getCell(sheetId, row, col);
		if(store.isMergedCell(c, sheetId, row, col)){
			var minrow = row+c.minrow;
			var mincol = col+c.mincol;
			var maxrow = row+c.maxrow;
			var maxcol = col+c.maxcol;
			
			for(var i = minrow; i <= maxrow; i++){
				for(var j = mincol; j <= maxcol; j++){
					this.refreshCell(i, j);
				}
			}
		}else{
			this.refreshCell(row, col, cell);
		}
	},
	
	/**
	 * get the row data from store and rerender this row
	 */
	refreshRow : function(row){
		var sheetId = this.getSheetId();
		var store = this.getStore();
		var rowEl = this.getRowEl(row);
		if(rowEl){
			var cells = [];
			for(var i = this.colStart; i <= this.colEnd; i++){
				if(store.isVisibleColumn(sheetId, i)){
					var data = this.getData(row, i);
					cells.push(data);
				}
			}
			var o = this.getData(row, 0);
			o.cells = cells;
			var html = this.regionTpl.apply(o);
			Ext.core.DomHelper.insertBefore(rowEl, html);		
			Ext.removeNode(rowEl.dom);
			this.fireEvent('refreshrow', row, this);
		}
	},
	
	/**
	 * get the column data from store and rerender this column
	 */
	refreshColumn : function(col){
		var sheetId = this.getSheetId();
		var store = this.getStore();
		if(store.isVisibleColumn(sheetId, col)){
			
			for(var i = this.rowStart; i <= this.rowEnd; i++){				
				this.refreshCell(i, col);
			}
		}
	},
	
	/*
	 * refresh the cell when it's changed
	 */
	onCellChange : function(sheetId, row, col, modified, deleted, odata, data, store){
		if(sheetId == this.getSheetId()){
			if(this.isVisible() && this.isInRange(row, col) && store.isVisibleRow(sheetId, row) && store.isVisibleColumn(sheetId, col)){
				var cell = store.getCell(sheetId, row, col);
				if(store.isMergedCell(cell, sheetId, row, col)){
					var minrow = row+cell.minrow;
					var mincol = col+cell.mincol;
					if(minrow == row && mincol == col){
						/*
						 * only if the left-top cell changed in the merged cell, we call refreshMergeCell
						 */
						this.refreshMergedCell(row, col);
						return;
					}
				}	
				this.refreshCell(row, col);
			}
		}
	},
	
	/*
	 * refresh the col when it's changed
	 */
	onColumnChange : function(sheetId, col, modified, deleted, odata, data, store){
		if(sheetId == this.getSheetId()){				
			if(this.isVisible() && this.isInColumnRange(col)){
				var s = this.getStore();
				/*
				 * update the cells in this column 
				 */
				for(var i = this.rowStart; i <= this.rowEnd; i++){
					if(s.isVisibleRow(sheetId, i)){
						this.refreshCell(i, col);
					}
				}
				/*
				 * check the range column width, if it's grow then update region element width
				 * or we need render more columns at right
				 */
				var cw = this.currentWidth;			
				var w = s.getRangeWidth(sheetId, this.colStart, this.colEnd);			
				var offset = w-cw;
				this.updateOffsetWidth(offset);									
			}else{
				if(col < this.colStart){
					/*
					 * if the resizing column's index is less than the start column of this region
					 * it means we need sysn the scroller, or the selection and other floating element on the inner ct will be in wrong place
					 */
					this.sysn();
				}
			}			
			this.fireEvent('columnchange', col, modified, deleted, odata, data, store, this);
		}
	},
	
	/*
	 * refresh the row when it's changed
	 */
	onRowChange : function(sheetId, row, modified, deleted, odata, data, store){
		if(sheetId == this.getSheetId()){
			if(this.isVisible() && this.isInRowRange(row)){			
				var s = this.getStore();			
				/*
				 * check the range row height, if it's narrower then we need render more rows at bottom;
				 * here we need get the height first then refresh the row
				 */
				var ch = this.regionEl.getHeight();
				/*
				 * update the cells in this row
				 */
				this.refreshRow(row);
				var h = s.getRangeHeight(sheetId, this.rowStart, this.rowEnd);
				var offset = h-ch;			
				if(0 != offset){									
					this.updateOffsetHeight(offset);	
				}					
			}else{
				if(row < this.rowStart){
					/*
					 * if the resizing row's index is less than the start row of this region
					 * it means we need sysn the scroller, or the selection and other floating element on the inner ct will be in wrong place
					 */
					this.sysn();
				}
			}
			this.fireEvent('rowchange', row, modified, deleted, odata, data, store, this);
		}
	},		
	
	/*
	 * extend onRender to render region frame in el and init selectors
	 * we did not use renderTpl, cause this is more flexiable
	 */
	onRender : function(){
		this.callParent(arguments);

		/*
		 * add a inner element to contain rows		 
		 */
		var html;
		if(this.noInnerContainer){
			html = [
				'<div class="ss-region"></div>'].join('');
			this.el.update(html);	
		}else{
			/*
			 * define a inner container which will contain the floating element in this region
			 * for example, an image or a chart, it's because when the region is moving, the floating
			 * element also need moving
			 */
			html = [
				'<div class="ss-region"></div>',
				'<div class="ss-ifct" style="', SCONST.dir['none'], '">',
					'<div class="ss-ifbody" style="', SCONST.dirbody['none'],'">',
                    '</div>',
				'</div>',
                this.skipCanvas ? '' : '<canvas class="ss-ifct"></canvas>'
            ].join('');
			this.el.update(html);	
			this.ifctEl = Ext.get(this.el.dom.childNodes[1]);
            this.ifbodyEl = Ext.get(this.ifctEl.dom.firstChild);
            if(!this.skipCanvas){
                this.canvasEl = Ext.get(this.el.dom.childNodes[2]);
                this.context2d = this.canvasEl.dom.getContext('2d');
            }
		}
		this.regionEl = Ext.get(this.el.dom.firstChild);
		
	},
	
	/*
	 * extend afterRender to render region content if need
	 */
	afterRender : function(){				
		/*
		 * update the region El if it's fixedRowForResize, or we wait for resize
		 */
        if(this.fixedRowForResize){        	
        	/*
        	 * if true then need render the row now or delay render until resize
        	 */
        	var s = this.getStore();
        	var rows = [];
        	for(var i = this.rowStart; i <= this.rowEnd; i++){
        		var cells = [];
        		if(this.fixedColForResize){
        			/*
        	 		 * if true then need render the col now or delay render until resize
        	 		 */
        			for(var j = this.colStart; j <= this.colEnd; j++){
        				cells.push(this.getData(i, j));
        			}
        		}
        		var o = this.getData(i, 0);
        		o.cells = cells;
        		rows.push(o);        		
        	}
        	var html = this.regionTpl.apply(rows);        	        	
        	this.regionEl.update(html);
       }
       this.callParent();       
       
       this.wrapElEvent();
	},
	
	/*
	 * init cell mouse down, mouse move, mouse over and mouse up events
	 */
	wrapElEvent : function(){
		var sm = this.getSelectionModel();
		this.mon(this.el, 'contextmenu', function(e){
			e.preventDefault();
			var target = e.getTarget(null, null, true);
			/*
			 * if dblclick on body or selection model then we fire the celldblclick event
			 */
			try{
				if(target.hasCls('ss-ifct') || target.hasCls('ss-ifbody') || (sm && sm.within(target))
					|| target.hasCls('ss-cell') || target.hasCls('ss-incell') || target.hasCls('ss-vcell') || target.hasCls('ss-cell-inside')){
					var rc = this.getRowColFromPos(e.getXY());
					if(rc){
						this.fireEvent('cellcontextmenu', rc[0], rc[1], this, e);
					}
				}
			}catch(e){}
		}, this);
		this.mon(this.el, 'dblclick', function(e){
			if(0 === e.button){
				e.preventDefault();
				var target = e.getTarget(null, null, true);
				/*
				 * if dblclick on body or selection model then we fire the celldblclick event
				 */
				if(target.hasCls('ss-ifct') || target.hasCls('ss-ifbody') || (sm && sm.within(target))
					|| target.hasCls('ss-cell') || target.hasCls('ss-incell') || target.hasCls('ss-vcell') || target.hasCls('ss-cell-inside')){
					var rc = this.getRowColFromPos(e.getXY());
					if(rc){
						this.fireEvent('celldblclick', rc[0], rc[1], this, e);
					}
				}
			}
		}, this);
		
		this.mon(this.el, 'click', function(e){
			if(0 === e.button){
				var target = e.getTarget();
				var tagName = target.tagName.toUpperCase();
				var rc = this.getRowColFromPos(e.getXY());
				if('A' !== tagName && 'INPUT' !== tagName){
					e.preventDefault();
				}else{
					this.fireEvent('clickcellitem', tagName, target, rc, this);
					return;
				}				
				if(rc){
					this.fireEvent('cellclick', rc[0], rc[1], this, e);
				}
			}
		}, this);
		
		this.mon(this.el, 'mousedown', function(e){
			this.fireEvent('regionmousedown', e, this);
			if(0 === e.button){				
				var target = e.getTarget(null, null, true), dot;
				var tagName = target.dom.tagName.toUpperCase();
				if('INPUT' !== tagName){
					e.preventDefault();
				}else{
					this.fireEvent('mousedowncellitem', tagName, this.getRowColFromPos(e.getXY()), this);
					return;
				}
				/*
				 * for chart element, avoid the exception
				 */
				if(Ext.supports.ClassList && !target.dom.classList){
					return;
				}
				if(sm && (dot = sm.atDot(target))){
					/*
					 * if mouse down on the autofill dots
					 */
					this.autofillpressed = true;
                    var xy = e.getXY();

					var rc = this.getRowColFromPos(xy);
					if(rc){
						/*
						 * lt means the left-top dot, rb for right-bottom dot
						 */
						this.fireEvent('autofillmousedown', rc[0], rc[1], this, e, dot);
					}
				}else if(target.hasCls('ss-ifct') || target.hasCls('ss-ifbody') || (sm && sm.within(target))
					|| target.hasCls('ss-cell') || target.hasCls('ss-incell') || target.hasCls('ss-vcell') || target.hasCls('ss-cell-inside')){
					/*
					 * if mouse down on body or selection model then we fire the cell mouse down event
					 */
					this.mousepressed = true;
                    var xy = e.getXY();                    
					var rc = this.getRowColFromPos(xy);
					if(rc){
                        if(false !== this.fireEvent('beforecellmousedown', rc[0], rc[1], this, e)){
                            this.fireEvent('preparecellmousedown', rc[0], rc[1], this, e);
                            this.fireEvent('cellmousedown', rc[0], rc[1], this, e);
                        }
					}
				}else if(target.parent('.ss-cell')){
                    var xy = e.getXY();
					var rc = this.getRowColFromPos(xy);
					if(rc){
						if(false === this.fireEvent('incellmousedown', rc, target, this, e)){
							this.mousepressed = true;							
						}
					}
				}
			}			
		}, this);
		if(this.enableCellMouseOver || this.enableCellMouseMove){
			this.mon(this.el, 'mousemove', function(e){				
				/*
				 * only fire cell mouse over event when the mouse is not down
				 */
				if(!this.mousepressed){			
					var target = e.getTarget(null, null, true);
					/*
					 * for chart element, avoid the exception
					 */
					if(Ext.supports.ClassList && !target.dom.classList){
						return;
					}
					/*
					 * if mouse down on body or selection model then we fire the cell mouse down event
					 * ss-cell-inside css class is a sepcail class for recognize click in the cell
					 */
					if(target.hasCls('ss-ifct') || target.hasCls('ss-ifbody') || (sm && sm.within(target))
						|| target.hasCls('ss-cell') || target.hasCls('ss-incell') || target.hasCls('ss-vcell') || target.hasCls('ss-cell-inside')){
						var rc = this.getRowColFromPos(e.getXY());
						if(rc){
							if(this.trackMouseOver){
								var lp = this.lastMouseOverPos;
								if(lp){
									var lastCell = this.getCellEl(lp.row, lp.col);
									if(lastCell){
										lastCell.removeCls('ss-cellover');
									}									
								}
								var cell = this.getCellEl(rc[0], rc[1]);
								if(cell){
									cell.addCls('ss-cellover');
								}
								this.lastMouseOverPos = {
									row:rc[0],
									col:rc[1]
								};
							}
							if(this.enableCellMouseOver){
								/*
								 * mouseOverRow and mouseOverCol is 2 private varible which use to keep the mouse over cell
								 * only if the mouse over cell is changed, then fire cellmouseover event
								 */
								if(this.mouseOverRow != rc[0] || this.mouseOverCol != rc[1]){								
									if(false == SCOM.typeOf(this.mouseOverRow)){
										/*
										 * if mouseOverRow is undefine, then this is the first time mouse enter this cell position
										 */
										this.fireEvent('cellmouseenter', rc[0], rc[1], this, e);
									}else{
										/*
										 * if mouseOverRow is not undefine, then fireEvent cellmouseout event
										 */
										this.fireEvent('cellmouseout', this.mouseOverRow, this.mouseOverCol, this, e);
									}
									/*
									 * update the mouse over cell position
									 */
									this.mouseOverRow = rc[0];
									this.mouseOverCol = rc[1];								
									this.fireEvent('cellmouseover', rc[0], rc[1], this, e);
								}
							}							
							if(this.enableCellMouseMove){
								/*
								 * always fire the cell mouse move event
								 */
								this.fireEvent('cellmousemove', rc[0], rc[1], this, e);
							}													
						}
					}
				}
			}, this);
		}
		this.mon(this.el, 'mouseout', function(e){
			if(this.trackMouseOver){
				var lp = this.lastMouseOverPos;
				if(lp){
					var lastCell = this.getCellEl(lp.row, lp.col);
					if(lastCell){
						lastCell.removeCls('ss-cellover');
					}									
				}
			}
			/*
			 * fire mouse out event
			 */		
			 if(false != SCOM.typeOf(this.mouseOverRow)){
			 	this.fireEvent('cellmouseout', this.mouseOverRow, this.mouseOverCol, this, e);
			 }
		}, this);
		Ext.getDoc().on('mousemove', function(e){					
			if(this.mousepressed){
				e.preventDefault();
				var rc = this.getRowColFromPos(e.getXY(), true);
				if(rc){
					/*
					 * rc[0] and rc[1] is for row and column index
					 * rc[2] is for the position/size information, which is an object contains {x, y, width, height} 
					 */
					this.fireEvent('cellmousedrag', rc[0], rc[1], rc[2], this, e);
				}
			}else if(this.autofillpressed){
				e.preventDefault();
				var rc = this.getRowColFromPos(e.getXY(), true);
				if(rc){
					/*
					 * rc[0] and rc[1] is for row and column index
					 * rc[2] is for the position/size information, which is an object contains {x, y, width, height} 
					 */
					this.fireEvent('autofillmousedrag', rc[0], rc[1], rc[2], this, e);
				}
			}
		}, this);
		
		Ext.getDoc().on('mouseup', function(e){
			if(this.mousepressed){				
				delete(this.mousepressed);				
				this.fireEvent('cellmouseup', this, e);
			}
			if(this.autofillpressed){				
				delete(this.autofillpressed);
				this.fireEvent('autofillmouseup', this, e);
			}
		}, this);		
	},
	/*
	 * get row, col index from the xy ordinates
	 * if checkout is true, then check whether the mouse is out of the EL of region
	 * and this function will return 3 numbers in array, last pos is the info of the relative position of mouse in the region
	 * and the width and height of region
	 */
	getRowColFromPos : function(xy, checkout){
		var rowBoundMax = SCONST.MAX_ROW_NUMBER, colBoundMax = SCONST.MAX_COLUMN_NUMBER;
		var sheetId = this.getSheetId();
		var x = xy[0], y = xy[1], l = this.el.getLeft()+this.el.getBorderWidth('l'), t = this.el.getTop()+this.el.getBorderWidth('t');
		x -= l;
		y -= t;

		var s = this.getStore();
		var col = this.colStart;
        var woff = 0, hoff = 0;
		if(0 < x){
			/*
			 * true to skip the hidden column
			 */
            /*
			var w = s.getColWidth(sheetId, col, true);
			while(w <= x && (!colBoundMax || col < colBoundMax)){
				col++;
				w += s.getColWidth(sheetId, col, true);
			}*/
            var rowDom = this.regionEl.dom.childNodes[0];
            var w = Ext.get(rowDom.firstChild).getWidth();
            col = Number(rowDom.firstChild.getAttribute('ci'));
            var i = 1, len = rowDom.childNodes.length;
            while(w <= x && (!colBoundMax || col < colBoundMax)){
            	if(i < len){
            		var child = Ext.get(rowDom.childNodes[i]);
                    col = Number(child.getAttribute('ci'));
                    w += child.getWidth();
                    i++;
            	}else{
            		col++;
    				w += s.getColWidth(sheetId, col, true);
            	}                
            }
            woff = x-w;
		}else if(0 > x){
			var px = -x;
			var w = 0;
			while(w <= px && col > 1){
				col--;
				w += s.getColWidth(sheetId, col, true);
			}
            woff = px-w;
		}
		var row = this.rowStart;
		if(0 < y){
            /*
			var h = s.getRowHeight(sheetId, row, true);
			while(h <= y && (!rowBoundMax || row < rowBoundMax)){
				row++;
				h += s.getRowHeight(sheetId, row, true);
			}*/
			var firstChild = Ext.get(this.regionEl.dom.childNodes[0]);
            var h = firstChild.getHeight();
            row = Number(firstChild.dom.firstChild.getAttribute('ri'));
            var i = 1, len = this.regionEl.dom.childNodes.length;
            while(h <= y && (!rowBoundMax || row < rowBoundMax)){
            	if(i < len){
            		var child = Ext.get(this.regionEl.dom.childNodes[i]);
                    row = Number(child.dom.firstChild.getAttribute('ri'));
                    h += child.getHeight();
                    i++;
            	}else{
            		row++;
            		h += s.getRowHeight(sheetId, row, true);
            	}                
            }
            hoff = y-h;
		}else if(0 > y){
			var py = -y;
			var h = 0;
			while(h <= py && row > 1){
				row--;
				h += s.getRowHeight(sheetId, row, true);
			}
            hoff = py-h;
		}
		if(0 < x){
			s.cacheRangeWidth(xy[0]-this.ifbodyEl.getLeft()-woff, this.colBound.min, col, sheetId);
		}
		if(0 < y){
			s.cacheRangeHeight(xy[1]-this.ifbodyEl.getTop()-hoff, this.rowBound.min, row, sheetId);
		}
        
		if(!checkout){
			return [row, col];
		}else{
			var pos = {
				x:x,
				y:y,
				w:this.getEl().getWidth(),
				h:this.getEl().getHeight()
			};			
			return [row, col, pos];
		}
	},
	
	/*
	 * when the component resize
	 */
	processAfterResize: function(comp, width, height) {		
		/*
		 * a flag to use skip the resize process
		 */
		if(!this._skipProcessResize){			
			this.getEl().setWidth(width);
			/*
			 * if the row span is not fixed for resizing, then adjust the row span
			 */
			if(!this.fixedRowForResize){			
				this.adjustRows(height-this.regionEl.getHeight());
			}
			/*
			 * if the col span is not fixed for resizing, then adjust the column span
			 */
			if(!this.fixedColForResize){			
				this.adjustCols(width-this.currentWidth);
			}		
			
			this.currentWidth = this.regionEl.getWidth();							
			/*
			 * here we set holdInfinateScroll to true, cause we don't need sys infinate scroller
			 * the infinate scroller will catch the resize event to sys itself
			 */
			this.sysn(true);
            if(this.canvasEl){
                /*
                 * setup the canvas size
                 */
                this.canvasEl.dom.width = this.canvasEl.getWidth();
                this.canvasEl.dom.height = this.canvasEl.getHeight();
            }
        }
	},
	
	/*
	 * if the offsetwidth is > 0, then need render more col at the right side
	 */
	adjustCols : function(offsetWidth){		
		var w = 0;
		var s = this.getStore();
		var sheetId = this.getSheetId();
		if(0 < offsetWidth){
			var colEnd = this.colEnd;	
			var colBoundMax = SCONST.MAX_COLUMN_NUMBER;
			while(true && (!colBoundMax || this.colEnd < colBoundMax)){				
				var width = s.getColWidth(sheetId, ++this.colEnd, true);				
				w += width;				
				if(w >= offsetWidth){
					break;
				}				
			}					
			/*
			 * need reset the width of region element, or the last cell may not show
			 * it's because the cell css float:left, the container element has to provide
			 * enough width, or the cell element will break the row
			 */
			this.updateRegionElWidth(this.currentWidth+w);
			var columnVisible = [];
			colEnd++;
			for(var j = colEnd; j <= this.colEnd; j++){
				columnVisible.push(s.isVisibleColumn(sheetId, j));
			}
			var k = 0;
			for(var i = this.rowStart; i <= this.rowEnd; i++){
				if(s.isVisibleRow(sheetId, i)){
					var cells = [];
					for(var j = colEnd; j <= this.colEnd; j++){	
						if(columnVisible[j-colEnd]){
							var c = this.getData(i, j);
							cells.push(c);				
						}	
					}
					if(0 < cells.length){
						var rowel = this.regionEl.dom.childNodes[k++];
                        if(rowel){
                            var html = this.rowTpl.apply(cells);
                            Ext.core.DomHelper.append(rowel, html);
                        }
					}
				}
			}	
		}
	},
	
	/*
	 * if offsetheight > 0 then need render more rows at bottom
	 */
	adjustRows : function(offsetHeight){
		var sheetId = this.getSheetId();
		var h = 0;
		var s = this.getStore();
		if(0 < offsetHeight){
			var rowEnd = this.rowEnd;
			var rowBoundMax = SCONST.MAX_ROW_NUMBER;
			while(true && (!rowBoundMax || this.rowEnd < rowBoundMax)){
				var height = s.getRowHeight(sheetId, ++this.rowEnd, true);
				h += height;				
				if(h >= offsetHeight){
					break;
				}				
			}	
			var rows = [], columnVisible = [];
			/*
			 * keep the visible status of columns in an array for futher using
			 */
			for(var j = this.colStart; j <= this.colEnd; j++){
				columnVisible.push(s.isVisibleColumn(sheetId, j));
			}
			rowEnd++;
			for(var i = rowEnd; i <= this.rowEnd; i++){
				if(s.isVisibleRow(sheetId, i)){
					var cells = [];
					for(var j = this.colStart; j <= this.colEnd; j++){		
						if(columnVisible[j-this.colStart]){
							var c = this.getData(i, j);
							cells.push(c);					
						}
					}
					var o = this.getData(i, 0);
					o.cells = cells;
					rows.push(o);
				}
			}
			this.appendRows(rows);	
		}		
	},
	
	/*
	 * append rows html 
	 */
	appendRows : function(rows){
		var html = this.regionTpl.apply(rows);
		Ext.core.DomHelper.append(this.regionEl.dom, html);
	},		
	
	/*
	 * move the region up, it will skip the hidden row
	 * @param {int} offset: how many row roll up
	 */
	moveUp : function(offset){
		var sheetId = this.getSheetId();
		var s = this.getStore();
		/*
		 * here we need handle the case the low bound is not visibe
		 */
		var low = this.rowBound.low;
		for(var i = low; i < this.rowStart; i++){	
			if(s.isVisibleRow(sheetId, low)){
				break;
			}else{
				low = i+1;
			}
		}
		/*
		 * can not move beyond the row bound 
		 */
		if(low > this.rowStart-offset){
			offset = this.rowStart-low;
		}
		if(0 >= offset) return 0;
		
		var el = this.regionEl.dom, rowDom = el.firstChild;
		var ah = 0, rows = [], visibleColumn = [];
		/*
		 * the region height
		 */
		var eh = this.getEl().getHeight();
		/*
		 * keep the column visible status for the column range
		 */
        for(var j = 0, len = rowDom.childNodes.length; j < len; j++){
            var child = rowDom.childNodes[j], ci = Number(child.getAttribute('ci'));
            visibleColumn.push(ci);
        }
		var rowStart = this.rowStart, rowEnd;
		var oldRowStart = rowStart, tmpH = [];
		for(var i = 0; i < offset && low < rowStart;){
            var h = s.getRowHeight(sheetId, --rowStart, true);
			if(0 !== h){
				i++;
                tmpH.unshift({
                    i: rowStart,
                    h: h
                });
			}
		}
		 
		/*
		 * calculate the inserted row height, and then use it to calcualte how many rows need be removed at bottom
		 * the inserted row can not beyond the low bound
		 */		 
        for(var i = 0, size = tmpH.length; i < size; i++){
            var it = tmpH[i];
            rowEnd = it.i;
			/*
			 * set skipHidden to true to skip the hidden row
			 */		
			var h = it.h;
			
            var cells = [];
            for(var j = 0, len = visibleColumn.length; j < len; j++){
                cells.push(this.getData(rowEnd, visibleColumn[j]));
            }
            var o = this.getData(rowEnd, 0);
            o.cells = cells;
            rows.push(o);
            ah += h;
            if(ah > eh){
                /*
                 * if ah is larger than eh, then we just stop;
                 */
                break;
            }
		}		
				
		
		if(ah > eh){
			/*
			 * recalculate the moved offset
			 */
			ah = s.getRangeHeight(sheetId, rowStart, this.rowStart-1);				
			/*
			 * if ah is larger than eh, then we just re-render the region;
			 * only need render top rows which can cover the region will be enough
			 */			
			var html = this.regionTpl.apply(rows); 
			this.regionEl.update(html);
			/*
			 * update the rowStart and rowEnd
			 */
			this.rowStart = rowStart;
			this.rowEnd = rowEnd;
		}else{
			/*
			 * get the height of all rows
			 */
			var ih = this.regionEl.getHeight();
			var html = this.regionTpl.apply(rows);
			Ext.core.DomHelper.insertBefore(el.firstChild, html);
			ih += ah;			
			/*
			 * calculate the height need to remove at the bottom
			 */
			var offsetHeight = ih-eh;			
			var rh = 0, rowEnd = this.rowEnd;
			while(true){
				var h = s.getRowHeight(sheetId, rowEnd--, true);
				/*
				 * if not a hidden row
				 */
				if(0 != h){
					rh += h;
					if(rh > offsetHeight){						
						rowEnd++;
						break;
					}else{						
						Ext.removeNode(el.lastChild);
					}
				}
			}	
			/*
			 * update the rowStart and rowEnd
			 */
			this.rowStart = rowStart;		
			this.rowEnd = rowEnd;
		}		
		if(this.ifctEl){
			this.ifctEl.dom.scrollTop -= ah;
		}
		
		this.fireEvent('moving', 'up', offset, this);
		return -offset;
	},
	
	/*
	 * move row to the passed position
	 */
	moveRow : function(rowStart, rowEnd, scrollTop){
		if(rowEnd == this.rowEnd && rowStart == this.rowStart){
			return;
		}
		var el = this.regionEl.dom, rowDom = el.firstChild;
		var s = this.getStore();
		var sheetId = this.getSheetId();
		var renderWhole = false;
		var visibleColumn = [];
		/*
		 * keep the column visible status for the column range
		 */
		for(var j = 0, len = rowDom.childNodes.length; j < len; j++){
            var child = rowDom.childNodes[j], ci = Number(child.getAttribute('ci'));
			visibleColumn.push(ci);
		}
		if(rowStart < this.rowStart){
			/*
			 * move up
			 */
			if(rowEnd < this.rowStart){
				renderWhole = true;
			}else{
				var rows = [];
				for(var i = rowStart; i < this.rowStart; i++){
					if(s.isVisibleRow(sheetId, i)){
						var cells = [];				
						for(var j = 0, len = visibleColumn.length; j < len; j++){
							cells.push(this.getData(i, visibleColumn[j]));
						}
						var o = this.getData(i, 0);
						o.cells = cells;
						rows.push(o);
					}
				}
				var html = this.regionTpl.apply(rows);
				Ext.core.DomHelper.insertBefore(el.firstChild, html);
				/*
				 * remove the rows at bottom
				 */
				for(var k = rowEnd+1; k <= this.rowEnd; k++){
					if(s.isVisibleRow(sheetId, k)){
						Ext.removeNode(el.lastChild);	
					}
				}
			}
		}else{
			/*
			 * move down
			 */
			if(rowStart > this.rowEnd){
				renderWhole = true;
			}else{
				var rows = [];
				for(var i = this.rowEnd+1; i <= rowEnd; i++){
					if(s.isVisibleRow(sheetId, i)){
						var cells = [];				
						for(var j = 0, len = visibleColumn.length; j < len; j++){
                            cells.push(this.getData(i, visibleColumn[j]));
						}
						var o = this.getData(i, 0);
						o.cells = cells;
						rows.push(o);
					}
				}
				var html = this.regionTpl.apply(rows);
				Ext.core.DomHelper.append(el, html);
				/*
				 * remove the rows at top
				 */
				for(var k = this.rowStart; k < rowStart; k++){
					if(s.isVisibleRow(sheetId, k)){
						Ext.removeNode(el.firstChild);	
					}
				}
			}
		}
		if(renderWhole){
			var rows = [];
			for(var i = rowStart; i <= rowEnd; i++){
				if(s.isVisibleRow(sheetId, i)){
					var cells = [];				
					for(var j = 0, len = visibleColumn.length; j < len; j++){
                        cells.push(this.getData(i, visibleColumn[j]));
					}
					var o = this.getData(i, 0);
					o.cells = cells;
					rows.push(o);
				}
			}
			var html = this.regionTpl.apply(rows);
			this.regionEl.update(html);
		}
		this.rowStart = rowStart;
		this.rowEnd = rowEnd;
		if(this.ifctEl){
			this.ifctEl.dom.scrollTop = scrollTop;
		}
	},
	
	/*
	 * move the region down, it will skip the hidden row
	 * @param {int} offset: how many row roll down
	 */		
	moveDown : function(offset){
		if(0 == offset || this.rowBound.high) return 0;
		/*
		 * check whether has max limit
		 */
		var rowBoundMax = SCONST.MAX_ROW_NUMBER;
		var sheetId = this.getSheetId();
		var s = this.getStore();
		var el = this.regionEl.dom;		
		/*
		 * get the region visible height, and the actual height
		 */
		var eh = this.getEl().getHeight(), ih = this.regionEl.getHeight();
		/*
		 * calculate the removed row height, and then use it to calcualte how many rows need be append
		 */
		var rowStart = this.rowStart, rowEnd, minh, rh;
        var rowSpan = el.childNodes.length;
		if(offset >= rowSpan){
			/*
			 * means the whole region is removed, we just need re-render the whole region
			 */
			rowStart = this.rowEnd;
			for(var i = 0, len = offset-rowSpan+1; i < len;){
				if(s.isVisibleRow(++rowStart)){
					i++;
				}
			}			
			/*
			 * check max limit
			 */
			if(rowBoundMax && rowStart > rowBoundMax){
				rowStart = rowBoundMax;
			}
			rowEnd = rowStart-1;
			minh = eh;
			rh = s.getRangeHeight(sheetId, this.rowStart, rowEnd);
		}else{
			rh = 0;			
			for(var k = 0; k < offset; k++){
                var child = Ext.get(el.childNodes[k]);
                var h = child.getHeight();
                rh += h;
                rowStart = child.dom.firstChild.getAttribute('ri');
                rowStart = Number(rowStart)+1;
			}						
			rowEnd = this.rowEnd;		
			/*
			 * minh is the offset height at bottom if we remove the rows at top
			 */
			minh = rh-(ih-eh);
			/*
			 * if minh is larger than the height of region, then we just need cover the height of region
			 */
			if(eh < minh){
				minh = eh;
			}
		}		
		/*
		 * calculate how many row need add at bottom to fit the offset height
		 */
		var ah = 0;
        var rows = [], visibleColumn = [];
		/*
		 * keep the column visible status for the column range
		 */
        var rowDom = el.firstChild;
        for(var j = 0, len = rowDom.childNodes.length; j < len; j++){
            var child = rowDom.childNodes[j], ci = Number(child.getAttribute('ci'));
            visibleColumn.push(ci);
        }
		while(ah < minh && (!rowBoundMax || rowEnd < rowBoundMax)){			
			var h = s.getRowHeight(sheetId, ++rowEnd, true);
			/*
			 * if not a hidden row
			 */
			if(0 != h){
				ah += h;	
				var cells = [];
                for(var j = 0, len = visibleColumn.length; j < len; j++){
					cells.push(this.getData(rowEnd, visibleColumn[j]));
				}
				var o = this.getData(rowEnd, 0);
				o.cells = cells;
				rows.push(o);
			}		
		}
		var html;
		if(0 < rows.length){
			html = this.regionTpl.apply(rows);
		}
		
		/*
		 * if the rowStart is larger than this.rowEnd, it means we should update regionEl
		 */
		if(rowStart <= this.rowEnd){
			/*
			 * remove the rows at top, and append rows at bottom
			 */
			for(var k = 1; k <= offset; k++){
				Ext.removeNode(el.firstChild);				
			}		
			if(html){
				Ext.core.DomHelper.append(el, html);
			}
			/*
			 * update the row range
			 */
			this.rowStart = rowStart;
			this.rowEnd = rowEnd;
		}else{
			/*
			 * update the row range
			 */
			this.rowStart = rowStart;
			this.rowEnd = rowEnd;
			this.regionEl.update(html);
		}
		if(this.ifctEl){
			this.ifctEl.dom.scrollTop += rh;
		}
		this.fireEvent('moving', 'down', offset, this);
		return offset;
	},
	
	
	/*
	 * move the region right, it will skip the hidden column
	 * @param {int} offset: how many row roll right
	 */
	moveRight : function(offset){
		if(0 == offset || this.colBound.high) return 0;
		/*
		 * check whether has max limit
		 */
		var colBoundMax = SCONST.MAX_COLUMN_NUMBER;
		
		var s = this.getStore();
		var sheetId = this.getSheetId();
		var el = this.regionEl.dom, rowDom = el.firstChild;
		/*
		 * get the visible region width and the actual width
		 */
		var ew = this.getEl().getWidth(), iw = this.currentWidth;
		var rw, colEnd, colStart, minw;
		var colSpan = rowDom.childNodes.length;
		var beyondFlag = false;
		if(offset >= colSpan){			
			/*
			 * means the whole region is removed, we just need re-render the whole region
			 */
			colStart = this.colEnd;
			for(var i = 0, len = offset-colSpan+1; i < len;){
				if(s.isVisibleColumn(++colStart)){
					i++;
				}
			}			
			/*
			 * check max limit
			 */
			if(colBoundMax && colStart > colBoundMax){
				colStart = colBoundMax;
				beyondFlag = true;
			}
			colEnd = colStart-1;			
			minw = ew;
			rw = s.getRangeWidth(sheetId, this.colStart, colEnd);
		}else{
			rw = 0;
			/*
			 * calculate the removed column width, and then use it to calcualte how many columns need be append
			 */
			colStart = this.colStart; 
			for(var k = 0; k < offset; k++){
                var child = Ext.get(rowDom.childNodes[k]);
                var w = child.getWidth();
                rw += w;
                colStart = child.getAttribute('ci');
                colStart = Number(colStart)+1;
			}
			colEnd = this.colEnd;
			
			/*
			 * minw is the offset width at right if we remove the columns at left
			 */
			minw = rw-(iw-ew);
			/*
			 * if minw is larger than the width of region, then we just need cover the width of region
			 */
			if(ew < minw){
				minw = ew;
			}
		}		
		/*
		 * calculate how many row need add at bottom to fit the offset height
		 */		
		var rows = [], rowVisible = [];
		/*
		 * keep the row visible status for the row range
		 */
        for(var i = 0, len = el.childNodes.length; i < len; i++){
            var child = el.childNodes[i].firstChild, ri = Number(child.getAttribute('ri'));
            rowVisible.push(ri);
            var o = this.getData(ri, 0);
            o.cells = [];
            rows.push(o);
        }
		var aw = 0;
		while(aw < minw && (!colBoundMax || colEnd < colBoundMax)){
			var w = s.getColWidth(sheetId, ++colEnd, true);
			/*
			 * if not a hidden column
			 */
			if(0 != w){
				aw += w;
                for(var k = 0, len = rowVisible.length; k < len; k++){
                    var cells = rows[k].cells;
                    cells.push(this.getData(rowVisible[k], colEnd));
                }
			}
		}
		/*
		 * if the colStart is larger than this.colEnd, it means we should update regionEl
		 */
		if(colStart <= this.colEnd){
			/*
			 * update the width of regionEl
			 */
			var tmp = iw-rw;
			if(!beyondFlag){
				tmp += aw;
			}
			
			this.updateRegionElWidth(tmp);
			for(var i = 0, len = el.childNodes.length; i < len; i++){
				var row = el.childNodes[i];
				for(var k = 0; k < offset; k++){
					Ext.removeNode(row.firstChild);									
				}
				var cells = rows[i].cells;
				if(0 < cells.length){
					var html = this.rowTpl.apply(cells);
					Ext.core.DomHelper.append(row, html);
				}
			}
			/*
			 * update the column range
			 */
			this.colStart = colStart;
			this.colEnd = colEnd;
		}else{
			/*
			 * update the width of regionEl
			 */
			this.updateRegionElWidth(aw);
			/*
			 * need get row Height and some other row property for every row in rows array
			 */
            for(var k = 0, len = rowVisible.length; k < len; k++){
                var o = this.getData(rowVisible[k], 0);
                Ext.applyIf(rows[k], o);
            }
			
			var html = this.regionTpl.apply(rows);
			/*
			 * update the column range
			 */
			this.colStart = colStart;
			this.colEnd = colEnd;
			this.regionEl.update(html);
		}		
		if(this.ifctEl){
			this.ifctEl.dom.scrollLeft += rw;
		}
		this.fireEvent('moving', 'right', offset, this);
		return offset;
	},
	
	/*
	 * move column to the passed position
	 */
	moveColumn : function(colStart, colEnd, scrollLeft){
		if(colEnd == this.colEnd && colStart == this.colStart){
			return;
		}
		var el = this.regionEl.dom, rowDom = el.firstChild;
		var s = this.getStore();
		var sheetId = this.getSheetId();
		var renderWhole = false;
		
		if(colStart < this.colStart){
			/*
			 * move left
			 */
			if(colEnd < this.colStart){
				renderWhole = true;
			}else{
				var visibleColumn = [], removeVisibleColumn = [];
				/*
				 * keep the column visible status for the column range
				 */
				for(var j = colStart; j < this.colStart; j++){
					visibleColumn.push(s.isVisibleColumn(sheetId, j));
				}
				for(var j = colEnd+1; j <= this.colEnd; j++){
					removeVisibleColumn.push(s.isVisibleColumn(sheetId, j));
				}
                for(var k = 0, len = el.childNodes.length; k < len; k++){
                    var child = el.childNodes[k].firstChild, i = Number(child.getAttribute('ri'));
					
                    var cells = [];
                    for(var j = colStart; j < this.colStart; j++){
                        if(visibleColumn[j-colStart]){
                            cells.push(this.getData(i, j));
                        }
                    }
                    var html = this.rowTpl.apply(cells);
                    var row = el.childNodes[k];
                    Ext.core.DomHelper.insertBefore(row.firstChild, html);
                    for(var j = colEnd+1; j <= this.colEnd; j++){
                        if(removeVisibleColumn[j-colEnd-1]){
                            Ext.removeNode(row.lastChild);
                        }
                    }
				}
			}
		}else{
			/*
			 * move right
			 */
			if(colStart > this.colEnd){
				renderWhole = true;
			}else{
				var visibleColumn = [], removeVisibleColumn = [];
				/*
				 * keep the column visible status for the column range
				 */
				for(var j = this.colEnd+1; j <= colEnd; j++){
					visibleColumn.push(s.isVisibleColumn(sheetId, j));
				}
				for(var j = this.colStart; j < colStart; j++){
					removeVisibleColumn.push(s.isVisibleColumn(sheetId, j));
				}
				for(var k = 0, len = el.childNodes.length; k < len; k++){
                    var child = el.childNodes[k].firstChild, i = Number(child.getAttribute('ri'));
                    var cells = [];
                    for(var j = this.colEnd+1; j <= colEnd; j++){
                        if(visibleColumn[j-this.colEnd-1]){
                            cells.push(this.getData(i, j));
                        }
                    }
                    var html = this.rowTpl.apply(cells);
                    var row = el.childNodes[k];
                    Ext.core.DomHelper.append(row, html);
                    for(var j = this.colStart; j < colStart; j++){
                        if(removeVisibleColumn[j-this.colStart]){
                            Ext.removeNode(row.firstChild);
                        }
                    }
				}
			}
		}
		var visibleColumn = [], w = 0;
		/*
		 * keep the column visible status for the column range
		 */
		for(var j = colStart; j <= colEnd; j++){
			var visible = s.isVisibleColumn(sheetId, j);
			visibleColumn.push(visible);
			if(visible){
				w += s.getColWidth(sheetId, j);
			}
		}
		if(renderWhole){
			var rows = [];
			
           for(var k = 0, len = el.childNodes.length; k < len; k++){
                var child = el.childNodes[k].firstChild, i = Number(child.getAttribute('ri'));
				
                var cells = [];
                for(var j = colStart; j <= colEnd; j++){
                    if(visibleColumn[j-colStart]){
                        cells.push(this.getData(i, j));
                    }
                }
                var o = this.getData(i, 0);
                o.cells = cells;
                rows.push(o);				
			}
			var html = this.regionTpl.apply(rows);
			this.regionEl.update(html);
		}
		this.colStart = colStart;
		this.colEnd = colEnd;
		
		if(this.ifctEl){
			this.ifctEl.dom.scrollLeft = scrollLeft;
		}
		/*
		 * update the width of regionEl
		 */
		this.updateRegionElWidth(w);
	},
	
	/*
	 * move the region left, it will skip the hidden column
	 * @param {int} offset: how many row roll left
	 */
	moveLeft : function(offset){
		var sheetId = this.getSheetId();
		var s = this.getStore();
		/*
		 * here we need handle the case the low bound is not visibe
		 */
		var low = this.colBound.low;
		for(var i = low; i < this.colStart; i++){	
			if(s.isVisibleColumn(sheetId, low)){
				break;
			}else{
				low = i+1;
			}
		}
		/*
		 * can not move to negative col index
		 */
		if(low > this.colStart-offset){
			offset = this.colStart-low;
		}
		if(0 >= offset) return 0;
		
		var el = this.regionEl.dom;		
		/*
		 * get the visible region width
		 */
		var ew = this.getEl().getWidth();
		var aw = 0, colStart = this.colStart, colEnd;
        var rowVisible = [], rows = [];
        
        for(var i = 0, len = el.childNodes.length; i < len; i++){
            var child = el.childNodes[i].firstChild, ri = Number(child.getAttribute('ri'));
            rowVisible.push(ri);
            var o = this.getData(ri, 0);
            o.cells = [];
            rows.push(o);
        }
		/*
		 * calculate the inserted column width, and then use it to calcualte how many columns need be removed at right
		 * the inserted column can not beyond the low bound
		 */		 	
		var oldColStart = colStart, tmpW = [];
		for(var i = 0; i < offset && low < colStart;){
            var w = s.getColWidth(sheetId, --colStart, true);
			if(0 !== w){
				i++;
                tmpW.unshift({
                    i: colStart,
                    w: w
                });
			}
		}
		
        for(var i = 0, size = tmpW.length; i < size; i++){
            var it = tmpW[i];
            colEnd = it.i;

			var w = it.w;
			
            for(var j = 0, len = rowVisible.length; j < len; j++){
                var cells = rows[j].cells;
                cells.push(this.getData(rowVisible[j], colEnd));
            }
            aw += w;
            if(aw > ew){
                /*
                 * if the insert width is larger than the region visible width, then stop
                 */
                break;
            }
		}
			
		/*
		 * if aw > ew, then means the insert column width is cover the whole region,
		 * we need re-render the Range
		 */
		if(aw > ew){
			/*
			 * if aw is larger than ew, then we just re-render the region;
			 * only need render left columns which can cover the region will be enough
			 */
			var xw = s.getRangeWidth(sheetId, colStart, this.colStart-1);			
			var html = this.regionTpl.apply(rows); 
			this.regionEl.update(html);
			/*
			 * update the colStart and colEnd
			 */
			this.colStart = colStart;
			this.colEnd = colEnd;
			/*
			 * update the width of regionEl
			 */
			this.updateRegionElWidth(aw);
			/*
			 * update it with the moved offset in scroller
			 */
			aw = xw;
		}else{
			/*
			 * insert columns at left first
			 */
			for(var i = 0, len = el.childNodes.length; i < len; i++){
				var row = el.childNodes[i];
				var html = this.rowTpl.apply(rows[i].cells);
				Ext.core.DomHelper.insertBefore(row.firstChild, html);
			} 
			/*
			 * calculate the offset width at right side, if we insert these columns at left
			 */
			var offsetWidth = this.currentWidth+aw-ew;
			var rw = 0, colEnd = this.colEnd;
			while(true){
				var w = s.getColWidth(sheetId, colEnd--, true);
				if(0 != w){
					rw += w;
					if(rw > offsetWidth){
						rw -= w;
						colEnd++;
						break;
					}else{
						for(var i = 0, len = el.childNodes.length; i < len; i++){
							var row = el.childNodes[i];
							Ext.removeNode(row.lastChild);
						}
					}
				}
			}
			/*
			 * update the colStart and colEnd
			 */
			this.colStart = colStart;
			this.colEnd = colEnd;
			/*
			 * update the width of regionEl
			 */
			this.updateRegionElWidth(this.currentWidth+aw-rw);
		}
		
		if(this.ifctEl){
			this.ifctEl.dom.scrollLeft -= aw;
		}
		this.fireEvent('moving', 'left', offset, this);
		return -offset;
	},
	
	/*
	 * just re-render the region
	 * it will skip the hidden row/column
	 */
	renderRange : function(){
		var sheetId = this.getSheetId();
		var s = this.getStore();
		var rows = [], visibleColumn = [];
		
		/*
		 * keep the visible of columns;
		 */
		for(var j = this.colStart; j <= this.colEnd; j++){
			visibleColumn.push(s.isVisibleColumn(sheetId, j));
		}
		for(var i = this.rowStart; i <= this.rowEnd; i++){
			/*
			 * only show visible rows and columns
			 */
			if(s.isVisibleRow(sheetId, i)){
				var cells = [];
				for(var j = this.colStart; j <= this.colEnd; j++){
					if(visibleColumn[j-this.colStart]){
						cells.push(this.getData(i, j));
					}
				}
				var o = this.getData(i, 0);
				o.cells = cells;
				rows.push(o);
			}
		}
		
		var html = this.regionTpl.apply(rows);
		this.regionEl.update(html);
	},
	
	/*
	 * change the row/col span of this region first
	 * and re-render the region, also need recalculate the width of regionEl
	 * if the keepRegionWidth is not true
	 */
	changeRange : function(range, keepRegionWidth){
		if(range){
			this.setRange(range);
		}
		this.renderRange();
		if(!keepRegionWidth){
			this.currentWidth = this.getStore().getRangeWidth(this.getSheetId(), this.colStart, this.colEnd);
			this.updateRegionElWidth(this.currentWidth);
		}
	},
	
	setRange : function(range){
		Ext.apply(this, range);		
	},
	
	/*
	 * show/hide the scroller
	 */
	switchScroller : function(visible){
		if(this.infinateScroller){
			this.infinateScroller.setVisible(visible);
		}
	},
	
	/*
	 * sysn the scroller's scrollLeft and scrollTop to the right position 
	 */
	sysInfinateScroller : function(dir){
		if(this.infinateScroller){
			this.infinateScroller.sysn(dir);
		}
	},
	
	/*
	 * sysn the scroller's scrollLeft and scrollTop to the right position
	 * also sysn the inner container element, it's for the floating element
	 * holdInfinateScroll is true then no need sys infinate scroller
	 */
	sysn : function(holdInfinateScroll){
		var s = this.getStore();	
		var sheetId = this.getSheetId();
		if(this.ifctEl){
			var w = s.getRangeWidth(sheetId, 1, this.colStart-1);
			var h = s.getRangeHeight(sheetId, 1, this.rowStart-1);
			this.ifctEl.dom.scrollLeft = w;
			this.ifctEl.dom.scrollTop = h;
		}
		if(!holdInfinateScroll){
			this.sysInfinateScroller();
		}
	},
	
	/*
	 * recalculate the range span based on width/height, or just use fixed range span
	 * it will rr-render the range
	 */
	recalculateRange : function(rowObj, colObj){		
		var sheetId = this.getSheetId();
		var s = this.getStore();
		/*
		 * skip resize
		 */
		this._skipProcessResize = true;
		if(rowObj){
			this.rowStart = rowObj.rowStart;
			var rowBoundMax = SCONST.MAX_ROW_NUMBER;
			var rh = rowObj.height;						
			var rowEnd = rowObj.rowEnd;
			if(false == SCOM.typeOf(rowEnd)){
				rowEnd = this.rowStart-1;
				var h = 0;
				while(true && (!rowBoundMax || rowEnd < rowBoundMax)){
					var height = s.getRowHeight(sheetId, ++rowEnd, true);
					h += height;				
					if(h >= rh){
						break;
					}				
				}
			}
			if(false == SCOM.typeOf(rh)){
				rh = s.getRangeHeight(sheetId, this.rowStart, rowEnd);
			}
			this.rowEnd = rowEnd;
			this.setHeight(rh);
		}
		if(colObj){
			this.colStart = colObj.colStart;
			var colBoundMax = SCONST.MAX_COLUMN_NUMBER;
			var cw = colObj.width;
			var colEnd = colObj.colEnd;
			if(false == SCOM.typeOf(colEnd)){
				colEnd = this.colStart-1;
				var w = 0;
				while(true && (!colBoundMax || colEnd < colBoundMax)){
					var width = s.getColWidth(sheetId, ++colEnd, true);
					w += width;				
					if(w >= cw){
						break;
					}				
				}
			}
			if(false == SCOM.typeOf(cw)){
				cw = s.getRangeWidth(sheetId, this.colStart, colEnd);
			}
			this.colEnd = colEnd;			
			this.setWidth(cw);
		}

		this.changeRange();				
		
		delete(this._skipProcessResize);				
	},
	
	setBound : function(rb, cb){
		Ext.apply(this.rowBound, rb)
		Ext.apply(this.colBound, cb)
	},
	
	getCellPosition : function(x, y){
		var s = this.getStore();
		var sheetId = this.getSheetId();
		var w = s.getRangeWidth(sheetId, this.colStart, y);
		var h = s.getRangeHeight(sheetId, this.rowStart, x);
		return [w, h];
	},
	
	getStore : function(){
		return this.store;
	},
	
	getSelectionModel : function(){
		return this.sm;
	},
	
	getScroller : function(){
		return this.infinateScroller;
	},
	
	/*
	 * auto moving this region to show the position if need
	 * only work when this region has a scroller
	 */
	autoMoving : function(pos){
		var scroller = this.getScroller();
		if(scroller){
			var row = pos.row, col = pos.col, moved = false;
			if(row < this.rowBound.low){
				row = this.rowBound.low;
			}
			if(row < this.rowStart){
				scroller.scrollRow(row-this.rowStart);
				moved = true;
			}else if(!this.rowBound.high && row > this.rowEnd){
				scroller.scrollRow(row-this.rowEnd);
				moved = true;
			}
			
			if(col < this.colBound.low){
				col = this.colBound.low;
			}			
			if(col < this.colStart){
				scroller.scrollCol(col-this.colStart);
				moved = true;
			}else if(!this.colBound.high && col > this.colEnd){				
				scroller.scrollCol(col-this.colEnd);
				moved = true;
			}			
			return moved;
		}
		return false;
	},		
	
	/*
	 * remove row in [minrow, maxrow] of the UI, this function will re-render all rows after maxrow
	 * @param {int} minrow: the min row index to remove
	 * @param {int} maxrow: the max row index to remove
	 * @param {array} deleted: the records deleted from store, cause usually this function is called after the records are deleted from store,
	 * but when remove rows from UI, we also need the information of these deleted records, so caller have to pass them in
	 */
	removeAfterRow : function(minrow, maxrow, deleted){
		var sheetId = this.getSheetId();
		/*
		 * if minrow is large than this.rowEnd, then no need do anything
		 */
		if(this.isVisible() && minrow <= this.rowEnd){
			/*
			 * here we re-render the row before the minrow, because the border refresh issue
			 */
			if(this.rowStart < minrow){
				minrow--;
			}
			/*
			 * if minrow < this.rowStart, then need sysn the scroller
			 * here we just keep the result, cause we need change minrow next
			 */
			var flag = minrow < this.rowStart, minr = minrow, maxr = maxrow;
			
			/*
			 * below is for calculate the minrow and maxrow to really remove the element,
			 * and the rowEnd after remove these rows.
			 * it's a little bit tricky
			 */
			var span = maxrow-minrow+1;
			if(minrow <= this.rowStart){
				minrow = this.rowStart;
				maxrow = minrow+span-1;
			}else{
				if(maxrow > this.rowEnd){
					maxrow = this.rowEnd;
				}
			}
			if(minrow <= this.rowStart && maxrow >= this.rowEnd){
				this.recalculateRange({
					rowStart:this.rowStart,
					height:this.getEl().getHeight()
				});
			}else{
				var s = this.getStore();
				/*
				 * this temp function is for calculate the child node index of a row in regionEl
				 */
				var fn = function(rowIndex){
					var k = 0;
					for(var i = this.rowStart; i < rowIndex; i++){
						/*
						 * here if i in [minr, maxr], then need check deleted object, cause the rd is already removed in store
						 */
						if(minr <= i && i <= maxr){
							if(!s.isVisibleRow(sheetId, i, deleted)){
								k++;
							}
						}else if(!s.isVisibleRow(sheetId, i)){
							k++;
						}
					}
					/*
					 * calculate the start child node to delete
					 */
					return rowIndex-this.rowStart-k;					
				}
				/*
				 * calculate the child node index of minrow, and then remove childNode start at startIndex
				 */
				var startIndex = fn.call(this, minrow), el = this.regionEl.dom;
				for(var i = startIndex, len = el.childNodes.length; i < len; i++){
					Ext.removeNode(el.childNodes[startIndex]);
				}				
				/*
				 * set the rowEnd and then render more at bottom if need
				 */
				this.rowEnd = minrow-1;
				var offset = this.regionEl.getHeight()-this.getEl().getHeight();
				if(0 > offset){
					this.adjustRows(-offset);
				}								
			}
			/*
			 * update the scroller of this region
			 */
			if(flag){
				this.sysn();
			}
		}
	},
	
	/*
	 * remove row in [minrow, maxrow] of the UI, this function will move up the rows after maxrow to fill the empty range but not re-render them
	 * @param {int} minrow: the min row index to remove
	 * @param {int} maxrow: the max row index to remove
	 * @param {array} deleted: the records deleted from store, cause usually this function is called after the records are deleted from store,
	 * but when remove rows from UI, we also need the information of these deleted records, so caller have to pass them in
	 */
	removeRow : function(minrow, maxrow, deleted){
		var sheetId = this.getSheetId();
		/*
		 * if minrow is large than this.rowEnd, then no need do anything
		 */
		if(this.isVisible() && minrow <= maxrow && minrow <= this.rowEnd){
			/*
			 * if minrow < this.rowStart, then need sysn the scroller
			 * here we just keep the result, cause we need change minrow next
			 */
			var flag = minrow < this.rowStart, minr = minrow, maxr = maxrow;			
			
			/*
			 * below is for calculate the minrow and maxrow to really remove the element
			 */
			var span = maxrow-minrow+1;
			if(minrow <= this.rowStart){
				minrow = this.rowStart;
				maxrow = minrow+span-1;
			}else{
				if(maxrow > this.rowEnd){
					maxrow = this.rowEnd;
				}
			}
			/*
			 * if the removed row range covered this region, then re-render this range base on height
			 */
			if(minrow <= this.rowStart && maxrow >= this.rowEnd){
				this.recalculateRange({
					rowStart:this.rowStart,
					height:this.getEl().getHeight()
				});
			}else{
				var s = this.getStore();
				/*
				 * this temp function is for calculate the child node index of a row in regionEl
				 */
				var fn = function(rowIndex){
					var k = 0;
					for(var i = this.rowStart; i < rowIndex; i++){
						/*
						 * here if i in [minr, maxr], then need check deleted array, cause the rd is already removed in store
						 */
						if(minr <= i && i <= maxr){
							if(!s.isVisibleRow(sheetId, i, deleted)){
								k++;
							}
						}else if(!s.isVisibleRow(sheetId, i)){
							k++;
						}
					}
					/*
					 * calculate the start child node to delete
					 */
					return rowIndex-this.rowStart-k;					
				}
				/*
				 * calculate the child node index of minrow and maxrow, and then remove the childNode in [startIndex, endIndex]
				 */
				var startIndex = fn.call(this, minrow), endIndex = fn.call(this, maxrow+1), el = this.regionEl.dom;
				/*
				 * remove row element
				 */
				for(var i = startIndex; i < endIndex; i++){
					Ext.removeNode(el.childNodes[startIndex]);
				}				
				/*
				 * set the rowEnd and then render more at bottom if need
				 */
				this.rowEnd -= (maxrow-minrow+1);
				var offset = this.regionEl.getHeight()-this.getEl().getHeight();
				if(0 > offset){
					this.adjustRows(-offset);
				}								
			}
			/*
			 * update the scroller of this region
			 */
			if(flag){
				this.sysn();
			}
		}
	},
	
	/*
	 * when cell(s) are removed, we need remove the related rest cell and render more rows at bottom or columns at right,
	 * if need
	 */
	onRemoveCell : function(sheetId, minrow, maxrow, mincol, maxcol, moveDir, deleted, merged, store){
		if(sheetId == this.getSheetId()){
			if('left' == moveDir){
				/*
				 * the rest cell move left to fill the deleted range
				 */
				this.removeAfterColumn(mincol, maxcol, deleted); 
			}else{
				this.removeAfterRow(minrow, maxrow, deleted);
			}
		}
	},
	
	onCellRemoved : function(sheetId, minrow, maxrow, mincol, maxcol, moveDir, deleted, merged, store){
		if(sheetId == this.getSheetId()){
			this.fireEvent('cellremoved', minrow, maxrow, mincol, maxcol, moveDir, deleted, merged, store, this);
		}
	},
	
	/*
	 * when a row is removed, we need remove the related row element and render more rows at bottom,
	 * if need
	 */
	onRemoveRow : function(sheetId, minrow, maxrow, deleted, merged, store){		
		if(sheetId == this.getSheetId() && this.isVisible()){
			//this.removeRow(minrow, maxrow, deleted);
			this.removeAfterRow(minrow, maxrow, deleted);
		}		
	},
	
	onRowRemoved : function(sheetId, minrow, maxrow, deleted, merged, store){
		if(sheetId == this.getSheetId()){
			this.fireEvent('rowremoved', minrow, maxrow, deleted, merged, store, this);
		}
	},
	
	/*
	 * remove column in [mincol, maxcol] of the UI, this function will re-render all columns behind maxcol
	 * @param {int} mincol: the min column index to remove
	 * @param {int} maxcol: the max column index to remove
	 * @param {array} deleted: the records deleted from store, cause usually this function is called after the records are deleted from store,
	 * but when remove rows from UI, we also need the information of these deleted records, so caller have to pass them in
	 */
	removeAfterColumn : function(mincol, maxcol, deleted){
		
		var sheetId = this.getSheetId();
		/*
		 * if mincol is large than this.colEnd, then no need do anything
		 */
		if(this.isVisible() && mincol <= maxcol && mincol <= this.colEnd){
			/*
			 * here we re-render the column before the mincol, because the border refresh issue
			 */
			if(this.colStart < mincol){
				mincol--;
			}
			/*
			 * if mincol < this.colStart, then need sysn the scroller
			 * here we just keep the result, cause we need change mincol next
			 */
			var flag = mincol < this.colStart, minc = mincol, maxc = maxcol;
			
			/*
			 * below is for calculate the mincol and maxcol to really remove the element
			 */
			var span = maxcol-mincol+1;
			if(mincol <= this.colStart){
				mincol = this.colStart;
				maxcol = mincol+span-1;
			}else{
				if(maxcol > this.colEnd){
					maxcol = this.colEnd;
				}
			}
			/*
			 * if the removed column range covered this region, then re-render this range base on width
			 */
			if(mincol <= this.colStart && maxcol >= this.colEnd){
				this.recalculateRange(null, {
					colStart:this.colStart,
					width:this.getEl().getWidth()
				});
			}else{				
				var s = this.getStore();
				/*
				 * this temp function is for calculate the child node index of a row in regionEl
				 */
				var fn = function(colIndex){
					var k = 0;
					for(var i = this.colStart; i < colIndex; i++){
						/*
						 * here if i in [minc, maxc], then need check deleted object, cause the rd is already removed in store
						 */
						if(minc <= i && i <= maxc){
							if(!s.isVisibleColumn(sheetId, i, deleted)){
								k++;
							}
						}else if(!s.isVisibleColumn(sheetId, i)){
							k++;
						}
					}
					/*
					 * calculate the start child node to delete
					 */
					return colIndex-this.colStart-k;					
				}
				/*
				 * calculate the child node index of mincol, and then remove childNode start at startIndex
				 */
				var startIndex = fn.call(this, mincol);
				/*
				 * get the width of removed columns
				 */
				var cw = 0, firstrow = this.regionEl.dom.firstChild;
				var len = firstrow.childNodes.length;
				for(var j = startIndex; j < len; j++){
					var cellEl = Ext.get(firstrow.childNodes[j]);
					cw += cellEl.getWidth();
				}
				/*
				 * remove column element
				 */				 
				for(var i = this.rowStart; i <= this.rowEnd; i++){
					if(s.isVisibleRow(sheetId, i)){
						var rowel = this.getRowEl(i).dom;
						for(var j = startIndex; j < len; j++){
							Ext.removeNode(rowel.childNodes[startIndex]);
						}
					}
				}
				/*
				 * set the colEnd and then render more at bottom if need
				 */
				this.colEnd = mincol-1;
				var nw = this.currentWidth-cw;
				var less = nw-this.getEl().getWidth();
				if(0 <= less){
					/*
					 * if less >= 0 then no need render at right, because there is no empty part
					 */
					this.updateRegionElWidth(nw);
				}else{
					this.currentWidth = nw; 	
					/*
					 * need render more col at the right empty part
					 */
					this.adjustCols(-less);
				}								
			}
			/*
			 * update the scroller of this region
			 */
			if(flag){
				this.sysn();
			}	
		}
	},
	
	/*
	 * remove column in [mincol, maxcol] of the UI, this function will move left the columns behind maxcol to fill the empty range but not re-render them
	 * @param {int} mincol: the min column index to remove
	 * @param {int} maxcol: the max column index to remove
	 * @param {array} deleted: the records deleted from store, cause usually this function is called after the records are deleted from store,
	 * but when remove rows from UI, we also need the information of these deleted records, so caller have to pass them in
	 */
	removeColumn : function(mincol, maxcol, deleted, merged){	
		var sheetId = this.getSheetId();
		/*
		 * if mincol is large than this.colEnd, then no need do anything
		 */
		if(this.isVisible() && mincol <= maxcol && mincol <= this.colEnd){
			/*
			 * if mincol < this.colStart, then need sysn the scroller
			 * here we just keep the result, cause we need change mincol next
			 */
			var flag = mincol < this.colStart, minc = mincol, maxc = maxcol;
			
			/*
			 * below is for calculate the mincol and maxcol to really remove the element
			 */
			var span = maxcol-mincol+1;
			if(mincol <= this.colStart){
				mincol = this.colStart;
				maxcol = mincol+span-1;
			}else{
				if(maxcol > this.colEnd){
					maxcol = this.colEnd;
				}
			}
			/*
			 * if the removed column range covered this region, then re-render this range base on width
			 */
			if(mincol <= this.colStart && maxcol >= this.colEnd){
				this.recalculateRange(null, {
					colStart:this.colStart,
					width:this.getEl().getWidth()
				});
			}else{				
				var s = this.getStore();
				/*
				 * this temp function is for calculate the child node index of a row in regionEl
				 */
				var fn = function(colIndex){
					var k = 0;
					for(var i = this.colStart; i < colIndex; i++){
						/*
						 * here if i in [minc, maxc], then need check deleted object, cause the rd is already removed in store
						 */
						if(minc <= i && i <= maxc){
							if(!s.isVisibleColumn(sheetId, i, deleted)){
								k++;
							}
						}else if(!s.isVisibleColumn(sheetId, i)){
							k++;
						}
					}
					/*
					 * calculate the start child node to delete
					 */
					return colIndex-this.colStart-k;					
				}
				/*
				 * calculate the child node index of mincol and maxcol, and then remove childNode start in [startIndex, endIndex]
				 */
				var startIndex = fn.call(this, mincol), endIndex = fn.call(this, maxcol+1);
				/*
				 * get the width of removed columns
				 */
				var cw = 0, firstrow = this.regionEl.dom.firstChild;
				var len = firstrow.childNodes.length;
				for(var j = startIndex; j < endIndex; j++){
					var cellEl = Ext.get(firstrow.childNodes[j]);
					cw += cellEl.getWidth();
				}
				/*
				 * remove column element
				 */	
				for(var i = this.rowStart; i <= this.rowEnd; i++){
					if(s.isVisibleRow(sheetId, i)){
						var rowel = this.getRowEl(i).dom;
						for(var j = startIndex; j < endIndex; j++){
							Ext.removeNode(rowel.childNodes[startIndex]);
						}
					}
				} 			 				
				/*
				 * set the colEnd and then render more at right if need
				 */
				this.colEnd -= (maxcol-mincol+1);
				var nw = this.currentWidth-cw;
				var less = nw-this.getEl().getWidth();
				if(0 <= less){
					/*
					 * if less >= 0 then no need render at right, because there is no empty part
					 */
					this.updateRegionElWidth(nw);
				}else{
					this.currentWidth = nw; 	
					/*
					 * need render more col at the right empty part
					 */
					this.adjustCols(-less);
				}								
			}
			/*
			 * update the scroller of this region
			 */
			if(flag){
				this.sysn();
			}	
		}
	},
	
	/*
	 * when a column is removed, we need remove the related col element and render more columns at right,
	 * if need 
	 */
	onRemoveColumn : function(sheetId, mincol, maxcol, deleted, merged, store){		
		if(sheetId == this.getSheetId() && this.isVisible()){
			//this.removeColumn(mincol, maxcol, deleted);
			/*
			 * need re-render all columns behind maxcol
			 */
			this.removeAfterColumn(mincol, maxcol, deleted);
		}
	},
	
	onColumnRemoved : function(sheetId, mincol, maxcol, deleted, merged, store){
		if(sheetId == this.getSheetId()){
			this.fireEvent('columnremoved', mincol, maxcol, deleted, merged, store, this);
		}
	},			
	
	onInsertCell : function(sheetId, row, col, rowSpan, colSpan, moveDir, merged, store){
		if(sheetId == this.getSheetId()){
			if('right' == moveDir){
				this.reinsertColumn(col, colSpan);
			}else{
				this.reinsertRow(row, rowSpan);
			}
		}
	},
	
	onCellInserted : function(sheetId, row, col, rowSpan, colSpan, moveDir, merged, store){
		if(sheetId == this.getSheetId()){
			this.fireEvent('cellinserted', row, col, rowSpan, colSpan, moveDir, merged, store, this);
		}
	},	
	
	/*
	 * insert rows in a spec row index, for rows below the insert point will be all re-render
	 * @param {int} row: the row index where to insert rows
	 * @param {int} span: how many rows are inserted
	 */
	reinsertRow : function(row, span){
		if(1 < row){
			row--;
		}
		var sheetId = this.getSheetId();
		/*
		 * if row is after this.rowEnd, then no need do anything
		 */
		if(this.isVisible() && 0 < row && 0 < span && row <= this.rowEnd){
			/*
			 * if row < this.rowStart, then need sysn the scroller
			 * here we just keep the result, cause we need change minrow next
			 */
			var flag = row < this.rowStart;
						
			if(row > this.rowStart){
				var s = this.getStore();
				/*
				 * this temp function is for calculate the child node index of a row in regionEl
				 */
				var fn = function(rowIndex){
					var k = 0;
					for(var i = this.rowStart; i < rowIndex; i++){
						if(!s.isVisibleRow(sheetId, i)){
							k++;
						}
					}
					/*
					 * calculate the start child node to delete
					 */
					return rowIndex-this.rowStart-k;					
				}
				var startIndex = fn.call(this, row), el = this.regionEl.dom;
				for(var i = startIndex, len = el.childNodes.length; i < len; i++){
					Ext.removeNode(el.childNodes[startIndex]);
				}
				this.rowEnd = row-1;
				var offset = this.regionEl.getHeight()-this.getEl().getHeight();
				if(0 > offset){
					this.adjustRows(-offset);
				}
			}else{
				this.recalculateRange({
					rowStart:this.rowStart,
					height:this.getEl().getHeight()
				});
			}	
			/*
			 * update the scroller of this region
			 */
			if(flag){
				this.sysn();
			}
		}
	},
	
	/*
	 * insert rows in a spec row index, will move down "span" steps the rows below the insert point but not re-render them
	 * @param {int} row: the row index where to insert rows
	 * @param {int} span: how many rows are inserted
	 */
	insertRow : function(row, span){
		var sheetId = this.getSheetId();
		/*
		 * if row is after this.rowEnd, then no need do anything
		 */
		if(this.isVisible() && 0 < row && 0 < span && row <= this.rowEnd){
			/*
			 * if row < this.rowStart, then need sysn the scroller
			 * here we just keep the result, cause we need change minrow next
			 */
			var flag = row < this.rowStart, minrow = row, maxrow = row+span-1;
				
			if(minrow <= this.rowStart && this.rowEnd <= maxrow){
				this.recalculateRange({
					rowStart:this.rowStart,
					height:this.getEl().getHeight()
				});
			}else{
				var s = this.getStore();
				if(minrow < this.rowStart){
					minrow = this.rowStart;
					maxrow = minrow+span-1;
				}
				var height = s.getRangeHeight(sheetId, this.rowStart, minrow-1);
				/*
				 * height is the rest height of this region from the insert point
				 */
				height = this.getEl().getHeight()-height;
				var h = 0, rows = [], i, columnVisible = [];
				for(var j = this.colStart; j <= this.colEnd; j++){
					columnVisible.push(s.isVisibleColumn(sheetId, j));
				}
				/*
				 * generate data
				 */
				for(i = minrow; i <= maxrow && h <= height; i++){
					var rh = s.getRowHeight(sheetId, i, true);
					/*
					 * if not 0 means this row is visible
					 */
					if(0 != rh){
						h += rh;
						var cells = [];
						for(var j = this.colStart; j <= this.colEnd; j++){
							if(columnVisible[j-this.colStart]){
								cells.push(this.getData(i, j));
							}
						}
						var o = this.getData(i, 0);
						o.cells = cells;
						rows.push(o);	
					}				
				}
				/*
				 * generate html
				 */
				var html = this.regionTpl.apply(rows);			
				/*
				 * this temp function is for calculate the child node index of a row in regionEl
				 */
				var fn = function(rowIndex){
					var k = 0;
					for(var i = this.rowStart; i < rowIndex; i++){
						if(!s.isVisibleRow(sheetId, i)){
							k++;
						}
					}
					/*
					 * calculate the start child node to delete
					 */
					return rowIndex-this.rowStart-k;					
				}	
				var startIndex = fn.call(this, minrow), el = this.regionEl.dom;
				if(i <= maxrow){
					/*
					 * this means the height of this region is not enough for all inserted rows,
					 * so we need remove all rest rows.					 
					 */
					/*
					 * update rowEnd
					 */ 
					var rowEnd = i-1;					
					for(i = startIndex, len = el.childNodes.length; i < len; i++){
						Ext.removeNode(el.childNodes[startIndex]);
					}
					Ext.core.DomHelper.append(el, html);
					this.rowEnd = rowEnd;
				}else{				
					el = el.childNodes[startIndex];
					Ext.core.DomHelper.insertBefore(el, html);
					/*
					 * update rowEnd
					 */
					this.rowEnd += span;
				}				
			}			
			/*
			 * update the scroller of this region
			 */
			if(flag){
				this.sysn();
			}
		}
	},
	
	/*
	 * when rows inserted in store, we need update the region UI
	 * @param {int} sheetId: the sheet id
	 * @param {int} row: the row index where to insert rows
	 * @param {int} span: how many rows are inserted
	 * @param {obj} store: the EnterpriseSheet.Store instance
	 */
	onInsertRow : function(sheetId, row, span, merged, store){
		if(sheetId == this.getSheetId() && this.isVisible()){
			//this.insertRow(row, span);
			this.reinsertRow(row, span);			
		}
	},
	
	onRowInserted : function(sheetId, row, span, merged, store){
		if(sheetId == this.getSheetId()){
			this.fireEvent('rowinserted', sheetId, row, span, merged, store, this);
		}
	},
	
	/*
	 * insert columns in a spec column index, for the columns behind the insert point will be all re-render
	 * @param {int} col: the column index where to insert columns
	 * @param {int} span: how many rows are inserted
	 */
	reinsertColumn : function(col, span){
		if(1 < col){
			col--;
		}
		var sheetId = this.getSheetId();
		/*
		 * if col is after this.colEnd, then no need do anything
		 */
		if(this.isVisible() && 0 < col && 0 < span && col <= this.colEnd){
			/*
			 * if col < this.colStart, then need sysn the scroller
			 * here we just keep the result, cause we need change minrow next
			 */
			var flag = col < this.colStart;
						
			if(col > this.colStart){
				var s = this.getStore();
				/*
				 * this temp function is for calculate the child node index of a row in regionEl
				 */
				var fn = function(colIndex){
					var k = 0;
					for(var i = this.colStart; i < colIndex; i++){
						if(!s.isVisibleColumn(sheetId, i)){
							k++;
						}
					}
					/*
					 * calculate the start child node to delete
					 */
					return colIndex-this.colStart-k;					
				}
				var startIndex = fn.call(this, col), el = this.regionEl.dom, firstrow = el.firstChild;
				/*
				 * get the removed columns' width
				 */ 
				var cw = 0, len = firstrow.childNodes.length;
				for(var j = startIndex; j < len; j++){
					cw += Ext.get(firstrow.childNodes[j]).getWidth();
				}				
				for(var i = this.rowStart; i <= this.rowEnd; i++){
					/*
					 * check whether the row is visible
					 */
					if(s.isVisibleRow(sheetId, i)){
						var rowEl = this.getRowEl(i);
						for(var j = startIndex; j <len; j++){
							Ext.removeNode(rowEl.dom.childNodes[startIndex]);
						}
					}
				}
				this.colEnd = col-1;
				var nw = this.currentWidth-cw;
				var less = nw-this.getEl().getWidth();
				if(0 <= less){
					/*
					 * if less >= 0 then no need render at right, because there is no empty part
					 */
					this.updateRegionElWidth(nw);
				}else{
					this.currentWidth = nw; 	
					/*
					 * need render more col at the right empty part
					 */
					this.adjustCols(-less);
				}
			}else{
				this.recalculateRange(null, {
					colStart:this.colStart,
					width:this.getEl().getWidth()
				});
			}	
			/*
			 * update the scroller of this region
			 */
			if(flag){
				this.sysn();
			}
		}
	},
	
	/*
	 * insert columns in a spec column index, will move right "span" steps the columns behind the insert point but not re-render them
	 * @param {int} col: the column index where to insert columns
	 * @param {int} span: how many rows are inserted
	 */
	insertColumn : function(col, span){
		var sheetId = this.getSheetId();
		/*
		 * if col is after this.colEnd, then no need do anything
		 */
		if(this.isVisible() && 0 < col && 0 < span && col <= this.colEnd){
			/*
			 * if row < this.rowStart, then need sysn the scroller
			 * here we just keep the result, cause we need change minrow next
			 */
			var flag = col < this.colStart, mincol = col, maxcol = col+span-1;
				
			if(mincol <= this.colStart && this.colEnd <= maxcol){
				this.recalculateRange(null, {
					colStart:this.colStart,
					width:this.getEl().getWidth()
				});
			}else{
				var s = this.getStore();
				if(mincol < this.colStart){
					mincol = this.colStart;
					maxcol = mincol+span-1;
				}
				var width = s.getRangeWidth(sheetId, this.colStart, mincol-1);
				/*
				 * width is the rest width of this region from the insert point
				 */
				width = this.getEl().getWidth()-width;
				var w = 0, rows = [], j;
				for(j = mincol; j <= maxcol && w <= width; j++){
					w += s.getColWidth(sheetId, j, true);
				}
				var notEnough = j <= maxcol;
				maxcol = j-1;				
				/*
				 * generate data
				 */
				var columnVisible = [], rowVisible = [];
				for(var i = this.rowStart; i <= this.rowEnd; i++){
					rowVisible.push(s.isVisibleRow(sheetId, i));
				}
				for(j = mincol; j <= maxcol; j++){
					columnVisible.push(s.isVisibleColumn(sheetId, j));
				}
				for(var i = this.rowStart; i <= this.rowEnd; i++){
					/*
					 * only generate data for visible row/column
					 */
					if(rowVisible[i-this.rowStart]){
						var cells = [];
						for(j = mincol; j <= maxcol; j++){
							if(columnVisible[j-mincol]){
								cells.push(this.getData(i, j));
							}
						}					
						rows.push(cells);
					}
				}		
				/*
				 * this temp function is for calculate the child node index of a row in regionEl
				 */
				var fn = function(colIndex){
					var k = 0;
					for(var i = this.colStart; i < colIndex; i++){
						if(!s.isVisibleColumn(sheetId, i)){
							k++;
						}
					}
					/*
					 * calculate the start child node to delete
					 */
					return colIndex-this.colStart-k;					
				}		
				if(notEnough){
					/*
					 * this means the width of this region is not enough for all inserted columns,
					 * so we need remove all rest columns.					 
					 */
					var startIndex = fn.call(this, mincol), el = this.regionEl.dom; 
					for(var k = 0, i = this.rowStart; i <= this.rowEnd; i++){
						var index = i-this.rowStart;
						if(rowVisible[index]){
							var rowel = this.getRowEl(i).dom;
							for(j = startIndex, len = rowel.childNodes.length; j < len; j++){
								Ext.removeNode(rowel.childNodes[startIndex]);
							}	
							/*
							 * insert columns for every visible row
							 */
							var html = this.rowTpl.apply(rows[k++]);
							Ext.core.DomHelper.append(rowel, html);
						}
					}					
					this.colEnd = maxcol;					
				}else{				
					/*
					 * get the right position to insert
					 */
					var startIndex = fn.call(this, mincol);
					for(var k = 0, i = this.rowStart; i <= this.rowEnd; i++){	
						var index = i-this.rowStart;
						if(rowVisible[index]){				
							var rowEl = this.getRowEl(i);			
							var el = rowEl.dom.childNodes[startIndex];									
							var html = this.rowTpl.apply(rows[k++]);
							Ext.core.DomHelper.insertBefore(el, html);							
						}
					}
					/*
					 * update colEnd
					 */
					this.colEnd += span;
				}
				width = s.getRangeWidth(sheetId, this.colStart, this.colEnd);
				this.updateRegionElWidth(width);
			}				
			/*
			 * update the scroller of this region
			 */
			if(flag){
				this.sysn();
			}
		}
	},
	
	/*
	 * when columns inserted in store, we need update the region UI
	 * @param {int} sheetId: the sheet id
	 * @param {int} col: the column index where to insert columns
	 * @param {int} span: how many columns are inserted
	 * @param {obj} store: the EnterpriseSheet.Store instance
	 */
	onInsertColumn : function(sheetId, col, span, merged, store){		
		if(sheetId == this.getSheetId() && this.isVisible()){
			//this.insertColumn(col, span);
			this.reinsertColumn(col, span);
		}
	},
	
	onColumnInserted : function(sheetId, col, span, merged, store){
		if(sheetId == this.getSheetId()){
			this.fireEvent('columninserted', sheetId, col, span, store, this);
		}
	},
	
	/*
	 * hide rows on the UI, just re-render the whole region
	 * @param {int} sheetId: the sheet id
	 * @param {int} minrow: the min row index start to hide
	 * @param {int} maxrow: the max row index to hide
	 */
	onHideRow : function(sheetId, minrow, maxrow, store){
		if(sheetId == this.getSheetId()){
			if(this.isVisible()){				
				if(false !== this.fireEvent('beforehiderow', minrow, maxrow, this)){					
					if(this.isRowOverlap(minrow, maxrow)){
						this.recalculateRange({
							rowStart:this.rowStart,
							height:this.getEl().getHeight()
						});
					}
					if(minrow < this.rowStart){
						this.sysn();
					}
					this.fireEvent('hiderow', minrow, maxrow, this);
				}
			}
		}
	},
	
	/*
	 * hide columns on the UI, just re-render the whole region
	 * @param {int} sheetId: the sheet id
	 * @param {int} mincol: the min column index start to hide
	 * @param {int} maxcol: the max column index to hide
	 */
	onHideColumn : function(sheetId, mincol, maxcol, store){
		if(sheetId == this.getSheetId()){
			if(this.isVisible()){
				if(false !== this.fireEvent('beforehidecolumn', mincol, maxcol, this)){
					if(this.isColumnOverlap(mincol, maxcol)){
						this.recalculateRange(null, {
							colStart:this.colStart,
							width:this.getEl().getWidth()
						});
					}
					if(mincol < this.colStart){
						this.sysn();
					}
					this.fireEvent('hidecolumn', mincol, maxcol, this);
				}
			}
		}
	},
	
	/*
	 * show rows on the UI, just re-render the whole region
	 * @param {int} sheetId: the sheet id
	 * @param {int} minrow: the min row index start to hide
	 * @param {int} maxrow: the max row index to hide
	 */
	onShowRow : function(sheetId, minrow, maxrow, store){
		if(sheetId == this.getSheetId()){
			if(this.isVisible()){
				if(false !== this.fireEvent('beforeshowrow', minrow, maxrow, this)){
					if(this.isRowOverlap(minrow, maxrow)){
						this.recalculateRange({
							rowStart:this.rowStart,
							height:this.getEl().getHeight()
						});
					}
					if(minrow < this.rowStart){
						this.sysn();
					}
					this.fireEvent('showrow', minrow, maxrow, this);
				}
			}
		}
	},
	
	/*
	 * show columns on the UI, just re-render the whole region
	 * @param {int} sheetId: the sheet id
	 * @param {int} mincol: the min column index start to hide
	 * @param {int} maxcol: the max column index to hide
	 */
	onShowColumn : function(sheetId, mincol, maxcol, store){
		if(sheetId == this.getSheetId()){
			if(this.isVisible()){
				if(false !== this.fireEvent('beforeshowcolumn', mincol, maxcol, this)){
					if(this.isColumnOverlap(mincol, maxcol)){
						this.recalculateRange(null, {
							colStart:this.colStart,
							width:this.getEl().getWidth()
						});
					}
					if(mincol < this.colStart){
						this.sysn();
					}
					this.fireEvent('showcolumn', mincol, maxcol, this);
				}
			}
		}
	},
	
	/*
	 * go to the scroller go to the left-top position
	 */
	go2LeftTop : function(){
		if(this.isVisible()){
			var scroller = this.getScroller();
			if(scroller){
				var offset = this.rowBound.low-this.rowStart;
				scroller.scrollRow(offset);
				offset = this.colBound.low-this.colStart;
				scroller.scrollCol(offset);
			}
		}
	},
	
	go2Left : function(){
		if(this.isVisible()){
			var scroller = this.getScroller();
			if(scroller){
				var offset = this.colBound.low-this.colStart;
				scroller.scrollCol(offset);
			}
		}
	},
	
	go2Top : function(){
		if(this.isVisible()){
			var scroller = this.getScroller();
			if(scroller){
				var offset = this.rowBound.low-this.rowStart;
				scroller.scrollRow(offset);				
			}
		}
	},
	
	/*
	 * get the cells for determine the column width
	 * @params {int} sheetId: the sheet id
	 * @param {int} col: the column index
	 * @return {array}: return an array of the cells which are the candidate of the cell with the maximum width
	 */
	guessMaxWidthCells : function(sheetId, col){
		var store = this.getStore();
		var row, dp = store.defaultProperty, set = {};
		store.each(function(rd){				
			var json = rd.data['json'];
			/*
			 * skip merged cell
			 */
			if(sheetId == rd.data['sheet'] && col == rd.data['col'] && 0 != rd.data.row && !store.isMergedCell(json, sheetId, rd.data.row, col)){								
				var obj = this.getData(rd.data['row'], col);
				delete(obj.width);
				/*
				 * if it's header or lefter, then we need transfer the format
				 */
				if(this instanceof EnterpriseSheet.sheet.regions.Header || this instanceof EnterpriseSheet.sheet.regions.Lefter){
					obj = SFORMAT.transferFormat(obj, obj.fm, {sheet:sheetId, row:rd.data.row, col:col});
				}
				var data = SCOM.nullOrUndefined(obj.value) ? obj.data : obj.value;				
				if(!SCOM.nullOrUndefined(data) && '' !== data){
					/*
					 * for height guess, we need treat different for font-family, white-space, font-size, font-weight
					 */
					var ff = obj['ff'];					
					var ws = obj['ws'];
					var fz = obj['fz'];
					var fw = obj['fw'];
					
					var id = [ff, ws, fz, fw].join('$');					
					/*
					 * set is for save the string of different id, for all different string under the same id, we use <br> to arrange them
					 * in different rows
					 */
					set[id] = set[id] || {};				
					if(set[id].cell){						
						set[id].cell.data += '<br>'+data;
					}else{
						obj.data = data;
						set[id].cell = obj;
					}
				}
			}
		}, this);
		var arr = [];
		for(var p in set){			
			arr.push(set[p].cell);		
		}
		
		if(0 < arr.length){
			return arr;
		}
	},
	
	/*
	 * guess the max width of the cells in a column
	 * @param {int} sheetId:the sheet id
	 * @param {int} col:the column index
	 * @return {int}: the max width of this column
	 */
	guessMaxColumnWidth : function(sheetId, col){
		var len = 0, text, row;

		var store = this.getStore();
		var rowTpl = this.rowTpl;
		var arr = this.guessMaxWidthCells(sheetId, col);
		if(arr){			
			var w = maxw = 0;
			var measureEl = Ext.core.DomHelper.append(document.body, '<div class="ss-guess-measure"></div>', true);
			var htmls = []
			for(var i = 0, len = arr.length; i < len; i++){
				htmls.push(this.prepare2Measure(arr[i]));
			}
			var el = rowTpl.overwrite(measureEl, htmls, true);
			w = el.getWidth();
			if(maxw < w){
				maxw = w;
			}
			measureEl.remove();
			return maxw;
		}
	},
	
	/*
	 * guess maximum height cells from a row
	 * @params {int} sheetId: the sheet id
	 * @param {int} row: the row index
	 * @return {array}: return an array of the cells which are the candidate of the cell with the maximum height
	 */	
	guessMaxHeightCells : function(sheetId, row){
		var store = this.getStore();
		var col, dp = this.defaultProperty, set = {};

		store.each(function(rd){				
			var json = rd.data['json'];	
			/*
			 * skip merged cell
			 */
			if(sheetId == rd.data['sheet'] && row == rd.data['row'] && 0 != rd.data.col && !store.isMergedCell(json, sheetId, row, rd.data.col)){											
				var obj = this.getData(row, rd.data['col']);
				obj.data = Ext.htmlEncode(obj.data);
                if(Ext.isString(obj.data)){
                    obj.data = obj.data.replace(/\n/gi, '<br/>');
                }
				var data = obj.data;
				
				if(!SCOM.nullOrUndefined(data) && '' !== data){
					/*
					 * for height guess, we need treat different for font-family, white-space, font-size, font-weight
					 */
					var ff = obj['ff'];					
					var ws = obj['ws'];
					var fz = obj['fz'];
					var fw = obj['fw'];
					var width = obj['width'];
					
					var id = [ff, ws, fz, fw, width].join('$');		
					var slong = data.toString().length;
					/*
					 * set is for save the longest string of different id
					 */
					if(!set[id]){
						set[id] = {
							len: slong,
							cell: obj
						};
					}					
					
					if(set[id].len < slong){
						set[id].len = slong;						
						set[id].cell = obj;
					}
				}
			}
		}, this);
		
		var arr = [];
		for(var p in set){		
			if(set[p].cell){
				arr.push(set[p].cell);
			}
		}
		if(0 < arr.length){
			return arr;
		}
	},
	
	
	/*
	 * guess the max height of the cells in a row
	 * @param {int} sheetId:the sheet id
	 * @param {int} row:the row index
	 * @return {int}: the max height of this row
	 */
	guessMaxRowHeight : function(sheetId, row){
		var len = 0, text, col;
		
		var store = this.getStore();
		var guessHeightTpl = SLAYOUT.guessHeightTpl;
		var arr = this.guessMaxHeightCells(sheetId, row);
		if(arr){
			var h = maxh = 0;
			var measureEl = Ext.core.DomHelper.append(document.body, '<div class="ss-guess-measure"></div>', true);
			var htmls = [];
			for(var i = 0, len = arr.length; i < len; i++){
				htmls.push(this.prepare2Measure(arr[i], 'height'));
			}
			
			var el = guessHeightTpl.overwrite(measureEl, htmls, true);
			h = el.getHeight();
			if(maxh < h){
				maxh = h;
			}
			measureEl.remove();
			var dh = store.defaultProperty.height+store.cellHeightOffset;
			maxh--;
			if(maxh < dh){
				maxh = dh;
			}
			
			return maxh;
		}
	},
	
	/*
	 * get the expanded width of a cell
	 * @param {int} sheetId:the sheet id
	 * @param {int} row:the row index of a cell
	 * @param {int} col:the col index of a cell
	 * @param {object} cell:the setting of a cell
	 * @param {boolean} ignoreOld: true to not compare with the old width, return the actual cell width it should be
	 * @return {int}: the expanded width of this cell
	 */
	guessCellWidth : function(sheetId, row, col, cell, ignoreOld){	
		var store = this.getStore(), w = 0;
		if(!cell){
			cell = store.getCellData(sheetId, row, col);
			cell.data = Ext.htmlEncode(cell.dta);
		}
		
		if(cell.data && 0 < cell.data.length){
			var cTpl = this.cellTpl;
			var measureEl = Ext.core.DomHelper.append(document.body, '<div class="ss-guess-measure"></div>', true);
			cell = this.prepare2Measure(cell);
			var el = cTpl.overwrite(measureEl, cell, true);
			w = el.getWidth();
			measureEl.remove();			
		}
		if(!ignoreOld){
			var cw = cell.w || store.getColWidth(sheetId, col);
			if(w < cw){
				w = cw;
			}
		}
		return w;
	},
	
	/*
	 * get the expanded height of a cell
	 * @param {int} sheetId:the sheet id
	 * @param {int} row:the row index of a cell
	 * @param {int} col:the col index of a cell
	 * @param {object} cell:the setting of a cell
	 * @param {boolean} ignoreOld: true to not compare with the old height, return the actual cell height it should be
	 * @return {int}: the expanded height of this cell
	 */
	guessCellHeight : function(sheetId, row, col, cell, ignoreOld){	
		var store = this.getStore(), h = 0;
		if(!cell){
			cell = store.getCellData(sheetId, row, col);
			cell.data = Ext.htmlEncode(cell.dta);
		}
		
		if(cell.data && 0 < cell.data.length){
			var cTpl = this.cellTpl;
			var measureEl = Ext.core.DomHelper.append(document.body, '<div class="ss-guess-measure"></div>', true);
			cell = this.prepare2Measure(cell, 'height');				
			var el = cTpl.overwrite(measureEl, cell, true);
			h = el.getHeight();
			measureEl.remove();			
		}
		if(!ignoreOld){
			var ch = cell.h || store.getRowHeight(sheetId, row);
			if(h < ch){
				h = ch;
			}
		}
		/*
		 * autoHeight can not less than default height
		 */
		var dh = store.defaultProperty.height+store.cellHeightOffset;
		if(h < dh){
			h = dh;
		}
		return h;
	},
	
	/*
	 * this function is prepare for measure the expand width or height for a cell
	 * it need process some property for measure, like remove the width, set wrap to false and so on
	 * @param {object} cell: the cell setting object, get from getCellData usually
	 * @param {string} flag: could be {width, height}
	 */
	prepare2Measure : function(cell, flag){
		if('height' != flag){
			flag = 'width';
		}
		if('width' == flag){
			cell.width = 'auto';
			/*
			 * this is for merged cell, if it's a merged cell, then h should not be null, h is the height of the merged cell, we use it
			 * instead height here
			 */
			cell.height = cell.h || cell.height || cell.autoHeight;
			cell.height += 'px';
		}else{
			cell.height = 'auto';
			/*
			 * this is for merged cell, if it's a merged cell, then w should not be null, w is the width of the merged cell, we use it
			 * instead width here
			 */
			cell.width = cell.w || cell.width;
			cell.width += 'px';
		}
		cell.incell = false;
		cell.wrap = false;
		cell.va = 'top';			
		
		return cell;
	}, 	
	
	/*
	 * scroll the cell to the view, if the cell is already in the view with some part out of bound, then it will also try to scroll to show the
	 * whole cell
	 * @param {int} row: the row index of the cell
	 * @param {int} col: the column index of the cell
	 * @param {Ext.element}: the cell element, if the cell is hidden or the row/col index is invalid, then return null
	 */
	scrollCell2View : function(row, col){
		var store = this.getStore();

		var sheetId = this.getSheetId();
		var cellEl = null, el = this.getEl();
		var scroller = this.getScroller();
		if(scroller){
			if(this.isInRange(row, col)){
				/*
				 * if the cell is already in the range but not show compeletely, after scrolling, it will show compeletely
				 */
				cellEl = this.getCellEl(row, col);
				if(cellEl){
					/*
					 * if the right part of the cell is out of the view, then move right to show it
					 */
					var xoff = cellEl.getRight()-el.getRight()+scroller.getScrollerLength('col'); 
					if(0 < xoff && this.colStart != col){
						var w = 0, i, fc = false;
						for(i = this.colStart; i < col; i++){
							if(store.isVisibleColumn(sheetId, i)){
                                if(false === fc){
                                    fc = i;
                                }
								w += store.getColWidth(sheetId, i);
								if(w >= xoff){
									break;
								}
							}
						}
                        fc = fc || this.colStart;
						var offset = i-fc+1;
						scroller.scrollCol(offset);
					}
					/*
					 * if the bottom part of the cell is out of the view, then move down to show it
					 */
					var yoff = cellEl.getBottom()-el.getBottom()+scroller.getScrollerLength('row'); 
					if(0 < yoff && this.rowStart != row){
						var h = 0, i, fr = false;
						for(i = this.rowStart; i < row; i++){
							if(store.isVisibleRow(sheetId, i)){
                                if(false === fr){
                                    fr = i;
                                }
								h += store.getRowHeight(sheetId, i);
								if(h >= yoff){
									break;
								}
							}
						}
                        fr = fr || this.rowStart;
						var offset = i-fr+1;
						scroller.scrollRow(offset);
					}
				}
			}else{
				/*
				 * if the cell is not in the show range, we just calculate the row/col offset to show the cell,
				 * not care whether the cell will show completely after scrolling
				 */
				var xoff, yoff;
				if(row < this.rowStart){
					yoff = row-this.rowStart;
					scroller.scrollRow(yoff);
				}else if(row > this.rowEnd){
					yoff = row-this.rowStart;
					scroller.scrollRow(yoff);
				}
				if(col < this.colStart){
					xoff = col-this.colStart;
					scroller.scrollCol(xoff);
				}else if(col > this.colEnd){
					xoff = col-this.colStart;
					scroller.scrollCol(xoff);
				}
			}
		}
		return cellEl;
	},	
	
	/*
	 * lock the ifctEl, don't allow it scroll
	 */
	lockIfctEl : function(){			
		if(this.ifctEl){
			this.ifScrollLeft = this.ifctEl.dom.scrollLeft;
			this.ifScrollTop = this.ifctEl.dom.scrollTop;
			if(!this.ifLocked){
				this.ifLocked = true;
				this.ifctEl.on('scroll', this.blockIfScroll, this);
			}		
		}
	},
	
	/*
	 * _private
	 */
	blockIfScroll : function(e){
		e.stopEvent();
		this.ifctEl.dom.scrollLeft = this.ifScrollLeft;
		this.ifctEl.dom.scrollTop = this.ifScrollTop; 
	},
	
	unlockIfctEl : function(){			
		if(this.ifctEl){
			delete(this.ifScrollLeft);
			delete(this.ifScrollTop);
			delete(this.ifLocked);
			this.ifctEl.un('scroll', this.blockIfScroll, this);			
		}
	},
	
	/*
	 * change the trackMouseOver flag
	 */
	switchTrackMouseOver : function(flag){
		/*
		 * save the last value for resume
		 */
		if(false == SCOM.typeOf(this.lstTrackMouseOver)){
			this.lstTrackMouseOver = this.trackMouseOver;
		}
		this.trackMouseOver = flag;
	},
	
	/*
	 * resume the trackMouseOver
	 */
	resumeTrackMouseOver : function(){
		this.trackMouseOver = this.lstTrackMouseOver;
		delete(this.lstTrackMouseOver);
	},		
	
	/*
	 * enable/disable selection model
	 */
	enableSelect : function(){		
		var sm = this.getSelectionModel();
		sm.enableSelect();
	},
	
	disableSelect : function(){		
		var sm = this.getSelectionModel();
		sm.disableSelect();
	},
	
	/*
	 * get the reference model
	 */
	getReferenceModel : function(){
		return this.rm;
	},
	
	/*
	 * enable/disable reference model
	 * @param {boolean} clear: true to clear the selection before enable/disable it
	 * @param {boolean} single: true to only select a single cell one time
	 * @param {boolean} simple: true to enable simple select mode
	 */
	enableRefer : function(clear, single, simple){
		var rm = this.getReferenceModel(); 
		rm.enableSelect.apply(rm, arguments);
	},
	
	disableRefer : function(clear, single, simple){
		var rm = this.getReferenceModel(); 
		rm.disableSelect.apply(rm, arguments);		
	},
	
	/*
	 * get rowStart/rowEnd and colStart/colEnd info and selecton info
	 */
	getRangeSpan : function(){		
		if(this.isVisible()){
			/*
			 * if visible, then we need save some info
			 */			
			return {					
				visible:true,
				/*
				 * range info
				 */
				range:{
					rowStart:this.rowStart,
					rowEnd:this.rowEnd,
					colStart:this.colStart,
					colEnd:this.colEnd
				},				
				/*
				 * bound info
				 */
				rowBound:Ext.apply({}, this.rowBound),
				colBound:Ext.apply({}, this.colBound)
			};
		}else{
			/*
			 * if not visible just store visible false
			 */
			return {
				visible:false
			};
		}
	},
	
	/*
	 * the default range span info
	 */
	getDefaultRangeSpan : function(){		
		var span = {
			visible:true
		};
		/*
		 * the inital span
		 */
		span.range = this.initSpan(true);
		/*
		 * the initial bound
		 */
		Ext.apply(span, this.initBound(true));
		return span;
	},
	
	/*
	 * set the range span info, include the selection and focus
	 */
	setRangeSpan : function(span){		
		if(span){		
			var oldRowSpan = this.rowEnd-this.rowStart+1;
			var oldColSpan = this.colEnd-this.colStart+1;
			/*
			 * update range 
			 */
			Ext.apply(this, span.range);
			if(SCOM.nullOrUndefined(this.rowEnd)){
				this.rowEnd = this.rowStart+oldRowSpan-1;
			}
			if(SCOM.nullOrUndefined(this.colEnd)){
				this.colEnd = this.colStart+oldColSpan-1;
			}
			/*
			 * set visible
			 */
			if(true === span.visible){
				
				/*
				 * if visible, then show it and sysn the other info
				 */				
				this.show();				
				/*
				 * update the bound info
				 */
				this.rowBound = Ext.apply({}, span.rowBound);
				this.colBound = Ext.apply({}, span.colBound);				
			}else if(false === span.visible){
				/*
				 * just hide it
				 */				
				this.hide();				
			}					
		}
	},
	
	show : function(){
		this._skipProcessResize = true;
		this.callParent(arguments);
		this._skipProcessResize = false;
	},
	
	hide  : function(){
		this._skipProcessResize = true;
		this.callParent(arguments);
		this._skipProcessResize = false;
	},
	
	/*
	 * getter and setter for sheetId
	 */
	getSheetId : function(){
		return this.sheetId;
	},
	
	setSheetId : function(sheetId){
		this.sheetId = sheetId;
	},
	
	/*
	 * render a component into ifbody
	 */
	render2RegionBody : function(comp){
		comp.bindRegion = this;
		comp.render(this.ifbodyEl);		
	},	
	
	isAutofillPress : function(){
		return this.autofillpressed;
	},
	
	destroy: function(){
		if(Ext.isFunction(this.purgeListeners)){
			this.purgeListeners();
		}
    },
           
    /**
     * get center position of the current ifbody
     */
    getIfPosOfCenter : function(){
        var scrollLeft = this.ifctEl.dom.scrollLeft, scrollTop = this.ifctEl.dom.scrollTop;
        var width = this.ifctEl.getWidth(), height = this.ifctEl.getHeight();
        
        return {
            x: scrollLeft+Math.floor(width/2),
            y: scrollTop+Math.floor(height/2)
        }
    },
           
    setReadOnly : function(readOnly){
        this.readOnly = readOnly;
    },
           
    isReadOnly : function(){
        return this.readOnly;
    },
           
    /**
     * get visible range coord
     */
    getVisibleCoord : function(){
        var el = this.regionEl.dom, rowDom = el.firstChild, rowIndexs = [], sheetId = this.getSheetId();
        var start = false, end;
        for(var i = 0, len = el.childNodes.length; i < len; i++){
            var child = el.childNodes[i].firstChild, ri = Number(child.getAttribute('ri'));
            if(false === start){
                start = ri;
                end = start;
            }else if(end+1 == ri){
                end = ri;
            }else{
                rowIndexs.push([start, end]);
                start = end = ri;
            }
        }
        if(false !== start){
            rowIndexs.push([start, end]);
        }
        var colIndexs = [];
        start = false;
        if(rowDom){
        	for(var i = 0, len = rowDom.childNodes.length; i < len; i++){
                var child = rowDom.childNodes[i], ci = Number(child.getAttribute('ci'));
                if(false === start){
                    start = ci;
                    end = start;
                }else if(end+1 == ci){
                    end = ci;
                }else{
                    colIndexs.push([start, end]);
                    start = end = ci;
                }
            }
        }        
        if(false !== start){
            colIndexs.push([start, end]);
        }
        var coord = [];
        for(var i = 0, len = rowIndexs.length; i < len; i++){
            var r = rowIndexs[i];
            for(var j = 0, size = colIndexs.length; j < size; j++){
                var c = colIndexs[j];
                var span = [sheetId, r[0], c[0], r[1], c[1]];
                coord.push(span);
            }
        }
        return coord;
    }
});
Ext.define('EnterpriseSheet.sheet.regions.Corner', {
	
	/* Begin Definitions */
	
	extend: 'Ext.Component',		
	
	/* End Definitions */
	
	cls : 'ss-corner',
	
	referDisabled : true,
	
	initComponent : function(){
		
		this.callParent();		
		
		
	},
	
	afterRender : function(){
		this.el.update('<div class="ss-cell" style="height:'+this.store.headerCellHeight+'px;"></div>');
		
		this.callParent();		
		
		this.mon(this.el, 'click', this.onClick, this);
	},
	
	onClick : function(){
		if(!this.selectDisabled){
			this.fireEvent('selectionchange', {
				row:0,
				col:0
			}, {
				row:0,
				col:0
			}, this);
			/*
			 * fake mouse up event
			 */
			this.fireEvent('cellmouseup', this, {});
		}
		if(!this.referDisabled){
			/*
			 * no referenceModel, use this to fake 
			 */
			this.fireEvent('referencechange', this, this);
		}
	},
	
	/*
	 * enable/disable selection model
	 */
	enableSelect : function(){
		delete(this.selectDisabled);		
	},
	
	disableSelect : function(){
		this.selectDisabled = true;
	},
	
	/*
	 * enable/disable reference model
	 * @param {boolean} clear: true to clear the selection before enable/disable it
	 * @param {boolean} single: true to only select a single cell one time
	 * @param {boolean} simple: true to enable simple select mode
	 */
	enableRefer : function(clear, single, simple){
		delete(this.referDisabled);
	},
	
	disableRefer : function(clear, single, simple){
		this.referDisabled = true;
	},
	
	/*
	 * fake the getReference, so it works as the ReferenceModel
	 */
	getReference : function(){
		return [[this.getSheetId(), 0, 0, 0, 0]];
	},	
	
	/*
	 * getter and setter for sheetId
	 */
	getSheetId : function(){
		return this.sheetId;
	},
	
	setSheetId : function(sheetId){
		this.sheetId = sheetId;
	},
           
    setReadOnly : function(readOnly){
        this.readOnly = readOnly;
    },
           
    isReadOnly : function(){
        return this.readOnly;
    }
});
Ext.define('EnterpriseSheet.sheet.regions.Header', {
	
	/* Begin Definitions */
	
	extend: 'EnterpriseSheet.sheet.regions.Region',		
	
	/* End Definitions */
	
	cls : 'ss-header',
           
    skipCanvas: true,

	//noInnerContainer : true,
	
	//disableSelectionModel : true,
	
	disableReferenceModel : true,
	
	defaultReferenceModel : 'ColumnReferenceModel',
	
	defaultSelectionModel : 'ColumnSelectionModel',
	
	trackMouseOver : true,
	
	skipZIndex: true,
	
	resizerConfig : {		
 	 	rtype : 'ColumnResizer'
	},
	
	/*
	 * init the row and col span start/end
	 * @param {boolean} noApply: true to not apply to this
	 */
	initSpan : function(noApply){
		var defaultSpan = {
			/*
			 * the start index of row span
			 */
			rowStart : 0,
			/*
			 * the end index of row span
			 */
			rowEnd : 0,
			/*
			 * the start index of column span
			 */
			colStart : 1,
			/*
			 * the end index of column span
			 */
			colEnd : 0,
			/*
			 * this flag means no need calculate the row when resize 
			 */
			fixedRowForResize:true
		};
		
		if(!noApply){
			Ext.applyIf(this, defaultSpan);
		}
		
		return defaultSpan;
	},
	
	/*
	 * init the row and column bound for this region, the bound will define the low and high limit for the region,
	 * @param {boolean} noApply: true to not apply to this.rowBound/this.colBound
	 */
	initBound : function(noApply){
		/*
		 * rowBound and colBound define the limit of the region can move to
		 * @low means the lowest row/col index this region can move to
		 * @high means the highest row/col index this region can move to,
		 * if it's false, then means no limit, if true or a number then means the region can not move down/right
		 */
		var defaultRowBound = {
			low : 0,
			min : 0,			
			high: true
		};		
		
		var defaultColBound = {
			low : 1,
			min : 1,
			high:false
		};
		
		if(!noApply){
			this.rowBound = Ext.apply(this.rowBound || {}, defaultRowBound);
			this.colBound = Ext.apply(this.colBound || {}, defaultColBound);
		}
		
		return {
			rowBound : defaultRowBound,
			colBound : defaultColBound
		};		
	},	
	
	/*
	 * when a column is removed, we need remove the related col element and render more columns at right,
	 * if need 
	 */
	onRemoveColumn : function(sheetId, mincol, maxcol, deleted, merged, store){
		if(sheetId == this.getSheetId() && this.isVisible()){
			/*
			 * need re-render all columns behind maxcol
			 */
			this.removeAfterColumn(mincol, maxcol, deleted);
		}
	},
	
	/*
	 * when columns inserted in store, we need update the region UI
	 * @param {int} sheetId: the sheet id
	 * @param {int} col: the column index where to insert columns
	 * @param {int} span: how many columns are inserted
	 * @param {obj} store: the EnterpriseSheet.Store instance
	 */
	onInsertColumn : function(sheetId, col, span, merged, store){
		if(sheetId == this.getSheetId() && this.isVisible()){
			this.reinsertColumn(col, span);
		}
	},
	
	getData : function(row, col, suspendEvent, timestamp){
		var cell = this.callParent(arguments);
		if(cell.hideTitle){
			delete(cell.data);
		}else if(Ext.isDefined(cell.ticon)){   
			var src = SCONFIG.TITLE_ICONS_PATH+'/'+cell.ticon+'.png';
        	cell.data = '<span style="padding-left:20px;background-image:url('+src+');background-repeat:no-repeat;">'+cell.data+'</span>'
        }
		
		return cell;
	}
});
Ext.define('EnterpriseSheet.sheet.regions.Lefter', {
	
	/* Begin Definitions */
	
	extend: 'EnterpriseSheet.sheet.regions.Region',		
	
	/* End Definitions */
	
	cls : 'ss-lefter',
    
    skipCanvas: true,

	//noInnerContainer : true,
	
	//disableSelectionModel : true,
	
	disableReferenceModel : true,	
	
	trackMouseOver : true,
	
	skipZIndex: true,
	
	resizerConfig : {		
 	 	rtype : 'RowResizer'
	},
	
	defaultReferenceModel:'RowReferenceModel',
	
	defaultSelectionModel:'RowSelectionModel',
	
	/*
	 * init the row and col span start/end
	 * @param {boolean} noApply: true to not apply to this
	 */
	initSpan : function(noApply){
		var defaultSpan = {
			/*
			 * the start index of row span
			 */
			rowStart : 1,
			/*
			 * the end index of row span
			 */
			rowEnd : 0,
			/*
			 * the start index of column span
			 */
			colStart : 0,
			/*
			 * the end index of column span
			 */
			colEnd : 0,
			/*
			 * this flag means no need calculate the column when resize 
			 */
			fixedColForResize : true
		};
		
		if(!noApply){
			Ext.applyIf(this, defaultSpan);
		}
		
		return defaultSpan;
	},
	
	/*
	 * init the row and column bound for this region, the bound will define the low and high limit for the region,
	 * @param {boolean} noApply: true to not apply to this.rowBound/this.colBound
	 */
	initBound : function(noApply){
		/*
		 * rowBound and colBound define the limit of the region can move to
		 * @low means the lowest row/col index this region can move to
		 * @high means the highest row/col index this region can move to,
		 * if it's false, then means no limit, if true or a number then means the region can not move down/right
		 */
		var defaultRowBound = {
			low : 1,
			min : 1,			
			high:false
		};		
		
		var defaultColBound = {
			low : 0,
			min : 0,
			high:true
		};
		
		if(!noApply){
			this.rowBound = Ext.apply(this.rowBound || {}, defaultRowBound);
			this.colBound = Ext.apply(this.colBound || {}, defaultColBound);
		}
		
		return {
			rowBound : defaultRowBound,
			colBound : defaultColBound
		};		
	},	
	
	/*
	 * when a row is removed, we need remove the related row element and render more rows at bottom,
	 * if need
	 */
	onRemoveRow : function(sheetId, minrow, maxrow, deleted, merged, store){
		/*
		 * need re-render all rows below maxrow
		 */
		if(sheetId == this.getSheetId() && this.isVisible()){
			this.removeAfterRow(minrow, maxrow, deleted);
		}
	},
	
	/*
	 * when rows inserted in store, we need update the region UI
	 * @param {int} sheetId: the sheet id
	 * @param {int} row: the row index where to insert rows
	 * @param {int} span: how many rows are inserted
	 * @param {obj} store: the EnterpriseSheet.Store instance
	 */
	onInsertRow : function(sheetId, row, span, merged, store){
		if(sheetId == this.getSheetId() && this.isVisible()){
			this.reinsertRow(row, span);
		}
	}
});
Ext.define('EnterpriseSheet.sheet.toolbar.options.CellTemplateOption', {
	
	/* Begin Definitions */
	
	extend: 'Ext.container.Container',				
	
	requires: [	    
	    'EnterpriseSheet.sheet.menu.CellStyleMenu'
	],
	   	
	/* End Definitions */					
	
	optionPaneWidth: 500,
	
	scrollOffset : 18,
	
	layout: 'fit',		
	
	initComponent : function(){				
		/*
		 * define stores
		 */
		var preferStore = new Ext.data.Store({		    		    
		    model: 'EnterpriseSheet.sheet.model.CellTplModel'		   
		});
		
		var modelStore = new Ext.data.Store({		    		    
		    model: 'EnterpriseSheet.sheet.model.CellTplModel'		   
		});
		
		var titleStore = new Ext.data.Store({		    		    
		    model: 'EnterpriseSheet.sheet.model.CellTplModel'		   
		});
		
		var subjectStore = new Ext.data.Store({		    		    
		    model: 'EnterpriseSheet.sheet.model.CellTplModel'		   
		});
		
		var numberStore = new Ext.data.Store({		    		    
		    model: 'EnterpriseSheet.sheet.model.CellTplModel'		   
		});
		
		var tpl = new Ext.XTemplate(
			'<tpl for=".">',
				'<div class="thumb-wrap">',
					'<div class="thumb cell-style" style="{style}">{text}</div>',
				'</div>',
			'</tpl>',
			'<div class="x-clear"></div>'
		);
		
		for(var i = 0, len = CELLTPL_DATA.length; i < len; i++){
			var it = CELLTPL_DATA[i];
			if('prefer' == it['type']){
				var r = preferStore.createModel(it);						
				preferStore.add(r);
			}else if('model' == it['type']){
				var r = modelStore.createModel(it);						
				modelStore.add(r);
			}else if('title' == it['type']){
				var r = titleStore.createModel(it);						
				titleStore.add(r);
			}else if('subject' == it['type']){
				var r = subjectStore.createModel(it);						
				subjectStore.add(r);
			}else if('number' == it['type']){
				var r = numberStore.createModel(it);						
				numberStore.add(r);
			}			
		}
		
		/*
		 * define views
		 */
		this.preferView = new Ext.view.View({
			cls: 'images-view',
		    store: preferStore,
		    tpl: tpl,
		    autoHeight:true,
		    singleSelect: true,
		    trackOver: true,
		    overItemCls:'x-view-over',
		    itemSelector:'div.thumb-wrap'
		});		
		
		this.modelView = new Ext.view.View({
			cls: 'images-view',
		    store: modelStore,
		    tpl: tpl,
		    autoHeight:true,
		    singleSelect: true,
		    trackOver: true,
		    overItemCls:'x-view-over',
		    itemSelector:'div.thumb-wrap'
		});
		
		this.titleView = new Ext.view.View({
			cls: 'images-view',
		    store: titleStore,
		    tpl: tpl,
		    autoHeight:true,
		    singleSelect: true,
		    trackOver: true,
		    overItemCls:'x-view-over',
		    itemSelector:'div.thumb-wrap'
		}); 
		
		this.subjectView = new Ext.view.View({
			cls: 'images-view',
		    store: subjectStore,
		    tpl: tpl,
		    autoHeight:true,
		    singleSelect: true,
		    trackOver: true,
		    overItemCls:'x-view-over',
		    itemSelector:'div.thumb-wrap'
		}); 
		
		this.numberView = new Ext.view.View({
			cls: 'images-view',
		    store: numberStore,
		    tpl: tpl,
		    autoHeight:true,
		    singleSelect: true,
		    trackOver: true,
		    overItemCls:'x-view-over',
		    itemSelector:'div.thumb-wrap'
		});
		
		this.items = [{
			xtype:'container',
			style:'background:rgb(250,250,250);',			
			autoScroll:true,
			items:[{
				xtype:'box',
				cls:'tpl-title',
				html:SLANG['bad_good_ok']
			}, this.preferView, {
				xtype:'box',
				cls:'tpl-title',
				html:SLANG['data_modal']
			}, this.modelView, {
				xtype:'box',
				cls:'tpl-title',
				html:SLANG['title']
			}, this.titleView, {
				xtype:'box',
				cls:'tpl-title',
				html:SLANG['subject_text']
			}, this.subjectView, {
				xtype:'box',
				cls:'tpl-title',
				html:SLANG['number_format']
			}, this.numberView /*, {
				xtype: 'button',
				style: 'margin:10px;',
				iconCls:'icon-cell-tpl',
				text:SLANG['new_cell_tpl']
			}*/],
			listeners: {
				'afterrender' : function(ct){
					var el = ct.getEl(); 
					var me = this;
					me.mon(el, 'mousewheel', function(e){
						var delta = e.getWheelDelta();
						el.dom.scrollTop += -delta*me.scrollOffset;
					})
				},
				scope: this
			}
		}];
		
		this.callParent();				
				
		this.mon(this.preferView, 'itemclick', this._onClickItem, this);
		this.mon(this.modelView, 'itemclick', this._onClickItem, this);
		this.mon(this.titleView, 'itemclick', this._onClickItem, this);
		this.mon(this.subjectView, 'itemclick', this._onClickItem, this);
		this.mon(this.numberView, 'itemclick', this._onClickItem, this);
	},
	
	bindSheet : function(sheet){
		this.sheet = sheet;
	},
	
	_onClickItem : function(dv, rec){				
		var property = rec.data.property, fn = rec.data.fn;
		if(property || fn){			
			this.setPropertyForSelection(property, fn);
		}
		this.fireEvent('done', this);
	},
	
	/*
	 * set tpl for selection in sheet
	 */
	setPropertyForSelection : function(property, fn){
		var sheet = this.sheet, store = sheet.getStore();
		var sm = sheet.getSelectionModel();
		
		var coord = sm.selection2Coord();    		
		var range = new EnterpriseSheet.sheet.range.Range({
    		sheet:sheet,
    		coord:coord
    	});		
		
		if(false !== sheet.fireEvent('beforeborderchange', range, sheet)){
			sheet.fireEvent('prepareborderchange', range, sheet);
			var dp = {				
				bgc:'',
				fz:'',
				fw:'',
				fs:'',			
				color:''
			};						
			property = Ext.apply(dp, property);
			sheet.setPropertyForSelection(property, null, true, true);
			if(fn){
				fn(sheet);
			}
			range.refresh();
			sheet.fireEvent('borderchange', range, sheet);
		}					
	}
});
Ext.define('EnterpriseSheet.sheet.toolbar.options.ChartOption', {
	
	/* Begin Definitions */
	
	extend: 'Ext.container.Container',				
	
	requires: [	    
	    'EnterpriseSheet.sheet.action.ActionBox'
	],
	   	
	/* End Definitions */					
	
	style: 'padding:10px 25px;',		
	
	initComponent : function(){				
		
		this.defaults = {
			xtype: 'button'			
		};
		
		
		this.items = [{
			xtype: 'component',
			html: '<div class="sc-set-title">'+SLANG['charts']+'</div>'
		}, SABOX.get('insertColumnChart', {
			minWidth: 60,
			iconCls:'icon-column-chart32',
            ui: 'default-toolbar',
			scale:'large',		
			iconAlign: 'top',
			text: SLANG['column'],
			style: 'margin-left:10px;margin-top:10px;',
            sender: this
		}), SABOX.get('insertAreaChart', {
			minWidth: 60,
			iconCls:'icon-area-chart32',
            ui: 'default-toolbar',
			scale:'large',
			iconAlign: 'top',
			text: Ext.isIE?'&nbsp;'+SLANG['area']+'&nbsp;':SLANG['area'],
			style: 'margin-left:10px;margin-top:10px;',
            sender: this
		}), SABOX.get('insertPieChart', {
			minWidth: 60,
			iconCls:'icon-pie-chart32',
            ui: 'default-toolbar',
			scale:'large',			
			iconAlign:'top',
			text: Ext.isIE?'&nbsp;&nbsp;&nbsp;'+SLANG['pie']+'&nbsp;&nbsp;&nbsp;':SLANG['pie'],
			style: 'margin-left:10px;margin-top:10px;',
            sender: this
		}), SABOX.get('insertLineChart', {
			minWidth: 60,
			iconCls:'icon-line-chart32',
            ui: 'default-toolbar',
			scale:'large',			
			iconAlign:'top',
			text: Ext.isIE?'&nbsp;'+SLANG['line']+'&nbsp;':SLANG['line'],
			style: 'margin-left:10px;margin-top:10px;',
            sender: this
		}), SABOX.get('insertBarChart', {
			minWidth: 60,
			iconCls:'icon-bar-chart32',
            ui: 'default-toolbar',
			scale:'large',			
			iconAlign:'top',
			text: Ext.isIE?'&nbsp;&nbsp;&nbsp;'+SLANG['bar']+'&nbsp;&nbsp;&nbsp;':SLANG['bar'],
			style: 'margin-left:10px;margin-top:10px;',
            sender: this
		}), SABOX.get('insertScatterChart', {
			minWidth: 60,
			iconCls:'icon-scatter-chart32',
            ui: 'default-toolbar',
			scale:'large',			
			iconAlign:'top',
			text: SLANG['scatter'],
			style: 'margin-left:10px;margin-top:10px;',
            sender: this
		}), SABOX.get('insertRadarChart', {
			minWidth: 60,
			iconCls:'icon-radar-chart32',
            ui: 'default-toolbar',
			scale:'large',			
			iconAlign:'top',
			text: SLANG['radar'],
			style: 'margin-left:10px;margin-top:10px;',
            sender: this
		}), {
			xtype: 'component',
			style: 'margin-top:20px;',
			html: '<div class="sc-set-title">'+SLANG['mini_charts']+'</div>'
		}, SABOX.get('insertColumnMiniChart', {
			minWidth: 60,
			iconCls:'icon-mini-column32',
            ui: 'default-toolbar',
			scale:'large',		
			iconAlign: 'top',
			text: SLANG['column'],
			style: 'margin-left:10px;margin-top:10px;',
            sender: this
		}), SABOX.get('insertGainLossMiniChart', {
			minWidth: 60,
			iconCls:'icon-mini-gainloss32',
            ui: 'default-toolbar',
			scale:'large',
			iconAlign: 'top',
			text: SLANG['gain_loss'],
			style: 'margin-left:10px;margin-top:10px;',
            sender: this
        }), SABOX.get('insertLineMiniChart', {
            minWidth: 60,
            iconCls:'icon-mini-line32',
            ui: 'default-toolbar',                      
            hidden: !Ext.supports.Svg,
            scale:'large',
            iconAlign: 'top',
            text: SLANG['line'],
            style: 'margin-left:10px;margin-top:10px;',
            sender: this
        })];
		
		this.callParent();		
		
		this.items.each(function(it){
			this.mon(it, {
				scope: this,
				'click': function(){
					this.fireEvent('done', this);
				}
			})
		}, this);
	},
	
	bindSheet : function(sheet){
		this.sheet = sheet;
	}
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.toolbar.options.ConditionOption', {
	
	/* Begin Definitions */
	
	extend: 'Ext.container.Container',				
	
	requires: [	    
	    'EnterpriseSheet.sheet.action.ActionBox',
	    'Ext.layout.container.Card',
        'EnterpriseSheet.sheet.pop.condition.IconSetRuleWin'
	],
	   	
	/* End Definitions */					
	
	style: 'padding:10px;',		
	
	layout: 'card',
	
	activeItem: 0,
	
	optionPaneWidth: 250,
	
	initComponent : function(){						
		
		this.colors = {
			'red':[255,0,0],
			'green':[0,255,0],
			'blue':[0,0,255],
			'orange':[255,128,0],
			'native':[0,128,255],
			'pink':[255,0,128],
			'white':[255,255,255],
			'yellow':[255,255,0]
		};
			
		this.gradColors = {
			'red':[248,105,107],
			'green':[90,190,123],
			'blue':[90,138,198],								
			'white':[255,255,255],
			'yellow':[255,235,132]	
		};
			
		this.colorTpl = new Ext.XTemplate(
			'rgb({0},{1},{2})'
		).compile();
        
        this.iconSetTpl = SCOM.iconSetTpl;
        
        this.iconSetStore = SCOM.iconSetStore;
           
        this.iconSetView = Ext.create('Ext.view.View', {
            store: this.iconSetStore,
            tpl: this.iconSetTpl,
            itemSelector: 'div.ss-condition-iconset',
            overItemCls: 'ss-iconset-over'
        });
           
        this.iconSetView.on('itemclick', this.onIconSetClick, this);
			
		this.items = [{
			xtype: 'container',
			layout: {
				type: 'vbox',
				align: 'stretch'
			},
			defaults: {
				xtype: 'button',
                ui: 'default-toolbar',
				scale: 'large',
				style: 'margin-top:10px;',
				textAlign: 'left'
			},
			items: [{							
				iconCls:'icon-compare-highlight32',
				text:SLANG['condition_highlight_cell'],
				handler: function(){
					this.getLayout().setActiveItem(1);
				},
				scope: this
			}, {														
				iconCls: 'icon-calculate-highlight32',
				text: SLANG['calculate_highlight_cell'],
				handler: function(){
					this.getLayout().setActiveItem(2);
				},
				scope: this
			}, {							
				iconCls:'icon-red-bar32',
				text:SLANG['colorbar'],
				handler: function(){
					this.getLayout().setActiveItem(3);
				},
				scope: this
			}, {							
				iconCls:'icon-colorchange32',
				text:SLANG['color_scales'],
				handler: function(){
					this.getLayout().setActiveItem(4);
				},
				scope: this
            }, {
                iconCls:'icon-iconset32',
                text:SLANG['icon_set'],
                handler: function(){
					this.getLayout().setActiveItem(5);
                },
                scope: this
            }, {
				xtype: 'component',
				flex: 1
			}, {				
				iconCls:'icon-clear-condition32',
				text:SLANG['clear_selecttion_condition'],
				handler:this.onClearSelectionCondition,
				scope:this
			}, {				
				iconCls:'icon-clear-condition32',
				text:SLANG['clear_sheet_condition'],
				handler:this.onClearSheetCondition,
				scope:this
			}, {							
				iconCls:'icon-manage-condition32',
				text:SLANG['condition_management']+'...',
				handler:this.onManageCondition,
				scope:this
			}]
		}, {
			xtype: 'container',
			layout: {
				type: 'vbox',
				align: 'stretch'
			},
			defaults: {
				xtype: 'button',
                ui: 'default-toolbar',
				scale: 'large',
				style: 'margin-top:10px;',
				textAlign: 'left'
			},
			items:[{															
				iconCls:'icon-condition-greater32',
				text:SLANG['greater_than']+'...',
				handler:this.onConditionGreater,
				scope:this
			}, {				
				iconCls:'icon-condition-less32',
				text:SLANG['less_than']+'...',
				handler:this.onConditionLess,
				scope:this
			}, {				
				iconCls:'icon-condition-equal32',
				text:SLANG['equal']+'...',
				handler:this.onConditionEqual,
				scope:this
			}, {				
				iconCls:'icon-condition-between32',
				text:SLANG['between']+'...',
				handler:this.onConditionBetween,
				scope:this
			}, {				
				iconCls:'icon-condition-include32',
				text:SLANG['include']+'...',
				handler:this.onConditionInclude,
				scope:this
			}, {				
				iconCls:'icon-condition-date32',
				text:SLANG['date_ocurring_at']+'...',
				handler:this.onConditionDate,
				scope:this
			}, {				
				iconCls:'icon-condition-repeat32',
				text:SLANG['repeat_value']+'...',
				handler:this.onConditionRepeat,
				scope:this
			}, {
				xtype: 'component',
				flex: 1
			}, {
				text:SLANG['back'],		
				iconCls:'icon-back32',
				handler:this.back2Home,
				scope:this
			}]
		}, {
			xtype: 'container',
			layout: {
				type: 'vbox',
				align: 'stretch'
			},
			defaults: {
				xtype: 'button',
                ui: 'default-toolbar',
				scale: 'large',
				style: 'margin-top:10px;',
				textAlign: 'left'
			},
			items:[{						
				iconCls:'icon-condition-max32',
				text:SLANG['top_10_value']+'...',
				handler:this.onConditionMax,
				scope:this
			}, {				
				iconCls:'icon-condition-top32',
				text:SLANG['top_10%']+'...',
				handler:this.onConditionTop,
				scope:this
			}, {				
				iconCls:'icon-condition-min32',
				text:SLANG['bottom_10_value']+'...',
				handler:this.onConditionMin,
				scope:this
			}, {				
				iconCls:'icon-condition-bottom32',
				text:SLANG['bottom_10%']+'...',
				handler:this.onConditionBottom,
				scope:this
			}, {				
				iconCls:'icon-condition-above32',
				text:SLANG['above_average']+'...',
				handler:this.onConditionAbove,
				scope:this
			}, {				
				iconCls:'icon-condition-below32',
				text:SLANG['below_average']+'...',
				handler:this.onConditionBelow,
				scope:this
			}, {
				xtype: 'component',
				flex: 1
			}, {
				text:SLANG['back'],		
				iconCls:'icon-back32',
				handler:this.back2Home,
				scope:this
			}]
		}, {
			xtype: 'container',
			layout: {
				type: 'vbox',
				align: 'stretch'
			},
			items: [{
				xtype: 'container',
				layout: {
			        type: 'table',
			        columns: 3,
			        tableAttrs: {
			            style: {
			                width: '100%'				                
			            }
			        }
			    },
			    style: 'padding:10px 25px;',
				defaults:{
					xtype: 'button',
					scale:'large',
                    ui: 'default-toolbar',
					style:'margin:5px;',
					textAlign: 'left',
					handler:this.onColorBar,
					scope:this
				},
				items: [{						
					iconCls:'icon-blue-bar32',
					color:'blue'
				}, {						
					iconCls:'icon-green-bar32',
					color:'green'
				}, {						
					iconCls:'icon-red-bar32',
					color:'red'
				}, {						
					iconCls:'icon-native-bar32',
					color:'native'
				}, {						
					iconCls:'icon-orange-bar32',
					color:'orange'
				}, {						
					iconCls:'icon-pink-bar32',
					color:'pink'
				}]
			}, {
				xtype: 'component',
				flex: 1
			}, {
				xtype: 'button',
				scale: 'large',
                ui: 'default-toolbar',
				text:SLANG['back'],		
				iconCls:'icon-back32',
				handler:this.back2Home,
				scope:this
			}]
		}, {
			xtype: 'container',
			layout: {
				type: 'vbox',
				align: 'stretch'
			},
			items: [{						
				xtype:'container',						
				layout: {
			        type: 'table',
			        columns: 4,
			        tableAttrs: {
			            style: {
			                width: '100%'
			            }
			        }
			    },
			    style: 'padding:10px 25px;',
				defaults:{
					xtype: 'button',
					scale:'large',
                    ui: 'default-toolbar',
					style:'margin:2px;',
					textAlign: 'left',
					handler:this.onColorChange,
					scope:this
				},
				items:[{						
					iconCls:'icon-grad-green2orange2red32',
					start:'green',
					stop:'yellow',
					end:'red'
				}, {											
					iconCls:'icon-grad-red2orange2green32',
					start:'red',
					stop:'yellow',
					end:'green'
				}, {						
					iconCls:'icon-grad-blue2orange2red32',
					start:'blue',
					stop:'yellow',
					end:'red'
				}, {											
					iconCls:'icon-grad-red2orange2blue32',
					start:'red',
					stop:'yellow',
					end:'blue'
				}, {											
					iconCls:'icon-grad-green2yellow32',
					start:'green',						
					end:'yellow'
				}, {						
					iconCls:'icon-grad-yellow2green32',
					start:'yellow',						
					end:'green'
				}, {						
					iconCls:'icon-grad-orange2red32',
					start:'yellow',						
					end:'red'
				}, {						
					iconCls:'icon-grad-red2orange32',
					start:'red',						
					end:'yellow'
				}, {						
					iconCls:'icon-grad-white2pink32',
					start:'white',						
					end:'red'
				}, {						
					iconCls:'icon-grad-pink2white32',
					start:'red',						
					end:'white'
				}, {						
					iconCls:'icon-grad-white2green32',
					start:'white',						
					end:'green'
				}, {						
					iconCls:'icon-grad-green2white32',
					start:'green',						
					end:'white'
				}]
			}, {
				xtype: 'component',
				flex: 1
			}, {
				xtype: 'button',
                ui: 'default-toolbar',
				scale: 'large',
				text:SLANG['back'],		
				iconCls:'icon-back32',
				handler:this.back2Home,
				scope:this
			}]
        }, {
            xtype: 'container',
            layout: {
                type: 'vbox',
                align: 'stretch'
            },
            items: [{
                xtype:'container',
                items: [this.iconSetView]
            }, {
                xtype: 'button',
                ui: 'default-toolbar',
                text: SLANG['other_rule']+'...',
                handler: this.onIconSetOtherRule,
                scope: this
            }, {
                xtype: 'component',
                flex: 1
            }, {
                xtype: 'button',
                scale: 'large',
                ui: 'default-toolbar',                    
                text:SLANG['back'],
                iconCls:'icon-back32',
                handler:this.back2Home,
                scope:this
            }]
        }];
		
		this.callParent();		
		
	},
	
	/*
	 * bind the sheet for handler use
	 */
	bindSheet : function(sheet){
		this.sheet = sheet;
	},
	
	/*
	 * highlight the cells in the selection, if it fit the condition,
	 * this condition is about greater than some value, it requires number
	 */
	onConditionGreater : function(){		
		/*
		 * get the average value
		 */
		var avg = this.sheet.getAverageOfSelection(3);
		avg = Math.round(avg*100)/100;
		var sheetId = this.sheet.getSheetId();
		SPOP.showConditionBool({
			/*
			 * pass the ref of sheet, it need
			 */
			sheet:this.sheet,
			title:SLANG['greater_than'],
			label:SLANG['set_style_for_greater'],
			value:avg,
			applyCallback:{
				fn:function(o){					
					var opt = {
						'type':'greater',
						'base':o.base,
						'style':o.style
					};
					this.sheet.setConditionForSelection('boolstyle', opt, sheetId);
				},
				scope:this
			}
		});			
	},
	
	/*
	 * highlight the cells in the selection, if it fit the condition,
	 * this condition is about less than some value, it requires number
	 */
	onConditionLess : function(){
		/*
		 * get the average value
		 */
		var avg = this.sheet.getAverageOfSelection(3);		
		SPOP.showConditionBool({
			/*
			 * pass the ref of sheet, it need
			 */
			sheet:this.sheet,
			title:SLANG['less_than'],
			label:SLANG['set_style_for_less'],
			value:avg,
			applyCallback:{
				fn:function(o){					
					var opt = {
						'type':'less',
						'base':o.base,
						'style':o.style
					};
					this.sheet.setConditionForSelection('boolstyle', opt);
				},
				scope:this
			}
		});			
	},
	
	/*
	 * highlight the cells in the selection, if it fit the condition,
	 * this condition is about equal some value, it requires number
	 */
	onConditionEqual : function(){
		/*
		 * get the average value
		 */
		var avg = this.sheet.getAverageOfSelection(3);		
		SPOP.showConditionBool({
			/*
			 * pass the ref of sheet, it need
			 */
			sheet:this.sheet,
			title:SLANG['equal'],
			label:SLANG['set_style_for_equal'],
			value:avg,
			applyCallback:{
				fn:function(o){					
					var opt = {
						'type':'equal',
						'base':o.base,
						'style':o.style
					};
					this.sheet.setConditionForSelection('boolstyle', opt);
				},
				scope:this
			}
		});			
	},
	
	/*
	 * highlight the cells in the selection, if it fit the condition,
	 * this condition is about between min and max value, it requires number
	 */
	onConditionBetween : function(){		
		SPOP.showConditionBetween({
			/*
			 * pass the ref of sheet, it need
			 */
			sheet:this.sheet,
			title:SLANG['between'],
			label:SLANG['set_style_for_between'],			
			applyCallback:{
				fn:function(o){					
					var opt = {
						'type':'between',
						'base':o.base,
						'style':o.style
					};
					this.sheet.setConditionForSelection('boolstyle', opt);
				},
				scope:this
			}
		});			
	},
	
	/*
	 * highlight the cells in the selection, if it fit the condition,
	 * this condition is about include some value
	 */
	onConditionInclude : function(){
		/*
		 * get the average value
		 */
		var avg = this.sheet.getAverageOfSelection(3);		
		SPOP.showConditionBool({
			/*
			 * pass the ref of sheet, it need
			 */
			sheet:this.sheet,
			title:SLANG['include'],
			label:SLANG['set_style_for_include'],
			value:avg,
			applyCallback:{
				fn:function(o){					
					var opt = {
						'type':'include',
						'base':o.base,
						'style':o.style
					};
					this.sheet.setConditionForSelection('boolstyle', opt);
				},
				scope:this
			}
		});			
	},
	
	/*
	 * highlight the cells in the selection, if it fit the condition,
	 * this condition is about the repeat value
	 */
	onConditionRepeat : function(){
		/*
		 * get the average value
		 */		
		SPOP.showConditionRepeat({
			/*
			 * pass the ref of sheet, it need
			 */
			sheet:this.sheet,
			title:SLANG['repeat_value'],
			label:SLANG['set_style_for_cell'],			
			applyCallback:{
				fn:function(o){					
					var opt = {
						'type':'repeat',
						'base':o.base,
						'style':o.style
					};
					this.sheet.setConditionForSelection('boolstyle', opt);
				},
				scope:this
			}
		});			
	},
	
	/*
	 * highlight the cells in the selection, if it fit the condition,
	 * this condition is about the repeat value
	 */
	onConditionDate : function(){
			
		SPOP.showConditionDate({
			/*
			 * pass the ref of sheet, it need
			 */
			sheet:this.sheet,
			title:SLANG['date_ocurring_at'],
			label:SLANG['set_style_date_ocurring_at'],			
			applyCallback:{
				fn:function(o){					
					var opt = {
						'type':'date',
						'base':o.base,
						'style':o.style
					};
					this.sheet.setConditionForSelection('boolstyle', opt);
				},
				scope:this
			}
		});			
	},
	
	/*
	 * highlight the cells in the selection, if it fit the condition,
	 * this condition is above the average value
	 */
	onConditionAbove : function(){
			
		SPOP.showConditionAverage({
			/*
			 * pass the ref of sheet, it need
			 */
			sheet:this.sheet,
			title:SLANG['above_average'],
			label:SLANG['set_style_above_average'],			
			applyCallback:{
				fn:function(o){					
					var opt = {
						'type':'average',	
						'base':SCONST.ABOVE_AVERAGE,
						'style':o.style
					};
					this.sheet.setConditionForSelection('boolstyle', opt);
				},
				scope:this
			}
		});			
	},
	
	/*
	 * highlight the cells in the selection, if it fit the condition,
	 * this condition is below the average value
	 */
	onConditionBelow : function(){
			
		SPOP.showConditionAverage({
			/*
			 * pass the ref of sheet, it need
			 */
			sheet:this.sheet,
			title:SLANG['below_average'],
			label:SLANG['set_style_below_average'],			
			applyCallback:{
				fn:function(o){					
					var opt = {
						'type':'average',	
						'base':SCONST.BELOW_AVERAGE,			
						'style':o.style
					};
					this.sheet.setConditionForSelection('boolstyle', opt);
				},
				scope:this
			}
		});			
	},
	
	/*
	 * highlight the cells in the selection, if it fit the condition,
	 * this condition is one of the 10 maximum values
	 */
	onConditionMax : function(){
			
		SPOP.showConditionPosition({
			/*
			 * pass the ref of sheet, it need
			 */
			sheet:this.sheet,
			title:SLANG['top_10_value'],
			label:SLANG['set_style_max_value'],	
			setAsTxt:SLANG['set_as'],
			applyCallback:{
				fn:function(o){					
					var opt = {
						'type':'max',	
						'base':o.base,			
						'style':o.style
					};
					this.sheet.setConditionForSelection('boolstyle', opt);
				},
				scope:this
			}
		});			
	},
	
	/*
	 * highlight the cells in the selection, if it fit the condition,
	 * this condition is one of the top 10% values
	 */
	onConditionTop : function(){
			
		SPOP.showConditionPosition({
			/*
			 * pass the ref of sheet, it need
			 */
			sheet:this.sheet,
			title:SLANG['top_10%'],
			label:SLANG['set_style_top_value'],	
			setAsTxt:SLANG['percent_set_as'],
			maxValue:100,
			applyCallback:{
				fn:function(o){					
					var opt = {
						'type':'top',	
						'base':o.base,			
						'style':o.style
					};
					this.sheet.setConditionForSelection('boolstyle', opt);
				},
				scope:this
			}
		});			
	},
	
	/*
	 * highlight the cells in the selection, if it fit the condition,
	 * this condition is one of the 10 minimum values
	 */
	onConditionMin : function(){
			
		SPOP.showConditionPosition({
			/*
			 * pass the ref of sheet, it need
			 */
			sheet:this.sheet,
			title:SLANG['bottom_10_value'],
			label:SLANG['set_style_min_value'],	
			setAsTxt:SLANG['set_as'],
			applyCallback:{
				fn:function(o){					
					var opt = {
						'type':'min',	
						'base':o.base,			
						'style':o.style
					};
					this.sheet.setConditionForSelection('boolstyle', opt);
				},
				scope:this
			}
		});			
	},
	
	/*
	 * highlight the cells in the selection, if it fit the condition,
	 * this condition is one of the bottom 10% values
	 */
	onConditionBottom : function(){
			
		SPOP.showConditionPosition({
			/*
			 * pass the ref of sheet, it need
			 */
			sheet:this.sheet,
			title:SLANG['bottom_10%'],
			label:SLANG['set_style_bottom_value'],	
			setAsTxt:SLANG['percent_set_as'],
			maxValue:100,
			applyCallback:{
				fn:function(o){					
					var opt = {
						'type':'bottom',	
						'base':o.base,			
						'style':o.style
					};
					this.sheet.setConditionForSelection('boolstyle', opt);
				},
				scope:this
			}
		});			
	},
      
    /**
     * set the iconset for the selection
     */
    onIconSetClick : function(view, rec){
        var data = rec.data;
        var opt = {
            'set': data.set,
            'level': data.level
        }
        this.sheet.setConditionForSelection('iconset', opt);
        this.fireEvent('done', this);
    },
           
	
	/*
	 * show color bar for selection range
	 */
	onColorBar : function(btn){
		var opt = {
			'pos':'red',
			'neg':'green'
		};
		if(btn){
			var color = this.colors[btn.color];
			if(color){
				opt = {
					'pos':this.colorTpl.apply(color),
					'neg':this.colorTpl.apply([255-color[0],255-color[1],255-color[2]])
				};
			}
		}
		this.sheet.setConditionForSelection('colorbar', opt);
		this.fireEvent('done', this);
	},
	
	/*
	 * show changing background color for selection range
	 */
	onColorChange : function(btn){
		var opt = {
			'start':this.gradColors['green'],
			'end':this.gradColors['red']
		};
		if(btn){
			var start = this.gradColors[btn.start];
			var stop = this.gradColors[btn.stop];
			var end = this.gradColors[btn.end];
			if(start){
				opt = opt || {};
				opt['start'] = start;
			}
			if(stop){
				opt = opt || {};
				opt['stop'] = stop;
			}
			if(end){
				opt = opt || {};
				opt['end'] = end;
			}			
		}
		this.sheet.setConditionForSelection('colorgrad', opt);
		this.fireEvent('done', this);
	},
	
	/*
	 * clear the condition for selection range
	 */
	onClearSelectionCondition : function(){
		this.sheet.clearConditionForSelection();
	},
	
	/*
	 * clear the condition for the whole sheet
	 */
	onClearSheetCondition : function(){
		this.sheet.clearConditonForSheet();
	},
	
	/*
	 * manage the conditions of selection range,
	 * it will pop up a window and list all conditions of selection range
	 */
	onManageCondition : function(){
		SPOP.showConditionManage({
			/*
			 * pass the ref of sheet, it need
			 */
			sheet:this.sheet			
		});
	},
	
	back2Home : function(){
		this.getLayout().setActiveItem(0);
	},
           
    onIconSetOtherRule : function(){
        if(!this.iconSetRuleWin){
            this.iconSetRuleWin = Ext.create('EnterpriseSheet.sheet.pop.condition.IconSetRuleWin', {
                sheet: this.sheet,
                applyCallback: {
                    fn: function(params){
                        this.sheet.setConditionForSelection('iconset', params);
                        this.fireEvent('done', this);
                    },
                    scope: this
                }
            });
        }
        this.iconSetRuleWin.popup();
    }
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.toolbar.options.PictureOption', {
	
	/* Begin Definitions */
	
	extend: 'Ext.container.Container',				
	
	/* End Definitions */			
	
	layout: 'anchor',
	
	style: 'padding:10px;',
	
	optionPaneWidth: 240,
	
	initComponent : function(){				
		
		this.previewBox = new Ext.Component({
			cls: 'sc-preview-box',
			style: 'margin-top:10px;',
			height: 160,
			html: '<img src="">'
		});
		
		this.urlField = new Ext.form.field.TextArea({
			labelAlign: 'top',
			fieldLabel: SLANG['picture_link'],
			anchor: '100%',
			height: 100,
			allowBlank: false
		});
		
		this.inCellCheckbox = new Ext.form.field.Checkbox({
			boxLabel: SLANG['image_in_cell']
		});
		this.items = [this.urlField, this.inCellCheckbox, {
			xtype: 'button',
			minWidth: 50,
			text: SLANG['preview'],
			handler: this.previewPicture, 
			scope: this
		}, {
			xtype: 'button',
			minWidth: 50,
			style: 'margin-left:10px;',
			text: SLANG['insert'],
			handler: this.insertPicture, 
			scope: this
		}, {
			xtype: 'component',
			style: 'padding-top:40px;color:gray;',
			html: SLANG['preview_img_below']
		}, this.previewBox];
		
		this.callParent();		
	},
	
	bindSheet : function(sheet){
		this.sheet = sheet;
	},
	
	/*
	 * preview the picture
	 */
	previewPicture : function(){
		if(this.urlField.isValid()){
			var url = this.urlField.getValue();
			var img = this.previewBox.getEl().down('img');
			img.dom.src = url;
		}
	},
	
	/*
	 * insert the picture 
	 */
	insertPicture : function(){
		if(this.urlField.isValid()){
			var url = this.urlField.getValue();
			var incell = this.inCellCheckbox.getValue();
			if(incell){
				this.sheet.createInCellPicture(url);
			}else{
				this.sheet.createPicture(url);
			}
			
			this.fireEvent('done', this);
		}
	}
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.toolbar.options.WedgitOption', {
	
	/* Begin Definitions */
	
	extend: 'Ext.container.Container',				
	
	/* End Definitions */			
	
	layout: 'anchor',
	
	style: 'padding:10px;',
	
	optionPaneWidth: 340,
	
	initComponent : function(){				
		
		this.previewBox = new Ext.Component({
			cls: 'sc-preview-box',
			style: 'margin-top:10px;',
			height: 160,
			html: '<iframe src=""></iframe>'
		});
		
		this.urlField = new Ext.form.field.TextArea({
			labelAlign: 'top',
			fieldLabel: SLANG['wedgit_link'],
			anchor: '100%',
			height: 100,
			allowBlank: false
		});
		
		this.items = [this.urlField, {
			xtype: 'button',
			minWidth: 50,
			text: SLANG['preview'],
			handler: this.previewWedgit,
			scope: this
		}, {
			xtype: 'button',
			minWidth: 50,
			style: 'margin-left:10px;',
			text: SLANG['insert'],
			handler: this.insertWedgit,
			scope: this
		}, {
			xtype: 'component',
			style: 'padding-top:40px;color:gray;',
			html: SLANG['preview_widget_below']
		}, this.previewBox];
		
		this.callParent();		
	},
	
	bindSheet : function(sheet){
		this.sheet = sheet;
	},
	
	/*
	 * preview the picture
	 */
	previewWedgit : function(){
		if(this.urlField.isValid()){
			var url = this.urlField.getValue();
            if(0 !== url.indexOf('http://')){
                url = 'http://'+url;
            }
			var iframe = this.previewBox.getEl().down('iframe');
           iframe.dom.src = url;
		}
	},
	
	/*
	 * insert the picture 
	 */
	insertWedgit : function(){
		if(this.urlField.isValid()){
			var url = this.urlField.getValue();
            if(0 !== url.indexOf('http://')){
                url = 'http://'+url;
            }
            this.sheet.createWedgit(url);
			this.fireEvent('done', this);
		}
	}
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.toolbar.options.SearchOption', {
	
	/* Begin Definitions */
	
	extend: 'Ext.grid.Panel',		
	
	requires: [
	   'EnterpriseSheet.sheet.model.TargetModel',
	   'Ext.grid.feature.Grouping'
	],
	
	/* End Definitions */				
	
	bodyStyle: 'border-left:none;border-right:none;',
	
	optionPaneWidth: 240,
	
	hideHeaders: true,
	
	initComponent : function(){				
		
		this.searchField = new Ext.form.field.Text({			
			fieldLabel: SLANG['search'],
			labelAlign: 'top',
			anchor: '100%',			
			allowBlank: false,
			enableKeyEvents:true,	
			listeners:{
				'keypress':{
					fn:this.onFindKeyPress,
					scope:this
				}
			}
		});
		
		this.replaceField = new Ext.form.field.Text({			
			fieldLabel: SLANG['replace_with'],
			labelAlign: 'top',
			anchor: '100%',
			enableKeyEvents:true
		});		
		
		this.searchBtn = new Ext.button.Button({
			flex: 1,
			text: SLANG['find'],
			handler: this.findMatch,
			scope: this
		});
		
		this.prevBtn = new Ext.button.Button({
			disabled: true,
			text: SLANG['prev'],
			handler: this.prevMatch,
			scope: this
		});
		
		this.nextBtn = new Ext.button.Button({
			disabled: true,
			text: SLANG['next'],
			handler: this.nextMatch,
			scope: this
		});
		
		this.replaceBtn = new Ext.button.Button({
			disabled: true,
			flex: 1,
			text: SLANG['replace'],
			handler: this.replaceSelect,
			scope: this
		});
		
		this.replaceAllBtn = new Ext.button.Button({
			disabled: true,
			flex: 1,
			text: SLANG['replace_all'],
			handler: this.replaceAll,
			scope: this
		});				
						
		this.nextPageBtn = Ext.create('Ext.button.Button', {			
			text: SLANG['more'],
			handler: this.loadMore,
			scope: this
		});		
		
		this.moreBar = Ext.create('Ext.toolbar.Toolbar', {
			hidden: true,
			layout: {
				type: 'hbox',
				pack: 'center'
			},
			dock: 'bottom',
			style: 'border-left:none;border-right:none;',
			items: [this.nextPageBtn]
		})
		
		this.dockedItems = [{
			xtype: 'container',
			dock: 'top',
			layout: 'anchor',
			cls: 'ss-search-fields-ct',			
			items: [
				this.searchField, 
				this.replaceField /*,
				{
					xtype: 'fieldset',
					title: SLANG['options'],
					defaultType: 'checkbox',
					items: [{
						boxLabel: SLANG['case_sensitive']
					}]
				}*/
			]
		}, {
			xtype: 'container',
			style: 'padding:0px 10px 10px 10px;',
			cls: 'ss-search-button-ct',
			dock: 'bottom',
			layout: 'hbox',
			items: [this.replaceBtn, {xtype: 'component', width: 10}, this.replaceAllBtn]
		}, {
			xtype: 'container',			
			cls: 'ss-search-button-ct',
			dock: 'bottom',
			layout: 'hbox',
			items: [this.searchBtn, {xtype: 'component', width: 10}, this.prevBtn, {xtype: 'component', width: 10}, this.nextBtn]
		}, this.moreBar];
		
		var me = this;
		this.columns = [{            
            width: 50,
            dataIndex: 'cell'
        },{            
            flex: 1,
            dataIndex: 'data'
        }];
		
		this.store = new Ext.data.Store({
			model: 'EnterpriseSheet.sheet.model.TargetModel',
			groupField: 'sheetName'
		});
		
		var groupingFeature = Ext.create('Ext.grid.feature.Grouping',{
	        groupHeaderTpl: '{name} ({rows.length})',
	        hideGroupedHeader: true
	    });
		
		this.features = [groupingFeature];
		
		this.callParent();		
		
		this.loadMask = new Ext.LoadMask({
        	target: this,
        	msg: SLANG['processing']
        });
		
		this.on('itemclick', this.onItemClick, this);
		
		var sm = this.getSelectionModel();
		this.mon(sm, {
			scope: this,
			'selectionchange': this.onSelectionChange
		});
		this.on('show', this._onShow, this);
	},
	
	bindSheet : function(sheet){
		this.sheet = sheet;
	},
	
	_onShow : function() {
		this.searchField.focus(true, 100);
	},
	
	/*
	 * find match in sheet
	 */
	findMatch : function(){
		if(this.searchField.isValid()){
			var txt = '*'+this.searchField.getValue()+'*';			
			this.findText = txt;
			var sheet = this.sheet;
			var store = sheet.getStore(), sm = sheet.getSelectionModel();
			var focusCell = sm.getFocusCell();
			var startRow = focusCell.row, startCol = focusCell.col;
			this.loadMask.show();
			Ext.Function.defer(function(){
				store.findMatchCells(txt, function(matchs, nextCellId){
					this.store.removeAll();
					if(matchs && 0 < matchs.length){
						var match = matchs[0];
						var sheetId = match.sheet, row = match.row, col = match.col;
						this.store.add(matchs);
						
						this.replaceBtn.enable();
						this.replaceAllBtn.enable();
					}else{
						this.prevBtn.disable();
						this.nextBtn.disable();
					}
					this.loadMask.hide();
					if(nextCellId){
						this.moreBar.show();
						this.nextCellId = nextCellId;
					}else{
						this.moreBar.hide();
						delete(this.nextCellId);
					}
				}, this);
			}, 100, this);								
		}
	},
	
	loadMore : function(){
		this.loadMask.show();
		Ext.Function.defer(function(){
			store.findMatchCells(this.findText, function(matchs, nextCellId){				
				if(matchs && 0 < matchs.length){
					var match = matchs[0];
					var sheetId = match.sheet, row = match.row, col = match.col;
					this.store.add(matchs);
				}
				this.loadMask.hide();
				if(nextCellId){
					this.moreBar.show();
					this.nextCellId = nextCellId;
				}else{
					this.moreBar.hide();
					delete(this.nextCellId);
				}
			}, this, this.nextCellId);
		}, 100, this);
	},
	
	onFindKeyPress : function(field, e){
		if(e.ENTER == e.getKey()){
			this.findMatch();
		}
	},
	
	/*
	 * click on the grid item
	 */
	onItemClick : function(grid, rec){
		this.go2Pos(rec.data.sheet, rec.data.row, rec.data.col);		
	},
	
	go2Pos : function(sheetId, row, col){
		var sheet = this.sheet, curSheetId = sheet.getSheetId();
		var store = sheet.getStore(), sm = sheet.getSelectionModel();
		
		var fn = function(){
            var orow = row, ocol = col;
			var cregion = sheet.cregion;
			if(!cregion.isInRange(row, col)){
				row = row-Math.floor((cregion.rowEnd-cregion.rowStart)/2);
				col = col-Math.floor((cregion.colEnd-cregion.colStart)/2);
				if(row < 1){
					row = 1;
				}
				if(col < 1){
					col = 1;
				}
				sheet.go2Pos(row, col);
			}
            sm.selectRange({row: orow, col: ocol});
            sm.setFocusCell(orow, ocol);
		};
		
		if(curSheetId == sheetId){
			fn();
		}else{
			sheet.go2Sheet(sheetId, fn, this);
		}
	},
	
	onSelectionChange : function(sm, sels){
		if(0 < sels.length){
			var sel = sels[0];
			var index = this.store.indexOf(sel);
			if(0 < index){
				this.prevBtn.enable();
			}else{
				this.prevBtn.disable();
			}
			if(index < this.store.getCount()-1){
				this.nextBtn.enable();
			}else{
				this.nextBtn.disable();
			}
		}else{
			this.prevBtn.disable();
			this.nextBtn.disable();
		}
	},
	
	prevMatch : function(){
		var sm = this.getSelectionModel();
		var sel = sm.getSelection()[0];
		var index = this.store.indexOf(sel);
		index--;
		sm.select(index);
		var rec = this.store.getAt(index);
		this.go2Pos(rec.data.sheet, rec.data.row, rec.data.col);		
	},
	
	nextMatch : function(){
		var sm = this.getSelectionModel();
		var sel = sm.getSelection()[0];
		var index = this.store.indexOf(sel);
		index++;
		sm.select(index);
		var rec = this.store.getAt(index);
		this.go2Pos(rec.data.sheet, rec.data.row, rec.data.col);
	},
	
	/*
	 * replace the selected cell
	 */
	replaceSelect : function(){
		var txt = this.replaceField.getValue();
		var findTxt = this.searchField.getValue();
		
		var sm = this.getSelectionModel();
		var sels = sm.getSelection();
		if(0 < sels.length){
			var sel = sels[0];
			var modified, deleted;
			
			// find the data text
			var originalData = sel.data.data;
			var reg = new RegExp(findTxt, 'gi');
			if (SCOM.nullOrUndefined(txt)) txt = '';
			txt = originalData.replace(reg, txt);

			if(!SCOM.nullOrUndefined(txt) && '' != txt){			
				modified = {'data': txt};
			}else{
				deleted = ['data'];
			}
			this.sheet.setCellData(sel.data.sheet, sel.data.row, sel.data.col, modified, deleted);
		}else{
			Ext.Msg.alert(SLANG['hint'], SLANG['no_selection_replace']);
		}
	},
	
	replaceAll : function(){
		var txt = this.replaceField.getValue();
		var findTxt = this.searchField.getValue();		
		var modified, deleted;

		Ext.Msg.show({
			title: SLANG['hint'],
			msg: SLANG['really_replace_all'],
			icon: Ext.Msg.QUESTION,
			buttons: Ext.Msg.YESNO,
			fn: function(bid){
				if('yes' == bid){
					this.loadMask.show();
					Ext.Function.defer(function(){
						this.loadMask.hide();
						this.store.each(function(rec){
							
							// find the data text
							var originalData = rec.data.data;
							var reg = new RegExp(findTxt, 'gi');
							if (SCOM.nullOrUndefined(txt)) txt = '';
							var replacedTxt = originalData.replace(reg, txt);
							if(!SCOM.nullOrUndefined(replacedTxt) && '' != replacedTxt) modified = {'data': replacedTxt};
				            else deleted = ['data'];
							
							this.sheet.setCellData(rec.data.sheet, rec.data.row, rec.data.col, modified, deleted, true);
						}, this);
						/*
						 * save the change immediately.
						 */
						this.sheet.getStore().pullingAction();
						this.sheet.refreshRange(null, true);
					}, 100, this);					
				}
			},
			scope: this
		});
	}
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.toolbar.options.TableTemplateOption', {
	
	/* Begin Definitions */
	
	extend: 'Ext.container.Container',		
	
	requires: [
	    'EnterpriseSheet.sheet.menu.TableStyleMenu'
	],
	
	/* End Definitions */						
	
	optionPaneWidth: 515,
	
	scrollOffset : 18,
	
	layout: 'fit',
		
	/*
	 * bind this to sheet
	 */
	bindSheet : function(sheet){
		this.sheet = sheet;
	},		
	
	initComponent : function(){ 
				
		var lightStore = new Ext.data.Store({		    		    
		    model: 'EnterpriseSheet.sheet.model.TableTplModel'		   
		});
		
		var mediumStore = new Ext.data.Store({		    		    
			model: 'EnterpriseSheet.sheet.model.TableTplModel'		   
		});
		
		var darkStore = new Ext.data.Store({		    		    
			model: 'EnterpriseSheet.sheet.model.TableTplModel'		   
		});
		
		var tpls = EnterpriseSheet.sheet.tpl.TableTemplate.prototype.tableTplData;
		for(var i = 0, len = tpls.length; i < len; i++){
			var it = tpls[i];
			if('light' == it['type']){
				var r = lightStore.createModel(it);						
				lightStore.add(r);
			}else if('medium' == it['type']){
				var r = mediumStore.createModel(it);						
				mediumStore.add(r);							
			}else{
				var r = darkStore.createModel(it);						
				darkStore.add(r);							
			}			
		}
		
		var tpl = new Ext.XTemplate(
			'<tpl for=".">',
				'<div class="thumb-wrap">',
					'<div class="thumb"><img src="{url}"></div>',
				'</div>',
			'</tpl>',
			'<div class="x-clear"></div>'
		);

		this.lightView = new Ext.view.View({
			cls: 'images-view',
	        store: lightStore,
	        tpl: tpl,
	        autoHeight: true,
	        singleSelect: true,
	        trackOver: true,
	        overItemCls:'x-view-over',
	        itemSelector:'div.thumb-wrap'
	    });				
		
		this.mediumView = new Ext.view.View({
			cls: 'images-view',
	        store: mediumStore,
	        tpl: tpl,
	        autoHeight:true,
	        singleSelect: true,
	        trackOver: true,
	        overItemCls:'x-view-over',
	        itemSelector:'div.thumb-wrap'
	    });
		
		this.darkView = new Ext.view.View({
			cls: 'images-view',
	        store: darkStore,
	        tpl: tpl,
	        autoHeight:true,
	        singleSelect: true,
	        trackOver: true,
	        overItemCls:'x-view-over',
	        itemSelector:'div.thumb-wrap'
	    });
		
		this.items = [{
			xtype:'container',
			style:'background:white;',
			autoScroll:true,
			items:[{			
				xtype: 'button',
				style: 'margin:5px;',
				text:SLANG['clear_table_tpl'],
				handler : this.clearTableTpl,
				scope: this
			}, {
				xtype:'component',
				cls:'tpl-title',
				html:SLANG['light_color']
			}, this.lightView, {
				xtype:'component',
				cls:'tpl-title',
				html:SLANG['dark_color']
			}, this.mediumView, {
				xtype:'component',
				cls:'tpl-title',
				html:SLANG['deep_dark_color']
			}, this.darkView],
			listeners: {
				'afterrender' : function(ct){
					var el = ct.getEl(); 
					var me = this;
					me.mon(el, 'mousewheel', function(e){
						var delta = e.getWheelDelta();
						el.dom.scrollTop += -delta*me.scrollOffset;
					})
				},
				scope: this
			}
		}];
		
		this.callParent();		
		
		this.mon(this.lightView, 'itemclick', this._onClickItem, this);
		this.mon(this.mediumView, 'itemclick', this._onClickItem, this);
		this.mon(this.darkView, 'itemclick', this._onClickItem, this);
	},
	
	/*
	 * bind the sheet for handler use
	 */
	bindSheet : function(sheet){
		this.sheet = sheet;		
	},
	
	/*
	 * set tpl for selection in sheet
	 */
	setTplForSelection : function(tpl){
		var sm = this.sheet.getSelectionModel();
		var span = sm.selection2Span();
		var tableTpl = this.sheet.getTableTpl();
		if(tableTpl){
			tableTpl.setTplForSpan(span, tpl);					
		}		
	},
	
	/*
	 * clear the table tpl for selection
	 */
	clearTableTpl : function(){
		var sm = this.sheet.getSelectionModel();
		var span = sm.selection2Span();
		var tableTpl = this.sheet.getTableTpl();
		if(tableTpl){
			tableTpl.clearTplForSpan(span);
		}		
	},
	
	_onClickItem : function(dv, rec){				
		var tpl = rec.data.tpl;
		if(tpl){
			this.setTplForSelection({'id':rec.data.id});			
		}				
		this.fireEvent('done', this);
	}
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.toolbar.pieces.BackgroundColorButton', {
	
	/* Begin Definitions */
	
	extend : 'EnterpriseSheet.common.ColorButton',	
		
	/* End Definitions */
	
	/*
	 * define the initial fill color
	 */
	initialColor : '#C0504D',	
	
	iconCls:'icon-paintcan',
	
	themeColorStr:SLANG['theme_colors'],
	
	standardColorStr:SLANG['standard_colors'],	

	initComponent : function(){		
	    this.currentFillColor = this.initialColor;
	    
		this.menu = [{
	        text: SLANG['no_fill_color'],
            cls: 'no-fill-color-item',
	        handler:this.onNoFillColor,
	        scope:this
	    }];
		
		this.callParent();		
	},
	
	
	/*
	 * bind sheet for handler use
	 */
	bindSheet : function(sheet){
		this.sheet = sheet;
	},
	
	/*
	 * for select fill color
	 */
	selectHandler : function(cp, color){
		/*
		 * keep the color we selected
		 */
		this.currentFillColor = color;
		this.fillColor(this.currentFillColor);
	},
	
	handler : function(){
		this.fillColor(this.currentFillColor);	
	},
	
	onNoFillColor : function(){
		this.currentFillColor = null;
		this.fillColor();
		/*
		 * sysn the color of the button
		 */
		this.setColor();
		this.menu.hide();
	},
	 
	fillColor : function(color){		
		this.sheet.setPropertyForSelection({
			bgc:color || ''
		});		
	}
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.toolbar.pieces.BorderButton', {
	
	/* Begin Definitions */
	
	extend: 'Ext.button.Split',	
	
	requires: [	    
	    'EnterpriseSheet.common.Common',       
	    'Ext.picker.Color'
	],
		
	/* End Definitions */
	
	iconCls:'icon-border-bottom',
	
	initComponent : function(){
		
		this.menu = new Ext.menu.Menu({
			items:['<b class="menu-title">'+SLANG['border_style']+'</b>', {
	            iconCls:'icon-border-bottom',
	            text:SLANG['border_bottom'],
	            handler:this.onBorderBottom,
	            scope:this
	        }, {
	            iconCls:'icon-border-top',
	            text:SLANG['border_top'],
	            handler:this.onBorderTop,
	            scope:this
	        }, {
	            iconCls:'icon-border-left',
	            text:SLANG['border_left'],
	            handler:this.onBorderLeft,
	            scope:this
	        }, {
	            iconCls:'icon-border-right',
	            text:SLANG['border_right'],
	            handler:this.onBorderRight,
	            scope:this
	        }, '-', {
	            iconCls:'icon-border-none',
	            text:SLANG['border_none'],
	            handler:this.onBorderNone,
	            scope:this
	        }, {
	            iconCls:'icon-border-all',
	            text:SLANG['border_all'],
	            handler:this.onBorderAll,
	            scope:this
	        }, {
	            iconCls:'icon-border-outside',
	            text:SLANG['border_outside'],
	            handler:this.onBorderOutside,
	            scope:this
	        }, {
	            iconCls:'icon-bold-border-outside',
	            text:SLANG['bold_border_outside'],
	            handler:this.onBoldBorderOutside,
	            scope:this
	        }, '-', {
	            iconCls:'icon-double-border-bottom',
	            text:SLANG['double_border_bottom'],
	            handler:this.onDoubleBorderBottom,
	            scope:this
	        }, {
	            iconCls:'icon-bold-border-bottom',
	            text:SLANG['bold_border_bottom'],
	            handler:this.onBoldBorderBottom,
	            scope:this
	        }, {
	            iconCls:'icon-border-top-bottom',
	            text:SLANG['border_top_bottom'],
	            handler:this.onBorderTopBottom,
	            scope:this
	        }, {
	            iconCls:'icon-border-top-bottombold',
	            text:SLANG['border_top_bottom_bold'],
	            handler:this.onBorderTopBottomBold,
	            scope:this
	        }, {
	            iconCls:'icon-border-top-bottomdouble',
	            text:SLANG['double_border_bottom_top_border'],
	            handler:this.onBorderTopBottomDouble,
	            scope:this
	        }, /**'<b class="menu-title">'+SLANG['paint_border']+'</b>', {
	        	iconCls:'icon-paint-border',
	            text:SLANG['paint_border'],
	            handler:this.onPaintBorder,
	            scope:this
	        }, **/ {
	        	iconCls:'icon-clean-border',
	            text:SLANG['clean_border'],
	            handler:this.onBorderNone,
	            scope:this
	        }, {
	        	iconCls:'icon-border-color',
	            text:SLANG['border_color'],
	            menu:new Ext.menu.Menu({
					cls:'color-menu',
					plain:true,
					style:'padding-left:5px;background-position:-30px 0;',
					items:['<b class="menu-title">'+SLANG['theme_colors']+'</b>', new Ext.picker.Color({
				        allowReselect:true,
				        style:'height:120px;width:185px;',
				        colors:SCOM['themeColors'],
				        listeners:{
				        	'select':{
				        		fn:this.onSelectBorderColor,
				        		scope:this
				        	}
				        }
				    }), '<b class="menu-title">'+SLANG['standard_colors']+'</b>', new Ext.picker.Color({
				        allowReselect:true,
				        style:'width:185px;height:80px;',
				        listeners:{
				        	'select':{
				        		fn:this.onSelectBorderColor,
				        		scope:this
				        	}
				        }
				    })]
				})
	        }, {
	            text:SLANG['line_style'],
	            menu:new Ext.menu.Menu({
	            	//plain:true,
	            	items:[{
	            		checked:true,
	            		group:'line-style',
		            	text:'&nbsp;',
		            	cls: 'ls-solid',
		            	handler:this.onSolidLine,
		            	scope:this
		            }, {
		            	checked: false,
		            	group:'line-style',
		            	text:'&nbsp;',
		            	cls: 'ls-dotted',
		            	handler:this.onDottedLine,
		            	scope:this
		            }, {
		            	checked: false,
		            	group:'line-style',
		            	text:'&nbsp;',
		            	cls: 'ls-dashed',
		            	handler:this.onDashedLine,
		            	scope:this
		            }, {
		            	checked: false,
		            	group:'line-style',
		            	text:'&nbsp;',
		            	cls: 'ls-dotted2',		            	
		            	handler:this.onBoldDottedLine,
		            	scope:this
		            }, {
		            	checked: false,
		            	group:'line-style',
		            	text:'&nbsp;',
		            	cls: 'ls-dashed2',		            	
		            	handler:this.onBoldDashedLine,
		            	scope:this
		            }, {
		            	checked: false,
		            	group:'line-style',
		            	text:'&nbsp;',
		            	cls: 'ls-solid2',		            	
		            	handler:this.onBoldSolidLine,
		            	scope:this
		            }, {
		            	checked: false,
		            	group:'line-style',
		            	text:'&nbsp;',
		            	cls: 'ls-double',		            	
		            	handler:this.onDoubleLine,
		            	scope:this
		            }, {
		            	checked: false,
		            	group:'line-style',
		            	text:'&nbsp;',
		            	cls: 'ls-solid3',		            	
		            	handler:this.onTriSolidLine,
		            	scope:this
		            }]
	            })
	        }/**, {
	            text:SLANG['other_borders']+'...',
	            handler:this.onOtherBorders,
	            scope:this
	        }**/]
		});
		
		this.handler = this.onBorder = this.onBorderBottom;
		
		this.callParent();		
	},
	
	/*
	 * bind sheet for handler use
	 */
	bindSheet : function(sheet){
		this.sheet = sheet;
	},
	
	/*
	 * for change border functions
	 */
	onBorderAll : function(btn){		
		this.setRangeBorder('all');		
		this.setIconCls(btn.iconCls);	
		this.handler = this.onBorderAll;
	},
	
	onBorderNone : function(btn){
		var s = this.sheet.getStore();
		this.setRangeBorder('all', '', 1, 'solid');
		this.setIconCls(btn.iconCls);	
		this.handler = this.onBorderNone;
	},
	
	onBorderTop : function(btn){
		this.setRangeBorder('top');
		this.setIconCls(btn.iconCls);	
		this.handler = this.onBorderTop;
	},
	
	onBorderBottom : function(btn){
		this.setRangeBorder('bottom');
		this.setIconCls(btn.iconCls);	
		this.handler = this.onBorderBottom;
	},
	
	onBorderLeft : function(btn){
		this.setRangeBorder('left');
		this.setIconCls(btn.iconCls);	
		this.handler = this.onBorderLeft;
	},
	
	onBorderRight : function(btn){
		this.setRangeBorder('right');
		this.setIconCls(btn.iconCls);	
		this.handler = this.onBorderRight;
	},
	
	onBorderTopBottom : function(btn){
		this.setRangeBorder('topbottom', null, 1, 'solid');
		this.setIconCls(btn.iconCls);	
		this.handler = this.onBorderTopBottom;
	},
	
	onBorderOutside : function(btn){
		this.setRangeBorder('outside');
		this.setIconCls(btn.iconCls);	
		this.handler = this.onBorderOutside;
	},
	
	onBoldBorderOutside : function(btn){
		this.setRangeBorder('outside', null, 2);
		this.setIconCls(btn.iconCls);	
		this.handler = this.onBoldBorderOutside;
	},
	
	onDoubleBorderBottom : function(btn){
		this.setRangeBorder('bottom', null, 3, 'double');
		this.setIconCls(btn.iconCls);	
		this.handler = this.onDoubleBorderBottom;
	},
	
	onBoldBorderBottom : function(btn){
		this.setRangeBorder('bottom', null, 2);
		this.setIconCls(btn.iconCls);	
		this.handler = this.onBoldBorderBottom;
	},
	
	onBorderTopBottomBold : function(btn){
		this.setRangeBorder('top', null, 1, 'solid', true);
		this.setRangeBorder('bottom', null, 2, 'bold');
		this.setIconCls(btn.iconCls);	
		this.handler = this.onBorderTopBottomBold;
	},
	
	onBorderTopBottomDouble : function(btn){
		this.setRangeBorder('top', null, 1, 'solid', true);
		this.setRangeBorder('bottom', null, 3, 'double');		
		this.setIconCls(btn.iconCls);	
		this.handler = this.onBorderTopBottomDouble;
	},
	
	onSelectBorderColor : function(cp, color){
		/*
		 * hide the menu
		 */
		this.menu.hide();
		this.borderColor = '#'+color;
	},
	
	onPaintBorder : function(btn){
		
	},
	
	onSolidLine : function(){
		this.borderWidth = 1;
		this.borderStyle = 'solid';
	},
	
	onDottedLine : function(){
		this.borderWidth = 1;
		this.borderStyle = 'dotted';
	},
	
	onDashedLine : function(){
		this.borderWidth = 1;
		this.borderStyle = 'dashed';
	},
	
	onBoldDottedLine : function(){
		this.borderWidth = 2;
		this.borderStyle = 'dotted';
	},
	
	onBoldDashedLine : function(){
		this.borderWidth = 2;
		this.borderStyle = 'dashed';
	},	
	
	onBoldSolidLine : function(){
		this.borderWidth = 2;
		this.borderStyle = 'solid';
	},	
	
	onDoubleLine : function(){
		this.borderWidth = 3;
		this.borderStyle = 'double';
	},
	
	onTriSolidLine : function(){
		this.borderWidth = 3;
		this.borderStyle = 'solid';
	},					
	 
	/*
	 * this function provide a interface to set a border for the selection range
	 * @param {string} dir: the direction of the border, should be one of ['l', 'r', 't', 'b']
	 * @param {string} color: the color of the border
	 * @param {int} width: the width of the border
	 * @param {string} style: the style of the broder
	 * @param {boolean} suspendRefresh: a flag to suspend the refresh action for ss
	 */
	setRangeBorder : function(dir, color, width, style, suspendRefresh){
		dir = dir || 'all';
		if(false == SCOM.typeOf(color)){
			color = this.borderColor || 'black';
		}
		
		if(false == SCOM.typeOf(width)){
			width = this.borderWidth || 1;
		}
		
		if(false == SCOM.typeOf(style)){
			style = this.borderStyle;
		}
		
		this.sheet.setRangeBorder(dir, color, width, style, suspendRefresh);		
	}
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.toolbar.pieces.BrushButton', {
	
	/* Begin Definitions */
	
	extend: 'Ext.button.Button',		
	
	/* End Definitions */
	
	initComponent : function(){
		this.enableToggle = true;
		if(this.sheet){
			this.handler = this.onBrush;
		}
		this.callParent();
	},
	
	bindSheet : function(sheet){
		this.sheet = sheet;
		this.handler = this.onBrush;
	},
	
	/**
	 * go brush
	 */
	onBrush : function(){
		var sheet = this.sheet;
		if(this.pressed){					
			this.brush = Ext.core.DomHelper.append(document.body, 
				'<div class="ss-brush icon-brush" style="z-index:'+SCONST['TOP_Z_INDEX']+';"></div>', true);	
			this.brush.hide();
			Ext.getDoc().on('mousemove', this.moveBrush, this);
			this.mon(sheet, 'cellmouseup', this.cancelBrush, this, {single:true});
			/*
			 * show reference of the selection
			 */			
			var sm = sheet.getSelectionModel(), rm = sheet.getReferenceModel();
			this.brushFromCoord = sm.selection2Coord();			
			//rm.setReference(this.brushFromCoord);
			//rm.show();
		}else{			
			sheet.un('cellmouseup', this.cancelBrush, this, {single:true});
			this.cancelBrush();
		}	
	},
	
	/*
	 * moving the brush with the mouse
	 */
	moveBrush : function(e){
		if(this.brush){
			var xy = e.getXY();
			var sel = this.sheet.getEl();
			var left = sel.getLeft(), top = sel.getTop(), right = sel.getRight(), bottom = sel.getBottom();
			if(left <= xy[0] && xy[0] <= right && top <= xy[1] && xy[1] <= bottom){
				var x = xy[0]+16, y = xy[1]-5;
				this.brush.setLeft(x);
				this.brush.setTop(y);
				this.brush.show();
			}else{
				this.brush.hide();
			}
		}
	},
	
	/*
	 * cancel the brush, remove the element and cancel the moving listener
	 */
	cancelBrush : function(region, e){
		
		var sheet = this.sheet;
		if(region && e){
			var sm = sheet.getSelectionModel();
			var fromSpan = this.brushFromCoord[0];
			var toSpan = sm.selection2Span();
			var res = sm.calculateRowColSpan(fromSpan);
			if(!res.hasMerged){
				res.hasMerged = true;
				res.rowSpan = fromSpan[3]-fromSpan[1]+1;
				res.colSpan = fromSpan[4]-fromSpan[2]+1;
			}
			toSpan = sm.adjustToSpanForMerged(fromSpan, toSpan, res);
			if(toSpan){
				/*
				 * apply the brush on the selection
				 */
				sheet.applyBrush(this.brushFromCoord, [toSpan]);
			}else{
				Ext.Msg.alert(SLANG['hint'], SLANG['target_range_shouldbe_same_size']);
			}			
		}
		Ext.removeNode(this.brush.dom);
		delete(this.brush);
		Ext.getDoc().on('mousemove', this.moveBrush, this);
		/*
		 * hide reference
		 */		
		//var rm = sheet.getReferenceModel();		
		//rm.hide();
		this.toggle(false, true);
	}
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.toolbar.pieces.FontColorButton', {
	/* Begin Definitions */
	
	extend : 'EnterpriseSheet.common.ColorButton',				
	
	/* End Definitions */
	
	iconCls:'icon-font',
	
	themeColorStr:SLANG['theme_colors'],
	
	standardColorStr:SLANG['standard_colors'],
	
	/*
	 * bind sheet for handler use
	 */
	bindSheet : function(sheet){
		this.sheet = sheet;
	},
	
	/*
	 * for font color functions
	 */
	selectHandler : function(cp, color){
		Ext.Function.defer(function(){
			var editor = this.sheet.editor;
			if(editor && editor.isVisible()){
				editor.focus();				
			}
			var ss = this.sheet;
			var fc = this.fontColor = color;
			if(false !== ss.fireEvent('cmd', 'forecolor', fc, ss)){
				ss.setPropertyForSelection({
					color:fc
				});
			}
		}, 10, this);		
	},
	
	handler : function(){
		var fc = this.fontColor;
		var ss = this.sheet;
		if(false !== ss.fireEvent('cmd', 'forecolor', fc, ss)){
			ss.setPropertyForSelection({
				color:fc
			});
		}
	}
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.toolbar.pieces.FontFamilyButton', {
	
	/* Begin Definitions */
	
	extend: 'Ext.button.Button',	
	
	requires: ['EnterpriseSheet.common.Common'],
		
	/* End Definitions */
		
	defaultValue:'Arial',
    
    minWidth: 125,
    
    textAlign: 'right',
        
	initComponent : function(){
						
		this.store = SCOM.fontFamilyStore;
		
		var items = [], text;		
		this.store.each(function(rec){
			if(this.defaultValue == rec.data.id){
				text = rec.data.text;
			}
			items.push({
				ff: rec.data.id,
				text: rec.data.text,
				handler: this.onFontFamilySelect,
				scope: this
			});
		}, this);
		
		this.text = text;
		this.menu = items;
		
		this.callParent();			
	},
	
	/*
	 * bind sheet for handler use
	 */
	bindSheet : function(sheet){
		this.sheet = sheet;
	},
		
	onFontFamilySelect : function(item){		
		var editor = this.sheet.editor;
		if(editor && editor.isVisible()){
			editor.focus();				
		}			
		var ff = item.ff;
		var ss = this.sheet;
		if(false !== ss.fireEvent('cmd', 'fontName', ff, ss)){
			ss.setPropertyForSelection({
				ff:ff
			});					
		}
		this.setText(item.text);
	},
	
	setFontFamily : function(ff){
		var text = ff || this.defaultValue;
		this.store.each(function(rec){
			if(ff == rec.data.id){
				text = rec.data.text;
				return false;
			}			
		}, this);
		this.setText(text);
	}
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.toolbar.pieces.FontFamilyCombo', {
	
	/* Begin Definitions */
	
	extend: 'Ext.form.field.ComboBox',	
	
	requires: ['EnterpriseSheet.common.Common'],
		
	/* End Definitions */
	
	displayField:'text',
	
    valueField:'id',
    
    value:'Arial',
    
    typeAhead:true,
    
    queryMode:'local',
    
    triggerAction:'all',
    
    forceSelection : true,               
    	
	initComponent : function(){
						
		this.store = SCOM.fontFamilyStore;
		
		this.callParent();
		
		this.on('select', this.onFontFamilySelect, this);
	},
	
	/*
	 * bind sheet for handler use
	 */
	bindSheet : function(sheet){
		this.sheet = sheet;
	},
		
	onFontFamilySelect : function(cb, sels){		
		/*
		 * the combox will take the cursor from editor, need force to get back after
		 * combo seleted
		 */
		Ext.Function.defer(function(){
			var editor = this.sheet.editor;
			if(editor && editor.isVisible()){
				editor.focus();				
			}
			var rec = sels[0];
			var ff = rec.data.id;
			var ss = this.sheet;
			if(false !== ss.fireEvent('cmd', 'fontName', ff, ss)){
				ss.setPropertyForSelection({
					ff:ff
				});					
			}
		}, 10, this);
	}
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.toolbar.pieces.FontSizeButton', {
	
	/* Begin Definitions */
	
	extend: 'Ext.button.Button',	
	
	requires: ['EnterpriseSheet.common.Common'],
		
	/* End Definitions */				
    
    defaultValue:'10',  
    
    minWidth: 50,
	
	initComponent : function(){
		
		this.store = SCOM.fontSizeStore;
		
		var items = [], text;		
		this.store.each(function(rec){
			if(this.defaultValue == rec.data.id){
				text = rec.data.text;
			}
			items.push({
				fontsize: rec.data.id,
				text: rec.data.text,
				handler: this.onFontSizeSelect,
				scope: this
			});
		}, this);
		
		this.text = text;
		this.menu = items;
		
		this.callParent();	
	},
	
	/*
	 * bind sheet for handler use
	 */
	bindSheet : function(sheet){
		this.sheet = sheet;
	},
	
	onFontSizeSelect : function(item){		
		var editor = this.sheet.editor;
		if(editor && editor.isVisible()){
			editor.focus();				
		}
		var ss = this.sheet;					
		if(false !== ss.fireEvent('cmd', 'fontSize', item.fontsize, ss)){					
			ss.setPropertyForSelection({
				fz: item.fontsize
			});
		}
		this.setText(item.text);
	},
	
	setFontSize : function(fz){
		var text = fz || this.defaultValue;
		this.store.each(function(rec){
			if(fz == rec.data.id){
				text = rec.data.text;
				return false;
			}			
		}, this);
		this.setText(text);
	}
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.toolbar.pieces.FontSizeCombo', {
	
	/* Begin Definitions */
	
	extend: 'Ext.form.field.ComboBox',	
	
	requires: ['EnterpriseSheet.common.Common'],
		
	/* End Definitions */		
	
	displayField:'text',
	
    valueField:'id',
    
    value:'14',
    
    typeAhead:true,
    
    queryMode:'local',
    
    triggerAction:'all',
    
    forceSelection : true,        
	
	initComponent : function(){
		
		this.store = SCOM.fontSizeStore;
		
		this.callParent();
		
		this.on('select', this.onFontSizeSelect, this);
	},
	
	/*
	 * bind sheet for handler use
	 */
	bindSheet : function(sheet){
		this.sheet = sheet;
	},
	
	onFontSizeSelect : function(cb, sels){		
		/*
		 * the combox will take the cursor from editor, need force to get back after
		 * combo seleted
		 */
		Ext.Function.defer(function(){
			var editor = this.sheet.editor;
			if(editor && editor.isVisible()){
				editor.focus();				
			}
			var ss = this.sheet;		
			var rec = sels[0];
			if(false !== ss.fireEvent('cmd', 'fontSize', rec.data.id, ss)){					
				ss.setPropertyForSelection({
					fz:rec.data.id
				});
			}
		}, 10, this);
	}
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.toolbar.pieces.MoneyButton', {

	/* Begin Definitions */

	extend : 'Ext.button.Split',

	requires : [
        'EnterpriseSheet.sheet.menu.TextFormatMenu',
        'EnterpriseSheet.sheet.pop.MoneySelectWin',
        'EnterpriseSheet.sheet.menu.CustomFormatMenu',
        'EnterpriseSheet.sheet.pop.NumberSpecialWin'
    ],

	/* End Definitions */

	iconCls : 'icon-money',

	overflowText : SLANG['currency'],

	initComponent : function() {

		this.formatMenu = new EnterpriseSheet.sheet.menu.TextFormatMenu({
			minWidth : 160
		});
		
		this.customMenu = new EnterpriseSheet.sheet.menu.CustomFormatMenu({
			minWidth : 170
		});

		this.menu = [{
			iconCls : 'icon-dollar',
			name: 'usd',
			text : SLANG['money_us_dollar'],
			handler : this.onPopMoney,
			scope : this
		}, {
			iconCls : 'icon-rmb',
			text : SLANG['money_china_rmb'],
			name: 'rmb',
			handler : this.onPopMoney,
			scope : this
		}, {
			iconCls : 'icon-euro',
			name: 'eur',
			text : SLANG['money_european_euro'],
			handler : this.onPopMoney,
			scope : this
		}, {
			iconCls : 'icon-jap',
			name: 'jpy',
			text : SLANG['money_japanese_yen'],
			handler : this.onPopMoney,
			scope : this
		},{
			iconCls : 'icon-rupee',
			name: 'inr',
			text : SLANG['money_indian_rupee'],
			handler : this.onPopMoney,
			scope : this
		}, {
			iconCls : 'icon-pound',
			name: 'gbp',
			text : SLANG['money_english_pound'],
			handler : this.onPopMoney,
			scope : this
		}, {
			text: SLANG['more'] + '...',
			handler : this.onPopMoney,
			scope: this
		}, '-', {
			text : SLANG['number_format'],
			menu : this.formatMenu
		}, {
			iconCls: 'icon-custom',
			text : SLANG['custom'],
			menu : this.customMenu
		}, {
			text : SLANG['number_special'],
			handler : this.onNumberSpecial,
			scope : this
		}];
		
		this.handler = this.onPopMoney;

		this.callParent();

		this.mon(this.formatMenu, {
			scope : this,
			'show' : this.onFormatMenuShow
		});
	},
	
	// this is function to popup money window ...
	onPopMoney : function(item) {
		if(!this.openMoneyWin){
			this.openMoneyWin = Ext.create("EnterpriseSheet.sheet.pop.MoneySelectWin", {});
			this.openMoneyWin.bindSheet(this.sheet);
    	}
	
        if (item && item.name) this.openMoneyWin.popup(item.name);
        else this.openMoneyWin.popup();
	},
	
	onNumberSpecial : function(item) {
		if(!this.numberSpecialWin){
			this.numberSpecialWin = Ext.create("EnterpriseSheet.sheet.pop.NumberSpecialWin", {});
			this.numberSpecialWin.bindSheet(this.sheet);
    	}
	
        this.numberSpecialWin.popup();
	},

	onFormatMenuShow : function() {
		var sheet = this.sheet;
		if (sheet) {
			/*
			 * preview the text format
			 */
			var sm = sheet.getSelectionModel(), store = sheet.getStore();
			var focus = sm.getFocusCell();
			var cell = sheet.getCellValue(sheet.getSheetId(), focus.row, focus.col);

			this.formatMenu.previewTextFormat(cell.data);
		}
	},

	/*
	 * bind the sheet for handler use
	 */
	bindSheet : function(sheet) {
		this.sheet = sheet;
		this.formatMenu.bindSheet(sheet);
		this.customMenu.bindSheet(sheet);
	}
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
/*
 * the class for text format combo, 
 * we made it a stand alone class cause it may need reuse in other place of sheet
 */
Ext.define('EnterpriseSheet.sheet.toolbar.pieces.TextFormatCombo', {
	
	/* Begin Definitions */
	
	extend: 'Ext.form.field.ComboBox',	
	
	requires: ['EnterpriseSheet.common.Common', 'Ext.toolbar.Toolbar'],
		
	/* End Definitions */		
	
	displayField : 'text',
	
    valueField : 'id',       
    
    typeAhead : true,
    
    queryMode : 'local',
    
    triggerAction : 'all',
    
    selectOnFocus : true,
    
    forceSelection : true,        
    
    value : 'regular',        
    
    initComponent : function(){
    	this.listConfig = {
        	minWidth : 250,
        	getInnerTpl : function(display){
        		return ['<div class="ss-textformat icon-{id}32">',
        		    '<b>{text}</b><br>',
        			'{preview}',
        		'</div>'].join('');
        	},
        	pagingToolbar : new Ext.toolbar.Toolbar({
        		style: 'border-left:none;border-right:none;border-bottom:none;',
    			items:[{
    				text:SLANG['number_format']+'...',
    				handler:this.onOtherFormat,
    				scope:this
    			}],
    			bindStore: Ext.emptyFn
    		})
        };
        
    	this.store = SCOM.textFormatStore;
    	
    	this.callParent();    	
    	
    	this.on({
    		scope:this,
    		'select':this.selectTextFormat,
    		'expand':this.onDropListExpand
    	});
    },
    
    /*
     * bind sheet, bind this combo to a sheet, which will use for changing the text format
     */
    bindSheet : function(sheet){
    	this.sheet = sheet;
    },
        
    onOtherFormat : function(){
    	
    },
    
    /*
     * handler for select, it will change the text format of selection
     */
    selectTextFormat : function(pick, sels){    	
    	var sheet = this.sheet;
    	if(sheet){    		    		  
    		var value = sels[0].data.id; 
    		sheet.setTextFormatForSelection(value);
    	}
    },
    
    /*
     * preview the different formats for focus data
     */
    previewTextFormat : function(data){
    	if(data){
    		var rds = this.store.getRange();
    		for(var i = 0, len = rds.length; i < len; i++){
    			var rd = rds[i];
    			var preview = SFORMAT.transferFormat({data:data}, rd.data.id).data;    			
    			rd.set('preview', preview);
    		}
    	}else{
    		var rds = this.store.getRange();
    		for(var i = 0, len = rds.length; i < len; i++){
    			rds[i].set('preview', null);
    		}
    	}
    },
    
    /*
     * when drop list expand, we will try to show preview
     */
    onDropListExpand : function(){
    	var sheet = this.sheet;
    	if(sheet){
			/*
			 * preview the text format
			 */
    		var sm = sheet.getSelectionModel(), store = sheet.getStore();
    		var focus = sm.getFocusCell();
    		var cell = store.getCell(sheet.getSheetId(), focus.row, focus.col, true);    		
    		this.previewTextFormat(cell.data);
		}
    },
    
    /*
     * override setValue
     */
    setValue : function(v){
    	v = v || 'regular';
    	var moneySet = {
    		'rmb':'money',
    		'pound':'money',
    		'dollar':'money',
    		'euro':'money'
    	};
    	v = moneySet[v] || v;
    	
    	this.callParent([v]);    	
    }
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.toolbar.Contentbar', {
	
	/* Begin Definitions */
	
	extend: 'Ext.container.Container',	
	
	requires: [
	   	'EnterpriseSheet.common.Common',
	   	'EnterpriseSheet.common.SimpleButton',
	   	'EnterpriseSheet.sheet.editor.ContentEditor',
	   	'EnterpriseSheet.sheet.pop.ReferenceNameList'
	],
	   	
	/* End Definitions */	
	
	cls: 'ss-content-bar',
	
	height: 23,
	
	collapsedHeight : 23,
	
	epxandHeight: 63,
	
	layout: {
		type: 'hbox',
		align: 'stretch'
	},
		
	initComponent : function(){
		
		this.anchorBtn = new EnterpriseSheet.common.SimpleButton({
			iconCls: 'icon-anchor',			
			width: 25,
			style: 'background-position:center center;',
			color: 'silver',
			handler:this.doAnchor,
			scope:this
		});
		
		this.posBox = new Ext.Component({
			style: 'padding:3px;text-align:center;',
			width: 107
		});
		
		this.splitBtn = new EnterpriseSheet.common.SimpleButton({
			iconCls: 'icon-hbar',
			//style: 'cursor:e-resize;',
			width: 20,				
			color: 'silver',
			handler: this.showNameList,
			scope: this
		});
		
		this.enterBtn = new EnterpriseSheet.common.SimpleButton({
			iconCls: 'icon-check',				
			style: 'background-position:center center;',
			disabled: true,
			width: 24,				
			color: 'silver',
			handler: function(){			
				this.contentBox.completeEdit();
				this.contentBox.blurOff();
				this.sheet.fireEvent('loseeditingfocus', this.sheet);
				this.onSheetChange();
			},
			scope: this
		});
		
		this.escBtn = new EnterpriseSheet.common.SimpleButton({
			iconCls: 'icon-cross',			
			style: 'background-position:center center;',
			disabled: true,
			width: 24,				
			color: 'silver',
			handler: function(){				
				this.contentBox.cancelEdit();
				this.contentBox.blurOff();
				this.sheet.fireEvent('loseeditingfocus', this.sheet);
				this.onSheetChange();				
			},
			scope: this
		});
		
		this.contentBox = new EnterpriseSheet.sheet.editor.ContentEditor({						
			flex: 1
		});
		
		this.expandBtn = new EnterpriseSheet.common.SimpleButton({
			iconCls: 'icon-list-drop',
			width: 20,
			color: 'silver',
			handler: this.toggleContentbar,
			scope: this
		});
		
		this.items = [
		    this.anchorBtn,
		    this.posBox, 
		    this.splitBtn,
		    this.enterBtn,
		    this.escBtn,
		    this.contentBox,
		    this.expandBtn
		];
		
		this.callParent(arguments);
		
		this.contentBox.on({
			scope: this,
			'afterstartedit': function(){
				this.enterBtn.enable();
				this.escBtn.enable();
			},
			'quit': function(){
				this.enterBtn.disable();
				this.escBtn.disable();
			}
		});
	},
		
	/*
	 * init as a plugin of EnterpriseSheet.Sheet
	 */
	init : function(sheet){		
		if(this.sheet){
			return;
		}
		this.sheet = sheet;				
		
		this.contentBox.init(sheet);
		
		this.mon(sheet, 'focuschange', this.checkFocusChange, this);		
        this.mon(sheet, 'changereadonly', this.onChangeReadOnly, this);
		this.mon(sheet, 'focuschange', this.onFocusChange, this, {buffer: 100});
		this.mon(sheet, 'selectionchange', this.onSelectionChange, this, {buffer: 50});
		
		var store = sheet.getStore();
		this.mon(store, 'renamesheet', this.refreshContentBox, this);
		this.mon(store, 'deletesheet', this.refreshContentBox, this);
           
        this.contentBox.on({
            scope: this,
            'editorfocus': this.onEditorFocus
        });
        
	},
	
	doAnchor : function(){
		this.sheet.go2LeftTop();
		this.sheet.focus(this.sheet.focusDelayTime);
	},
	
	checkFocusChange : function(row, col, sm, cd){		
		var ss = this.sheet, editor = ss.getEditor();		
		var sheetId = ss.getSheetId();
		var store = ss.getStore();
		
		var contentBox = this.contentBox;
		if(ss.isReadOnly() || store.isDisabledCell(sheetId, row, col)){
            if(!contentBox.inputing){
                contentBox.disable();
			}
		}else{
			contentBox.enable();
		}
	},
           
    onEditorFocus : function(){
        var store = this.sheet.getStore();
        if(this.focusCell){
            var row = this.focusCell.row, col = this.focusCell.col;
            var boxEl = this.posBox.getEl();
            if(boxEl){
                boxEl.removeCls('ss-cross-pos');
            }
            this.posBox.update(store.getColName(col)+row);
        }
        
    },
           
    onChangeReadOnly : function(readOnly, sheet){
		var contentBox = this.contentBox;
        if(readOnly){
            if(!contentBox.inputing){
                contentBox.disable();
            }
        }else{
           contentBox.enable();
        }
    },
    
    onSheetChange : function(){
    	var sm = this.sheet.getSelectionModel(), store = this.sheet.getStore();
    	var focusCell = sm.getFocusCell();
    	this.onFocusChange(focusCell.row, focusCell.col, sm, store.getCell(store.getActivedSheetId(), focusCell.row, focusCell.col));
    },
	
	/*
	 * update the pos field when focus cell changed
	 */
	onFocusChange : function(row, col, sm, cd){		
		var ss = this.sheet, editor = ss.getEditor();		
		var sheetId = ss.getSheetId();
		var store = ss.getStore();			
		
		var contentEditing = this.contentBox.isEditing(), editing = editor.isEditing();
		if(!contentEditing && !editing){			
			if(0 == row){
				row = 1;
			}
			if(0 == col){
				col = 1;
			}
			/*
			 * save this cell as the focus cell
			 */
			this.focusCell = {
				row:row,
				col:col
			};
			var boxEl = this.posBox.getEl();
            if(boxEl){
                boxEl.removeCls('ss-cross-pos');
            }
			this.posBox.update(store.getColName(col)+row);
				
			var data = cd.data;
			if(SCOM.nullOrUndefined(data)){
				data = '';
			}
			
            if(Ext.isNumber(cd.afrow)){
                var afrow = cd.afrow+row, afcol = cd.afcol+col;
                if(afrow === row && afcol === col){
                    this.contentBox.setValue('{'+Ext.htmlEncode(data)+'}');
                }else{
                    var afCell = store.getCell(sheetId, afrow, afcol);
                    this.contentBox.setValue('{'+Ext.htmlEncode(afCell.data)+'}');
                }
            }else{
            	/*
            	 * update only if it's not editing
            	 */
            	this.contentBox.setValue(Ext.htmlEncode(data));
            }
		}else{		
			var curEditor = contentEditing ? this.contentBox : editor;
			if(curEditor.sheetId != sheetId){
				var sheetName = store.getSheetNameById(curEditor.sheetId);
				var boxEl = this.posBox.getEl();
                if(boxEl){
                    boxEl.addCls('ss-cross-pos');
                }
				this.posBox.update(sheetName+'!'+store.getColName(curEditor.col)+curEditor.row);
			}else{
				var boxEl = this.posBox.getEl();
                if(boxEl){
                    boxEl.removeCls('ss-cross-pos');
                }
				this.posBox.update(store.getColName(curEditor.col)+curEditor.row);
			}
		}
	},
	
	refreshContentBox : function(){
		if(this.focusCell){
			var store = this.sheet.getStore();
			var cd = store.getCellData(store.getActivedSheetId(), this.focusCell.row, this.focusCell.col);
			var data = cd.data || '';			
			
			this.contentBox.setValue(Ext.htmlEncode(data));
		}
	},
	
	/*
	 * update the pos filed when selecton is changing
	 */
	onSelectionChange : function(startPos, endPos, region, sm){		
		if(startPos){
			var rowSpan = Math.abs(startPos.row-endPos.row)+1, colSpan = Math.abs(startPos.col-endPos.col)+1;
			if(1 == rowSpan && 1 == colSpan){
				//this.posBox.update(store.getColName(this.focusCell.col)+this.focusCell.row);
			}else if(1 == rowSpan){
				this.posBox.update(colSpan+'C');
			}else if(1 == colSpan){
				this.posBox.update(rowSpan+'R');
			}else{
				this.posBox.update(rowSpan+'R x '+colSpan+'C');
			}
		}		
	},
	
	/*
	 * expand or collapse the content bar
	 */
	toggleContentbar : function(btn){
		if('icon-list-drop' == btn.iconCls){
			btn.setIconCls('icon-list-collapse');
			this.setHeight(this.epxandHeight);
		}else{
			btn.setIconCls('icon-list-drop');
			this.setHeight(this.collapsedHeight);
		}
        var editor = this.sheet.getEditor();
        if(editor){
            editor.syncPosition();   
        }
	},
	
	/**
	 * show the name range list
	 */
	showNameList : function(btn){
		var sheet = this.sheet, store = sheet.getStore();
		var refs = store.getRefConfig();
		if(!this.nameList){
			
			this.nameList = new EnterpriseSheet.sheet.pop.ReferenceNameList({						
				sheet: sheet,
				refList: refs
			});
		}else{
			this.nameList.loadRefList(refs);
		}
		this.nameList.showBy(btn.getEl());
	}
});
Ext.define('EnterpriseSheet.sheet.toolbar.SheetTabbar', {
	
	/* Begin Definitions */
	
	extend: 'Ext.container.Container',	
	
	requires: [
	    'EnterpriseSheet.common.Common',
	    'EnterpriseSheet.sheet.action.ActionBox',
	    'Ext.button.Split',
	    'EnterpriseSheet.common.SimpleButton',
	    'Ext.ux.BoxReorderer',
	    'Ext.window.MessageBox',
	    'Ext.form.field.Text',
	    'Ext.toolbar.Spacer',
	    'EnterpriseSheet.sheet.pop.TextWin',
        'EnterpriseSheet.common.ColorMenu'
	],
	
	/* End Definitions */	
	
	cls: 'ss-sheet-tabbar',
	
	height: 30,
	
	maxTitleLen: 100,
           
    tabThemeColor: 'rgb(12,155,77)', //#005839
           
	/*
	 * init as a plugin of EnterpriseSheet.Sheet
	 */
	init : function(sheet){		
		
		if(this.sheet){
			return;
		}
		this.sheet = sheet;			
		
		this.mon(this.sheet, {
			scope:this,
			'switchsheet':this.onSwitchSheet,
			'afterloadsheet': this.afterLoad,
            'changereadonly': this.onChangeReadOnly
		});
		
		var store = sheet.getStore();
		if(store){
            this.mon(store, {
                scope: this,
                'updatesheettab': this.onUpdateSheetTab,
                'deletesheet': this.onDeleteSheet,
                'copysheet': this.onSheetCreated,
                'addsheet': this.onSheetCreated
            });
			this.initSheetButtons();
		}
	},
	
           
	initComponent : function(){
		
		this.sheetMenu = this.initSheetMenu();
		this.sheetBar = this.initSheetBar();
		
		/*
		 * sheet list button
		 */
		this.displayItem = new Ext.toolbar.TextItem({
			text: '&nbsp;'
		});
		this.sheetListBtn = new EnterpriseSheet.common.SimpleButton({
			cls: 'icon-list-drop',				
			color: 'silver',
            width: 20,
			notSplited: true,
			menu: new Ext.menu.Menu({
				items: [],
				minWidth: 160,
                bbar: {
                    xtype: 'toolbar',
                    cls: 'ss-sheetlist-bar',
                    border: false,
                    items: [this.displayItem]
                },
				listeners: {
					'beforeshow': {
						fn: this.beforeSheetListShow,
						scope: this
					}
				}
			})
		});
		
        this.addSheetBtn = Ext.create('EnterpriseSheet.common.SimpleButton', {
            color: this.tabThemeColor,
            width: 30,
            cls: 'ss-simple-button-add',
            text: '+',
            handler: function(){
                this.addSheet();
            },
            scope:this
        });
        this.items = [{
			xtype: 'container',
            height: 30,
			layout: {
				type: 'hbox',
                align: 'stretch'
			},
			items: [this.addSheetBtn, this.sheetListBtn, this.sheetBar]
		}];
		
		this.callParent(arguments);	
	},
           
    
	/*
	 * remove sheet buttons 
	 */
	removeSheetBtns : function(){
		this.sheetBar.items.each(function(it){
			if(!SCOM.nullOrUndefined(it.sheetId)){
				this.sheetBar.remove(it);
			}
		}, this);
	},
		
	/*
	 * create sheet buttons based on store
	 */
	initSheetButtons : function(){
		this.removeSheetBtns();
		
		var ss = this.sheet, store = ss.getStore(), activeSheetId = ss.getSheetId();
		var sheets = store.getSheets(), loadedFile = store.getLoadedFile();

		var sheetListMenu = this.sheetListBtn.menu;
		
		sheetListMenu.removeAll();
		for(var i = 0, len = sheets.length; i < len; i++){
			var s = sheets[i];
			var pressed = s.id == activeSheetId;
			this.sheetBar.add({
				xtype: 'simplebtn',
                color: s.color || this.tabThemeColor,
				sheetId:s.id,
				pressed:pressed,
				toggleGroup: 'sheetbar-overflow',
				enableToggle: true,
				text:s.name,						
				menu: this.sheetMenu,
				handler:this.switchSheet,
				scope:this
			});
			sheetListMenu.add({
				group: 'sheetbar-sheetlist',
				checked: pressed,
				sheetId:s.id,
				text: s.name,
				handler: this.switchSheetByMenu,
				scope:this
			});
		}	
	},
	
	/*
	 * init sheet menu
	 */
	initSheetMenu : function(){
		this.nameField = new Ext.form.field.Text({
			width: 200,
			enableKeyEvents: true
		});
        this.deleteTabItem = Ext.create('Ext.menu.Item', {
        	iconCls: 'icon-delete',
            text: SLANG['delete'],
            handler: this.deleteSheet,
            scope: this
        });
        
        this.rowHeightItem = Ext.create('Ext.menu.Item', {
        	iconCls : 'icon-row-height',
            text: SLANG['row_height'],
            handler: this.changeAllRowHeight,
            scope: this
        });
        
        this.columnWidthItem = new Ext.menu.Item({
			iconCls : 'icon-column-width',
			text: SLANG['column_width'],
			handler: this.changeAllColumnWidth,
			scope: this
		});
        
		this.sheetMenu = new Ext.menu.Menu({
			items: [{
				text: SLANG['rename'],
				menu: {
					plain: true,
					items: [{
						xtype: 'label',
						cls: 'sc-menu-label',
						text: SLANG['input_sheet_name']
					}, this.nameField],
					listeners: {
						'show': {
							fn: this.onNameFieldShow,
							scope: this
						}
					}
				}				
			}, {
				text: SLANG['copy'],
				handler: this.copySheet,
				scope: this
			}, this.deleteTabItem, {
                text: SLANG['color'],
                menu: new EnterpriseSheet.common.ColorMenu({
                    selectHandler: this.changeTabColor,
                    scope: this
                })
            }, this.rowHeightItem, this.columnWidthItem]
		});
		
		this.mon(this.sheetMenu, {
			scope: this,
			'beforeshow': function(){
                if(this.sheet.isReadOnly()){
                    return false;
                }
				var store = this.sheet.getStore();
				var sheets = store.getSheets();
				/*
				 * if only one sheet left, can not delete it
				 */
				if(1 >= sheets.length){
					this.deleteTabItem.hide();
				}else{
					this.deleteTabItem.show();
				}
			}
		});
		this.mon(this.nameField, {
			scope: this,
			'keydown': this.onNameFieldKeyDown			
		});
		return this.sheetMenu;
	},
	
	/*
	 * rename the sheet when press enter
	 */
	onNameFieldKeyDown : function(field, e){		
		if(e.ENTER == e.getKey()){
			e.stopEvent();
			this.renameSheet();
			this.sheetMenu.hide();
		}
	},
	
	onNameFieldShow : function(){
		var menu = this.sheetMenu;
		var btn = menu.bindBtn;
		if(btn){
			var sheetId = btn.sheetId;
			var store = this.sheet.getStore();
			var name = store.getSheetNameById(sheetId);
			this.nameField.setValue(name);
		}
	},
	
	changeAllRowHeight : function() {
		SPOP.showRowHeightBox({
			applyCallback : {
				fn : function(h) {
					this.sheet.setRowHeight(h, {minrow:0, maxrow:0});
				},
				scope : this
			}
		});
	},
	
	changeAllColumnWidth : function() {
		SPOP.showColumnWidthBox({
			applyCallback : {
				fn : function(w) {
					this.sheet.setColumnWidth(w, {mincol:0, maxcol:0});
				},
				scope : this
			}
		});
	},
	
	/*
	 * init sheet bar
	 */
	initSheetBar : function(){
		this.barReorder = Ext.create('Ext.ux.BoxReorderer', {
			listeners: {
				'drop': {
					fn: this.afterReorder,
					scope: this
				}
			}
		});
		this.sheetBar = new Ext.toolbar.Toolbar({
			cls: 'ss-transparent-toolbar ss-sheetbar',
			flex: 1,
			plugins: [this.barReorder],
			layout: {
				type: 'hbox',
                align: 'stretch',
                overflowHandler: 'Scroller'
			},
			items: []
		});
		this.mon(this.sheetBar, {
			scope: this,
			'afterlayout': function(){
				var layout = this.sheetBar.getLayout();
				var overflow = layout.overflowHandler;
				if(overflow){
					var item;
					this.sheetBar.items.each(function(it){
						if(it.pressed){
							item = it;
							return false;
						}
					});
                    if(item){
                        overflow.scrollToItem(item, true);
                    }
				}
			}
		});
		return this.sheetBar;
	},
	
	/*
	 * get current actived one
	 */
	getActivedSheetButton : function(){
		var actived;
		this.sheetBar.items.each(function(btn){
			if(!SCOM.nullOrUndefined(btn.sheetId) && btn.isPressed()){
				actived = btn;
				return false;
			}
		}, this);
		return actived;
	},
	
	/*
	 * after store reload
	 */
	afterLoad : function(){
		/*
		 * reset the sheet buttons
		 */
		this.initSheetButtons();
	},		
	
	/*
	 * click btn to swtich sheet
	 */
	switchSheet : function(btn){
        this.switchSheetByBtn(btn);
	},
           
    switchSheetByBtn : function(btn, callback, scope){
        var sheet = this.sheet, store = sheet.getStore();
        var loadMask = sheet.loadMask;
        var sheetId = btn.sheetId;
        if(loadMask){
            loadMask.show();
            Ext.Function.defer(function(){
                store.loadSheet(sheetId, function(success){
                    if(success){
                        /*
                         * call sheet to switch
                         */
                        sheet.switchSheet(sheetId);
                        loadMask.hide();
                        if(callback){
                            callback.call(scope, sheetId, this);
                        }
                    }else{
                        loadMask.hide();
                    }
                }, this);
            }, 50);
        }else{
            store.loadSheet(sheetId, function(success){
                if(success){
                    /*
                     * call sheet to switch
                     */
                    sheet.switchSheet(sheetId);
                    if(callback){
                        callback.call(scope, sheetId, this);
                    }
                }else{
                    loadMask.hide();
                }
            }, this);
        }
        var layout = this.sheetBar.getLayout();
        var overflow = layout.overflowHandler;
        if(overflow){
            overflow.scrollToItem(btn, true);
        }
    },
	
	/*
	 * switch sheet by select in menu
	 */
	switchSheetByMenu : function(item){
		var sheetId = item.sheetId;
		var btn;
		this.sheetBar.items.each(function(it){
			if(it.sheetId == sheetId){
				btn = it;
				return false;
			}
		});
		if(btn){			
			this.switchSheetByBtn(btn);
		}
	},
	
	onSwitchSheet : function(oldSheetId, sheetId, sheet){
		var btn;
		this.sheetBar.items.each(function(it){
			if(it.isPressed() && !SCOM.nullOrUndefined(it.sheetId)){
				it.toggle(false, true);
			}
			if(it.sheetId == sheetId){
				btn = it;
			}
		}, this);
		if(btn){
			btn.toggle(true, true);
		}	
		var menu = this.sheetListBtn.menu;
		var item;
		menu.items.each(function(it){			
			if(it.sheetId == sheetId){
				item = it;
				return false;
			}
		});
		if(item){
			item.setChecked(true, true);
		}
	},		
	
	/*
	 * is existed name
	 */
	isExistedSheetName : function(name){
        return this.sheet.getStore().isExistedSheetName(name);
	},
	
	/*
	 * add a new sheet tab 
	 */	
	addSheet : function(tabConfig, notSwitchToNewSheet, callback, scope){
		var ss = this.sheet, store = ss.getStore(), activeSheetId = ss.getSheetId();
        if(ss.isReadOnly()){
           Ext.Msg.alert(SLANG['error'], SLANG['action_on_read_only']);
            return false;
        }
        tabConfig = tabConfig || {};
		var sheets = store.getSheets();
		var len = sheets.length, name = tabConfig.name, color = tabConfig.color;
        if(name){
            if(this.isExistedSheetName(name)){
                Ext.Msg.alert(SLANG['error'], SLANG['tab_name_existed']);
                return false;
            }
        }else{
            name = SLANG['sheet']+len;
            while(this.isExistedSheetName(name)){
                len++;
                name = SLANG['sheet']+len;
            }
            tabConfig.name = name;
        }
        var position = tabConfig.position;
		store.addSheet(tabConfig, function(data){
            var btnObj = {
                xtype: 'simplebtn',
                color: color || this.tabThemeColor,
                sheetId: data.id,
                text: name,
                menu: this.sheetMenu,
                handler: this.switchSheet,
                scope: this
            };
            var btn, menu = this.sheetListBtn.menu;

            var itemObj = {
                xtype: 'menucheckitem',
                sheetId: data.id,
                text: name,
                group: 'sheetbar-sheetlist',
                handler: this.switchSheetByMenu,
                scope: this
            }
            if(Ext.isNumber(position)){
                btn = this.sheetBar.insert(position, btnObj);
                menu.insert(position, itemObj);
            }else{
                btn = this.sheetBar.add(btnObj);
                menu.add(itemObj);
            }
            if(!notSwitchToNewSheet){
                /*
                 * switch to the new sheet just added
                 */
                this.switchSheetByBtn(btn, callback, scope);
            }else if(callback){
                callback.call(scope, data.id, this);
            }
		}, this);		
	},
	
	doDeleteSheet : function(btn){
		var store = this.sheet.getStore();
		var sheetId = btn.sheetId;
		var isActived = btn.isPressed();
		var loadMask = this.sheet.loadMask;
		if(loadMask){
			loadMask.show();
		}
		store.deleteSheet(sheetId, function(deleted, success){
            if(success){
                this.sheetBar.remove(btn);
                var item = this.getMenuItemBySheetId(sheetId);
                if(item){
                    this.sheetListBtn.menu.remove(item);
                }
                if(isActived){
                    /*
                     * switch to the first sheet
                     */
                    this.switchSheetByBtn(this.sheetBar.items.get(0));
                }else if(loadMask){
                    loadMask.hide();
                }
            }else if(loadMask){
                loadMask.hide();                                
            }
		}, this);
	},
	
	/*
	 * delete a sheet
	 */
	deleteSheet : function(){
		var menu = this.sheetMenu;
		var btn = menu.bindBtn;
		if(btn){
			var sheetId = btn.sheetId;
			var store = this.sheet.getStore();
			var name = store.getSheetNameById(sheetId);			
			Ext.Msg.show({
				title: SLANG['confirm'],
				msg: SLANG['do_u_really_wanna_delete']+' ['+name+']?',
				buttons: Ext.Msg.YESNO,
			    icon: Ext.Msg.QUESTION,
				fn: function(bid){
					if('yes' == bid){
						this.doDeleteSheet(btn);
					}
				},
				scope: this
			});					
		}
	},
	
	/*
	 * get the sheet menu item by sheetId
	 */
	getMenuItemBySheetId : function(sheetId){
		var item;
		this.sheetListBtn.menu.items.each(function(it){
			if(it.sheetId == sheetId){
				item = it;
				return false;
			}
		});
		return item;
	},
           
    getBtnBySheetId : function(sheetId){
        var item;
        this.sheetBar.items.each(function(it){
            if(it.sheetId == sheetId){
                item = it;
                return false;
            }
        });
        return item;
    },
	
	/*
	 * rename a sheet
	 */
	renameSheet : function(){
		var menu = this.sheetMenu;
		var btn = menu.bindBtn;
		var newName = this.nameField.getValue();
		
		if(btn && newName){
			var valid = EnterpriseSheet.sheet.calculate.Coordinate.prototype.sheetNameReg.test(newName);			
			if(valid){
				var sheetId = btn.sheetId;
				var store = this.sheet.getStore();
				var name = store.getSheetNameById(sheetId);
				if(name != newName){
					store.renameSheet(sheetId, newName, function(){
						btn.setText(newName);
						var item = this.getMenuItemBySheetId(sheetId);
						if(item){
							item.setText(newName);
						}
						if(Ext.isFunction(this.sheetBar.doLayout)){
							this.sheetBar.doLayout();
						}else if(Ext.isFunction(this.sheetBar.updateLayout)){
							this.sheetBar.updateLayout();
						}										
					}, this);				
				}
			}else{
				Ext.Msg.alert(SLANG['hint'], SLANG['sheet_name_invalid']);
			}					
		}
	},		
	
	/*
	 * after sheet has been reordered
	 */
	afterReorder : function(reorder, bar, box, startIndex, currentIndex){
		if(this.sheet){
            this.reorderBox = box;
            
            this.sheet.changeSheetOrder(startIndex, currentIndex, function(success){
                if(success){
                    this.sheetBar.insert(currentIndex, this.reorderBox);
                }else{
                    this.sheetBar.insert(startIndex, this.reorderBox);
                }
            }, this);
		}
	},
	
	
	/*
	 * copy a sheet
	 */
	copySheet : function(){
		var menu = this.sheetMenu;
		var btn = menu.bindBtn;
		if(btn){
			var sheetId = btn.sheetId;
			var store = this.sheet.getStore();
			var sheetName = store.getCopyName(sheetId);
						
			SPOP.showTextBox({
				title: SLANG['copy_sheet_to'],
				fieldLabel: SLANG['input_sheet_name'],
				value: sheetName,
				applyCallback: {
					fn: function(name){
						store.copySheet(sheetId, name, function(data){
							this.sheetBar.add({
								xtype: 'simplebtn',
                                color: data.color || this.tabThemeColor,
								sheetId: data.id,			
								text: data.name,
								menu: this.sheetMenu,
								handler: this.switchSheet,
								scope: this
							});
							this.sheetListBtn.menu.add({
								group: 'sheetbar-sheetlist',
								checked: false,
								sheetId: data.id,			
								text: data.name,
								handler: this.switchSheetByMenu,
								scope: this
							});
						}, this);
					},
					scope: this
				}
			});
		}		
	},
	
	/*
	 * before sheet list show
	 */
	beforeSheetListShow : function(menu){		
		var len = menu.items.getCount();		
		this.displayItem.setText(SLANG['total_sheet_number']+': '+len);
	},
           
    /**
     * change tab color
     */
    changeTabColor : function(cp, color){
        var menu = this.sheetMenu;
        var btn = menu.bindBtn;
        if(btn){
            var sheetId = btn.sheetId;
            var store = this.sheet.getStore();
            var sheet = store.getSheetById(sheetId);
            if(sheet.color !== color){
                store.changeSheetColor(sheetId, color, function(){
                    btn.setBtnColor(color);
                }, this);
           }
        }
    },
           
    onChangeReadOnly : function(readOnly, sheet){
        if(readOnly){
            this.addSheetBtn.hide();
            for(var i = 0, len = this.sheetBar.items.getCount(); i < len; i++){
                var it = this.sheetBar.items.get(i);
                it.reorderable = false;
            }
            this.addCls('ss-disabled-sheetbar');
        }else{
            this.addSheetBtn.show();
            for(var i = 0, len = this.sheetBar.items.getCount(); i < len; i++){
                var it = this.sheetBar.items.get(i);
                it.reorderable = true;
            }
            this.removeCls('ss-disabled-sheetbar');
        }
    },
    
    /**
     * need update the bar after sheetTab is updated
     */
    onUpdateSheetTab : function(sheetId){
        var store = this.sheet.getStore();
        var sheetTab = store.getSheetById(sheetId);
        var btn = this.getBtnBySheetId(sheetId);
        if(sheetTab.name){
        	btn.setText(sheetTab.name);
        }        
        if(sheetTab.color){
        	btn.setBtnColor(sheetTab.color);
        }        

        if(sheetId === store.getActivedSheetId()){
            btn.toggle(true, true);
        }else{
            btn.toggle(false, true);
        }
        var item = this.getMenuItemBySheetId(sheetId);
        if(item){
           item.setText(sheetTab.name);
        }
        var index = this.sheetBar.items.indexOf(btn);
        if(Ext.isNumber(sheetTab.position) && index !== sheetTab.position){
           this.sheetBar.insert(sheetTab.position, btn);
           this.sheetListBtn.menu.insert(sheetTab.position, item);
        }
        if(Ext.isFunction(this.sheetBar.doLayout)){
			this.sheetBar.doLayout();
		}else if(Ext.isFunction(this.sheetBar.updateLayout)){
			this.sheetBar.updateLayout();
		}	
    },
           
    onDeleteSheet : function(sheetId){
        var btn = this.getBtnBySheetId(sheetId);
        var item = this.getMenuItemBySheetId(sheetId);
        if(btn){
            this.sheetBar.remove(btn);
        }
        if(item){
            this.sheetListBtn.menu.remove(item);
        }
        
    },
           
    onSheetCreated: function(sheetId){
        var btn = this.getBtnBySheetId(sheetId);
        var store = this.sheet.getStore();
        if(!btn){
            var sheetTab = store.getSheetById(sheetId);
            var index = store.indexOfSheetId(sheetId);
            var btnObj = {
                xtype: 'simplebtn',
                color: sheetTab.color || this.tabThemeColor,
                sheetId: sheetId,
                text: sheetTab.name,
                menu: this.sheetMenu,
                handler: this.switchSheet,
                scope: this
            };
            var itemObj = {
                group: 'sheetbar-sheetlist',
                checked: false,
                sheetId: sheetId,
                text: sheetTab.name,
                handler: this.switchSheetByMenu,
                scope: this
            };
            if(Ext.isNumber(index)){
                btn = this.sheetBar.insert(index, btnObj);
                this.sheetListBtn.menu.insert(index, itemObj);
            }else{
                btn = this.sheetBar.add(btnObj);
                this.sheetListBtn.menu.add(itemObj);
            }
            if(sheetId === store.getActivedSheetId()){
                btn.toggle(true, true);
            }
            var layout = this.sheetBar.getLayout();
            var overflow = layout.overflowHandler;
            if(overflow){
                overflow.scrollToItem(btn, true);
            }
        }
    }
});
Ext.define('EnterpriseSheet.sheet.toolbar.Toolbar', {
	
	/* Begin Definitions */
	
	extend: 'Ext.container.Container',	
	
	requires: [	          
	    'EnterpriseSheet.sheet.action.ActionBox',
	    'EnterpriseSheet.sheet.history.History',
	    'EnterpriseSheet.sheet.history.HistoryButton',
	    'EnterpriseSheet.sheet.toolbar.pieces.BrushButton',	    
	    'EnterpriseSheet.sheet.toolbar.pieces.FontFamilyButton',	    
	    'EnterpriseSheet.sheet.toolbar.pieces.FontSizeButton',
	    'EnterpriseSheet.sheet.toolbar.pieces.BorderButton',
	    'EnterpriseSheet.sheet.toolbar.pieces.FontColorButton',
	    'EnterpriseSheet.sheet.toolbar.pieces.BackgroundColorButton',
	    'EnterpriseSheet.sheet.toolbar.pieces.MoneyButton',
	    'EnterpriseSheet.common.toolbar.BorderToolbar',
        'EnterpriseSheet.sheet.pop.DateSelectWin'
	],
	
	/* End Definitions */	
	
	cls: 'ss-toolbar',
	
	height: 30,
	
	constructor : function(){
        /*
         * an array to contain the pieces we use in toolbar
         */
        this.pieces = [];
		this.defaultText = SLANG ? SLANG['ready'] : 'Ready';
		
		this.callParent(arguments);
	},
		
	/*
	 * init as a plugin of EnterpriseSheet.Sheet
	 */
	init : function(sheet){		
		
		if(this.sheet){
			return;
		}
		this.sheet = sheet;		
		
		this.history.init(sheet);	
		
		/*
		 * init the pieces we used in toolbar
		 */
		this.initPieces(sheet);
		
		this.store = this.sheet.getStore();
		
		
		this.mon(sheet, 'focuschange', this.onFocusChange, this, {buffer: 100});
        this.mon(sheet, {
            scope: this,
            'changereadonly': this.onChangeReadOnly
        });
	},
	
	/*
	 * init the pieces we used in toolbar
	 */
	initPieces : function(sheet){
		/*
		 * bind sheet for pieces
		 */
		if('array' == SCOM.typeOf(this.pieces)){
			for(var i = 0, len = this.pieces.length; i < len; i++){
				this.pieces[i].bindSheet(sheet);
			}
		}		
	},
	
	layout: {
		type: 'hbox',
		align: 'middle',
		overflowHandler: 'Menu',
		padding: '0 45 0 30'
	},		
	
	initComponent : function(){		
		
		this.items = this.prepareIcons();
		
		this.callParent(arguments);				
	},	
	
	/*
	 * prepare icons
	 */
	prepareIcons : function(){
		this.cutBtn = new Ext.Button(				
			SABOX.get('cut', {						
				iconCls: 'icon-cut',
				tooltip: SLANG['cut_tip'],
				text: '',
				overflowText: SLANG['cut'],
                sender: this
			})
		);
			
		this.copyBtn = new Ext.Button(
			SABOX.get('copy', {									
				iconCls:'icon-copy',
				tooltip: SLANG['copy_tip'],
				text: '',
				overflowText: SLANG['copy'],
                sender: this
			})	
		);
		
		this.pasteBtn = new Ext.button.Button(
			SABOX.get('paste', {				
				iconCls:'icon-paste',
				tooltip: SLANG['paste_tip'],
				text: '',
				overflowText: SLANG['paste'],
                sender: this
			})				
		);
		/*
		 * create a history instance, it will init later
		 */
		var historyClassName = this.historyClassName || 'EnterpriseSheet.sheet.history.History';
		this.history = Ext.create(historyClassName, {});
		/*
		 * create undo/redo button
		 */		
		this.undoBtn = new EnterpriseSheet.sheet.history.HistoryButton({
			iconCls:'icon-undo',
			history:this.history,
			tooltip: SLANG['undo'],
			overflowText: SLANG['undo']
		});
		
		this.redoBtn = new EnterpriseSheet.sheet.history.HistoryButton({
			iconCls:'icon-redo',
			mode:'redo',
			history:this.history,
			tooltip: SLANG['redo'],
			overflowText: SLANG['redo']
		});
		
		this.brushBtn = new EnterpriseSheet.sheet.toolbar.pieces.BrushButton({
			iconCls:'icon-brush',
			tooltip: SLANG['format_brush'],
			overflowText: SLANG['format_brush']
		});
		this.pieces.push(this.brushBtn);
		/*
		 * for font icons
		 */
		this.fontFamilyBtn = new EnterpriseSheet.sheet.toolbar.pieces.FontFamilyButton({
			tooltip: SLANG['font_family'],
			overflowText: SLANG['font_family']
		});
		this.pieces.push(this.fontFamilyBtn);
		
		this.fontSizeBtn = new EnterpriseSheet.sheet.toolbar.pieces.FontSizeButton({
			tooltip: SLANG['font_size'],
			overflowText: SLANG['font_size']
		});
		this.pieces.push(this.fontSizeBtn);
		
		this.sizeIncBtn = new Ext.Button(
			SABOX.get('incFontSize', {
				tooltip: SLANG['increase_font_size'],
				overflowText: SLANG['increase_font_size'],
                sender: this
			})
		);
			
		this.sizeDesBtn = new Ext.Button(
			SABOX.get('descFontSize', {
				tooltip: SLANG['decrease_font_size'],
				overflowText: SLANG['decrease_font_size'],
                sender: this
			})
		);
		
		this.boldBtn = new Ext.Button(
			SABOX.get('bold', {			
				enableToggle:true,
				tooltip: SLANG['bold_tip'],
				text: '',
				overflowText: SLANG['bold'],
                sender: this
			})
		);
		
		this.italicBtn = new Ext.Button(
			SABOX.get('italic', {			
				enableToggle:true,
				tooltip: SLANG['italic_tip'],
				text: '',
				overflowText: SLANG['italic'],
                sender: this
			})	
		);
		
		this.underlineBtn = new Ext.Button(
			SABOX.get('underline', {			
				enableToggle:true,
				tooltip: SLANG['underline_tip'],
				text: '',
				overflowText: SLANG['underline'],
                sender: this
			})
		);		
		
		this.strikeBtn = new Ext.Button(
			SABOX.get('strike', {			
				enableToggle:true,
				tooltip: SLANG['strike'],
				text: '',
				overflowText: SLANG['strike'],
                sender: this
			})	
		);
					
		this.borderBtn = new EnterpriseSheet.sheet.toolbar.pieces.BorderButton({
			tooltip: SLANG['border'],
			overflowText: SLANG['border']
		});  
		this.pieces.push(this.borderBtn);
			
		this.fontBtn = new EnterpriseSheet.sheet.toolbar.pieces.FontColorButton({
			tooltip: SLANG['font_color'],
			overflowText: SLANG['font_color']
		});
		this.pieces.push(this.fontBtn);
					
		this.paintcanBtn = new EnterpriseSheet.sheet.toolbar.pieces.BackgroundColorButton({
			tooltip: SLANG['background_color'],
			overflowText: SLANG['background_color']
		});
		this.pieces.push(this.paintcanBtn);
		
		/*
		 * for align icons
		 */		
		var listeners = {
			'click': {
				fn : function(){
					this.alignBtn.menu.hide();
					this.sheet.focus();
				},
				scope: this
			}
		};
		
		this.alignLeftBtn = Ext.create('Ext.Button', SABOX.get('alignLeft', {
			tooltip: SLANG['align_left'],
			text: '',
			listeners: listeners,
            sender: this
		}));
		
		this.alignCenterBtn = Ext.create('Ext.Button', SABOX.get('alignCenter', {
			tooltip: SLANG['align_center'],
			style: 'margin-left:3px;',	
			text: '',
			listeners: listeners,
            sender: this
		}));
		
		this.alignRightBtn = Ext.create('Ext.Button', SABOX.get('alignRight', {
			tooltip: SLANG['align_right'],
			style: 'margin-left:3px;',
			text: '',
			listeners: listeners,
            sender: this
		}));
		
		this.alignTopBtn = Ext.create('Ext.Button', SABOX.get('alignTop', {
			tooltip: SLANG['align_top'],
			style: 'margin-left:3px;',
			text: '',
			listeners: listeners,
            sender: this
		}));
		
		this.alignMiddleBtn = Ext.create('Ext.Button', SABOX.get('alignMiddle', {
			tooltip: SLANG['align_middle'],
			style: 'margin-left:3px;',
			text: '',
			listeners: listeners,
            sender: this
		}));
		
		this.alignBottomBtn = Ext.create('Ext.Button', SABOX.get('alignBottom', {
			tooltip: SLANG['align_bottom'],
			style: 'margin-left:3px;',
			text: '',
			listeners: listeners,
            sender: this
		}));
		
		this.alignBtn = new Ext.Button({
			iconCls: 'icon-align-left',
			tooltip: SLANG['align'],
			overflowText: SLANG['align'],			
			menu: {
				plain: true,
				items: [{
					xtype: 'toolbar',
                    border: false,
                    style: 'background:white;',
					defaults: {
						xtype: 'button'
					},
					items: [
						this.alignLeftBtn,
						this.alignCenterBtn,
						this.alignRightBtn,
						
						this.alignTopBtn,
						this.alignMiddleBtn,
						this.alignBottomBtn
					]					
				}]
			}
		});
		/*
		 * for calculate icons
		 */
		this.wordWrapBtn = new Ext.Button(
			SABOX.get('wordWrap', {						
				tooltip: SLANG['word_wrap'],
				text: '',
				overflowText: SLANG['word_wrap'],
                sender: this
			})
		);
			
		this.combineBtn = new Ext.button.Split(
			SABOX.get('mergeCell', {	
				iconCls: 'icon-merge',
				text: '',
				tooltip: SLANG['merge_cell'],
				overflowText: SLANG['merge_cell'],
				menu: new Ext.menu.Menu({
					items: [SABOX.get('mergeCell', { text:SLANG['merge_cell'], sender: this}),
					        SABOX.get('mergeColumn', { text:SLANG['merge_cell_in_column'], sender: this}),
					        SABOX.get('mergeRow', {text:SLANG['merge_cell_in_row'], sender: this}),
					        SABOX.get('cancelMerge', {text:SLANG['cancel_merge_cell'], sender: this})
					]
				}),
                sender: this
			})
		);
		
		this.formulaMenu = new Ext.menu.Menu({
			items: [	
			    SABOX.get('sum', {	text:SLANG['sum'], sender: this}),
				SABOX.get('average', {text:SLANG['average'], sender: this}),
				SABOX.get('count', {text:SLANG['count'], sender: this}),
				SABOX.get('maxValue', {text:SLANG['max'], sender: this}),
				SABOX.get('minValue', {	text:SLANG['min'], sender: this}),
				'-',
				SABOX.get('insertFormula', {iconCls : 'icon-fx', text : SLANG['more_functions'] + '...', sender: this})
			]
		});
		
		this.formulaBtn = new Ext.Button({	
			iconCls : 'icon-sum',
			tooltip: SLANG['function'],
			overflowText: SLANG['function'],
			menu: this.formulaMenu
		});
		
		this.filterMenu = new Ext.menu.Menu({
			items: [SABOX.get('sortAsc', {
				iconCls:'icon-sort-asc',
				text:SLANG['sort_asc'],
                sender: this
			}), SABOX.get('sortDesc', {
				iconCls:'icon-sort-desc',
				text:SLANG['sort_desc'],
                sender: this
			}), /*SABOX.get('customSort', {				
				text:SLANG['custom_sort']+'...',
                sender: this
			}),*/ {				
				text:SLANG['filtering'],
				handler: this.toggleFiltering,
				scope: this
			}],
			listeners: {
				'show': {
					fn: this.onFilterMenuShow,
					scope: this
				}
			}
		});
		
		this.filterBtn = new Ext.Button({			
			iconCls:'icon-filter',		
			tooltip: SLANG['filter_sort'],
			overflowText: SLANG['filter_sort'],
			menu: this.filterMenu
		});	
		
		this.cleanRangeBtn = new Ext.button.Button({
			iconCls:'icon-clean-range',
			tooltip: SLANG['clean'],
			overflowText: SLANG['clean'],
			menu: new Ext.menu.Menu({
				items: [SABOX.get('clean', {		
					text: SLANG['clean_all'],
                    sender: this
				}), SABOX.get('cleanContent', {
					text:SLANG['clean_content'],
                    sender: this
				}), SABOX.get('cleanStyle', {
					text:SLANG['clean_style'],
                    sender: this
				})]
			})
		});
		
		/*
		 * enable/disable the selection
		 */				
		this.editableBtn = this.getEditableBtn();				
		
		this.moneyBtn = new EnterpriseSheet.sheet.toolbar.pieces.MoneyButton({
			tooltip: SLANG['money'],
			overflowText: SLANG['money'],
			iconCls:'icon-dollar'
		});
		this.pieces.push(this.moneyBtn);
		
		this.dotMoveLeftBtn = new Ext.Button(
			SABOX.get('leftDot', {
				tooltip: SLANG['decimalIncrease'],
				overflowText:SLANG['dot_move_left'],
                sender: this
			})
		);
			
		this.dotMoveRightBtn = new Ext.Button(
			SABOX.get('rightDot', {
				tooltip: SLANG['decimalDecrease'],
				overflowText:SLANG['dot_move_right'],
                sender: this
			})
		);
		
		this.percentBtn = new Ext.Button(
			SABOX.get('percentFormat', {
				tooltip: SLANG['percent'],
				overflowText: SLANG['percent'],
                sender: this
			})
		);
			
		this.commaBtn = new Ext.Button(
			SABOX.get('commaFormat', {
				tooltip: SLANG['comma'],
				overflowText: SLANG['comma'],
                sender: this
			})	
		);
		
		// this is for datetime window ...
		this.dateTimeWin = Ext.create("EnterpriseSheet.sheet.pop.DateSelectWin", {});
		this.pieces.push(this.dateTimeWin);
		this.initDateFormatMenu();
		this.dateBtn = new Ext.Button({
			iconCls:'icon-date',
	        tooltip: SLANG['date'],
			menu: this.dateFormatMenu		
		});
			
		var icons = [
		    this.undoBtn,
		    this.redoBtn,
		    {
				xtype:'tbspacer',
				width: 10
			},
		    this.cutBtn,
		    this.copyBtn,
		    this.pasteBtn,
		    {
				xtype:'tbspacer',
				width: 10
			},
		    this.brushBtn,
		    {
				xtype:'tbspacer',
				flex:1
			},
			this.boldBtn, 
			this.underlineBtn,			
			this.italicBtn,
			this.strikeBtn,	
			{
				xtype:'tbspacer',
				flex:1
			},
			this.fontFamilyBtn,
			this.fontSizeBtn,
			this.sizeIncBtn,
			this.sizeDesBtn,
			this.fontBtn,
			this.wordWrapBtn,
			{
				xtype:'tbspacer',
				flex:1
			},						
			this.alignBtn,				
			this.paintcanBtn,				
			this.borderBtn,
			this.combineBtn,			
			{
				xtype:'tbspacer',
				flex:1
			},						
			this.dotMoveLeftBtn,
			this.dotMoveRightBtn,
			{
				xtype:'tbspacer',
				width: 10
			},
			this.moneyBtn,		
			this.percentBtn,
			this.commaBtn,
			this.dateBtn,
			{
				xtype: 'tbspacer',
				flex: 1
			},
			this.filterBtn,
			this.formulaBtn,
			this.cleanRangeBtn,
			this.editableBtn
		];
		
		return icons;
	},
	
	getEditableBtn : function(){
		return new Ext.Button({
			iconCls: 'icon-lock-edit',			
			menu: {
				plain: true,
				defaults: {
					xtype: 'menucheckitem'
				},
				items: [SABOX.get('editable', {			
					group: 'editable',					
					text: SLANG['lock_edit_for_all'],
	                sender: this
				}), SABOX.get('lockOtherEdit', {					
					group: 'editable',					
					text: SLANG['lock_edit_for_other'],
	                sender: this
				})]
			}
		});
	},
	
	/**
	 * when the filter menu show
	 */
	onFilterMenuShow : function(){
		var filterItem = this.filterMenu.items.last();
		var sheet = this.sheet, sheetId = sheet.getSheetId();
		var store = sheet.getStore();
		if(store.withFilterInSheet(sheetId)){
			filterItem.setText(SLANG['cancel_filtering']);
			filterItem.setIconCls('icon-cross');
			filterItem.filtered = true;
		}else{
			filterItem.setText(SLANG['filtering']);
			filterItem.setIconCls();
			filterItem.filtered = false;
		}
		
	},
	
	/*
     * init date format menu
     */
    initDateFormatMenu : function(){
    	var formats = SCONST.jsDateFm;
        var formatDetails = SCONST.javaDateFm;
    	var items = [];
    	var today = new Date(); 	
    	
    	for(var i = 0, len = formats.length; i < len; i++){
    		var fm = formats[i];
            var fmDetail = formatDetails[i];
    		items.push({
    			iconCls:'icon-date-go',
    			text: Ext.Date.format(today, fm),
    			fm: fm,
    			handler: this.selectDateFormat,
    			scope: this
    		});
    	}
    	// TODO - would be great to add separator in here ...
    	// items.push('-');  
        
        // ok this will handle time ...
    	var timeFts = SCONST.jsTimeFm;    
        for(var i = 0, len = timeFts.length; i < len; i++){
    		var fm = timeFts[i];
    		items.push({
    			iconCls:'icon-time',
    			text: Ext.Date.format(today, fm),
    			fm: fm,
    			handler: this.selectTimeFormat,
    			scope: this
    		});
    	}   
        
        // ok this will handle date time ...
    	var dateTimeFts = SCONST.jsDateTimeFm;
        var dateTimeFormatDetails = SCONST.javaDateTimeFm;       
        for(var i = 0, len = dateTimeFts.length; i < len; i++){
    		var fm = dateTimeFts[i];
            var fmDetail = dateTimeFormatDetails[i];
    		items.push({
    			text: Ext.Date.format(today, fm),
    			fm: fm,
    			handler: this.selectDateTimeFormat,
    			scope: this
    		});
    	}
        
        // add more button
        items.push({
			text: SLANG['more'] + '...',
			handler: this.moreDateTimeFormat,
			scope: this
		});
        
    	this.dateFormatMenu = Ext.create('Ext.menu.Menu', {
    		defaults: {
    			group:Ext.id()+'-date',
				checked:false
    		},
    		width: 180,
    		items: items
    	});
    },
    
    moreDateTimeFormat : function() {
		this.dateTimeWin.popup();
    },
    
    /*
     * select a date format
     */
    selectDateFormat : function(btn){
    	var fm = btn.fm;
    	this.sheet.setDateFormatForSelection(fm);
    },
    
    selectTimeFormat : function(btn){
    	var fm = btn.fm;
    	this.sheet.setTimeFormatForSelection(fm);
    },
    
    selectDateTimeFormat : function(btn){
    	var fm = btn.fm;
    	this.sheet.setDateTimeFormatForSelection(fm);
    },
	
	/**
	 * toggle filtering
	 */
	toggleFiltering : function(item){
		var sheet = this.sheet, filter = sheet.getFilter();
		if(filter){
			if(item.filtered){
				filter.cleanFilterForSheet(sheet.getSheetId());
			}else{
				filter.createFilterForSelecton();
			}
			sheet.focus();
		}
	},
	
	/*
	 * update the toolbar status(such as font family, font size, algin etc) based on the selected cell
	 */
	updateStatus : function(row, col){
		var ss = this.sheet;
		var sheetId = ss.getSheetId();
		var store = ss.getStore();
		/*
		 * get the property of the cell
		 */
		var cell = store.getCellData(sheetId, row, col);		
		/*
		 * update toolbar status
		 */
		this.fontFamilyBtn.setFontFamily(cell.ff);			
				
		this.fontSizeBtn.setFontSize(cell.fz);			
		
		if('bold' == cell.fw){
			this.boldBtn.toggle(true, true);
		}else{
			this.boldBtn.toggle(false, true);
		}
		if('italic' == cell.fs){
			this.italicBtn.toggle(true, true);
		}else{
			this.italicBtn.toggle(false, true);
		}
		if('underline' == cell.u){
			this.underlineBtn.toggle(true, true);
		}else{
			this.underlineBtn.toggle(false, true);
		}
		
		if('line-through' == cell.s){
			this.strikeBtn.toggle(true, true);
		}else{
			this.strikeBtn.toggle(false, true);
		}
		
		if('normal' == cell.ws){
			this.wordWrapBtn.toggle(true, true);
		}else{
			this.wordWrapBtn.toggle(false, true);
		}
		
		if('center' == cell.ta){
			this.alignLeftBtn.toggle(false, true);
			this.alignCenterBtn.toggle(true, true);			
			this.alignRightBtn.toggle(false, true);
		}else if('right' == cell.ta){
			this.alignLeftBtn.toggle(false, true);
			this.alignCenterBtn.toggle(false, true);			
			this.alignRightBtn.toggle(true, true);
		}else{
			this.alignLeftBtn.toggle(true, true);
			this.alignCenterBtn.toggle(false, true);			
			this.alignRightBtn.toggle(false, true);
		}
		
		if('middle' == cell.va){
			this.alignTopBtn.toggle(false, true);
			this.alignMiddleBtn.toggle(true, true);			
			this.alignBottomBtn.toggle(false, true);
		}else if('bottom' == cell.va){
			this.alignTopBtn.toggle(false, true);
			this.alignMiddleBtn.toggle(false, true);			
			this.alignBottomBtn.toggle(true, true);
		}else{
			this.alignTopBtn.toggle(true, true);
			this.alignMiddleBtn.toggle(false, true);			
			this.alignBottomBtn.toggle(false, true);
		}
		
		this.updateEditableBtnState(cell);
	},
	
	updateEditableBtnState : function(cell){
		if(cell.dsd){
			this.editableBtn.toggle(true, true);
			var menu = this.editableBtn.menu;
			if('ed' == cell.dsd){				
				menu.items.get(0).setChecked(true, true);
				menu.items.get(1).setChecked(false, true);				
			}else{
				menu.items.get(0).setChecked(false, true);
				menu.items.get(1).setChecked(true, true);
			}
		}else{
			this.editableBtn.toggle(false, true);
			var menu = this.editableBtn.menu;
			menu.items.get(0).setChecked(false, true);
			menu.items.get(1).setChecked(false, true);			
		}
	},
	
	/*
	 * update the pos field when focus cell changed
	 */
	onFocusChange : function(row, col, sm, cd){		
		this.updateStatus(row, col);
	},
	
	onFindReplace : function(){
		this.fireEvent('findreplace', this);
	},
	
	onShowCharts : function() {
		this.fireEvent('showCharts', this);
	},
	
	onShowTables : function() {
		this.fireEvent('showTables', this);
	},
	
	onShowCellStyles : function() {
	    this.fireEvent('showcellstyles', this);	
	},
	
	onConditionMgr : function() {
	    this.fireEvent('showconditionmgr', this);	
	},
	
	onLinkFunctionList : function() {
		window.open('http://www.enterprisesheet.com/enterpriseSheetFormulas.jsp');
	},
           
    onChangeReadOnly : function(readOnly, sheet){
        if(readOnly){
           this.disable();
        }else{
           this.enable();
        }
    }
});
Ext.define('EnterpriseSheet.sheet.toolbar.Sidebar', {
	
	/* Begin Definitions */
	
	extend: 'Ext.panel.Panel',	
	
	requires: [
	    'Ext.layout.container.Card',       
	    'Ext.toolbar.Spacer',
        'EnterpriseSheet.sheet.model.InfoModel',
	    'EnterpriseSheet.sheet.toolbar.options.PictureOption',
	    'EnterpriseSheet.sheet.toolbar.options.WedgitOption',
	    'EnterpriseSheet.sheet.toolbar.options.SearchOption',
	    'EnterpriseSheet.sheet.toolbar.options.ChartOption',
	    'EnterpriseSheet.sheet.toolbar.options.TableTemplateOption',
	    'EnterpriseSheet.sheet.toolbar.options.CellTemplateOption',
	    'EnterpriseSheet.sheet.toolbar.options.ConditionOption'
	],
	
	/* End Definitions */			
	
	border: false,
	
	autoWidth: true,
	
	width: 45,
	
	optionPaneWidth: 200,
	
	layout: 'fit',
	
    // this is for multiple window action ...
	constructor : function(){
        /*
         * an array to contain the pieces we use in toolbar
         */
        this.pieces = [];
		this.callParent(arguments);
	},
		
	/*
	 * init as a plugin of EnterpriseSheet.Sheet
	 */
	init : function(sheet){		
		if(this.sheet){
			return;
		}
		this.sheet = sheet;		
				
		/*
		 * init the pieces we used in toolbar
		 */
		this.initPieces(sheet);
          
        var sm = sheet.getSelectionModel();
           
        if(sm){
           this.mon(sm, 'selectionchange', this.onSelectionChange, this, {buffer: 500});
        }
        this.mon(sheet, {
            scope: this,
            'changereadonly': this.onChangeReadOnly
        });
	},
	
	/*
	 * init the pieces we used in toolbar
	 */
	initPieces : function(sheet){
		/*
		 * bind sheet for pieces
		 */
		if('array' == SCOM.typeOf(this.pieces)){
			for(var i = 0, len = this.pieces.length; i < len; i++){
				this.pieces[i].bindSheet(sheet);
			}
		}		
	},
		
	initComponent : function(){		
		/*
		 * init option pane
		 */
		this.initOptionPane();
		
		/*
		 * define the buttons in sidebar
		 */
		this.searchBtn = new Ext.Button({			
			iconCls:'icon-lookup32',
			/*
			 * an empty css use as flag
			 */
			cls: 'option-button',
			scale:'large',			
			iconAlign:'top',
			tooltip: SLANG['search'],
			arrowAlign: 'bottom',		
			toggleGroup: 'ss-side',
			name: 'search',
			handler: this.toggleOption,
			scope: this
		});
		
		this.pictureBtn = new Ext.Button({			
			iconCls:'icon-picture32',
			/*
			 * an empty css use as flag
			 */
			cls: 'option-button',
			scale:'large',			
			iconAlign:'top',
			tooltip: SLANG['picture'],
			arrowAlign: 'bottom',		
			toggleGroup: 'ss-side',
			name: 'picture',
			handler: this.toggleOption,
			scope: this
		});
           
        this.wedgitBtn = new Ext.Button({
            iconCls:'icon-plugin32',
            /*
             * an empty css use as flag
             */
            cls: 'option-button',
            scale:'large',
            iconAlign:'top',
            tooltip: SLANG['wedgit'],
            arrowAlign: 'bottom',
            toggleGroup: 'ss-side',
            name: 'wedgit',
            handler: this.toggleOption,
            scope: this
        });
				
		this.conditionStyleBtn = new Ext.Button({
			iconCls:'icon-condition32',
			cls: 'option-button',
			scale:'large',			
			iconAlign:'top',
			arrowAlign: 'bottom',
			tooltip:SLANG['condition'],
			toggleGroup: 'ss-side',
			name: 'condition',
			handler: this.toggleOption,
			scope: this
		});
		
		this.tableStyleBtn = new Ext.Button({			
			iconCls:'icon-table-template32',
			cls: 'option-button',
			scale:'large',			
			iconAlign:'top',
			tooltip: '&nbsp;&nbsp;'+SLANG['table']+'&nbsp;&nbsp;',
			arrowAlign: 'bottom',
			toggleGroup: 'ss-side',
			name: 'table',
			handler: this.toggleOption,
			scope: this
		});
		
		this.cellStyleBtn = new Ext.Button({			
			iconCls:'icon-letter32',		
			cls: 'option-button',
			scale:'large',			
			iconAlign:'top',
			arrowAlign: 'bottom',
			tooltip: SLANG['cell'],
			toggleGroup: 'ss-side',
			name: 'cell',
			handler: this.toggleOption,
			scope: this
		});
		
		this.chartBtn = new Ext.Button({
			scale: 'large',
			iconCls: 'icon-chart32',
			cls: 'option-button',
			iconAlign: 'top',
			arrowAlign: 'bottom',
			tooltip: SLANG['chart'],
			toggleGroup: 'ss-side',
			name: 'chart',
			handler: this.toggleOption,
			scope: this
        });
           
		
        this.initInfoStore();
           
        this.infoView = new Ext.view.View({
            store: this.infoStore,
            tpl: new Ext.XTemplate([
                '<tpl for=".">',
                    '<div class="ss-cal-info-item {[0===xindex%2?"ss-cal-info-item-strip":""]}">',
                        '<div class="ss-cal-info-item-inner" data-qtip="{value}">',
                            '<div class="ss-cal-info-title">{display}</div>',
                            '<div class="ss-cal-info-value">{value}</div>',
                        '</div>',
                    '</div>',
                '</tpl>'
            ].join(''), {
                compile: true
            }),
            itemSelector: 'div.ss-cal-info-item',
            cls: 'ss-info-bar',
            autoHeight: true,
            width: 40
        });
           
		this.sidebar = new Ext.toolbar.Toolbar({
            dock: 'right',
			cls: 'ss-side-bar',			
			vertical: true,
			items: [		
			    this.searchBtn,     
				this.pictureBtn, 
				this.wedgitBtn, 
				this.chartBtn,  
				this.tableStyleBtn,  
				this.cellStyleBtn,   
				this.conditionStyleBtn, '->',
                this.infoView
			]
		});
           
        this.dockedItems = [this.sidebar];
           
		
		this.callParent(arguments);
		
		this.on({
			scope: this,
			'done': function(){
				if(!this.suspendMintorMouseDown){					
					this.closeOptionPane();
				}				
			}
		});
	},
           
    /**
     * init the information store
     */
    initInfoStore : function(){
        this.infoStore = new Ext.data.Store({
            model: 'EnterpriseSheet.sheet.model.InfoModel',
            data: [
                { name: 'sum', display: 'Sum', value: 100 },
                { name: 'average', display: 'Avg.', value: 10 },
                { name: 'max', display: 'Max', value: 50, hidden: true },
                { name: 'min', display: 'Min', value: -15, hidden: true },
                { name: 'count', display: 'Count', value: 5 }
            ]
        });
        this.sumRec = this.infoStore.getAt(0);
        this.avgRec = this.infoStore.getAt(1);
        this.maxRec = this.infoStore.getAt(2);
        this.minRec = this.infoStore.getAt(3);
        this.countRec = this.infoStore.getAt(4);
    },
	
	/*
	 * create a pane for contain options
	 */
	initOptionPane : function(){
		this.pinTool = new Ext.panel.Tool({
			type: 'pin',
			handler: this.pinOptionPane,
			scope: this
		});
		this.unpinTool = new Ext.panel.Tool({
			type: 'unpin',
			hidden: true,
			handler: this.unPinOptionPane,
			scope: this
		});
		
		/*
		 * create different option
		 */
		this.searchOption = new EnterpriseSheet.sheet.toolbar.options.SearchOption();
		this.pieces.push(this.searchOption);
		
		this.pictureOption = new EnterpriseSheet.sheet.toolbar.options.PictureOption();
		this.pieces.push(this.pictureOption);
		
        this.wedgitOption = new EnterpriseSheet.sheet.toolbar.options.WedgitOption();
        this.pieces.push(this.wedgitOption);
		
		this.chartOption = new EnterpriseSheet.sheet.toolbar.options.ChartOption();
		this.pieces.push(this.chartOption);
		
		this.tableOption = new EnterpriseSheet.sheet.toolbar.options.TableTemplateOption();
		this.pieces.push(this.tableOption);
		
		this.cellOption = new EnterpriseSheet.sheet.toolbar.options.CellTemplateOption();
		this.pieces.push(this.cellOption);
		
		this.conditionOption = new EnterpriseSheet.sheet.toolbar.options.ConditionOption();
		this.pieces.push(this.conditionOption);
		/*
		 * create option pane
		 */
		this.optionPane = new Ext.panel.Panel({
            cls: 'ss-option-pane',
			tools: [this.pinTool, this.unpinTool, {
				type: 'close',
				handler: this.closeOptionPane,
				scope: this
			}],
			width: this.optionPaneWidth,
			floating: {
				shadow: false
			},
			layout: 'card',
			activeItem: 0,
			items: [
                this.searchOption,
			    this.pictureOption,
                this.wedgitOption,
			    this.chartOption, 
			    this.tableOption, 
			    this.cellOption,
			    this.conditionOption
			]
		});
		
		this.mon(Ext.getBody(), {
			'mousedown': function(e){
				if(!this.suspendMintorMouseDown){
					var target = e.getTarget('.option-button');
					if(this.optionPane && !e.within(this.optionPane.getEl()) && !target){
						this.optionPane.hide();
						if(this.currentActiveBtn){
							this.currentActiveBtn.toggle(false, true);
						}
					}					
				}				
			},
			scope: this
		});			
		
		this.optionPane.items.each(function(it){
			this.relayEvents(it, ['done']);
		}, this);				
	},
	
	/*
	 * show Option pane 
	 */
	showOptionPane : function(name, callback, scope){
		var activeOption;
		if('picture' == name){
			activeOption = this.pictureOption;				
        }else if('wedgit' == name){
            activeOption = this.wedgitOption;
        }else if('search' == name){
			activeOption = this.searchOption;
		}else if('chart' == name){
			activeOption = this.chartOption;
		}else if('table' == name){
			activeOption = this.tableOption;
		}else if('cell' == name){
			activeOption = this.cellOption;
		}else if('condition' == name){
			activeOption = this.conditionOption;
		}
		var optionPaneWidth = activeOption.optionPaneWidth || this.optionPaneWidth; 
		this.optionPane.setWidth(optionPaneWidth);		
		var el = this.sidebar.getEl();
		var x = el.getX()-optionPaneWidth, y = el.getY();
		
        var title = SLANG[name] || name;
        this.optionPane.setTitle(title);
           
        this.optionPane.getLayout().setActiveItem(activeOption);

		if(!this.optionPane.isVisible()){			
			var h = this.getHeight();
			this.optionPane.setHeight(h);					
											
			this.optionPane.showAt(-1000, -1000);
			if(this.suspendMintorMouseDown){
				this.setWidth(this.sidebar.getWidth()+optionPaneWidth-1);
			}			
			this.optionPane.animate({
				duration: 500,
			    from: {
			        x: el.getLeft(),
			        y: el.getTop()
			    },
			    to: {
			        x: x,
			        y: y
			    },
                callback: function(){
                    if(callback){
                        callback.call(scope, this);
                    }
                },
                scope: this
			});	
		}else{
			if(this.suspendMintorMouseDown){
				this.setWidth(this.sidebar.getWidth()+optionPaneWidth-1);
			}
			this.optionPane.showAt(x, y);
		}
	},
	
	/*
	 * swtich option type
	 */
	toggleOption : function(btn, e, callback, scope){
		btn.toggle(true, true);
		this.currentActiveBtn = btn;		
		this.showOptionPane(btn.name, callback, scope);
	},
	
	/*
	 * pin Option pane at right
	 */
	pinOptionPane : function(){
		this.suspendMintorMouseDown = true;
		var width = this.sidebar.getWidth();
		var activeOption = this.optionPane.getLayout().activeItem;
		var optionPaneWidth = activeOption.optionPaneWidth || this.optionPaneWidth;
		
		this.setWidth(width+optionPaneWidth-1);
		this.pinTool.hide();
		this.unpinTool.show();
		
	},
	
	/*
	 * unpin option pane
	 */
	unPinOptionPane : function(){
		this.suspendMintorMouseDown = false;
		var width = this.sidebar.getWidth();
		this.setWidth(width);
		this.pinTool.show();
		this.unpinTool.hide();
	},
	
	/*
	 * close option pane
	 */
	closeOptionPane : function(){
		this.suspendMintorMouseDown = false;
		if(this.currentActiveBtn){
			this.currentActiveBtn.toggle(false, true);
		}
		this.optionPane.hide();		
		var width = this.sidebar.getWidth();
		this.setWidth(width);
	},
           
    /**
     * when seleciton of sheet is changing
     */
    onSelectionChange : function(startPos, endPos, region, sm){       
    	//return;
        var me = this;
        if(startPos){
            var infoStore = me.infoStore;
            var coord = sm.selection2Coord();
            var sheet = this.sheet, store = sheet.getStore(), sheetLookup = store.getSheetLookup();
            var sum = 0, count = 0, min = false, max = false, avg = 0;
            var rowVisibles = {}, colVisibles = {}, arr = [];
            for(var i = 0, len = coord.length; i < len; i++){
            	var span = coord[i];
            	var sheetObj = sheetLookup[span[0]];
            	if(sheetObj){
            		var maxRow = sheetObj.maxRow, maxCol = sheetObj.maxCol;
                	if(span[3] > maxRow){
                		span[3] = maxRow;
                	}
                	for(var r = span[1]; r <= span[3]; r++){
                		if(store.isVisibleRow(span[0], r)){
                			rowVisibles[r] = true; 
                		}
                	}
                	if(span[4] > maxCol){
                		span[4] = maxCol;
                	}
                	for(var c = span[2]; c <= span[4]; c++){
                		if(store.isVisibleColumn(span[0], c)){
                			colVisibles[c] = true; 
                		}
            		}
                	arr.push(span);
            	}            	
            }
            store.walkRange(arr, function(rd){
                var sheetId = rd.data.sheet, row = rd.data.row, col = rd.data.col;
                var json = rd.data.json;
                if(rowVisibles[row] && colVisibles[col]){
                	if(!store.isMergedCell(json, sheetId, row, col) || (0 === json.minrow && 0 === json.mincol)){
                        var val = json.value;
                        if(!Ext.isDefined(val)){
                        	val = json.data;
                        }
                        var num = Number(val);
                        if(Ext.isNumber(num)){
                            count++;
                            if(false === min || min > num){
                                min = num;
                            }
                            if(false === max || max < num){
                                max = num;
                            }
                            sum += num;
                        }
                    }
                }                
            }, this, undefined, undefined, true);
            if(0 < count){
                avg = Math.round(sum/count*1000)/1000;
            }
            if(false === min){
                min = 0;
            }
            if(false === max){
                max = 0;
            }
            me.sumRec.set('value', sum);
            me.minRec.set('value', min);
            me.maxRec.set('value', max);
            me.avgRec.set('value', avg);
            me.countRec.set('value', count);
        }
    },
           
    onChangeReadOnly : function(readOnly, sheet){
        if(readOnly){
            this.disable();
        }else{
            this.enable();
        }
    }
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.toolbar.MenuTitlebar', {
	
	/* Begin Definitions */
	
	extend: 'Ext.toolbar.Toolbar',
	
	alias : 'widget.menutitlebar',
	
	requires: [
	    'EnterpriseSheet.common.Common',
	    'EnterpriseSheet.sheet.action.ActionBox',
	    'Ext.button.Split',
	    'EnterpriseSheet.common.SimpleButton',
	    'Ext.ux.BoxReorderer',
	    'Ext.window.MessageBox',
	    'Ext.form.field.Text',
	    'Ext.toolbar.Spacer',
	    'EnterpriseSheet.sheet.pop.TextWin',
        'EnterpriseSheet.sheet.pop.MoneySelectWin',
        'EnterpriseSheet.sheet.menu.CustomFormatMenu',
        'EnterpriseSheet.sheet.pop.NumberSpecialWin',
        'EnterpriseSheet.sheet.pop.PrintSettingWin'
	],
	
	/* End Definitions */	

	cls: 'ss-title-bar ss-title-menubar',
           
    height: 35,

    layout: {
        type: 'hbox',
        align: 'stretch'
    },
	
	maxTitleLen: 30,
    
	constructor : function(){
    /*
     * an array to contain the pieces we use in toolbar
     */
        this.pieces = [];		
		
		this.callParent(arguments);
	},
           
	/*
	 * init as a plugin of EnterpriseSheet.Sheet
	 */
	init : function(sheet){		
		
		if(this.sheet){
			return;
		}
		this.sheet = sheet;			
		
        /*
         * init the pieces we used in toolbar
         */
        this.initPieces(sheet);
           
        this.store = this.sheet.getStore();
        /*
         * bind the store
         */
        if(this.store){
           this.mon(this.store, {
                scope:this,
                'beforeload': this.beforeLoad,
                'beforepull': this.beforePulling,
                'pull': this.onPull,
                'load': this.onLoad,
                'afterload': this.afterLoad,
                'exception': this.onLoadError,
                'disconnectserver': this.onLostConnection,
                'connectserver': this.onConnectServer,
                'prepareloadingrange': this.beforeLoadingRange,
                'loadingrange': this.onLoad
            });
        }
        
        // this is for other format ... need show it .. as MoneyButton.js - onFormatMenuShow
		this.mon(this.otherFormatMenu, {
			scope : this,
			'show' : this.onOtherFormatMenuShow
		});
        
		this.mon(this.sheet, {
			scope:this,
			'afterloadsheet': this.afterLoad,
            'changereadonly': this.onChangeReadOnly
		});
	},
	
    /*
     * init the pieces we used in toolbar
     */
    initPieces : function(sheet){
        /*
         * bind sheet for pieces
         */
        if('array' == SCOM.typeOf(this.pieces)){
            for(var i = 0, len = this.pieces.length; i < len; i++){
                this.pieces[i].bindSheet(sheet);
            }
        }
    },
    
    defaults: {
    	arrowVisible: false,
    	padding: '0 5'    	
    },
           
	initComponent : function(){		
        this.items = this.prepareMenuItems();
		
		this.callParent(arguments);
		
		this.mon(this.titleBox, {
			scope: this,
			'afterrender': function(){
				var el = this.titleBox.getEl();
				if(el){
					this.mon(el, {
						scope: this,
						'click': this.onTitleBoxClick
					});
				}
			}
		});
        this.on({
            scope: this,
            'afterlayout': function(){
                var titleEl = this.titleBox.getEl(), el = this.getEl(), fillEl = this.fillBtn.getEl();
                if(titleEl){
                    var bw = el.getWidth(), tw = titleEl.getWidth()-titleEl.getPadding('lr');
                    var pad = (bw-tw)/2;
                    var left = el.getX();
                    var loff = titleEl.getX()-left;
                    var nw = tw+(pad-loff)*2;
                    if(100 > nw){
                        nw = 100;
                    }
                    titleEl.setWidth(nw);
                    fillEl.setWidth(fillEl.getRight()-titleEl.getRight());
                    fillEl.setLeft(titleEl.getRight()); 
                }
            }
        });
	},
           
    /*
     * prepare menu items
     */
    prepareMenuItems : function(){
        this.titleBox = new Ext.Component({
            cls: 'ss-file-title',
            html: '<span class="ss-file-title-span" >'+SLANG['untitle_spreadsheet']+'</span><span class="ss-file-title-star">&nbsp;</span>',
            flex: 1
        });

        this.refreshBtn = new Ext.button.Button({
            text: '&nbsp;',
            iconCls: 'icon-refresh',
            minWidth: 25,
            disabled: true,
            reorderable:false,
            handler:this.doRefresh,
            scope:this
        });
           
        this.reconnectBtn = new Ext.button.Button({
            iconCls: 'icon-lighting',                                                  
            minWidth: 25,
            hidden: true,
            reorderable:false,
            handler:this.doReconnect,
            scope:this
        });

           
        this.statusItem = new Ext.toolbar.TextItem({
            text:this.text || this.defaultText || '',
            reorderable:false
        });

        this.shareFileItem = Ext.create('Ext.menu.Item', SABOX.get('shareFile', {text: SLANG['share'] + "...", sender: this}));
        // this.publicFileItem = Ext.create('Ext.menu.Item', SABOX.get('publicFile', {text: SLANG['public'] + "...", sender: this}));
        this.exportFileItem = Ext.create('Ext.menu.Item', SABOX.get('exportFile', {text: SLANG['exportExcel'], disabled: !SCONFIG.enableExport, sender: this}));
        this.printSettingItem = Ext.create('Ext.menu.Item', {
        	text: SLANG['print_setting'],
        	handler: this.onPrintSetting,
        	scope: this
        });
        
        /**
         * add menu bar for file ...
         */
        this.fileMenu = Ext.create('Ext.menu.Menu', {
            items: [{
	                text: SLANG['new'],
	                menu : [
                        SABOX.get('newSheet', {text: SLANG['sheet'], sender:this}),
                        SABOX.get('newSheetFromTpl', {text: SLANG['sheetFromTpl'], sender:this}),
                        SABOX.get('newSheetTpl', {text: SLANG['sheetTpl'], sender:this})
	                ]
	            },
                SABOX.get('openFile', {text: SLANG['open'] + ' (Ctrl+O)', sender: this}),
                SABOX.get('saveFile', {text: SLANG['save_as'] + ' (Ctrl+S)', sender: this}),
	            '-',
                SABOX.get('importFile', {text: SLANG['import'],  disabled: !SCONFIG.enableImport, sender: this}),
                this.exportFileItem,
                '-',
                this.printSettingItem
            ]            
        });
           
        /**
         * This is for edit drop down menu
         */
        this.editMenu = Ext.create('Ext.menu.Menu', {
            items: [
                SABOX.get('cut', {iconCls: 'icon-cut',tooltip: SLANG['cut_tip'],text: SLANG['cut'] + ' (Ctrl+X)', sender: this}),
                SABOX.get('copy', {iconCls: 'icon-copy',tooltip: SLANG['copy_tip'],text: SLANG['copy']  + ' (Ctrl+C)', sender: this}),
                SABOX.get('paste', {iconCls: 'icon-paste',tooltip: SLANG['paste_tip'],text: SLANG['paste']  + ' (Ctrl+V)', sender:this}),
                '-',
                {text: SLANG['find_replace'] + '... (Ctrl+F)', handler: this.onFindReplace, scope: this},
                {text: SLANG['charts'] + '...', handler: this.onShowCharts, scope: this},
                {text: SLANG['table_styles'] + '...', handler: this.onShowTables, scope: this},
                {text: SLANG['cell_styles'] + '...', handler: this.onShowCellStyles, scope: this},
                {text: SLANG['condition_management'] + '...', handler: this.onConditionMgr, scope: this}
            ]
        });
           
        this.freezeItem = new Ext.menu.Item(SABOX.get('doFreeze', {
            text : SLANG['freeze_sheet'],
            /*
             * define a toggle to change the item text, it will called by the
             * action
             */
            toggle : function(pressed, suspendEvent) {
                if (!pressed) {
                    this.setText(SLANG['freeze_sheet']);
                } else {
                    this.setText(SLANG['cancel_freeze']);
                }
            },
            sender: this
        }));
           
        this.splitItem = new Ext.menu.Item(SABOX.get('doSplit', {
            text : SLANG['split_sheet'],
            /*
             * define a toggle to change the item text, it will called by the
             * action
             */
            toggle : function(pressed, suspendEvent) {
                if (!pressed) {
                    this.setText(SLANG['split_sheet']);
                } else {
                    this.setText(SLANG['cancel_split']);
                }
            },
            sender: this
        }));
           
        this.gridLineItem = new Ext.menu.Item(SABOX.get('toggleGridLine', {
            text : SLANG['hide_grid_line'],
            /*
             * define a toggle to change the item text, it will called by the
             * action
             */
            toggle : function(pressed, suspendEvent) {
                if (!pressed) {
                    this.setText(SLANG['hide_grid_line']);
                } else {
                    this.setText(SLANG['show_grid_line']);
                }
            },
            sender: this
        }));
        
        this.rowNameItem = new Ext.menu.Item(SABOX.get('toggleRowName', {
            text : SLANG['hide_row_name'],
            /*
             * define a toggle to change the item text, it will called by the
             * action
             */
            toggle : function(pressed, suspendEvent) {
                if (!pressed) {
                    this.setText(SLANG['hide_row_name']);
                } else {
                    this.setText(SLANG['show_row_name']);
                }
            },
            sender: this
        }));
        
        this.colNameItem = new Ext.menu.Item(SABOX.get('toggleColName', {
            text : SLANG['hide_col_name'],
            /*
             * define a toggle to change the item text, it will called by the
             * action
             */
            toggle : function(pressed, suspendEvent) {
                if (!pressed) {
                    this.setText(SLANG['hide_col_name']);
                } else {
                    this.setText(SLANG['show_col_name']);
                }
            },
            sender: this
        }));
        /**
         * This is for view drop down menu
         */
        this.viewMenu = Ext.create('Ext.menu.Menu', {
            items: [
                this.freezeItem,
                this.splitItem,
                this.gridLineItem,
                this.rowNameItem,
                this.colNameItem
            ]
        });
           
        this.viewMenu.on({
            scope: this,
            'show': this.onViewMenuShow
        });
           
        /**
         * this is for add format menu
         */
        this.insertMenu = Ext.create('Ext.menu.Menu', {
            items: [
                SABOX.get('insertDropList', {text: SLANG['insert_drop_list'], hidden: SCONFIG.js_standalone, sender: this}),
                SABOX.get('insertCheckbox', {text: SLANG['checkbox'], sender: this}),
                SABOX.get('insertRadio', {text: SLANG['radio'], sender: this}),
                SABOX.get('insertDatePicker', {text: SLANG['insert_date_picker'], sender: this}),                    
                SABOX.get('clearItem', {text: SLANG['clearCheckboxRadio'], sender: this}),
                // SABOX.get('insertSequenceNo', {text: SLANG['insert_sequence_no']}),
                '-',
                {
                    text: SLANG['function'], iconCls : 'icon-sum',
                    menu: [
                        SABOX.get('sum', {	text:SLANG['sum'], sender: this}),
                        SABOX.get('average', {text:SLANG['average'], sender: this}),
                        SABOX.get('count', {text:SLANG['count'], sender: this}),
                        SABOX.get('maxValue', {text:SLANG['max'], sender: this}),
                        SABOX.get('minValue', {	text:SLANG['min'], sender: this}),
                        '-',
                        SABOX.get('insertFormula', {iconCls : 'icon-fx', text : SLANG['more_functions'] + '...' , sender: this})
                    ]
                },
                SABOX.get('markRange', {text : SLANG['mark_range'] + '..', sender: this}),
                SABOX.get('insertComment', {iconCls : 'icon-insert-comment', text : SLANG['insert_comment'], sender: this}),
                '-',
                SABOX.get('insertHyperlink', {iconCls : 'icon-link', text : SLANG['hyperlink'] + '... (Ctrl+K)', sender: this}),
                {text: SLANG['image'] + '...', handler: this.onInsertImage, scope: this}
            ]
        });
           
        // for number item in the format drop down list
        this.otherFormatMenu = Ext.create("EnterpriseSheet.sheet.menu.TextFormatMenu", {minWidth: 160});
        this.pieces.push(this.otherFormatMenu);
        
        this.currencyWin = Ext.create("EnterpriseSheet.sheet.pop.MoneySelectWin", {});
        this.pieces.push(this.currencyWin);
           
        this.customMenu = Ext.create("EnterpriseSheet.sheet.menu.CustomFormatMenu", {});
        this.pieces.push(this.customMenu);
        
        this.numberSpecialWin = Ext.create("EnterpriseSheet.sheet.pop.NumberSpecialWin", {});
        this.pieces.push(this.numberSpecialWin);
           
        /**
         * this is for add format menu
         */
        this.formatMenu = Ext.create('Ext.menu.Menu', {
            items: [
                { text: SLANG['currency'], iconCls: 'icon-dollar', handler: function() {
                    this.currencyWin.popup();
                }, scope: this},
                { text: SLANG['number_format'], menu: this.otherFormatMenu, sender: this},
                { text: SLANG['custom'], iconCls: 'icon-custom', menu: this.customMenu, sender: this},
                { text: SLANG['number_special'], handler: function() {
                    this.numberSpecialWin.popup();
                }, scope: this},
                '-',
                SABOX.get('bold', {iconCls: 'icon-bold',tooltip: SLANG['bold_tip'],text: SLANG['bold'] + ' (Ctrl+B)', sender: this}),
                SABOX.get('underline', {iconCls: 'icon-underline',tooltip: SLANG['underline_tip'],text: SLANG['underline'] + ' (Ctrl+U)', sender: this}),
                SABOX.get('italic', {iconCls: 'icon-italic',tooltip: SLANG['italic_tip'],text: SLANG['italic'] + ' (Ctrl+I)', sender: this}),
                SABOX.get('strike', {iconCls: 'icon-strike',tooltip: SLANG['strike'],text: SLANG['strike'], sender: this}),
                '-',
                {
                    text: SLANG['align'], iconCls: 'icon-align',
                    menu : [
                        SABOX.get('alignLeft', {text: SLANG['align_left'], sender: this}),
                        SABOX.get('alignCenter', {text: SLANG['align_center'], sender: this}),
                        SABOX.get('alignRight', {text: SLANG['align_right'], sender: this}),
                        SABOX.get('alignTop', {text: SLANG['align_top'], sender: this}),
                        SABOX.get('alignMiddle', {text: SLANG['align_middle'], sender: this}),
                        SABOX.get('alignBottom', {text: SLANG['align_bottom'], sender: this})
                    ]
                },{
                    text: SLANG['merge_cell'], iconCls: 'icon-merge',
                    menu : [
                        SABOX.get('mergeCell', { text:SLANG['merge_cell'], sender: this}),
                        SABOX.get('mergeColumn', {text:SLANG['merge_cell_in_column'], sender: this}),
                        SABOX.get('mergeRow', {text:SLANG['merge_cell_in_row'], sender: this}),
                        SABOX.get('cancelMerge', {text:SLANG['cancel_merge_cell'], sender: this})
                    ]
                },
                SABOX.get('wordWrap', {tooltip: SLANG['word_wrap'], text: SLANG['word_wrap'], sender:this}),
                '-',
                {
                    text: SLANG['clean'],
                    iconCls: 'icon-clean-range',
                    menu: [
                        SABOX.get('clean', {text: SLANG['clean_all'], sender: this}),
                        SABOX.get('cleanContent', {text:SLANG['clean_content'], sender: this}),
                        SABOX.get('cleanStyle', {text:SLANG['clean_style'], sender: this})
                    ]
                }
            ]
        });
           
        /**
         * this is for add format menu
         */
        this.dataMenu = Ext.create('Ext.menu.Menu', {
            items: [
                SABOX.get('validation', {text: SLANG['validation']+'..', sender: this}),
                '-',
                SABOX.get('sortAsc', { iconCls:'icon-sort-asc',text:SLANG['sort_asc'], sender: this}),
                SABOX.get('sortDesc', {iconCls:'icon-sort-desc',text:SLANG['sort_desc'], sender: this}),
                '-',
                SABOX.get('deleteRepeat', {text:SLANG['delete_repeat_item'], sender: this})
                //'-',
                //SABOX.get('pivotTable', {text:SLANG['pivot_table'], sender: this})
            ]
        });
        
        this.langMenu = Ext.create('Ext.menu.Menu', {
            items: [SABOX.get('langen', {text : SLANG['lang_en'], sender: this}),
                SABOX.get('langzh', {text : SLANG['lang_zh'], sender: this})
            ]
        });
        
        var hidden = SCONFIG.help_menu_hide && 'commercial' === SCONST.limitType;
        this.helpMenu = Ext.create('Ext.menu.Menu', {
            hidden: hidden,
            items: [{
                text: SLANG['documentation'],
                handler: this.onSupport,
                scope: this
            }, 
            SABOX.get('keyboardShortcuts', {
                text : SLANG['keyboard_shortcuts'],
                sender: this
            }),
            SABOX.get('aboutSheet', {
                iconCls:'icon-sheet',
                text : SLANG['aboutSheet'],
                sender: this
            })]
        });

        this.fillBtn = Ext.create('Ext.toolbar.Fill', {});

        var items = [{
            text: SLANG['file'],            
            hidden: SCONFIG.file_menu_hide,
            menu: this.fileMenu
        }, {
            text: SLANG['edit'],
            menu: this.editMenu
        }, {
            text: SLANG['view'],
            menu: this.viewMenu
        }, {
            text: SLANG['insert'],
            menu: this.insertMenu
        }, {
            text: SLANG['format'],
            menu: this.formatMenu
        }, {
            text: SLANG['data'],
            menu: this.dataMenu
        }, /** {
            text: SLANG['tool'],
            menu: []
        },**/ {
            text: SLANG['help'],
            menu: this.helpMenu
        }, this.titleBox, this.fillBtn, this.statusItem, this.refreshBtn, this.reconnectBtn, {
            xtype: 'tbseparator',
            hidden: SCONFIG.language_menu_hide
        }, {
            text: SLANG['language'],
            hidden: SCONFIG.language_menu_hide,
            menu: this.langMenu
        }];
           
        return items;
    },
           
    beforePulling : function(){
        if(this.rendered && this.refreshBtn){
            this.refreshBtn.disable();
            var sEl = this.statusItem.getEl();
            if(sEl){
                sEl.addCls('ss-loading-span');
            }
            if(this.countDownTask){
                Ext.TaskManager.stop(this.countDownTask);
            }
            this.reconnectBtn.hide();
            this.statusItem.setText(SLANG['saving']+'...');
        }
    },
           
    onPull : function(){
        this.onLoad();
    },
           
    beforeLoad : function(){
        if(this.rendered && this.refreshBtn){
            this.refreshBtn.disable();
            var sEl = this.statusItem.getEl();
            if(sEl){
                sEl.addCls('ss-loading-span');
            }
            this.statusItem.setText(SLANG['loading']+'...');
        }
    },
           
    beforeLoadingRange : function(){
        if(this.rendered && this.refreshBtn){
            this.refreshBtn.disable();
            var sEl = this.statusItem.getEl();
            if(sEl){
                sEl.addCls('ss-loading-span');
            }
            this.statusItem.setText(SLANG['loading_calculating']+'...');
        }
    },
        
           
    onLoad : function(){
        this.refreshBtn.enable();
        var sEl = this.statusItem.getEl();
        if(sEl){
           sEl.removeCls('ss-loading-span');
        }
        var date = new Date();
        var dateStr = Ext.Date.format(date, 'H:i:s');
        this.statusItem.setText(SLANG['all_changes_are_saved']+' '+SLANG['at']+' '+dateStr);
    },
           
    onLoadError : function(){
        if(!this.rendered){
           return;
        }
        var sEl = this.statusItem.getEl();
        if(sEl){
           sEl.removeCls('ss-loading-span');
        }
        this.refreshBtn.enable();
    },
           
    doRefresh : function(){
        if(this.store){
            this.store.loadFile();
        }
    },
           
    onFindReplace : function(){
        this.fireEvent('findreplace', this);
    },
           
    onShowCharts : function() {
        this.fireEvent('showCharts', this);
    },
           
    onShowTables : function() {
        this.fireEvent('showTables', this);
    },
           
    onShowCellStyles : function() {
        this.fireEvent('showcellstyles', this);
    },
           
    onConditionMgr : function() {
        this.fireEvent('showconditionmgr', this);
    },
           
    onInsertImage : function() {
        this.fireEvent('showinsertimage', this);
    },
           
    onLinkFunctionList : function() {
        window.open('http://www.enterprisesheet.com/resource/document/EnterpriseSheetFunctions.pdf');
    },
    
    onSupport : function() {
        window.open('http://www.enterprisesheet.com/api');
    },
	
    onViewMenuShow : function(){
        this.splitItem.toggle(this.sheet.isSplited(), true);
        this.freezeItem.toggle(this.sheet.isFreezed(), true);
        this.gridLineItem.toggle(!this.sheet.withGridLine(), true);
        this.rowNameItem.toggle(this.sheet.getStore().rowNameHidden, true);
        this.colNameItem.toggle(this.sheet.getStore().colNameHidden, true);
    },
	
	/*
	 * update title box with the file name
	 */
	updateTitleBox : function(fileName, fileStared, exname, isPublic){

        var fullName = fileName;
		fileName = Ext.String.ellipsis(fileName, this.maxTitleLen, true);
		var tip = '';
        if(fullName !== fileName){
            tip = 'data-qtip="'+fullName+'"';
        }
        var tpl = '';
        if (exname == "xlt"){
           tpl = '<span class="ss-file-tpl icon-sheet-tpl" data-qtip="'+SLANG['sheetTplUpdateTip']+'">&nbsp;</span>';
        };
        
		var cls = fileStared ? 'ss-file-stared' : '';
		this.titleBox.update([
            tpl,
		    '<span class="ss-file-title-span" '+tip+'>',
		    	fileName,		    			    
		    '</span>',
		    '<span class="ss-file-title-star ',
		    	cls,
		    '">&nbsp;</span>'	
		].join(''));
	},
		
	/*
	 * after store reload
	 */
	afterLoad : function(){
        var ss = this.sheet, store = ss.getStore(), activeSheetId = ss.getSheetId();
        var sheets = store.getSheets(), loadedFile = store.getLoadedFile();
        var fileName;
        if(loadedFile){
            fileName = loadedFile.name;
        }
        fileName = fileName || SLANG['untitle_spreadsheet'];
           
        this.updateTitleBox(fileName, loadedFile.stared, loadedFile.exname);
        this.onLoad();
	},
	
	/*
	 * click on title box
	 */
	onTitleBoxClick : function(e){
        if(this.sheet.isReadOnly()){
            return;  
        }
		var store = this.sheet.getStore();
		var starSpan = e.getTarget('.ss-file-title-star');
		if(starSpan){
            var file = store.getLoadedFile();
			starSpan = Ext.get(starSpan);
			if(starSpan.hasCls('ss-file-stared')){
                if(Ext.isDefined(file.id)){
                    store.changeFileStared(false, function(success){
                        if(success){
                            starSpan.removeCls('ss-file-stared');
                        }
                    }, this);
                }else{
				starSpan.removeCls('ss-file-stared');
                }
			}else{
                if(Ext.isDefined(file.id)){
                    store.changeFileStared(true, function(success){
                        if(success){
                            starSpan.addCls('ss-file-stared');
                        }
                    }, this);
			}else{
				starSpan.addCls('ss-file-stared');
                }
			}			
		}else{
			var titleSpan = e.getTarget('.ss-file-title-span');
			if(titleSpan){
				var fileName = store.getLoadedFileName() || SLANG['untitle_spreadsheet'];
				this.showRenameFileWin(fileName);
			}
		}		
	},		
	
	showRenameFileWin : function(fileName){
		SPOP.showTextBox({
			title: SLANG['change_file_title'],
			fieldLabel: SLANG['input_file_name'],
			value: fileName,
			applyCallback: {
				fn: function(name){
					this.changeFileName(name);
				},
				scope: this
			}
		});
	},
	
	/*
	 * change the file name
	 */
	changeFileName : function(fileName){		
		var stared;
		if(this.sheet){		
			var store = this.sheet.getStore();
            var file = store.getLoadedFile();
            if(Ext.isDefined(file.id)){
                stared = file.stared;
                store.changeFileName(fileName, function(success){
                    if(success){
                        this.updateTitleBox(fileName, stared);
                    }
                }, this);
            }else{
                this.updateTitleBox(fileName, stared);           
            }
		}	
	},
	
    // this is for other format menu show
    onOtherFormatMenuShow : function() {
    	var sheet = this.sheet;
		if (sheet) {
			var sm = sheet.getSelectionModel(), store = sheet.getStore();
			var focus = sm.getFocusCell();
			var cell = sheet.getCellValue(sheet.getSheetId(), focus.row, focus.col);
			this.otherFormatMenu.previewTextFormat(cell.data);
		}
    },
           
    onChangeReadOnly : function(readOnly, sheet){
        this.items.each(function(it){
            if(!Ext.isDefined(it.initHidden)){
                it.initHidden = !it.isVisible();
            }
        }, this);
        if(readOnly){
            this.items.each(function(it, index){
                if(it !== this.titleBox && Ext.isFunction(it.hide)){
                    it.hide();
                }
            }, this);
            this.addCls('ss-disabled-title-menubar');
        }else{
           this.items.each(function(it){
                if(Ext.isFunction(it.show)){
                    if(true !== it.initHidden){
                        it.show();
                    }
                }
            }, this);
            this.removeCls('ss-disabled-title-menubar');
        }
        if(Ext.isFunction(this.doLayout)){
        	this.doLayout();
        }else if(Ext.isFunction(this.updateLayout)){
        	this.updateLayout();
        } 
    },
           
    beforeFileMenuShow : function(){
        if(this.sheet){
            var store = this.sheet.getStore();
            if(store.isShareableFile()){
                this.shareFileItem.enable();
                this.publicFileItem.enable();
            }else{
                this.shareFileItem.disable();
                this.publicFileItem.disable();
           }
            var isShowExport = store.isExportableFile();
            if(SCONFIG.enableExport && isShowExport){
                this.exportFileItem.enable();
            }else{
                this.exportFileItem.disable();
            }
        }
    },
           
    /**
     * when lost connection with backend
     */
    onLostConnection : function(){
        this.statusItem.show();
        this.reconnectBtn.show();
        var sEl = this.statusItem.getEl();
        if(sEl){
            sEl.removeCls('ss-loading-span');
        }
        var count = Math.round(SCONST['RECONNECT_SERVER_INTERVAL']/1000), me = this;
           this.statusItem.setText(SLANG['disconnect_with_server']+', '+SLANG['reconnect_in']+' '+count+' '+(1 < count ? SLANG['seconds'] : SLANG['second']));
        if(this.countDownTask){
            Ext.TaskManager.stop(this.countDownTask);
        }
        this.countDownTask = Ext.TaskManager.start({
            run: function(){
                count--;
                me.statusItem.setText(SLANG['disconnect_with_server']+', '+SLANG['reconnect_in']+' '+count+' '+(1 < count ? SLANG['seconds'] : SLANG['second']));
            },
            interval: 1000,
            repeat: count-1
        });
    },
    
    onConnectServer : function(){
        this.reconnectBtn.hide();
        this.refreshBtn.show();
        this.onLoad();
    },
           
    doReconnect : function(){
        if(this.countDownTask){
            Ext.TaskManager.stop(this.countDownTask);
        }
        this.statusItem.setText(SLANG['connectiong_sever']+'...');
        this.sheet.getStore().reconnectServer();
    },
    
    onPrintSetting : function(){
    	if(!this.printSettingWin){
    		this.printSettingWin = Ext.create('EnterpriseSheet.sheet.pop.PrintSettingWin', {
    			sheet: this.sheet,
    			applyCallback: {
    				fn: function(params){
    					this.sheet.savePrintSettingForSheet(this.sheet.getSheetId(), params);
    				},
    				scope: this
    			}
    		});
    	}    	    
    	this.printSettingWin.popup();
    }
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.sheet.plugin.SequenceNumber', {
	
	constructor : function(config){
		Ext.apply(this, config);
		this.callParent(arguments);
		
		this.initMenu();
	},
	
	initMenu : function(){
		this.menu = Ext.create('Ext.menu.Menu', {
			items: [{
				text: 'Insert sequence No after'
			}, {
				text: 'Insert sub-sequence No after'
			}]
		});
	},
	
	init : function(sheet){
		this.sheet = sheet;
		
		Ext.getDoc().on('mousedown', this.onMouseDownViewEl, this);
	},
	
	onMouseDownViewEl : function(e){
		var target = Ext.get(e.getTarget());
		if(target.hasCls('ss-cell-seq')){		
			if(this.pressedTarget && this.pressedTarget !== target){
				this.pressedTarget.removeCls('ss-cell-seq-pressed');
				delete(this.pressedTarget);
				return;
			}
			this.pressedTarget = target;
			target.addCls('ss-cell-seq-pressed');
			this.menu.showBy(target);
		}else{
			if(this.pressedTarget){
				this.pressedTarget.removeCls('ss-cell-seq-pressed');
				delete(this.pressedTarget);
			}			
		}
	}
});
Ext.define('EnterpriseSheet.sheet.Sheet', {
	
	/* Begin Definitions */
	
	extend: 'Ext.container.Container',
	
	alias : 'widget.enterprisesheet',
	
	requires: [	    
		'EnterpriseSheet.common.CONST',
		'EnterpriseSheet.common.Common',
		'EnterpriseSheet.sheet.plugin.CellRender',
		'EnterpriseSheet.sheet.plugin.DataTypeProcessor',
		'EnterpriseSheet.sheet.layout.LayoutTemplates',
		'EnterpriseSheet.sheet.layout.Table',
		'EnterpriseSheet.sheet.data.Format',    
		'EnterpriseSheet.common.Tip',
		'EnterpriseSheet.sheet.autofill.Autofill',               
		'EnterpriseSheet.sheet.action.ActionBox',
		'EnterpriseSheet.sheet.menu.ContextMenu',       
	    'EnterpriseSheet.sheet.regions.Region',
	    'EnterpriseSheet.sheet.regions.Lefter',
	    'EnterpriseSheet.sheet.regions.Header',
	    'EnterpriseSheet.sheet.regions.Corner',	    	    
	    'EnterpriseSheet.sheet.calculate.Condition',
	    'EnterpriseSheet.sheet.filter.Filter',
	    'EnterpriseSheet.sheet.tpl.TableTemplate',	    
	    'EnterpriseSheet.sheet.range.Range',
	    'EnterpriseSheet.sheet.data.RangeStore',
	    'EnterpriseSheet.sheet.floating.picture.PictureFloor',
	    'EnterpriseSheet.sheet.floating.chart.ChartFloor',
	    'EnterpriseSheet.sheet.pop.FloatingContainer',
        'EnterpriseSheet.common.LoadMask',
        'EnterpriseSheet.sheet.floating.DeleteRepeatOption'
	],
	
	/* End Definitions */
	
	
	resizeCheckBuffer : 0,
           
    calMaskDelayTime: 1000,
	
	keyDownThrottled : 15,
	
	maxDigital : 18,
	
	/*
	 * the kip show position offset
	 */
	kitOffset: [0, 5],
	
	focusDelayTime : Ext.isIE ? 500 : 100,
	/*
	 * true to disable condition
	 */
	disableCondition : false,
		
	/*
	 * creat a default editor if don't have one
	 */
	useDefaultEditor: true,
    
    /*
     * a flag to highlight the cells after recalculating
     */
    highlightCellsAfterCalculate: true,
	
	/*
	 * creat a default table template if don't have one
	 */
	useDefaultTableTpl : true,		
	
	/*
	 * creat a default filter if don't have one
	 */
	useDefaultFilter : true,	
	
	/*
	 * true to disable calculate
	 */
	disableCalculate : false,
		
	/*
	 * default sheet id
	 */
	sheetId : 0,
	
	scrollStep : Ext.isChrome?3:1,
	/*
	 * how many digitals of max row index
	 */	 
	defaultRowIndexDigital : 2,
		 
	maxRowIndexDigital : 2,
	
	digitalWidth : 8,		
	
	spaceWidth : 5,		
	
	/*
	 * enable row/column group
	 */
	enableRowColGroup : true,
	/*
	 * group level length
	 */
	groupPadding : 10,
	
	groupOffset : 15,
	
	/*
	 * the millisecond of delay checking lefter width
	 * it will use in checkLefterWidth function
	 */
	checkLeftDelay : 100,
           
    processingDataChangeBuffer: 50,
	
	/*
	 * flag to init comment tip
	 */
	enableCommentTip : true,
	
	enableVariableTip : true,
	
	enableCustomBindingDataTip : true,
           
	/**
	 * init data type config
	 */	
	initDataTypeProcessor : function(){
		this.dtProcessor = Ext.create('EnterpriseSheet.sheet.plugin.DataTypeProcessor', {});
		this.dtProcessor.init(this);
	},
	
	getDataTypeProcessor : function(){
		return this.dtProcessor;
	},
	
	/**
	 * init comment tip, and create listeners for edit/delete comment
	 */		
	initCommentTip : function(){
		var me = this, store = me.getStore();
		this.commentTip = new EnterpriseSheet.sheet.pop.FloatingContainer({		
			cls: 'ss-comment-ct',
			defaultAlign: 'tl-tr?',
			width: 200,
			autoHeight: true,			
			items: [{
				xtype: 'component',
				cls: 'ss-comment-inner'
			}, {
				xtype: 'container',
				cls: 'ss-comment-bbar',				
				items: [{
					xtype: 'button',
					text: SLANG['edit'],
					margin: '0 5 0 0',
					handler: function(){
						SPOP.showCommentBox({
							title: SLANG['insert_comment'],
							comment: me.commentTip.comment,
							applyCallback : {
								fn : function(comment) {
									me.insertComment(comment, me.commentTip.currentPos);										
								},
								scope : this
							}
						});	
						me.commentTip.hide();
					}
				}, {
					xtype: 'button',
					text: SLANG['delete'],
					handler: function(){
						var pos = me.commentTip.currentPos, sheetId = pos.sheet, minrow = pos.row, mincol = pos.col, maxrow = minrow, maxcol = mincol;
                        var cell = store.getCell(sheetId, minrow, mincol);
                        if(Ext.isDefined(cell.minrow)){
                            minrow += cell.minrow;
                            mincol += cell.mincol;
                            maxrow += cell.maxrow;
                            maxcol += cell.maxcol;
                        }
						me.deleteComment([[sheetId, minrow, mincol, maxrow, maxcol]]);
						me.commentTip.hide();
					}
				}]
			}],
			updateComment : function(msg){
				this.items.get(0).update(msg);
			},
			hideBtn : function() {
				this.items.get(1).setVisible(false);
			},
			showBtn : function() {
				this.items.get(1).setVisible(true);
			}
		});
	},
	
	/**
	 * init variable tip, and create listeners for edit/delete comment
	 */		
	initVariableTip : function(){
		var me = this, store = me.getStore();
		this.variableTip = new EnterpriseSheet.sheet.pop.FloatingContainer({		
			cls: 'ss-var-ct',
			defaultAlign: 'tl-tr?',
			width: 200,
			autoHeight: true,			
			items: [{
				xtype: 'component',
				cls: 'ss-var-inner'
			}, {
				xtype: 'container',
				cls: 'ss-var-bbar',				
				items: [{
					xtype: 'button',
					text: SLANG['edit'],
					margin: '0 5 0 0',
					handler: function(){
						var pos = me.variableTip.currentPos;
						var str = me.coord2StringWithSheetName([[pos.sheet, pos.row, pos.col, pos.row, pos.col]], '');
						SPOP.showVarTextBox({
							title: SLANG['add_variable_for']+str,
							fieldLabel: SLANG['input_variable_name'],
							value: me.variableTip.vname,
							applyCallback : {
								fn : function(name) {									
									me.insertVariable(pos.sheet, pos.row, pos.col, name);
								},
								scope : this
							}
						});							
						me.variableTip.hide();
					}
				}, {
					xtype: 'button',
					text: SLANG['delete'],
					handler: function(){
						var pos = me.variableTip.currentPos;
						me.deleteVariable([[pos.sheet, pos.row, pos.col, pos.row, pos.col]]);
						me.variableTip.hide();
					}
				}]
			}],
			updateContent : function(msg){
				msg = SLANG['define_variable_for_cell']+'<br><b>'+msg+'</b>';
				this.items.get(0).update(msg);
			},
			hideBtn : function() {
				this.items.get(1).setVisible(false);
			},
			showBtn : function() {
				this.items.get(1).setVisible(true);
			}
		});
	},
	
	// customer binding data 
	initCustomBindingDataTip : function(){
		var me = this, store = me.getStore();
		this.customBindingDataTip = new EnterpriseSheet.sheet.pop.FloatingContainer({		
			cls: 'ss-var-ct',
			defaultAlign: 'tl-tr?',
			width: 300,
			autoHeight: true,			
			items: [{
				xtype: 'component',
				cls: 'ss-var-inner'
			}],
			updateContent : function(msg) {
				this.items.get(0).update(msg);
			}
		});
	},
		
	/**
	 * init exception tip
	 */
	initExceptionTip : function(){
		this.exceptionTip = new EnterpriseSheet.sheet.pop.FloatingContainer({		
			cls: 'ss-exception-ct',
			defaultAlign: 'tr-tl?',			
			width: 200,
			autoHeight: true
		});
	},
	
	constructor : function(){
		this.callParent(arguments);
	},
	
	initComponent : function(){
        SABOX.addHotKey(this);
        /*
         * create clipboard and autofill
         */
        this.clipboard = new EnterpriseSheet.sheet.action.ClipBoard();
        this.clipboard.init(this);
           
        this.autofill = new EnterpriseSheet.sheet.autofill.Autofill();
        this.autofill.init(this);
		/*
		 * use table layout
		 */
		this.layout = 'fit';
		var sheetId = this.getSheetId();
		this.cls = this.cls || '';
		this.cls = 'ss-ct '+this.cls;
		/*
		 * calculate the lefter width based on the max row index digital number
		 */		
		var lw = this.maxRowIndexDigital*this.digitalWidth+this.spaceWidth;
		/*
		 * init store if not defined yet
		 */
		this.store = this.store || new EnterpriseSheet.sheet.data.Store({
			url:this.url
		});
				
		this.store.setLeftWidth(sheetId, lw);					

		/*
		 * for the lefter and header
		 */
		this.ltcorner = new EnterpriseSheet.sheet.regions.Corner({			
			store: this.store
		});
				
		this.lheader = new EnterpriseSheet.sheet.regions.Header({	
			hidden:true,			
			fixedRowForResize:true,
			store:this.store,					
			scrollConfig:{
				dir:'none',
				scrollStep:this.scrollStep,
				alwaysVisible: this.scrollerAlwaysVisible
			},
			resizerConfig:{
				rtype:'ColumnResizer',
				/*
				 * the id of the column resize proxy, we need generate the element
				 * in onRender function
				 */
				proxy:'ss-cproxy'
			}
		});
		
		this.sheader = new EnterpriseSheet.sheet.regions.Header({						
			fixedRowForResize:true,
			store:this.store,
			scrollConfig:{
				dir:'none',  
				scrollStep:this.scrollStep,
				alwaysVisible: this.scrollerAlwaysVisible
			},
			resizerConfig:{
				rtype:'ColumnResizer',
				/*
				 * the id of the column resize proxy, we need generate the element
				 * in onRender function
				 */
				proxy:'ss-cproxy'
			}
		});
		
		this.ulefter = new EnterpriseSheet.sheet.regions.Lefter({
			hidden:true,			
			fixedColForResize:true,
			store:this.store,
			scrollConfig:{
				dir:'none',
				scrollStep:this.scrollStep,
				alwaysVisible: this.scrollerAlwaysVisible
			},
			resizerConfig:{
				rtype:'RowResizer',
				/*
				 * the id of the row resize proxy, we need generate the element
				 * in onRender function
				 */
				proxy:'ss-rproxy'
			}
		});
		
		this.slefter = new EnterpriseSheet.sheet.regions.Lefter({			
			fixedColForResize:true,			
			store:this.store,
			scrollConfig:{
				dir:'none',
				scrollStep:this.scrollStep,
				alwaysVisible: this.scrollerAlwaysVisible
			},			
			resizerConfig:{
				rtype:'RowResizer',
				/*
				 * the id of the row resize proxy, we need generate the element
				 * in onRender function
				 */
				proxy:'ss-rproxy'
			}
		});
		/*
		 * for region
		 */
		this.ltregion = new EnterpriseSheet.sheet.regions.Region({
			hidden:true,
			cls:'ss-ltregion',
			fixedRowForResize:true,
			fixedColForResize:true,
			store:this.store,
			scrollConfig:{
				dir:'none',
				scrollStep:this.scrollStep,
				alwaysVisible: this.scrollerAlwaysVisible
			}
		});
		
		this.tregion = new EnterpriseSheet.sheet.regions.Region({
			hidden:true,
			cls:'ss-tregion',
			fixedRowForResize:true,
			store:this.store,
			scrollConfig:{
				dir:'y',
				scrollStep:this.scrollStep,
				alwaysVisible: this.scrollerAlwaysVisible
			}
		});
		
		this.lregion = new EnterpriseSheet.sheet.regions.Region({
			hidden:true,
			cls:'ss-lregion',
			fixedColForResize:true,
			store:this.store,	
			scrollConfig:{
				dir:'x',
				scrollStep:this.scrollStep,
				alwaysVisible: this.scrollerAlwaysVisible
			}
		});
		
		this.cregion = new EnterpriseSheet.sheet.regions.Region({		
			cls:'ss-cregion',
			store:this.store,
			scrollConfig:{
				dir:'xy',
				scrollStep:this.scrollStep,
				alwaysVisible: this.scrollerAlwaysVisible
			}
		});					
		
		/*
		 * use the defaults to pass the sheetId
		 */
		this.defaults = this.defaults || {};
		Ext.applyIf(this.defaults, {sheetId:this.getSheetId()});
		
		this.innerCt = new Ext.container.Container({
			cls: 'ss-inner-ct',
			layout: {
				type:'sheettable',			
				columns:3
			},
			items: [
				this.ltcorner,
				this.lheader,
				this.sheader,
				
				this.ulefter,			
				this.ltregion,
				this.tregion,
				
				this.slefter,
				this.lregion,
				this.cregion
			]
		});
		this.items = [this.innerCt];
			
		
		/*
		 * lookup array, a neat way to visit all regions
		 */
		this.regionLookup = ['ulefter', 'slefter', 'lheader', 'sheader', 'ltregion', 'tregion', 'lregion', 'cregion'];
		
		this.bodyRegionLookup = ['ltregion', 'lregion', 'tregion', 'cregion'];
		
		this.floorRegionLookup = ['ltregion', 'lregion', 'tregion', 'cregion'];
		
		this.lefterHeaderRegionLookup = ['ulefter', 'slefter', 'lheader', 'sheader'];
		
		/*
		 * init reference model
		 */
		this.initReferenceModel();
		/*
		 * create the editor
		 */
		this.initEditor();		
		
		/*
		 * create a table template 
		 */		
		this.initTableTpl();
		
		/*
		 * create a filter 
		 */	
		this.initFilter();
		
		this.initDataTypeProcessor();
		
		/*
		 * prepare the calculate stuff
		 */
		this.prepareCalculate();
		
		this.callParent();
		
		/*
		 * enable comment tip
		 */
		if(this.enableCommentTip){
			this.initCommentTip();
		}
		
		if(this.enableVariableTip){
			this.initVariableTip();
		}
		
		if (this.enableCustomBindingDataTip) {
		    this.initCustomBindingDataTip();	
		}
		
		this.initExceptionTip();
		
		
		
		this.store.relayEvents(this, ['freezechange', 'splitchange', 'afterloadsheet']);
		/*
		 * relay events from store
		 */
		this.relayEvents(this.store, ['beforesortspan', 'preparesortspan', 'sortspan', 'valuechange']);
		
		/*
		 * relay some events from the regions
		 */
		this.relayEvents(this.ltcorner, ['selectionchange', 'referencechange', 'cellmouseup']); 
		var evts = [
		    'columnchange',
		    'rowchange',
		    'cellcontextmenu',
		    'incellmousedown',
            'beforecellmousedown',
		    'preparecellmousedown',
			'cellmousedown', 
			'cellmouseenter', 
			'cellmouseout', 
			'cellmouseover', 
			'cellmousemove', 
			'cellmousedrag', 
			'celldblclick',
			'cellclick',
			'cellmouseup', 
			'focuschange',
			'selectionchange',
			'pushcurrentselection',
			'referencechange',
			'selectionmoving',
			'showreference',
			'hidereference',
			'dragscrollinglimited',
			'prepareautofillstyle',
			'resetautofillstyle',
			'autofilldragend',			
			/*
			 * moving reference events
			 */
			'startmovereference',
			'beforemovingreference',
			'movingreference', 			
			'endmovereference',
			'referencemouseup',
			'rowscrolling',
			'colscrolling',
			/*
			 * click in cell item
			 */
			'clickcellitem'
		];
		
		for(var i = 0, len = this.regionLookup.length; i < len; i++){
			this.relayEvents(this[this.regionLookup[i]], evts);
		}		
		
		/*
		 * for show/hide events, it's only for the freeze mode 
		 */
		evts = [
		    'beforehiderow',		    
		    'beforehidecolumn',
		    'beforeshowrow',		    
		    'beforeshowcolumn'
		];
		this.relayEvents(this.lheader, evts);
		this.relayEvents(this.ulefter, evts);
		this.relayEvents(this.ltregion, evts);
		this.relayEvents(this.tregion, evts);
		this.relayEvents(this.lregion, evts);
		
		/*
		 * for column resize events
		 */
		evts = ['columnresized', 'selectedcolumnresized'];
		this.relayEvents(this.lheader, evts);
		this.relayEvents(this.sheader, evts);
		
		/*
		 * for row resize events
		 */
		evts = ['rowresized', 'rowautoresized', 'selectedrowresized'];
		this.relayEvents(this.ulefter, evts);
		this.relayEvents(this.slefter, evts);
		
		/*
		 * add processdata for body regions
		 */
		evts = ['processdata'];
		for(var i = 0, len = this.bodyRegionLookup.length; i < len; i++){
			this.relayEvents(this[this.bodyRegionLookup[i]], evts);
		}				

		/**********************************************
		 * Add some listeners below
		 **********************************************/
		 
		this.bindListeners();		
	},		
	
	/*
	 * init editor, create a default one if not exist
	 */
	initEditor : function(){
		/*
		 * create the editor
		 */
		if(!this.editor && this.useDefaultEditor){
            this.editor = new EnterpriseSheet.sheet.editor.CellEditor({
                disableCalEditorStyle: this.disableCalEditorStyle
            });
		}		
		this.editor.init(this);
	},
	
	/*
	 * init tableTpl, create a default one if not exist
	 */
	initTableTpl : function(){
		if(!this.tableTpl && this.useDefaultTableTpl){
			this.tableTpl = new EnterpriseSheet.sheet.tpl.TableTemplate();
		}
		this.tableTpl.init(this);
	},
	
	/*
	 * init filter, create a default one if not exist
	 */
	initFilter : function(){
		if(!this.filter && this.useDefaultFilter){
			this.filter = new EnterpriseSheet.sheet.filter.Filter();
		}
		this.filter.init(this);
	},
	
	/*
	 * init reference model, bind header lefter to reference
	 */
	initReferenceModel : function(){
		var rm = this.getReferenceModel();
		for(var i = 0, len = this.lefterHeaderRegionLookup.length; i < len; i++){
			var region = this[this.lefterHeaderRegionLookup[i]];
			rm.bindListener2Region(region);
		}
	},
	
	/*
	 * bind listeners 
	 */
	bindListeners : function(){
		/*
		 * listeners for store event
		 */
		this.mon(this.store, {
			scope:this,
			'clear':this.refresh,
			'beforeafterload':this.beforeAfterLoad,
			'afterload':this.afterLoad,			
			
			'beforeremovecell': this.beforeRemoveCell,
			'beforeinsertcell': this.beforeInsertCell,
            
            'beforeremoverow': this.beforeRemoveRow,
            'beforeinsertrow': this.beforeInsertRow,
            'beforeremovecolumn': this.beforeRemoveColumn,
            'beforeinsertcolumn': this.beforeInsertColumn,
                 
			
			'holdremoverow': this.holdRemoveRow,			
			'holdremovecolumn': this.holdRemoveColumn,
			'holdremovecell': this.holdRemoveCell,
			'holdinsertrow': this.holdInsertRow,
			'holdinsertcolumn': this.holdInsertColumn,
			'holdinsertcell': this.holdInsertCell,
			
						
			/*
			 * before proecess border, we can insert some action
			 */
			'beforeprocessborder': this.beforeProcessBorder,
			/*
			 * for rename a sheet
			 */
			'renamesheet': this.afterRenameSheet,
			/*
			 * for delete a sheet			 
			 */
			'deletesheet': this.afterDeleteSheet,
			
			'refconfigchange': this.onRefConfigChange,
			
			'setcell2update': this.onSetCell2Update,
                 
            'disconnectserver': this.onLostConnection,
            'connectserver': this.onConnectServer,
            'loadingmore': this.onLoadingMore           
		});
		if(this.enableRowColGroup){
			this.mon(this.store, {
				scope:this,
				'processcolumngroup': this.processColumnGroup,
				'processrowgroup': this.processRowGroup
			});
			this.mon(this.innerCt, {
				scope: this,
				'afterrender': function(ct){
                    var ctEl = ct.getEl();
					this.mon(ctEl, {
						scope: this,
						'click': this.onClickInnerCt
					});
                    if(SCOM.needShowLogo()){
                        SCOM.showPoweredByLogo(ctEl);
                    }
				}
			});
		}
		this.mon(this.store, 'datachange', this.onDataChange, this);
		
		/*
		 * handler row/col scrolling event from different regions
		 */
		this.mon(this.lheader, {
			'colscrolling': this.onLHeaderColScrolling, 
			/*
			 * for column resize event
			 * if in freeze mode, the left-top, left region column resize will cause the whole Sheet relayout		 
			 */
			'columnresized': this.onLeftColumnResize,
			scope: this
		}); 		
		this.mon(this.sheader, {
			'colscrolling':this.onSHeaderColScrolling,
			scope: this
		});  
		
		this.mon(this.ulefter, {
			'rowscrolling':this.onULefterRowScrolling, 
			/*
			 * for column resize event
			 * if in freeze mode, the left-top, left region column resize will cause the whole Sheet relayout		 
			 */
			'rowresized':this.onUpperRowResize,
			scope:this
		}); 
		
		this.mon(this.slefter, {
			'rowscrolling':this.onSLefterRowScrolling, 			
			scope:this
		}); 		
		
		this.mon(this.ltregion, {
			'rowscrolling':this.onLTRegionRowScrolling, 
			'colscrolling':this.onLTRegionColScrolling,				
			scope:this
		});				
		
		this.mon(this.tregion, {
			'rowscrolling':this.onTRegionRowScrolling, 
			'colscrolling':this.onTRegionColScrolling,
			scope:this
		});				
		
		this.mon(this.lregion, {
			'rowscrolling':this.onLRegionRowScrolling, 
			'colscrolling':this.onLRegionColScrolling,
			scope:this
		});
		
		this.mon(this.cregion, {
			'rowscrolling':this.onCRegionRowScrolling,
			'colscrolling':this.onCRegionColScrolling,
			scope:this
		});
					
		/*
		 * create throttled function for key down
		 */		
		this.on({
			scope:this,
			'render': this._onRender,
			'afterrender': this._afterRender,
			/*
			 * handle focuschange event from different regions
			 */
			'focuschange': this.onFocusChange,
			
			/*
			 * handle selectionchange event from different regions
			 */
			'selectionchange': this.onSelectionChange,
			'pushcurrentselection': this.onPushSelection,
			/*
			 * when mouse down on a cell
			 */
			'cellmousedown': this.onCellMouseDown,
            'beforecellmousedown': this.beforeCellMouseDown,
			/*
			 * handle referencechange event from different regions
			 */
			'referencechange': this.onReferenceChange,
			'prepareautofillstyle': this.onPrepareAutofill,
			'resetautofillstyle': this.onResetAutofill,
			/*
			 * handle reference model show and hide
			 */
			'showreference': this.onShowReferenceModel,
			'hidereference': this.onHideReferenceModel,									
			'dragscrollinglimited':this.onDragScrollingLimited,
			'beforehiderow':this.beforeHideRow,			
			'beforehidecolumn':this.beforeHideColumn,
			'beforeshowrow':this.beforeShowRow,
			'beforeshowcolumn':this.beforeShowColumn,
			/*
			 * add listener for processdata
			 */
			'processdata': function(sheetId, row, col, cell, timestamp, region){				
				this.processData(sheetId, row, col, cell, timestamp, undefined, region);
			},
			/*
			 * moving the selection
			 */
			'selectionmoving': this.moveSelection,
			/*
			 * when click on chart
			 */
			'chartfocus': this.onChartFocus,
			/*
			 * when floor is moved or resized
			 */
			'floormove': this.onFloorMoveResize,
			'floorresize': this.onFloorMoveResize,
			/*
			 * when the related coord in range store is changed
			 */
			'rangestorecoordchagne': this.onRangeStoreCoordChange,
			/*
			 * when chart is changed, need update the store
			 */
			'chartchange': this.onChartChange,
			/*
			 * click on in-cell item
			 */
			'clickcellitem': this.onClickCellItem,
			/*
			 * mouse move on cell
			 */
			'cellmousemove': this.onCellMouseMove,
			/*
			 * for selected column and row resize
			 */
			'selectedcolumnresized': this.onSelectedColumnResized,
			'columnresized': this.onColumnResized,
			'selectedrowresized': this.onSelectedRowResized,
			'changing': this.onChanging,
            'keydown': this.onKeyDown,
            'try2changepartofarrayformula': this.onTry2ChangePartOfArrayFormula,
            /*
             * check the valid
             */
            'beforecompleteedit': this.beforeCompleteEdit,
            'loseeditingfocus': this.onLoseEditingFocus
		});		
		
		this.on('processingdatachange', this.onProcessingDataChange, this, {buffer: this.processingDataChangeBuffer});
		
		this.mon(this.editor, {
			scope: this,
			'keydown': this.onEditorKeyDown
		});		
		/*
		 * for resize
		 */
		this.innerCt.on('resize', this.processAfterResize, this, {buffer: this.resizeCheckBuffer});			
	},		
		
	onLoseEditingFocus : function(){
		this.editor.focus(100);
	},
	
	/*
	 * prepare the calcualte 
	 */
	prepareCalculate : function(){
		if(!this.disableCalculate){
			this.calculate = new EnterpriseSheet.sheet.calculate.Calculate();
			this.calculate.init(this);
		}
		if(!this.disableCondition){
			this.condition = new EnterpriseSheet.sheet.calculate.Condition();
			this.condition.init(this);
		}		
	},
	
	
	/*
	 * check whether the passed sheetId, row and col is in the current sheet show range
	 */
	isInShowRange : function(sheetId, row, col){
		if(this.getSheetId() == sheetId){
			for(var i = 0, len = this.bodyRegionLookup.length; i < len; i++){
				var region = this[this.bodyRegionLookup[i]];				
				if(region.isVisible() && region.isInRange(row, col)){
					return true;
				}
			}
		}
		return false;
	},
	
	/*
	 * get element(s) for a cell
	 * @param {int} row: the row index
	 * @param {int} col: the column index
	 * @return {array}: an array of the related cell element, if could more than one if in freeze/split mode
	 */
	getCellEls : function(row, col){
		var arr = [];
		var r = this.cregion;
		if(r.isInRange(row, col)){
			var el = r.getCellEl(row, col);
			if(el){
				arr.push(el);
			}
		}
		var r = this.tregion;
		if(r.isVisible()){
			if(r.isInRange(row, col)){
				var el = r.getCellEl(row, col);
				if(el){
					arr.push(el);
				}
			}
		}
		var r = this.lregion;
		if(r.isVisible()){
			if(r.isInRange(row, col)){
				var el = r.getCellEl(row, col);
				if(el){
					arr.push(el);
				}
			}
		}
		var r = this.ltregion;
		if(r.isVisible()){
			if(r.isInRange(row, col)){
				var el = r.getCellEl(row, col);
				if(el){
					arr.push(el);
				}
			}
		}
		return arr;
	},

	/*
	 * return the selection model of cregion
	 */
	getSelectionModel : function(){
		return this.cregion.getSelectionModel();
	},	
	
	/*
	 * return the reference model of cregion
	 */
	getReferenceModel : function(){
		return this.cregion.getReferenceModel();
	},
	
    getClipboard : function(){
        return this.clipboard;
    },
           
    getAutofill : function(){
        return this.autofill;
    },
	/*
	 * enable/disable selection model
	 */
	enableSelect : function(){		
		this.ltcorner.enableSelect();
		for(var i = 0, len = this.regionLookup.length; i < len; i++){
			var region = this[this.regionLookup[i]];
			region.enableSelect();
		}
	},
	
	disableSelect : function(){
		this.ltcorner.disableSelect();
		for(var i = 0, len = this.regionLookup.length; i < len; i++){
			var region = this[this.regionLookup[i]];
			region.disableSelect();
		}
	},
	
	/*
	 * enable/disable reference model
	 * @param {boolean} clear: true to clear the selection before enable/disable it
	 * @param {boolean} single: true to only select a single cell one time
	 * @param {boolean} simple: true to enable simple select mode
	 */
	enableRefer : function(clear, single, simple){
		this.ltcorner.enableRefer();
		for(var i = 0, len = this.regionLookup.length; i < len; i++){
			var region = this[this.regionLookup[i]];
			if(region.getReferenceModel()){
				region.enableRefer.apply(region, arguments);
			}
		}
	},
	
	disableRefer : function(clear, single){
		this.ltcorner.disableRefer();
		for(var i = 0, len = this.regionLookup.length; i < len; i++){
			var region = this[this.regionLookup[i]];
			if(region.getReferenceModel()){
				region.disableRefer.apply(region, arguments);
			}
		}
	},
	
	/*
	 * enable/disable edit
	 */
	enableEdit : function(){
		if(this.editor){
			this.editor.enable();
		}
	},
	
	disableEdit : function(){
		if(this.editor){
			this.editor.disable();
		}
	},
           
	getEditor : function(){
		return this.editor;
	},
	
	/*
	 * private function to show/hide second tr in this table layout
	 * @param {boolean} visible; A flag to define show/hide the second TR element of the table layout
	 */
	setSecondTRVisible : function(visible){
		var layout = this.getLayout();
		if(visible){
			layout.getRow(1).style.display = '';
		}else{
			layout.getRow(1).style.display = 'none';	
		}		
	},
	
	/*
	 * when the selection in any region is changed, need sysn the selection in other regions
	 */
	onSelectionChange : function(startPos, endPos, region, sm){		
		for(var i = 0, len = this.regionLookup.length; i < len; i++){
			var r = this[this.regionLookup[i]];
			if(r.isVisible()){
				var selModel = r.getSelectionModel();
				if(selModel && sm != selModel){
					selModel.selectRange(startPos, endPos, true);
				}
			}
		}
		/*
		 * save to currentRegion
		 */		
		this.currentRegion = region;
		
		this.focus(this.focusDelayTime);		
	},
	
	onPushSelection : function(sm){
		for(var i = 0, len = this.regionLookup.length; i < len; i++){
			var r = this[this.regionLookup[i]];
			if(r.isVisible()){
				var selModel = r.getSelectionModel();
				if(selModel && selModel instanceof EnterpriseSheet.sheet.sm.CellSelectionModel){
					selModel.pushSelection();
				}
			}
		}
	},
	
	/*
	 * return the current region, which is region now focus
	 */
	getCurrentRegion : function(){
		if(this.isFreezed()){
			var rowStart = this.cregion.rowStart, colStart = this.cregion.colStart;
			var sm = this.cregion.getSelectionModel();
			var focusCell = sm.getFocusCell();
			var row = focusCell.row, col = focusCell.col;
			if(row < rowStart && col < colStart){				
				return this.ltregion;
			}else if(row < rowStart){				
				return this.tregion;
			}else if(col < colStart){				
				return this.lregion;
			}else{				
				return this.cregion;
			}
		}else{
			if(this.isSplited()){
				if(this.lheader == this.currentRegion || this.ulefter == this.currentRegion){
					return this.ltregion;
				}else if(this.sheader == this.currentRegion){
					return this.tregion;
				}else if(this.slefter == this.currentRegion){
					return this.lregion;
				}else if(this.ltcorner == this.currentRegion){
					return this.cregion;
				}
				return this.currentRegion || this.cregion;
			}else{
				return this.cregion;
			}						
		}			
	},
	
	simulateFocusChange : function(){
		var sm = this.getSelectionModel(), focusCell = sm.focusCell;
		var cd = this.store.getCell(this.getSheetId(), focusCell.row, focusCell.col);
		this.fireEvent('focuschange', focusCell.row, focusCell.col, sm, cd);
	},
	
	/**
	 * refresh the focus
	 */
	refreshFocus : function(row, col, suspendEvent){
		var sm = this.getSelectionModel(), store = this.getStore();
		
		var focusCell = sm.getFocusCell();
		if((!SCOM.nullOrUndefined(row) && row !== focusCell.row) || (!SCOM.nullOrUndefined(col) && col !== focusCell.col)){
			sm.setFocusCell(row, col, suspendEvent);
		}else{			
			if(!suspendEvent){
				var sheetId = this.getSheetId();
				var cd = store.getCell(sheetId, focusCell.row, focusCell.col);
				sm.fireEvent('focuschange', focusCell.row, focusCell.col, sm, cd);
			}else{
				this.onFocusChange(focusCell.row, focusCell.col, sm);
			}
		}
        this.focus(500);
	},
	
	/*
	 * when the focus in any region is change, need sysn all 
	 */
	onFocusChange : function(row, col, sm){		
		for(var i = 0, len = this.regionLookup.length; i < len; i++){
			var region = this[this.regionLookup[i]];
			var selModel = region.getSelectionModel();
			if(selModel && sm != selModel){
				selModel.setFocusCell(row, col, true, true);				
			}
		}
		/*
		 * if focus on a calcualte, then sync reference
		 */
		var store = this.getStore(), editor = this.getEditor();
		var sheetId = this.getSheetId();
		var cd = store.getCellData(sheetId, row, col);			
		var data = cd.data || '', flag = false;

		if(store.isDisabledCell(store.getActivedSheetId(), row, col)){
			if(!editor.inputing){
                editor.disable();
			}
		}else{
			editor.enable();
		}	
		
		if(cd.link){
			/*
			 * show a floating box for the links
			 */
			this.showLinkKit({row: row, col: col}, cd);
		}else{
			this.hideLinkKit();
		}
		if(EnterpriseSheet.sheet.calculate.Calculate.prototype.isCalculate(data)){
            /*
             * for array formula we need get the left-top cell's data
             */
            if(Ext.isNumber(cd.afrow)){
                var afrow = cd.afrow+row, afcol = cd.afcol+col;
                if(afrow !== row || afcol !== col){
                    cd = store.getCell(sheetId, afrow, afcol);
                    data = cd.data;
                }
            }
			/*
			 * sync the reference if it's a calculate
			 */
			flag = this.syncReferenceForCalculate(data, true);					
		}else if(this.isConditionCell(cd, sheetId, row, col) && this.condition){			
			flag = this.condition.showConditionReference(cd, sheetId, row, col);			
		}else if(this.isFitlerCell(cd)){
			flag = this.filter.showFilterReference(cd, sheetId, row, col);			
		}
		
		if(!flag){
			var rm = this.getReferenceModel();
			if(rm.hasCls('ss-cal-ref')){				
				rm.hide();
			}					
		}
	},		
		
	
	/*
	 * when the selection in any region is changed, need sysn the selection in other regions
	 */
	onReferenceChange : function(region, rm, forceRefresh){		
		var refs = rm.getReference(true);		
		var curCls = rm.curCls;
		var currentColorIndex = rm.colorIndex;
		
		for(var i = 0, len = this.regionLookup.length; i < len; i++){
			var r = this[this.regionLookup[i]];
			if(r.isVisible()){
				var refModel = r.getReferenceModel();				
				if(refModel && r != region){		
					refModel.clearSelection(true);
					refModel.setReference(refs, forceRefresh, true, curCls, currentColorIndex);
				}
			}
		}				
	},
	
	/*
	 * show all reference model at the same time
	 */
	onShowReferenceModel : function(region, rm){
		for(var i = 0, len = this.regionLookup.length; i < len; i++){
			var r = this[this.regionLookup[i]];
			if(r.isVisible()){
				var refModel = r.getReferenceModel();				
				if(refModel && refModel != rm){					
					refModel.show(true);				
				}
			}			
		}
	},
	
	/*
	 * hide all reference model at the same time
	 */
	onHideReferenceModel : function(region, rm){
		for(var i = 0, len = this.regionLookup.length; i < len; i++){
			var r = this[this.regionLookup[i]];
			if(r.isVisible()){
				var refModel = r.getReferenceModel();				
				if(refModel && refModel != rm){					
					refModel.hide(true);
				}
			}
		}
	},
	
	/**
	 * on sheet render
	 */
	_onRender : function(){
		if(this.el){
			/*
			 * define the column/row resize proxy here, need fit the id we pass in the config for EnterpriseSheet.sheet.resize.RowResizer
			 */
			Ext.core.DomHelper.append(this.el.dom, '<div id="ss-cproxy" class="ss-crz-xproxy" style="z-index:'+SCONST['TOP_Z_INDEX']+';"></div><div id="ss-rproxy"  class="ss-crz-yproxy" style="z-index:'+SCONST['TOP_Z_INDEX']+';"></div>');
		}  
	},
	
	/**
	 * after sheet is render
	 */
	_afterRender : function(){
        /*
         * here need assign a z-index for other z-index issues.
         */
        this.getEl().setStyle('z-index', 0);
        /*
         * create loadMask if need
         */        
        if(this.loadMask){
        	var store = this.getStore();
        	
            this.loadMask = new EnterpriseSheet.common.LoadMask(Ext.apply({
            	target: this
            }, this.loadMask));
            
            store.on({
        	   scope: this,
        	   'beforeload': function(){
        		   this.loadMask.show();
        	   }
            });          
        }
        
	},
	
	/*
	 * select the left-top cell
	 */
	initSelection : function(){		
		var fn = function(region){		
			/*
			 * simulate a cellmousedown event
			 */
			region.fireEvent('cellmousedown', region.rowStart, region.colStart, region);
		};
		if(this.ltregion.isVisible()){
			fn(this.ltregion);
		}else if(this.tregion.isVisible()){
			fn(this.tregion);
		}else if(this.lregion.isVisible()){
			fn(this.lregion);
		}else{						
			fn(this.cregion);
		}
	},
	
	/*
	 * For left header column scrolling, need sysn left-top region and left region
	 */
	onLHeaderColScrolling : function(offset, region){
		var colStart = region.colStart, colEnd = region.colEnd, scrollLeft = region.ifctEl.dom.scrollLeft;
		if(this.ltregion.isVisible()){
			this.ltregion.moveColumn(colStart, colEnd, scrollLeft);
		}
		this.lregion.moveColumn(colStart, colEnd, scrollLeft);
		/*
		 * sysn left region scroller if need
		 */
		this.lregion.sysInfinateScroller('x');
	},
	
	/*
	 * For header column scrolling, need sysn top region and center region
	 */
	onSHeaderColScrolling : function(offset, region){
		if(0 < offset){	
			if(this.tregion.isVisible()){
				this.tregion.moveRight(offset);
			}
			this.cregion.moveRight(offset);
		}else{
			if(this.tregion.isVisible()){
				this.tregion.moveLeft(-offset);
			}
			this.cregion.moveLeft(-offset);
		}
		/*
		 * sysn center region scroller if need
		 */
		this.cregion.sysInfinateScroller('x');
	},
	
	/*
	 * For upper lefter row scrolling, need sysn top region and center region
	 */	
	onULefterRowScrolling : function(offset, region){
		var rowStart = region.rowStart, rowEnd = region.rowEnd, scrollTop = region.ifctEl.dom.scrollTop;
		if(this.ltregion.isVisible()){
			this.ltregion.moveRow(rowStart, rowEnd, scrollTop);	
		}	
		this.tregion.moveRow(rowStart, rowEnd, scrollTop);	
		/*
		 * sysn top region scroller if need
		 */
		this.tregion.sysInfinateScroller('y');
		/*
		 * check the lefter width when the row index is changed
		 */
		this.checkLefterWidth();
	},
	
	onSLefterRowScrolling : function(offset, region){
		var rowStart = region.rowStart, rowEnd = region.rowEnd, scrollTop = region.ifctEl.dom.scrollTop;
		if(this.lregion.isVisible()){
			this.lregion.moveRow(rowStart, rowEnd, scrollTop);	
		}	
		this.cregion.moveRow(rowStart, rowEnd, scrollTop);	
		/*
		 * sysn center region scroller if need
		 */
		this.cregion.sysInfinateScroller('y');
		/*
		 * check the lefter width when the row index is changed
		 */
		this.checkLefterWidth();
	},
	
	/*
	 * when top region row scrolling, need sysn the upper lefter region and left-top region
	 */
	onTRegionRowScrolling : function(offset, region){
		var rowStart = region.rowStart, rowEnd = region.rowEnd, scrollTop = region.ifctEl.dom.scrollTop;
		this.ulefter.moveRow(rowStart, rowEnd, scrollTop);
		if(this.ltregion.isVisible()){
			this.ltregion.moveRow(rowStart, rowEnd, scrollTop);
		}
		/*
		 * check the lefter width when the row index is changed
		 */
		this.checkLefterWidth();
	},
	
	/*
	 * when left region col scrolling, need sysn left header and left-top region
	 */
	onLRegionColScrolling : function(offset, region){
		var colStart = region.colStart, colEnd = region.colEnd, scrollLeft = region.ifctEl.dom.scrollLeft;
		this.lheader.moveColumn(colStart, colEnd, scrollLeft);
		if(this.ltregion.isVisible()){
			this.ltregion.moveColumn(colStart, colEnd, scrollLeft);
		}	
	},
	
	/*
	 * when left region row scrolling, need sysn lefter and center region
	 */
	onLRegionRowScrolling : function(offset, region){
		var rowStart = region.rowStart, rowEnd = region.rowEnd, scrollTop = region.ifctEl.dom.scrollTop;
		this.slefter.moveRow(rowStart, rowEnd, scrollTop);
		this.cregion.moveRow(rowStart, rowEnd, scrollTop);
		/*
		 * need sysn the scroller position of cetner region
		 */
		this.cregion.sysInfinateScroller('y');
		/*
		 * when row is scrolling, need check the lefter width and adjust it
		 */
		this.checkLefterWidth();
	},	
	
	/*
	 * when left-top region row scrolling, need sysn upper lefter and top region
	 */
	onLTRegionRowScrolling : function(offset, region){
		var rowStart = region.rowStart, rowEnd = region.rowEnd, scrollTop = region.ifctEl.dom.scrollTop;
		this.ulefter.moveRow(rowStart, rowEnd, scrollTop);
		this.tregion.moveRow(rowStart, rowEnd, scrollTop);
		/*
		 * sysn top region scroller if need
		 */
		this.tregion.sysInfinateScroller('y');
		/*
		 * check the lefter width when the row index is changed
		 */
		this.checkLefterWidth();
	},
	
	/*
	 * when center region row scrolling, need sysn lefter and left region
	 */
	onCRegionRowScrolling : function(offset, region){
		var rowStart = region.rowStart, rowEnd = region.rowEnd, scrollTop = region.ifctEl.dom.scrollTop;
		this.slefter.moveRow(rowStart, rowEnd, scrollTop);
		if(this.lregion.isVisible()){
			this.lregion.moveRow(rowStart, rowEnd, scrollTop);
		}
		/*
		 * check the lefter width when the row index is changed
		 */
		this.checkLefterWidth();
	},
	
	/*
	 * when left-top region col scrolling, need sysn left header and left region
	 */
	onLTRegionColScrolling : function(offset, region){
		var colStart = region.colStart, colEnd = region.colEnd, scrollLeft = region.ifctEl.dom.scrollLeft;
		this.lheader.moveColumn(colStart, colEnd, scrollLeft);
		this.lregion.moveColumn(colStart, colEnd, scrollLeft);
		/*
		 * need sysn the scroller position of cetner region
		 */
		this.lregion.sysInfinateScroller('x');
	},
	
	/*
	 * when top region col scrolling, need sysn header and center region
	 */
	onTRegionColScrolling : function(offset, region){
		var colStart = region.colStart, colEnd = region.colEnd, scrollLeft = region.ifctEl.dom.scrollLeft;
		this.sheader.moveColumn(colStart, colEnd, scrollLeft);
		this.cregion.moveColumn(colStart, colEnd, scrollLeft);
		/*
		 * need sysn the scroller position of cetner region
		 */
		this.cregion.sysInfinateScroller('x');
	},
	
	/*
	 * when center region col scrolling, need sysn header and top region
	 */
	onCRegionColScrolling : function(offset, region){
		var colStart = region.colStart, colEnd = region.colEnd, scrollLeft = region.ifctEl.dom.scrollLeft;
		
		this.sheader.moveColumn(colStart, colEnd, scrollLeft);
		if(this.tregion.isVisible()){
			this.tregion.moveColumn(colStart, colEnd, scrollLeft);
		}
	},
	
	/*
	 * private
	 */
	getPaddingOffset : function(){
		var p = 0;
		if(this.isSplited()){
			p = this.getStore().splitOffset;
		}
		return p;
	},
	
	/*
	 * handle resize for every region
	 */
	processAfterResize: function(comp, width, height) {				
		
		var innerEl = this.getInnerEl();
		
		width = innerEl.getWidth();
		height = innerEl.getHeight();		
		
		var sheetId = this.getSheetId();
		
		var s = this.getStore();
		
		var p = this.getPaddingOffset();
		
		var lw = s.getColWidth(sheetId, 0), hh = s.getRowHeight(sheetId, 0);					
		
		var sw = width-innerEl.getBorderWidth('lr')-lw-p, sh = height-innerEl.getBorderWidth('tb')-hh-p;
		
		this.ltcorner.setSize(lw, hh);
		
		if(this.isFreezed() || this.isSplited()){
			/*
			 * if freeze or split, we need handle lheader, ulefter, tregion and lregion too
			 */
			var fw = 0;
			if(this.lheader.isVisible()){
				fw = this.lheader.getWidth();
			}
			var fh = 0;
			if(this.ulefter.isVisible()){
				fh = this.ulefter.getHeight();
			}
			/*
			 * if the browser window is too small, and the sw <= fw, sh <= fh,
			 * we just ignore it, let it be
			 */
			if(sw > fw){
				sw -= fw;
			}
			if(sh > fh){
				sh -= fh;
			}
			if(this.tregion.isVisible()){
				this.tregion.setSize(sw, fh);	
			}
			if(this.lregion.isVisible()){
				this.lregion.setSize(fw, sh);	
			}
			this.sheader.setSize(sw, hh);
			this.slefter.setSize(lw, sh);
			this.cregion.setSize(sw, sh);
		}else{
			this.sheader.setSize(sw, hh);		
			this.slefter.setSize(lw, sh);		
			this.cregion.setSize(sw, sh);			
		}		
		/*
		 * only init selection at the very first time
		 */
		if(!this._firstInitSelection){
			this._firstInitSelection = true;
			this.initSelection();
			/*
			 * fire an event after first resize the sheet
			 */
			this.fireEvent('afterlayoutresized', this);
		}
	},
	
	/*
	 * get the row start of this sheet, if it's freezed/splited then return the rowStart of ulefter,
	 * or return the rowStart of slefter
	 */
	getRowStart : function(){
		return (this.ulefter.isVisible() || this.tregion.isVisible())?this.ulefter.rowStart:this.slefter.rowStart;
	},
	
	/*
	 * get the column start of this sheet, if it's freezed/splited then return the colStart of lheader,
	 * or return the colStart of sheader
	 */
	getColStart : function(){
		return (this.lheader.isVisible() || this.lregion.isVisible())?this.lheader.colStart:this.sheader.colStart;
	},
	
	/*
	 * get the current max row index in the sheet
	 */
	getMaxRow : function(){
		if(this.ulefter.isVisible()){
			var u = this.ulefter.rowEnd, s = this.slefter.rowEnd;
			return u > s ? u : s;
		}else{
			return this.slefter.rowEnd;
		}
	},
	
	/*
	 * private, get how many cells rendered in this sheet right now
	 */
	countCell : function(){
		var sum = 0;
		var r = this.cregion;
		sum += (r.rowEnd-r.rowStart+1)*(r.colEnd-r.colStart+1);
		if(this.tregion.isVisible()){
			r = this.tregion;
			sum += (r.rowEnd-r.rowStart+1)*(r.colEnd-r.colStart+1);
		}
		if(this.lregion.isVisible()){
			r = this.lregion;
			sum += (r.rowEnd-r.rowStart+1)*(r.colEnd-r.colStart+1);
		}
		if(this.ltregion.isVisible()){
			r = this.ltregion;
			sum += (r.rowEnd-r.rowStart+1)*(r.colEnd-r.colStart+1);
		}
		return sum;
	},
	
	/*
	 * get inner el
	 */
	getInnerEl : function(){
		return this.innerCt.getEl();
	},
	
	/*
	 * private
	 * show/hide left range when freezing
	 */
	switchLeftRangeForFreeze : function(row, col){	
		var colStart = this.getColStart();
		var rowStart = this.getRowStart();
		var sheetId = this.getSheetId();
		var s = this.getStore();
		var El = this.getInnerEl();
		var width = El.getWidth()-El.getBorderWidth('lr'), height = El.getHeight()-El.getBorderWidth('tb');
		var lw = s.getColWidth(sheetId, 0), hh = s.getRowHeight(sheetId, 0);
		var w = s.getRangeWidth(sheetId, colStart, col-1);
		var h = s.getRangeHeight(sheetId, rowStart, row-1);
		var sw = width-lw-w;
		var sh = height-hh-h;
		var lowcol = col;
		
		if(colStart < col){			
			this.lheader.show();
						
			this.lregion.show();
			
			this.sheader.recalculateRange(null, {
				colStart:col,
				width:sw
			});		
			this.sheader.setBound(null, {
				low:col,
				high:false
			});
			this.sheader.sysn();		
			
			this.lheader.recalculateRange({			
				rowStart:0,
				rowEnd:0,
				height:hh
			}, {
				colStart:colStart,
				colEnd:col-1,
				width:w
			});	
			this.lheader.setBound(null, {
				low:colStart,
				high:col-1
			});
			this.lheader.sysn();
						
			this.lregion.recalculateRange({				
				rowStart:row,
				height:sh
			}, {
				colStart:colStart,
				colEnd:col-1,
				width:w
			});			
			
			this.lregion.setBound({
				/*
				 * if rowStart < row then no row freezed, it means the low bound will be 1
				 */
				low:rowStart < row ? row : 1,
				high:false
			}, {
				low:colStart,
				high:col-1
			});
			this.lregion.sysn();
		}else{
			/*
			 * no column freeze and left header is visible, then hide below regions
			 */
			var lowcol = 1; 
			if(this.lheader.isVisible()){ 
				this.lheader.hide();
				this.lregion.hide();
				/*
				 * also need re render header
				 */
				this.sheader.recalculateRange(null, {
					colStart:col,
					width:sw
				});		
				this.sheader.setBound(null, {
					low:lowcol,
					high:false
				});
				this.sheader.sysn();
			}
		}
		
		return lowcol;
	},
	
	/*
	 * private
	 * show/hide top range when freezing
	 */
	switchTopRangeForFreeze : function(row, col){
		var colStart = this.getColStart();
		var rowStart = this.getRowStart();
		var sheetId = this.getSheetId();
		var s = this.getStore();
		var El = this.getInnerEl();
		var width = El.getWidth()-El.getBorderWidth('lr'), height = El.getHeight()-El.getBorderWidth('tb');
		var lw = s.getColWidth(sheetId, 0), hh = s.getRowHeight(sheetId, 0);
		var w = s.getRangeWidth(sheetId, colStart, col-1);
		var h = s.getRangeHeight(sheetId, rowStart, row-1);
		var sw = width-lw-w;
		var sh = height-hh-h;
		
		var lowrow = row;
		if(rowStart < row){					
			this.ulefter.show();								
			this.tregion.show();
			
			this.slefter.recalculateRange({
				rowStart:row,
				rowEnd:this.lregion.isVisible()?this.lregion.rowEnd:null,
				height:sh
			});	
			
			this.slefter.setBound({
				low:row,					
				high:false
			});
			this.slefter.sysn();
		
			this.ulefter.recalculateRange({
				rowStart:rowStart,
				rowEnd:row-1,
				height:h
			}, {
				colStart:0,
				colEnd:0,
				width:lw
			});	
			
			this.ulefter.setBound({
				low:rowStart,
				high:row-1
			});
			
			this.ulefter.sysn();
						
			this.tregion.recalculateRange({
				rowStart:rowStart,
				rowEnd:row-1,
				height:h
			}, {
				colStart:col,
				colEnd:this.sheader.colEnd,
				width:sw
			});					
			
			this.tregion.setBound({
				low:rowStart,
				high:row-1
			}, {
				/*
				 * if colStart < col then no col freezed, it means the low bound will be 1
				 */
				low:colStart < col ? col : 1,
				high:false
			});
			
			this.tregion.sysn();
		}else{
			/*
			 * if no row freeze and upper lefter is visible, then hide below regions
			 */
			lowrow = 1;  
			if(this.ulefter.isVisible()){
				this.ulefter.hide();				
				this.tregion.hide();		
				/*
				 * also need re render lefter
				 */
				this.slefter.recalculateRange({
					rowStart:row,
					height:sh
				});	
				
				this.slefter.setBound({
					low:lowrow,
					high:false
				});
				this.slefter.sysn();
			}
		}
		
		return lowrow;
	},
	
	/*
	 * private
	 * show/hide left-top range when freezing
	 */
	switchLeftTopRangeForFreeze : function(row, col){
		var colStart = this.getColStart();
		var rowStart = this.getRowStart();
		var sheetId = this.getSheetId();
		var s = this.getStore();		
		var w = s.getRangeWidth(sheetId, colStart, col-1);
		var h = s.getRangeHeight(sheetId, rowStart, row-1);		
		
		if(colStart < col && rowStart < row){
			this.ltregion.show();
			this.ltregion.recalculateRange({
				rowStart:rowStart,
				rowEnd:row-1,
				height:h
			}, {
				colStart:colStart,
				colEnd:col-1,
				width:w
			});	
			this.ltregion.setBound({
				low:rowStart,
				high:row-1
			}, {
				low:colStart,
				high:col-1
			});
			this.ltregion.sysn();
		}else{
			this.ltregion.hide();
		}
	},
	
	/*
	 * switch freeze css
	 * @param {boolean} on: true to add freeze css, false to remove
	 */
	switchFreezeCls : function(on){
		if(on){
			/*
			 * remove split css
			 */			
			this.removeSplitCss();
			/*
			 * add freeze css
			 */
			this.addCls('ss-freeze');
		}else{
			this.removeCls('ss-freeze');
		}
	},
	
	/*
	 * for freeze, need recalculate and render different regions, and relayout them
	 * row and col parameters define the end point of freeze
	 * @param {int} row: the row index
	 * @param {int} col: the column index	 
	 * @param {boolean} suspendEvent: true to not fire freezechange even
	 */
	freeze : function(row, col, suspendEvent){		
		var sheetId = this.getSheetId();
		var s = this.getStore();
		/*
		 * the row and col can not be less than 1
		 */
		if(row < 1){
			row = 1;
		}
		if(col < 1){
			col = 1;
		}
		/*
		 * save the old freezePos
		 */
		var oldFreezePos = this.freezePos ? Ext.apply({}, this.freezePos) : null;
		var oldSplitPos = this.splitPos ? Ext.apply({}, this.splitPos) : null;
		var oldRangeInfo = this.getRangeInfo();
		this.freezePos = this.freezePos || {};
		var fp = this.freezePos;
		if(fp.row != row || fp.col != col){					
			fp.row = row;
			fp.col = col;			
			/*
			 * remove split pos
			 */
			delete(this.splitPos);
			/*
			 * change to freeze css
			 */
			this.switchFreezeCls(true);
			
			var colStart = this.getColStart();
			var rowStart = this.getRowStart();
						
			var El = this.getInnerEl();
			var width = El.getWidth()-El.getBorderWidth('lr'), height = El.getHeight()-El.getBorderWidth('tb');
			var lw = s.getColWidth(sheetId, 0), hh = s.getRowHeight(sheetId, 0);
			var w = s.getRangeWidth(sheetId, colStart, col-1);
			var h = s.getRangeHeight(sheetId, rowStart, row-1);
			var sw = width-lw-w;
			var sh = height-hh-h;
			/*
			 * if col equals colStart, it means no column freeze
			 * need render left region and left header
			 */
			var lowcol = this.switchLeftRangeForFreeze(row, col);
			/*
			 * if row equals rowStart, it means no row freeze
			 * need render upper lefter and top region
			 */
			var lowrow = this.switchTopRangeForFreeze(row, col);
			/*
			 * if below condition is true, then both row and column are freezed
			 * need rerender left-top region
			 */
			this.switchLeftTopRangeForFreeze(row, col);
			/*
			 * render center region
			 */																																										
			this.cregion.recalculateRange({
				rowStart:row,
				rowEnd:this.slefter.rowEnd,
				height:sh
			}, {
				colStart:col,
				colEnd:this.sheader.colEnd,
				width:sw
			});
			
			this.cregion.setBound({
				low:lowrow,
				high:false
			}, {
				low:lowcol,
				high:false
			});
			this.cregion.sysn();						
			/*
			 * refresh the selection of all regions
			 */
			this.refreshSelection();
			/*
			 * if no freeze any more, then need delete freezePos object
			 */
			if(row <= rowStart && col <= colStart){
				delete(this.freezePos);
			}
			/*
			 * update the config
			 */
			this.updateSheetConfig(true);
			
			if(!suspendEvent){
				var freezePos = this.freezePos?Ext.apply({}, this.freezePos) : null;
				var splitPos = this.splitPos ? Ext.apply({}, this.splitPos) : null;
				var rangeInfo = this.getRangeInfo();
				this.fireEvent('freezechange', freezePos, oldFreezePos, splitPos, oldSplitPos, rangeInfo, oldRangeInfo, this);
			}
		}
	},
	
	/*
	 * cancel current freeze, hide left-top, left and top regions
	 * @param {boolean} suspendEvent: true to not fire freezechange even
	 */
	unfreeze : function(suspendEvent){
		if(this.isFreezed()){		
			/*
			 * save the old freezePos
			 */
			var oldFreezePos = Ext.apply({}, this.freezePos); 			
			var oldSplitPos = this.splitPos ? Ext.apply({}, this.splitPos) : null;
			var oldRangeInfo = this.getRangeInfo();
			var s = this.getStore();
			var sheetId = this.getSheetId();			
			
			var El = this.getInnerEl();
			var width = El.getWidth()-El.getBorderWidth('lr'), height = El.getHeight()-El.getBorderWidth('tb');			
			
			/*
			 * remove freeze css
			 */
			this.switchFreezeCls(false);
			
			var col = this.lheader.isVisible()?this.lheader.colStart:this.sheader.colStart;
			var row = this.ulefter.isVisible()?this.ulefter.rowStart:this.slefter.rowStart;
			
			/*
			 * hide all other regions
			 */
			this.lheader.hide();
			this.ulefter.hide();
			this.ltregion.hide();
			this.lregion.hide();
			this.tregion.hide();
			
			var lw = s.getColWidth(sheetId, 0), hh = s.getRowHeight(sheetId, 0);
			
			var sw = width-lw;
			var sh = height-hh;		
			/*
			 * if col > 1, then means we need reset the sheader's range
			 */					
			if(1 < this.freezePos.col){
				this.sheader.recalculateRange(null, {
					colStart:col,
					width:sw
				});	
				this.sheader.setBound(null, {
					low:1,
					high:false
				});
				
				this.sheader.sysn();			
			}
			/*
			 * if row > 1, then means we need reset the slefter's range
			 */	
			if(1 < this.freezePos.row){	
				this.slefter.recalculateRange({
					rowStart:row,
					height:sh
				});	
				
				this.slefter.setBound({
					low:1,
					high:false
				});
				
				this.slefter.sysn();
			}
			
			this.cregion.recalculateRange({
				rowStart:row,
				rowEnd:this.slefter.rowEnd,
				height:sh
			}, {
				colStart:col,
				colEnd:this.sheader.colEnd,
				width:sw
			});			

			this.cregion.setBound({
				low:1,
				high:false
			}, {
				low:1,
				high:false
			});
			
			this.cregion.sysn();		
			
			delete(this.freezePos);
			
			/*
			 * refresh the selection of all regions
			 */
			this.refreshSelection();
			
			/*
			 * update the config
			 */
			this.updateSheetConfig(true);
			
			if(!suspendEvent){
				var rangeInfo = this.getRangeInfo();
				/*
				 * fire freezechange event
				 */
				var splitPos = this.splitPos ? Ext.apply({}, this.splitPos) : null;
				this.fireEvent('freezechange', null, oldFreezePos, splitPos, oldSplitPos, rangeInfo, oldRangeInfo, this);
			}
		}		
	},
	
	setCtTdOffset : function(region, dir, offset){
		var td = region.getEl().parent('td');	
		if(0 < offset)
			offset -= 1;
		td.setStyle('padding-'+dir, offset+'px');
	},
	
	switchSplitCls : function(on){
		if(on){			
			var p = this.getStore().splitOffset;
			this.removeCls('ss-freeze');
			this.addCls('ss-split');
			if(0 < this.splitPos.width){
				this.setCtTdOffset(this.lregion, 'right', p);
				this.setCtTdOffset(this.ltregion, 'right', p);
				this.cregion.addCls('ss-leftborder');
				this.sheader.addCls('ss-leftborder');
				this.tregion.addCls('ss-leftborder');
				this.lregion.switchScroller(true);
			}else{
				this.setCtTdOffset(this.lregion, 'right', 0);
				this.setCtTdOffset(this.ltregion, 'right', 0);
				this.cregion.removeCls('ss-leftborder');
				this.sheader.removeCls('ss-leftborder');
				this.tregion.removeCls('ss-leftborder');
				this.lregion.switchScroller(false);
			}			
			if(0 < this.splitPos.height){
				this.setCtTdOffset(this.tregion, 'bottom', p);	
				this.setCtTdOffset(this.ltregion, 'bottom', p);	
				this.cregion.addCls('ss-topborder');
				this.slefter.addCls('ss-topborder');
				this.lregion.addCls('ss-topborder');
				this.tregion.switchScroller(true);
			}else{
				this.setCtTdOffset(this.tregion, 'bottom', 0);	
				this.setCtTdOffset(this.ltregion, 'bottom', 0);	
				this.cregion.removeCls('ss-topborder');
				this.slefter.removeCls('ss-topborder');
				this.lregion.removeCls('ss-topborder');
				this.tregion.switchScroller(false);
			}								
		}else{
			this.removeSplitCss();
		}
	},
	
	/*
	 * for split the sheet, every region can be scrollable
	 * @param {int} splitWidth: the width of the left-top region
	 * @param {int} splitHeight: the height of the left-top region
	 * @param {boolean} suspendEvent: true to suspend event
	 */
	split : function(splitWidth, splitHeight, suspendEvent){
		var sheetId = this.getSheetId();
		/*
		 * save the old splitPos
		 */
		var oldFreezePos = this.freezePos ? Ext.apply({}, this.freezePos) : null; 
		var oldSplitPos = this.splitPos ? Ext.apply({}, this.splitPos) : null; 
		var oldRangeInfo = this.getRangeInfo();
		this.splitPos = this.splitPos || {};
		var sp = this.splitPos;		
		if(sp.height != splitHeight || sp.width != splitWidth){		
			var s = this.getStore();
			sp.width = splitWidth;
			sp.height = splitHeight;			
			/*
			 * freezePos and splitPos can not be not null at the same time
			 */
			delete(this.freezePos);
			/*
			 * add split css
			 */
			this.switchSplitCls(true);
			
			var colStart = this.getColStart();
			var rowStart = this.getRowStart();
			
			var El = this.getInnerEl();
			var width = El.getWidth()-El.getBorderWidth('lr'), height = El.getHeight()-El.getBorderWidth('tb');			
			var lw = s.getColWidth(sheetId, 0), hh = s.getRowHeight(sheetId, 0), p = s.splitOffset;	
			var sw = width-lw-splitWidth;
			/*
			 * if there is a col split, then we need substract the split offset
			 */
			if(0 < splitWidth){
				sw -= p;
			}
			var sh = height-hh-splitHeight;
			/*
			 * if there is a row split, then we need substract the split offset
			 */
			if(0 < splitHeight){
				sh -= p;
			}												
			
			if(0 < splitWidth){						
				this.lheader.show();				
				this.lregion.show();
				
				this.lheader.recalculateRange({			
					rowStart:0,
					rowEnd:0,
					height:hh
				}, {
					colStart:colStart,
					width:splitWidth
				});	
				
				this.lheader.setBound(null, {
					low:1,
					high:false
				});
				this.lheader.sysn();
				
				this.sheader.recalculateRange(null, {
					colStart:this.lheader.colEnd+1,
					width:sw
				});		
				
				this.sheader.setBound(null, {
					low:1,
					high:false
				});				
				this.sheader.sysn();																
			}
			if(0 < splitHeight){								
				this.ulefter.show();										
				this.tregion.show();
				
				this.ulefter.recalculateRange({
					rowStart:rowStart,
					height:splitHeight
				}, {
					colStart:0,
					colEnd:0,
					width:lw
				});	
				
				this.ulefter.setBound({
					low:1,
					high:false
				});
				this.ulefter.sysn();
				
				this.slefter.recalculateRange({
					rowStart:this.ulefter.rowEnd+1,
					height:sh
				});		
				
				this.slefter.setBound({
					low:1,
					high:false
				});				
				this.slefter.sysn();										
			}
			
			if(0 < splitWidth){				
				this.lregion.recalculateRange({
					rowStart:this.slefter.rowStart,
					rowEnd:this.slefter.rowEnd,
					height:sh
				}, {
					colStart:colStart,
					colEnd:this.lheader.colEnd,
					width:splitWidth
				});		
				
				this.lregion.setBound({
					low:1,
					high:false
				}, {
					low:1,
					high:false
				});
				this.lregion.sysn();
			}
			
			if(0 < splitHeight){				
				this.tregion.recalculateRange({
					rowStart:rowStart,
					rowEnd:this.ulefter.rowEnd,
					height:splitHeight
				}, {
					colStart:this.sheader.colStart,
					colEnd:this.sheader.colEnd,
					width:sw
				});		
				
				this.tregion.setBound({
					low:1,
					high:false
				}, {
					low:1,
					high:false
				});
				this.tregion.sysn();
			}
			
			if(0 < splitWidth && 0 < splitHeight){								
				this.ltregion.show();
				this.ltregion.recalculateRange({
					rowStart:rowStart,
					rowEnd:this.ulefter.rowEnd,
					height:splitHeight
				}, {
					colStart:colStart,
					colEnd:this.lheader.colEnd,
					width:splitWidth
				});	
				
				this.ltregion.setBound({
					low:1,
					high:false
				}, {
					low:1,
					high:false
				});
				this.ltregion.sysn();
			}						
			sh++;
			sw++;
			this.cregion.recalculateRange({
				rowStart:this.slefter.rowStart,
				rowEnd:this.slefter.rowEnd,
				height:sh
			}, {
				colStart:this.sheader.colStart,
				colEnd:this.sheader.colEnd,
				width:sw
			});
			
			this.cregion.setBound({
				low:1,
				high:false
			}, {
				low:1,
				high:false
			});				
			this.cregion.sysn();		
			/*
			 * refresh the selection of all regions
			 */
			this.refreshSelection();
			
			/*
			 * update the config
			 */
			this.updateSheetConfig(true);
			
			if(!suspendEvent){
				/*
				 * fire splitchange event
				 */
				var freezePos = this.freezePos ? Ext.apply({}, this.freezePos) : null; 
				var splitPos = this.splitPos ? Ext.apply({}, this.splitPos) : null;			
				var rangeInfo = this.getRangeInfo();
				this.fireEvent('splitchange', splitPos, oldSplitPos, freezePos, oldFreezePos, rangeInfo, oldRangeInfo, this);
			}
		}
	},
	
	removeSplitCss : function(){
		this.removeCls('ss-split');
		this.setCtTdOffset(this.lregion, 'right', 0);
		this.setCtTdOffset(this.tregion, 'bottom', 0);
		this.setCtTdOffset(this.ltregion, 'right', 0);
		this.setCtTdOffset(this.ltregion, 'bottom', 0);
		
		this.cregion.removeCls('ss-leftborder');
		this.sheader.removeCls('ss-leftborder');
		this.lregion.removeCls('ss-topborder');
		this.tregion.removeCls('ss-leftborder');
		this.cregion.removeCls('ss-topborder');
		this.slefter.removeCls('ss-topborder');
		
		this.lregion.switchScroller(false);
		this.tregion.switchScroller(false);
	},
	/*
	 * cancel the split
	 * @param {boolean} suspendEvent: true to suspend event
	 */
	unsplit : function(suspendEvent){
		if(this.isSplited()){
			/*
			 * save the old splitPos
			 */
			var oldSplitPos = Ext.apply({}, this.splitPos);
			var oldFreezePos = this.freezePos ? Ext.apply({}, this.freezePos) : null; 
			var oldRangeInfo = this.getRangeInfo();
			var s = this.getStore();
			var sheetId = this.getSheetId();
			
			var El = this.getInnerEl();
			var width = El.getWidth()-El.getBorderWidth('lr'), height = El.getHeight()-El.getBorderWidth('tb');
			delete(this.splitPos);			
			/*
			 * hide all other regions first
			 */
			this.lheader.hide();
			this.ulefter.hide();
			this.ltregion.hide();
			this.lregion.hide();
			this.tregion.hide();
			/*
			 * remove the css
			 */
			this.switchSplitCls(false);
			
			var lw = s.getColWidth(sheetId, 0), hh = s.getRowHeight(sheetId, 0);
			var sw = width-lw;
			var sh = height-hh;
			
			var col = this.lheader.colStart;
			var row = this.ulefter.rowStart;
			/*
			 * refresh the remain regions
			 */
			this.sheader.recalculateRange(null, {
				colStart:col,
				width:sw
			});				
			
			this.sheader.setBound(null, {
				low:1,
				high:false
			});
			
			this.sheader.sysn();
			
			this.slefter.recalculateRange({
				rowStart:row,
				height:sh
			});	
			
			this.slefter.setBound({
				low:1,
				high:false
			});
			
			this.slefter.sysn();
			
			this.cregion.recalculateRange({
				rowStart:row,
				rowEnd:this.slefter.rowEnd,
				height:sh
			}, {
				colStart:col,
				colEnd:this.sheader.colEnd,
				width:sw
			});			

			this.cregion.setBound({
				low:1,
				high:false
			}, {
				low:1,
				high:false
			});
			
			this.cregion.sysn();		
			/*
			 * refresh the selection of all regions
			 */
			this.refreshSelection();
			
			/*
			 * update the config
			 */
			this.updateSheetConfig(true);
			
			if(!suspendEvent){
				/*
				 * fire splitchange event
				 */						
				var freezePos = this.freezePos ? Ext.apply({}, this.freezePos) : null; 
				var rangeInfo = this.getRangeInfo();
				this.fireEvent('splitchange', null, oldSplitPos, freezePos, oldFreezePos, rangeInfo, oldRangeInfo, this);
			}
		}
	},
	
	/*
	 * private
	 * refresh freeze mode
	 */
	refreshForFreeze : function(){
		var sheetId = this.getSheetId();
		
		/*
		 * if freezed, we need handle different regions, the row/col span of left-top regions are fixed,
		 * but the width/height of these regions could be changed
		 */
		var s = this.getStore();			
		var El = this.getInnerEl();
		var width = El.getWidth()-El.getBorderWidth('lr'), height = El.getHeight()-El.getBorderWidth('tb');
		var lw = s.getColWidth(sheetId, 0), hh = s.getRowHeight(sheetId, 0), w = 0, h = 0;
		if(this.lheader.isVisible()){			
			/*
			 * the span won't change at left-top part, but the width and height may be changed, 
			 * so we don't pass width or height as parameters, let the recalculateRange function
			 * computer them
			 */
			this.lheader.recalculateRange({
				rowStart:this.lheader.rowStart,
				rowEnd:this.lheader.rowEnd,
				height: hh 
			}, {
				colStart:this.lheader.colStart,
				colEnd:this.lheader.colEnd
			});				
			w = this.lheader.getWidth();	
			/*
			 * need sysn the inner ct and scroller
			 */
			this.lheader.sysn();			
		}
		if(this.ulefter.isVisible()){
			this.ulefter.recalculateRange({
				rowStart:this.ulefter.rowStart,
				rowEnd:this.ulefter.rowEnd
			}, {
				colStart:this.ulefter.colStart,
				colEnd:this.ulefter.colEnd,
				width: lw
			});
			h = this.ulefter.getHeight();
			/*
			 * need sysn the inner ct and scroller
			 */
			this.ulefter.sysn();
		}
		if(this.ltregion.isVisible()){
			this.ltregion.recalculateRange({
				rowStart:this.ltregion.rowStart,
				rowEnd:this.ltregion.rowEnd,				
				height:h
			}, {
				colStart:this.ltregion.colStart,
				colEnd:this.ltregion.colEnd,
				width:w
			});			
			
			/*
			 * need sysn the inner ct and scroller
			 */
			this.ltregion.sysn();	
		}
		var sw = width-lw-w;
		var sh = height-hh-h;						
		
		this.sheader.recalculateRange({
			rowStart:this.sheader.rowStart,
			rowEnd:this.sheader.rowEnd,
			height: hh 
		}, {
			colStart:this.sheader.colStart,
			width:sw
		});
		/*
		 * need sysn the inner ct and scroller
		 */
		this.sheader.sysn();
		
		this.slefter.recalculateRange({
			rowStart:this.slefter.rowStart,
			height:sh
		}, {
			colStart:this.slefter.colStart,
			colEnd:this.slefter.colEnd,
			width: lw
		});
		/*
		 * need sysn the inner ct and scroller
		 */
		this.slefter.sysn();
		
		if(this.lregion.isVisible()){			
			this.lregion.recalculateRange({
				rowStart:this.lregion.rowStart,
				rowEnd:this.slefter.rowEnd,
				height:sh
			}, {
				colStart:this.lheader.colStart,
				colEnd:this.lheader.colEnd,
				width:w
			});
			
			/*
			 * need sysn the inner ct and scroller
			 */
			this.lregion.sysn();
		}
		
		if(this.tregion.isVisible()){
			this.tregion.recalculateRange({
				rowStart:this.ulefter.rowStart,
				rowEnd:this.ulefter.rowEnd,
				height:h
			}, {
				colStart:this.tregion.colStart,
				colEnd:this.sheader.colEnd,
				width:sw
			});
			
			/*
			 * need sysn the inner ct and scroller
			 */
			this.tregion.sysn();
		}
		
		this.cregion.recalculateRange({
			rowStart:this.cregion.rowStart,
			rowEnd:this.slefter.rowEnd,
			height:sh
		}, {
			colStart:this.cregion.colStart,
			colEnd:this.sheader.colEnd,
			width:sw
		});
		
		/*
		 * need sysn the inner ct and scroller
		 */
		this.cregion.sysn();
	},
	
	/*
	 * private 
	 * refresh for split mode
	 */
	refreshForSplit : function(){
		var sheetId = this.getSheetId();		
		/*
		 * if splited, we need handle different regions
		 * the left-top regions are fixed in width/height
		 * but the row/col span could be changed
		 */
		var s = this.getStore();
		var El = this.getInnerEl();
		var width = El.getWidth()-El.getBorderWidth('lr'), height = El.getHeight()-El.getBorderWidth('tb');
		var lw = s.getColWidth(sheetId, 0), hh = s.getRowHeight(sheetId, 0), w = this.splitPos.width, h = this.splitPos.height;
		
		if(this.lheader.isVisible()){
			/*
			 * the span won't change at left-top part, but the width and height may be changed, 
			 * so we don't pass width or height as parameters, let the recalculateRange function
			 * computer them
			 */
			this.lheader.recalculateRange({
				rowStart:this.lheader.rowStart,
				rowEnd:this.lheader.rowEnd,
				height: hh
			}, {
				colStart:this.lheader.colStart,
				width:w
			});
			/*
			 * need sysn the inner ct and scroller
			 */
			this.lheader.sysn();
		}
		if(this.ulefter.isVisible()){
			this.ulefter.recalculateRange({
				rowStart:this.ulefter.rowStart,
				height:h
			}, {
				colStart:this.ulefter.colStart,
				colEnd:this.ulefter.colEnd,
				width: lw
			});
			/*
			 * need sysn the inner ct and scroller
			 */
			this.ulefter.sysn();
		}
		if(this.ltregion.isVisible()){
			this.ltregion.recalculateRange({
				rowStart:this.ltregion.rowStart,
				rowEnd:this.ulefter.rowEnd,
				height:h
			}, {
				colStart:this.ltregion.colStart,
				colEnd:this.lheader.colEnd,
				width:w
			});	
			/*
			 * need sysn the inner ct and scroller
			 */
			this.ltregion.sysn();			
		}
		var sw = width-lw-w-s.splitOffset;
		var sh = height-hh-h-s.splitOffset;						
		
		sh++;
		sw++;
		
		this.sheader.recalculateRange({
			rowStart:this.sheader.rowStart,
			rowEnd:this.sheader.rowEnd,
			height: hh
		}, {
			colStart:this.sheader.colStart,
			width:sw
		});
		
		/*
		 * need sysn the inner ct and scroller
		 */
		this.sheader.sysn();
			
		this.slefter.recalculateRange({
			rowStart:this.slefter.rowStart,
			height:sh
		}, {
			colStart:this.slefter.colStart,
			colEnd:this.slefter.colEnd,
			width: lw
		});
		
		/*
		 * need sysn the inner ct and scroller
		 */
		this.slefter.sysn();
		
		if(this.lregion.isVisible()){
			this.lregion.recalculateRange({
				rowStart:this.lregion.rowStart,
				rowEnd:this.slefter.rowEnd,
				height:sh
			}, {
				colStart:this.lregion.colStart,
				colEnd:this.lheader.colEnd,
				width:w
			});
			/*
			 * need sysn the inner ct and scroller
			 */
			this.lregion.sysn();
		}
		
		if(this.tregion.isVisible()){
			this.tregion.recalculateRange({
				rowStart:this.tregion.rowStart,
				rowEnd:this.ulefter.rowEnd,
				height:h
			}, {
				colStart:this.tregion.colStart,
				colEnd:this.sheader.colEnd,
				width:sw
			});
			/*
			 * need sysn the inner ct and scroller
			 */
			this.tregion.sysn();
		}
					
		this.cregion.recalculateRange({
			rowStart:this.cregion.rowStart,
			rowEnd:this.slefter.rowEnd,
			height:sh
		}, {
			colStart:this.cregion.colStart,
			colEnd:this.sheader.colEnd,
			width:sw
		});
		/*
		 * need sysn the inner ct and scroller
		 */
		this.cregion.sysn();
	},
	
	/*
	 * private 
	 * refresh all regions for normal mode, nigther freezed nor splited
	 */
	refreshForNormal : function(){		
		var sheetId = this.getSheetId();
		
		/*
		 * for normal mode, no freeze and split, we only need take care of center region
		 */
		var s = this.getStore();
		var El = this.getInnerEl();
		var width = El.getWidth()-El.getBorderWidth('lr'), height = El.getHeight()-El.getBorderWidth('tb');
		var lw = s.getColWidth(sheetId, 0), hh = s.getRowHeight(sheetId, 0);
		var sw = width-lw;
		var sh = height-hh;			
		this.sheader.recalculateRange({
			rowStart:this.sheader.rowStart,
			rowEnd:this.sheader.rowEnd,
			height: hh
		}, {
			colStart:this.sheader.colStart,
			width:sw
		});			
		/*
		 * need sysn the inner ct and scroller
		 */
		this.sheader.sysn();
		
		this.slefter.recalculateRange({
			rowStart:this.slefter.rowStart,
			height:sh
		}, {
			colStart:this.slefter.colStart,
			colEnd:this.slefter.colEnd,
			width: lw
		});
		
		/*
		 * need sysn the inner ct and scroller
		 */
		this.slefter.sysn();
		
		this.cregion.recalculateRange({
			rowStart:this.cregion.rowStart,
			rowEnd:this.slefter.rowEnd,
			height:sh
		}, {
			colStart:this.cregion.colStart,
			colEnd:this.sheader.colEnd,
			width:sw
		});
		/*
		 * need sysn the inner ct and scroller
		 */
		this.cregion.sysn();
	},
	
	/*
	 * refrsh all regions, it will handle different mode, no matter freezed or splited
	 */
	refresh : function(){			
		if(this.isFreezed()){	
			this.switchFreezeCls(true);			
			this.refreshForFreeze();
		}else if(this.isSplited()){
			this.switchSplitCls(true);			
			this.refreshForSplit();
		}else{
			this.switchFreezeCls(false);
			this.switchSplitCls(false);
			this.refreshForNormal();
		}
		this.checkLefterWidth();
		/*
		 * refresh the selection range
		 */
		this.refreshSelection();
		
		/*
		 * refresh the refrence range
		 */		
		this.refreshFocus();
	},
	
	/*
	 * force to fire a selectionchange event to let every region to sysn the selection 
	 */
	refreshSelection : function(){		
		var sm = this.cregion.getSelectionModel();
		var selection = sm.getSelection();
		this.cregion.fireEvent('selectionchange', selection.startPos, selection.endPos);
	},
	
	/*
	 * force to fire a selectionchange event to let every region to sysn the selection 
	 */
	refreshReference : function(){				
		var rm = this.cregion.getReferenceModel();	
		if(rm.isVisible()){					
			/*
			 * pass null as the region so all regions will refresh
			 */				
			this.cregion.fireEvent('referencechange', null, rm, true);
		}		
	},
	
	/*
	 * get a cell's left-top position in the Sheet,
	 * notice it's a relative position, the left-top point of Sheet body is referenced as [0, 0]
	 * the region parameter define the cell in which region, cause in split mode, a cell could appear in more than one region
	 * @param {int} row: the row index of the cell
	 * @param {int} col: the column index of the cell
	 * @param {object} region: the region ref, in which this function will try to find the cell,
	 * if not define then use cregion
	 * @return {array}: the left-top value in an array [left, top]
	 */
	getCellPosition : function(row, col, region){
		if(region){
			return region.getCellPosition(row, col);
		}else{
			return this.cregion.getCellPosition(row, col);
		}		
	},
	
	/*
	 * For merge cells, we only need change the records in store, 
	 * store will fire 'cellchange' event, and region will refresh changed cell
	 * @param {array} span: the span included the sheetId/minrow/maxrow/mincol/maxcol to merge 
	 * @param {boolean} suspendEvent: true to not fire event
	 * @param {boolean} suspendRefresh: true to not refresh the cells
	 */
	mergeCell : function(span, suspendEvent, suspendRefresh){
		this.doMergeCell(span, suspendEvent, suspendRefresh);
	},
	
	doMergeCell : function(span, suspendEvent, suspendRefresh){		
		var s = this.getStore();
		var sheetId = span[0], minrow = span[1], mincol = span[2], maxrow = span[3], maxcol = span[4];
		if(false == SCOM.typeOf(sheetId)){
			span[0] = sheetId = this.getSheetId();
		}
		if(minrow != maxrow || mincol != maxcol){	
			var reCalCells = this.getRecalculateCellsByCoord([span]);
			for(var i = minrow; i <= maxrow; i++){
				for(var j = mincol; j <= maxcol; j++){
					s.setCell(sheetId, i, j, {
						minrow:minrow-i,
						mincol:mincol-j,
						maxrow:maxrow-i,
						maxcol:maxcol-j
					}, null, true);
				}
			}
			if(!suspendRefresh){
				this.refreshRange([span], reCalCells);
			}			
			if(!suspendEvent){
				/*
				 * fire mergecell event
				 */
				this.fireEvent('mergecell', [].concat(span), this, reCalCells);
			}
		}
		/*
		 * focus the sheet
		 */
		this.focus(this.focusDelayTime);
	},
	
	/*
	 * almost the same as mergeCell function
	 * @param {array} span: the span included the sheetId/minrow/maxrow/mincol/maxcol to unmerge 
	 * @param {boolean} suspendEvent: true to not fire event
	 * @param {boolean} suspendRefresh: true to not refresh the cells
	 */
	unmergeCell : function(span, suspendEvent, suspendRefresh){
		this.doUnmergeCell(span, suspendEvent, suspendRefresh);
	},
	
	doUnmergeCell : function(span, suspendEvent, suspendRefresh){
		var s = this.getStore();		
		var sheetId = span[0], minrow = span[1], mincol = span[2], maxrow = span[3], maxcol = span[4];
		if(false == SCOM.typeOf(sheetId)){
			sheetId = this.getSheetId();
			span[0] = sheetId;
		}
		/*
		 * save the actually unmerged cells
		 */
		var merges = {};
		
		var reCalCells = this.getRecalculateCellsByCoord([span]);
		
		for(var i = minrow; i <= maxrow; i++){
			for(var j = mincol; j <= maxcol; j++){
				var o = s.getCell(sheetId, i, j);
				if(s.isMergedCell(o, sheetId, i, j)){
					var arr = [sheetId, i+o.minrow, j+o.mincol, i+o.maxrow, j+o.maxcol]; 
					merges[arr.join('$')] = arr;
					s.setCell(sheetId, i, j, null, ['minrow', 'mincol', 'maxrow', 'maxcol', 'abminrow', 'abmincol', 'abmaxrow', 'abmaxcol'], true);
				}
			}
		}
		if(!SCOM.isEmptyObj(merges)){
			if(!suspendRefresh){
				this.refreshRange([[sheetId, minrow, mincol, maxrow, maxcol]], reCalCells);
			}
			if(!suspendEvent){
				/*
				 * fire unmergecell event
				 */
				this.fireEvent('unmergecell', [sheetId, minrow, mincol, maxrow, maxcol], merges, this, reCalCells);
			}
		}
		/*
		 * focus the sheet
		 */
		this.focus(this.focusDelayTime);
	},
	
	/*
	 * need reset the lefter width when the index is changing, to make sure all digital can be shown
	 * @param {boolean} stopRecursion A flag to define whether need stop the recursion of this function
	 */
	checkLefterWidth : function(stopRecursion, forceCheckFlag){
		if(!this.checkingLefter && !this.store.rowNameHidden){			
			this.checkingLefter = true;
			var max = this.slefter.rowEnd;
			var sheetId = this.getSheetId();
			var low = Math.pow(10, this.maxRowIndexDigital-1);
			var high = Math.pow(10, this.maxRowIndexDigital);			
			if(this.ulefter.isVisible() && this.ulefter.rowEnd > this.slefter.rowEnd){
				max = this.ulefter.rowEnd;
			}
			var s = this.getStore();
			
			if(max >= high || max <= low || forceCheckFlag){
				/*
				 * calculate the new digital number and the offset width
				 */
				var old = this.maxRowIndexDigital;
				this.maxRowIndexDigital = Math.floor(Math.log(max)/Math.LN10)+1;
				/*
				 * 
				 */
				if(this.maxRowIndexDigital < this.defaultRowIndexDigital){
					this.maxRowIndexDigital = this.defaultRowIndexDigital;
				}
				var offsetWidth = (this.maxRowIndexDigital-old)*this.digitalWidth;
				if(0 != offsetWidth || forceCheckFlag){
					/*
					 * set the new left width to store
					 */
					s.setLeftWidth(sheetId, this.maxRowIndexDigital*this.digitalWidth+this.spaceWidth);
					/*
					 * get the new left width from store, and update the ltcorner, ulefter and slefter width
					 */
					var lw = s.getColWidth(sheetId, 0);
					this.ltcorner.setWidth(lw);
					this.slefter.recalculateRange(null, {
						colStart:this.slefter.colStart,
						colEnd:this.slefter.colEnd,
						width:lw
					});
					if(this.ulefter.isVisible()){
						this.ulefter.recalculateRange(null, {
							colStart:this.ulefter.colStart,
							colEnd:this.ulefter.colEnd,
							width:lw
						});
					}
					var sw = this.cregion.getWidth()-offsetWidth;
					/*
					 * change the width of top and center region
					 */
					if(this.tregion.isVisible()){					
						this.tregion.setWidth(sw);
					}
					this.sheader.setWidth(sw);
					this.cregion.setWidth(sw);				
					/*
					 * need reset the selectionmodel if it's row selected
					 */
					
					var lsm = this.slefter.getSelectionModel();
					if(lsm.startPos && 0 == lsm.startPos.col && 0 != lsm.startPos.row){
						lsm.selectRange(lsm.startPos, lsm.endPos, true);
						if(this.ulefter.isVisible()){
							lsm = this.ulefter.getSelectionModel();
							lsm.selectRange(lsm.startPos, lsm.endPos, true);
						}
					}
				}
			}
			/*
			 * if stopRecursion is not true then we will recursion this function;
			 * first we defer to set this.checkingLefter to false, it's because we don't want to call this function too soon
			 */
			if(!stopRecursion){
				Ext.Function.defer(function(){
					this.checkingLefter = false;
					/*
					 * defer to recursion
					 */
					Ext.Function.defer(this.checkLefterWidth, this.checkLeftDelay, this, [true]);
				}, this.checkLeftDelay, this);
			}else{				
				/*
				 * if stopRecursion is true, then set checkingLeftr to false immediately
				 */
				this.checkingLefter = false;				
			}
		}
	},
	
	getStore : function(){
		return this.store;
	},
		
	/*
	 * when left header column resize, maybe need change the size of different region
	 */
	onLeftColumnResize : function(column, old, cur){
		if(this.isFreezed()){
			/*
			 * if at freeze mode, we need update the region width
			 */	
			var s = this.getStore();
			var fw = s.getRangeWidth(this.getSheetId(), this.lheader.colStart, this.freezePos.col-1);			
			var offset = fw-this.lheader.getWidth();
			if(this.ltregion.isVisible()){
				this.ltregion.setWidth(fw);
			}
			
			this.lregion.setWidth(fw);
			this.lheader.setWidth(fw);;
			
			var sw = this.sheader.getWidth()-offset;
			this.sheader.setWidth(sw);
			this.cregion.setWidth(sw);
			if(this.tregion.isVisible()){
				this.tregion.setWidth(sw);
			}
		}
	},
	
	/*
	 * when upper lefter row resize, maybe need change the size of different region
	 */
	onUpperRowResize : function(){		
		if(this.isFreezed()){			
			/*
			 * if at freeze mode, we need update the region Height
			 */	
			var s = this.getStore();
			var fh = s.getRangeHeight(this.getSheetId(), this.ulefter.rowStart, this.freezePos.row-1);			
			var offset = fh-this.tregion.getHeight();
			if(this.ltregion.isVisible()){
				this.ltregion.setHeight(fh);
			}
			this.tregion.setHeight(fh);
			this.ulefter.setHeight(fh);
			
			var sh = this.slefter.getHeight()-offset;
			this.slefter.setHeight(sh);
			this.cregion.setHeight(sh);
			if(this.lregion.isVisible()){
				this.lregion.setHeight(sh);
			}
		}
	},
	
	
	/*
	 * before remove cells, we need check whether it will affect the merged cell
	 * if yes will ask user to cancel merged cell  first
	 */
	beforeRemoveCell : function(sheetId, minrow, maxrow, mincol, maxcol, moveDir, deleted, merged, store){
		var brokens = store.getBrokenMergedCells(sheetId, minrow, maxrow, mincol, maxcol, 'up' == moveDir ? 'row' : 'col');
		if(SCOM.countObjMember(brokens)){
			Ext.Msg.alert(SLANG['hint'], SLANG['action_broken_merged']);
			return false;
		}
        if(store.isBrokenArrayFormulaCells(sheetId, minrow, maxrow, mincol, maxcol, 'up' == moveDir ? 'row' : 'col')){
            Ext.Msg.alert(SLANG['hint'], SLANG['can_not_only_change_part_of_array_formula']);
            return false;
        }
	},
	
	/*
	 * before insert cells, we need check whether it will affect the merged cell
	 * if yes will ask user to cancel merged cell  first
	 */
	beforeInsertCell : function(sheetId, row, col, rowSpan, colSpan, moveDir, merged, store){
        var brokens = store.getBrokenMergedCells(sheetId, row, row+rowSpan-1, col, col+colSpan-1, 'down' == moveDir ? 'row' : 'col');
		if(SCOM.countObjMember(brokens)){
			Ext.Msg.alert(SLANG['hint'], SLANG['action_broken_merged']);
			return false;
		}
        if(store.isBrokenArrayFormulaCells(sheetId, row, row+rowSpan-1, col, col+colSpan-1, 'down' == moveDir ? 'row' : 'col')){
            Ext.Msg.alert(SLANG['hint'], SLANG['can_not_only_change_part_of_array_formula']);
            return false;
        }
	},
           
    /*
     * before remove row, we need check whether it will affect the array formula cell
     * if yes then abort the action
     */
    beforeRemoveRow : function(sheetId, minrow, maxrow, deleted, merged, store){
        if(store.isBrokenArrayFormulaCells(sheetId, minrow, maxrow, 0, 0, 'row')){
            Ext.Msg.alert(SLANG['hint'], SLANG['can_not_only_change_part_of_array_formula']);
            return false;
        }
    },
           
    /*
     * before remove column, we need check whether it will affect the array formula cell
     * if yes then abort the action
     */
    beforeRemoveColumn : function(sheetId, mincol, maxcol, deleted, merged, store){
        if(store.isBrokenArrayFormulaCells(sheetId, 0, 0, mincol, maxcol, 'col')){
            Ext.Msg.alert(SLANG['hint'], SLANG['can_not_only_change_part_of_array_formula']);
            return false;
        }
    },
           
    /*
     * before insert row, we need check whether it will affect the array formula cell
     * if yes then abort the action
     */
    beforeInsertRow : function(sheetId, row, rowSpan, merged, store){
        if(store.isBrokenArrayFormulaCells(sheetId, row, row+rowSpan-1, 0, 0, 'row')){
            Ext.Msg.alert(SLANG['hint'], SLANG['can_not_only_change_part_of_array_formula']);
            return false;
        }
    },
	
    /*
     * before insert col, we need check whether it will affect the array formula cell
     * if yes then abort the action
     */
    beforeInsertColumn : function(sheetId, col, colSpan, merged, store){
        if(store.isBrokenArrayFormulaCells(sheetId, 0, 0, col, col+colSpan-1, 'col')){
            Ext.Msg.alert(SLANG['hint'], SLANG['can_not_only_change_part_of_array_formula']);
            return false;
        }
    },
           
	
	/**
	 * _private
	 * 
	 */
	transferCalCdt2ObjArr : function(calObj, cdtObj){
		var store = this.getStore();
		var obj = {};
		if(calObj){
			for(var p in calObj){
				if(calObj.hasOwnProperty(p)){
					var it = calObj[p];
					obj[p] = [it.sheet, it.row, it.col];
				}
			}
		}
		if(cdtObj){			
			for(var p in cdtObj){
				if(cdtObj.hasOwnProperty(p)){
					var it = cdtObj[p];
					var cdt = Ext.decode(it.json);
					if(cdt){
						var rng = cdt.rng, coord;
                        coord = [];
                        for(var i = 0, len = rng.length; i < len; i++){
                            coord.push(rng[i].span);
                        }
						store.walkRange(coord, function(rd, walkSpan, store, internalId){
							var row = rd.data.row, col = rd.data.col;
							if(0 !== row && 0 !== col){
								var id = internalId;
								if(!obj[id]){
									obj[id] = [rd.data.sheet, row, col];
								}
							}
						}, this);
					}					
				}
			}
			
		}
		return obj;
	},
	
	/*
	 * hold insert/remove col/row/cell
	 */
	holdRemoveRow : function(sheetId, minrow, maxrow, deleted, merged, store){
		//this.startTime = new Date();
		var oldCal, curCal, oldCdt, curCdt, oldCells, curCells, needCalCdt, deletedNameRef;
		if(this.calculate){
			var obj = this.calculate.beforeRemoveRow(sheetId, minrow, maxrow);
			if(obj){
				oldCal = obj.oldCal;
				curCal = obj.curCal;
				needCalCdt = obj.needRefreshCal;
				deletedNameRef = obj.deletedNameRef;
			}
		}
		if(this.condition){
			var obj = this.condition.beforeRemoveRow(sheetId, minrow, maxrow);
			if(obj){
				oldCdt = obj.oldCdt;
				curCdt = obj.curCdt;
				oldCells = obj.oldCells;
				curCells = obj.curCells;
				needCalCdt = needCalCdt || obj.needRefreshCdt;
			}
		}
		/*
		 * get re-calculate cells
		 */
		//var reCalCells = this.getRecalculateCellsByCoord([[sheetId, minrow, 0, maxrow, 0]]);
		/*
		 * define e object to collect the info for the listeners
		 */
		var e = {};
		
		/*
		 * get the cells need recalculated
		 */		
		var oldReCalCells = this.transferCalCdt2ObjArr(oldCal, oldCdt);

		var reCalCells = this.transferCalCdt2ObjArr(curCal, curCdt);		
		
		/*
		 * listeners can set e.refresh to true, then sheet will refresh the whole UI
		 * set e.calCdt to true, then sheet will recal the cal/cdt cells
		 */
		this.fireEvent('holdremoverow', sheetId, minrow, maxrow, deleted, merged, e, this, oldCal, curCal, oldCdt, curCdt, oldCells, curCells, oldReCalCells, reCalCells, deletedNameRef);
		
		var needRefresh = this.onRemoveRow(sheetId, minrow, maxrow), refreshed;						
		
		//console.log(Ext.encode(reCalCells))
		//console.log(Ext.encode(reCalCells))
		if(e.calCdt || needCalCdt){
			refreshed = this.refreshCalCdt(reCalCells, true);
            if(refreshed){
                this.refreshRange();
            }
		}
		//console.log(Ext.Date.getElapsed(this.startTime));
		if(refreshed){				
			return false;
		}else if((e.refresh && false !== needRefresh) || true === needRefresh){
			this.refreshRange();
            return false;
		}				
		if(e.stop || false === needRefresh){
			return false;
		}
	},
		
	holdRemoveColumn : function(sheetId, mincol, maxcol, deleted, merged, store){		
		var oldCal, curCal, oldCdt, curCdt, oldCells, curCells, needCalCdt, deletedNameRef;
		if(this.calculate){
			var obj = this.calculate.beforeRemoveColumn(sheetId, mincol, maxcol);
			if(obj){
				oldCal = obj.oldCal;
				curCal = obj.curCal;
				needCalCdt = obj.needRefreshCal;
				deletedNameRef = obj.deletedNameRef;
			}
		}
		if(this.condition){
			var obj = this.condition.beforeRemoveColumn(sheetId, mincol, maxcol);
			if(obj){
				oldCdt = obj.oldCdt;
				curCdt = obj.curCdt;
				oldCells = obj.oldCells;
				curCells = obj.curCells;
				needCalCdt = needCalCdt || obj.needRefreshCdt;
			}
		}
		/*
		 * define e object to collect the info for the listeners
		 */
		var e = {};
		
		/*
		 * get the cells need recalculated
		 */		
		var oldReCalCells = this.transferCalCdt2ObjArr(oldCal, oldCdt);

		
		var reCalCells = this.transferCalCdt2ObjArr(curCal, curCdt);
		
		/*
		 * listeners can set e.refresh to true, then sheet will refresh the whole UI
		 * set e.calCdt to true, then sheet will recal the cal/cdt cells
		 */
		this.fireEvent('holdremovecolumn', sheetId, mincol, maxcol, deleted, merged, e, this, oldCal, curCal, oldCdt, curCdt, oldCells, curCells, oldReCalCells, reCalCells, deletedNameRef);
		
		var needRefresh = this.onRemoveColumn(sheetId, mincol, maxcol), refreshed;
		
		if(e.calCdt || needCalCdt){			
			refreshed = this.refreshCalCdt(reCalCells, true);
            if(refreshed){
                this.refreshRange();
            }
		}
		
		if(refreshed){				
			return false;
		}else if((e.refresh && false !== needRefresh) || true === needRefresh){
			this.refreshRange();
            return false;
		}				
		if(e.stop || false === needRefresh){
			return false;
		}
	},
	
	holdRemoveCell : function(sheetId, minrow, maxrow, mincol, maxcol, moveDir, deleted, merged, store){
		var oldCal, curCal, oldCdt, curCdt, oldCells, curCells, needCalCdt, deletedNameRef;
		if(this.calculate){
			var obj = this.calculate.beforeRemoveCell(sheetId, minrow, maxrow, mincol, maxcol, moveDir);
			if(obj){
				oldCal = obj.oldCal;
				curCal = obj.curCal;
				needCalCdt = obj.needRefreshCal;
				deletedNameRef = obj.deletedNameRef;
			}
		}
		if(this.condition){
			var obj = this.condition.beforeRemoveCell(sheetId, minrow, maxrow, mincol, maxcol, moveDir);
			if(obj){
				oldCdt = obj.oldCdt;
				curCdt = obj.curCdt;
				oldCells = obj.oldCells;
				curCells = obj.curCells;
				needCalCdt = needCalCdt || obj.needRefreshCdt;
			}
		}
		
		/*
		 * define e object to collect the info for the listeners
		 */
		var e = {};
		
		/*
		 * get the cells need recalculated
		 */		
		var oldReCalCells = this.transferCalCdt2ObjArr(oldCal, oldCdt);
		
        var reCalCells = this.transferCalCdt2ObjArr(curCal, curCdt);
		
		/*
		 * listeners can set e.refresh to true, then sheet will refresh the whole UI
		 * set e.calCdt to true, then sheet will recal the cal/cdt cells
		 */
		this.fireEvent('holdremovecell', sheetId, minrow, maxrow, mincol, maxcol, moveDir, deleted, merged, e, this, oldCal, curCal, oldCdt, curCdt, oldCells, curCells, oldReCalCells, reCalCells, deletedNameRef);
		var refreshed;
		if(e.calCdt || needCalCdt){			
			refreshed = this.refreshCalCdt(reCalCells, true);
            if(refreshed){
                this.refreshRange();
            }
		}
		
		if(refreshed){				
			return false;
		}else if(e.refresh){
			this.refreshRange();
            return false;
		}				
		if(e.stop){
			return false;
		}
	},
	
	holdInsertRow : function(sheetId, row, span, merged, store, insertCellCache){
		var oldCal, curCal, oldCdt, curCdt, oldCells, curCells, needCalCdt;
		if(this.calculate){
			var obj = this.calculate.beforeInsertRow(sheetId, row, span);
			if(obj){
				oldCal = obj.oldCal;
				curCal = obj.curCal;
				needCalCdt = obj.needRefreshCal;
			}
		}
		if(this.condition){
			var obj = this.condition.beforeInsertRow(sheetId, row, span);
			if(obj){
				oldCdt = obj.oldCdt;
				curCdt = obj.curCdt;
				oldCells = obj.oldCells;
				curCells = obj.curCells;
				needCalCdt = needCalCdt || obj.needRefreshCdt;
			}
		}
		/*
		 * define e object to collect the info for the listeners
		 */
		var e = {};
		
		/*
		 * get the cells need recalculated
		 */		
		var oldReCalCells = this.transferCalCdt2ObjArr(oldCal, oldCdt);
		
		var reCalCells = this.transferCalCdt2ObjArr(curCal, curCdt);
		
		
		/*
		 * listeners can set e.refresh to true, then sheet will refresh the whole UI
		 * set e.calCdt to true, then sheet will recal the cal/cdt cells
		 */
		this.fireEvent('holdinsertrow', sheetId, row, span, merged, e, this, oldCal, curCal, oldCdt, curCdt, oldCells, curCells, oldReCalCells, reCalCells, insertCellCache);
		
		var needRefresh = this.onInsertRow(sheetId, row, span), refreshed;

		if(e.calCdt || needCalCdt){
			refreshed = this.refreshCalCdt(reCalCells, true);
            if(refreshed){
                this.refreshRange();
            }
		}
		
		if(refreshed){				
			return false;
		}else if((e.refresh && false !== needRefresh) || true === needRefresh){
			this.refreshRange();
            return false;
		}				
		if(e.stop || false === needRefresh){
			return false;
		}
	},
	
	holdInsertColumn : function(sheetId, col, span, merged, store, insertCellCache){	
		var oldCal, curCal, oldCdt, curCdt, oldCells, curCells, needCalCdt;
		if(this.calculate){
			var obj = this.calculate.beforeInsertColumn(sheetId, col, span);
			if(obj){
				oldCal = obj.oldCal;
				curCal = obj.curCal;
				needCalCdt = obj.needRefreshCal;
			}
		}
		if(this.condition){
			var obj = this.condition.beforeInsertColumn(sheetId, col, span);
			if(obj){
				oldCdt = obj.oldCdt;
				curCdt = obj.curCdt;
				oldCells = obj.oldCells;
				curCells = obj.curCells;
				needCalCdt = needCalCdt || obj.needRefreshCdt;
			}
		}
		/*
		 * define e object to collect the info for the listeners
		 */
		var e = {};
		
		/*
		 * get the cells need recalculated
		 */		
		var oldReCalCells = this.transferCalCdt2ObjArr(oldCal, oldCdt);
		
		var reCalCells = this.transferCalCdt2ObjArr(curCal, curCdt);
		
		/*
		 * listeners can set e.refresh to true, then sheet will refresh the whole UI
		 * set e.calCdt to true, then sheet will recal the cal/cdt cells
		 */
		this.fireEvent('holdinsertcolumn', sheetId, col, span, merged, e, this, oldCal, curCal, oldCdt, curCdt, oldCells, curCells, oldReCalCells, reCalCells, insertCellCache);
		
		var needRefresh = this.onInsertColumn(sheetId, col, span), refreshed;

		if(e.calCdt || needCalCdt){
			refreshed = this.refreshCalCdt(reCalCells, true);
            if(refreshed){
                this.refreshRange();
            }
		}
		
		if(refreshed){				
			return false;
		}else if((e.refresh && false !== needRefresh) || true === needRefresh){
			this.refreshRange();
            return false;
		}				
		if(e.stop || false === needRefresh){
			return false;
		}
	},
	
	holdInsertCell : function(sheetId, row, col, rowSpan, colSpan, moveDir, merged, store, insertCellCache){
		var oldCal, curCal, oldCdt, curCdt, oldCells, curCells, needCalCdt;
		if(this.calculate){
			var obj = this.calculate.beforeInsertCell(sheetId, row, col, rowSpan, colSpan, moveDir);
			if(obj){
				oldCal = obj.oldCal;
				curCal = obj.curCal;
				needCalCdt = obj.needRefreshCal;
			}
		}
		if(this.condition){
			var obj = this.condition.beforeInsertCell(sheetId, row, col, rowSpan, colSpan, moveDir);
			if(obj){
				oldCdt = obj.oldCdt;
				curCdt = obj.curCdt;
				oldCells = obj.oldCells;
				curCells = obj.curCells;
				needCalCdt = needCalCdt || obj.needRefreshCal;
			}
		}
		/*
		 * define e object to collect the info for the listeners
		 */
		var e = {};
		
		/*
		 * get the cells need recalculated
		 */		
		var oldReCalCells = this.transferCalCdt2ObjArr(oldCal, oldCdt);
		var maxrow = row+rowSpan-1, maxcol = col+colSpan-1;
						
		var reCalCells = this.transferCalCdt2ObjArr(curCal, curCdt);
		
		/*
		 * listeners can set e.refresh to true, then sheet will refresh the whole UI
		 * set e.calCdt to true, then sheet will recal the cal/cdt cells
		 */
		this.fireEvent('holdinsertcell', sheetId, row, col, rowSpan, colSpan, moveDir, merged, e, this, oldCal, curCal, oldCdt, curCdt, oldCells, curCells, oldReCalCells, reCalCells, insertCellCache);
		
		var refreshed;
		if(e.calCdt || needCalCdt){
			refreshed = this.refreshCalCdt(reCalCells, true);
            if(refreshed){
                this.refreshRange();
            }
		}
		
		if(refreshed){				
			return false;
		}else if(e.refresh){
			this.refreshRange();
            return false;
		}				
		if(e.stop){
			return false;
		}
	},
	
	/*
	 * when a row is removed, maybe need change the size of different regions
	 */
	onRemoveRow : function(sheetId, minrow, maxrow){
		var needRefresh;
		if(sheetId == this.getSheetId()){
			if(this.isFreezed()){
				if(minrow < this.freezePos.row){
					maxrow = this.freezePos.row < maxrow?this.freezePos.row:maxrow;
					var span = maxrow-minrow+1;
					var row = this.freezePos.row-span;
					if(1 > row){
						row = 1;
					}
					this.freeze(row, this.freezePos.col, true);
					needRefresh = false;
				}
			}
		}
		/*
		 * prepare remove row, need sync column groups
		 */
		if(this.rowGroups){
			var oldMaxLevel = this.rowGroupMaxLevel;
			var groups = this.rowGroups, maps = this.rowGroupNameMap;
			var newGroups = [], rowSpan = maxrow-minrow+1;
			var levels = {};			
			for(var name in maps){
				var group = maps[name], span = group.span;
				if(!(minrow <= span[0] && span[1] <= maxrow)){
					if(minrow >= span[0] && maxrow <= span[1]){
						span[1] -= rowSpan;
					}else if(minrow >= span[0] && span[1] >= minrow){
						span[1] = minrow-1;
					}else if(maxrow >= span[0] && span[1] >= maxrow){
						span[0] = minrow;
						span[1] -= rowSpan;
					}else if(maxrow < span[0]){
						span[0] -= rowSpan;
						span[1] -= rowSpan;
					}
					if(0 < span[1]-span[0]){
						var level = group.level;
						levels[level] = levels[level] || {};						
						levels[level][span[1]] = group;
						newGroups.push(group);
					}									
				}
			}
			var index = 0;			
			for(var i = 1; i <= oldMaxLevel; i++){
				var line = levels[i];
				if(i < oldMaxLevel){
					var upper = levels[i+1], removes = {};
					for(var p in line){
						if(upper[p]){
							removes[p] = true;
						}
					}					
					for(var p in removes){
						delete(line[p]);
					}
				}
				if(line && !SCOM.isEmptyObj(line)){					
					index++;
					for(var p in line){
						line[p].level = index;
					}					
				}
			}		
			this.layoutRowGroups(newGroups);		
			/*
			 * means need refresh
			 */
			needRefresh = true;
		}
		return needRefresh;
	},
	
	/*
	 * when acolumn is removed, maybe need change the size of different regions
	 */
	onRemoveColumn : function(sheetId, mincol, maxcol){
		var needRefresh;
		if(sheetId == this.getSheetId()){
			if(this.isFreezed()){
				if(mincol < this.freezePos.col){
					maxcol = this.freezePos.col < maxcol?this.freezePos.col:maxcol;
					var span = maxcol-mincol+1;
					var col = this.freezePos.col-span;
					if(1 > col){
						col = 1;
					}
					this.freeze(this.freezePos.row, col, true);	
					needRefresh = false;
				}
			}			
		}
		/*
		 * prepare remove column, need sync column groups
		 */
		if(this.colGroups){
			var oldMaxLevel = this.colGroupMaxLevel;
			var groups = this.colGroups, maps = this.colGroupNameMap;
			var newGroups = [], colSpan = maxcol-mincol+1;
			var levels = {};
			for(var name in maps){
				var group = maps[name], span = group.span;
				if(!(mincol <= span[0] && span[1] <= maxcol)){
					if(mincol >= span[0] && maxcol <= span[1]){
						span[1] -= colSpan;
					}else if(mincol >= span[0] && span[1] >= mincol){
						span[1] = mincol-1;
					}else if(maxcol >= span[0] && span[1] >= maxcol){
						span[0] = mincol;
						span[1] -= colSpan;
					}else if(maxcol < span[0]){
						span[0] -= colSpan;
						span[1] -= colSpan;
					}
					if(0 < span[1]-span[0]){
						var level = group.level;
						levels[level] = levels[level] || {};						
						levels[level][span[1]] = group;
						newGroups.push(group);
					}									
				}
			}
			var index = 0;			
			for(var i = 1; i <= oldMaxLevel; i++){
				var line = levels[i];
				if(i < oldMaxLevel){
					var upper = levels[i+1], removes = {};
					for(var p in line){
						if(upper[p]){
							removes[p] = true;
						}
					}					
					for(var p in removes){
						delete(line[p]);
					}
				}
				if(line && !SCOM.isEmptyObj(line)){					
					index++;
					for(var p in line){
						line[p].level = index;
					}					
				}
			}						
			this.layoutColumnGroups(newGroups);					
			/*
			 * means need refresh
			 */
			needRefresh = true;
		}
		return needRefresh;
	},
		
	/*
	 * when row is inserted, maybe need change the size of different regions
	 */
	onInsertRow : function(sheetId, row, rowSpan){
		var needRefresh;
		if(sheetId == this.getSheetId()){
			if(this.isFreezed()){
				var maxrow = row+rowSpan-1;
				if(maxrow <= this.freezePos.row){
					var row = this.freezePos.row+rowSpan;				
					this.freeze(row, this.freezePos.col, true);
					needRefresh = false;
				}
			}
		}
		/*
		 * prepare insert row, need sync column groups
		 */
		if(this.rowGroups){
			var oldMaxLevel = this.rowGroupMaxLevel;
			var groups = this.rowGroups, maps = this.rowGroupNameMap;
			var newGroups = [];
			var levels = {};
			for(var name in maps){
				var group = maps[name], span = group.span;
				if(row <= span[1]){
					if(row < span[0]){
						span[0] += rowSpan;
						span[1] += rowSpan;
					}else{
						span[1] += rowSpan;
					}							
				}	
				var level = group.level;
				levels[level] = levels[level] || {};						
				levels[level][span[1]] = group;		
				newGroups.push(group);
			}
			var index = 0;			
			for(var i = 1; i <= oldMaxLevel; i++){
				var line = levels[i];
				if(i < oldMaxLevel){
					var upper = levels[i+1], removes = {};
					for(var p in line){
						if(upper[p]){
							removes[p] = true;
						}
					}					
					for(var p in removes){
						delete(line[p]);
					}
				}
				if(line && !SCOM.isEmptyObj(line)){					
					index++;
					for(var p in line){
						line[p].level = index;
					}					
				}
			}						
			this.layoutRowGroups(newGroups);					
			/*
			 * means need refresh
			 */
			needRefresh = true;
		}
		return needRefresh;
	},
	
	/*
	 * when column is inserted, maybe need change the size of different regions
	 */
	onInsertColumn : function(sheetId, col, colSpan){	
		var needRefresh;
		if(sheetId == this.getSheetId()){
			if(this.isFreezed()){
				var maxcol = col+colSpan-1;
				if(maxcol <= this.freezePos.col){				
					var col = this.freezePos.col+colSpan;				
					this.freeze(this.freezePos.row, col, true);
					needRefresh = false;
				}
			}
		}
		/*
		 * prepare insert column, need sync column groups
		 */
		if(this.colGroups){
			var oldMaxLevel = this.colGroupMaxLevel;
			var groups = this.colGroups, maps = this.colGroupNameMap;
			var newGroups = [];
			var levels = {};
			for(var name in maps){
				var group = maps[name], span = group.span;
				if(col <= span[1]){
					if(col < span[0]){
						span[0] += colSpan;
						span[1] += colSpan;
					}else{
						span[1] += colSpan;
					}							
				}	
				var level = group.level;
				levels[level] = levels[level] || {};						
				levels[level][span[1]] = group;			
				newGroups.push(group);
			}
			var index = 0;			
			for(var i = 1; i <= oldMaxLevel; i++){
				var line = levels[i];
				if(i < oldMaxLevel){
					var upper = levels[i+1], removes = {};
					for(var p in line){
						if(upper[p]){
							removes[p] = true;
						}
					}					
					for(var p in removes){
						delete(line[p]);
					}
				}
				if(line && !SCOM.isEmptyObj(line)){					
					index++;
					for(var p in line){
						line[p].level = index;
					}					
				}
			}						

			this.layoutColumnGroups(newGroups);					
			/*
			 * means need refresh
			 */
			needRefresh = true;
		}
		return needRefresh;
	},
	
	/*
	 * scroll the sheet to a position
	 */
	go2Pos : function(row, col){
		row = row || 1;
		col = col || 1;
		var splited = this.isSplited();
		var lvisible = this.lheader.isVisible(), uvisible = this.ulefter.isVisible(); 
		if(splited){								
			if(lvisible && !this.lheader.isInRange(0, col)){
				this.lheader.recalculateRange(null, {
					colStart: col < this.lheader.colBound.low ? this.lheader.colBound.low : col,			
					width: this.lheader.getWidth()
				});
				this.lheader.sysn();
			}
			if(uvisible && !this.ulefter.isInRange(row, 0)){
				this.ulefter.recalculateRange({			
					rowStart: row < this.ulefter.rowBound.low ? this.ulefter.rowBound.low : row,			
					height: this.ulefter.getHeight()
				});
				this.ulefter.sysn();
			}	
			if(this.ltregion.isVisible() && !this.ltregion.isInRange(row, col)){
				this.ltregion.recalculateRange({			
					rowStart: this.ulefter.rowStart,			
					rowEnd: this.ulefter.rowEnd
				}, {
					colStart: this.lheader.colStart,			
					colEnd: this.lheader.colEnd
				});
				this.ltregion.sysn();
			}
		}				
		
		if(!this.cregion.isInRange(row, col)){
			var height = this.cregion.getHeight();
			this.cregion.recalculateRange({			
				rowStart: row < this.cregion.rowBound.low ? this.cregion.rowBound.low : row,			
				height: height
			}, {
				colStart: col < this.cregion.colBound.low ? this.cregion.colBound.low : col,			
				width: this.cregion.getWidth()
			});
			this.cregion.sysn();
			this.slefter.recalculateRange({			
				rowStart: this.cregion.rowStart,			
				rowEnd: this.cregion.rowEnd,
				height: height
			});
			this.slefter.sysn();
			this.sheader.recalculateRange(null, {			
				colStart: this.cregion.colStart,			
				colEnd: this.cregion.colEnd
			});
			this.sheader.sysn();
			
			if(this.lregion.isVisible()){
				this.lregion.recalculateRange({			
					rowStart: this.cregion.rowStart,			
					rowEnd: this.cregion.rowEnd,
					height: this.lregion.getHeight()
				}, splited && lvisible ? {
					colStart: this.lheader.colStart,
					colEnd: this.lheader.colEnd
				} : null);
				this.lregion.sysn();
			}		
			if(this.tregion.isVisible()){
				this.tregion.recalculateRange(splited && uvisible ? {
					rowStart: this.ulefter.rowStart,
					rowEnd: this.ulefter.rowEnd
				} : null, {			
					colStart: this.cregion.colStart,			
					colEnd: this.cregion.colEnd,
					width: this.tregion.getWidth()
				});
				this.tregion.sysn();
			}
		}						
        var sm = this.getSelectionModel();
        sm.selectRange({row: row, col: col}, {row: row, col: col});
        sm.setFocusCell(row, col);
		
		this.checkLefterWidth();
	},
	
	/*
	 * set all regions in current sheet to the left-top position
	 */
	go2LeftTop : function(){
		this.go2Pos();
	},
		
	/*
	 * navigate the selection mode based on the event
	 */
	navigateSelection : function(e, region){
		var key = e.getKey(), shift = e.shiftKey, ctrl = e.ctrlKey;		
		var sm = region.getSelectionModel(), pos;
		if(e.TAB == key || e.RIGHT == key){						
			pos = sm.selectNext('col', shift);
		}else if(e.ENTER == key || e.DOWN == key){			
			pos = sm.selectNext('row', shift);			
		}else if(e.UP == key){			
			pos = sm.selectPrevious('row', shift);
		}else if(e.LEFT == key){			
			pos = sm.selectPrevious('col', shift);
		}		
		if(ctrl){
			if(65 == key){//ctrl+a
				e.preventDefault();
				var sm = this.getSelectionModel();
				sm.selectRange({row: 0, col: 0}, {row: 0, col: 0});
			}
		}		
		return pos;
	},
	
	/*
	 * when editor keydown - handle key event
	 */
	onEditorKeyDown : function(e, row, col, region, editor){
		if(!region){
			region = this.cregion;
			var sm = this.getSelectionModel();
			var focusCell = sm.getFocusCell();
			if(focusCell){
				row = focusCell.row;
				col = focusCell.col;
			}else{
				return false;
			}
		}
        /*
         * fire keydown event
         */
        if(false === this.fireEvent('preparekeydown', e, row, col, region, editor, this)){
           return false;
        }
		if(editor && !editor.isAvailable()){
           /*
            * fire keydown event
            */
           if(false === this.fireEvent('keydown', e, row, col, region, editor, this)){
                return false;
           }
			var key = e.getKey();
			region = region || this.getCurrentRegion();
			
			// some special key need ignore for edit, add in here ...36 - home key
			if(e.TAB == key || e.RIGHT == key || e.ENTER == key || e.DOWN == key 
					|| e.LEFT == key || e.UP == key || (e.ctrlKey && 65 == key) || key == 36
					|| key == 34 || key == 33){
				e.preventDefault();
				if(!this._navigating){
					this._navigating = true;
					var pos = this.navigateSelection(e, region);
					/*
					 * make sure the cell scroll to the view
					 */
					if(pos){			
						region.scrollCell2View(pos.row, pos.col);
						/*
						 * focus the region to get input focus
						 */		
						this.focus(this.focusDelayTime);
					}
					Ext.Function.defer(function(){
						delete(this._navigating);
					}, this.keyDownThrottled, this);						
				}			
				return false;
			}else if(e.ESC == key){
				this.hideCurrentOptionFloors();
				return false;
			}
		}			
	},				
	
	/*
	 * when drag scrolling limited in left-top/left/top, it will scroll the center region
	 */
	onDragScrollingLimited : function(dir, flag, pos, sm, region){		
		if('high' == flag){
			if(region == this.ltregion){
				this.cregion.go2LeftTop();			
			}else if(region == this.tregion){
				this.cregion.go2Top();
			}else if(region == this.lregion){
				this.cregion.go2Left();
			}
		}
	},
	
	/*
	 * for before hide/show row/columns in range, we only care about the left/top/left-top region in freeze mode
	 */
	beforeHideRow : function(minrow, maxrow, region){
		if(this.ulefter == region || this.ltregion == region){			
			return false;
		}else if(this.tregion == region){			
			this.refreshRange();
			return false;
		}
	},
	
	beforeHideColumn : function(mincol, maxcol, region){
		if(this.lheader == region || this.ltregion == region){		
			return false;
		}else if(this.lregion == region){			
			this.refreshRange();
			return false;
		}
	},
	
	beforeShowRow : function(minrow, maxrow, region){
		if(this.ulefter == region || this.ltregion == region){
			return false;
		}else if(this.tregion == region){
			this.refreshRange();
			return false;
		}
	},
	
	beforeShowColumn : function(mincol, maxcol, region){
		if(this.lheader == region || this.ltregion == region){
			return false;
		}else if(this.lregion == region){
			this.refreshRange();
			return false;
		}
	},
	
	/*
	 * get the cell data of the focus cell
	 */
	getFocusCellData : function(){		
		var sheetId = this.getSheetId();
		var sm = this.getSelectionModel();
		var store = this.getStore();
		/*
		 * get the current indent value of the focus cell
		 */
		var focusCell = sm.getFocusCell();
		if(focusCell){
			var row = focusCell.row, col = focusCell.col;						
			var data = store.getCellData(sheetId, row, col);
			return data;
		}
		/*
		 * if no focus, then return a default property which defined in store
		 */
		return Ext.apply({}, store.defaultProperty);
	},	
		
	/*
	 * @param {object} cell: the cell data object
	 * @param {int} sheetId: the sheet id
	 * @param {int} row: the row index of a cell
	 * @param {int} col: the column index of a cell
	 * @return {boolean}:true means it's a calculate cell, or false
	 * return true if this is a calculate cell
	 */
	isCalculateCell : function(cell, sheetId, row, col){
		if(this.calculate){
			if(!cell){
				cell = this.getStore().getCell(sheetId, row, col);
			}			
			return false !== SCOM.typeOf(cell.cal);
		}
		return false;
	},		
	
	/**
	 * reset the calculate cell's data property, convert arg property to data.
	 * This is because sometimes when copy/paste, the data is changing, such as =sum(F1:F2), should be change to =sum(D3:D4)
	 * the arg property hold the relative coord array, so we can transfer it back to string
	 * 
	 * @param {object} obj: obj contains the calculate string, such as "=sum(A1:B2)"
	 * @param {int} sheetId: the sheet id of the cell
	 * @param {int} row: the row index of the cell
	 * @param {int} col: the col index of the cell
	 * @param {int} oldSheetId: the old sheet id of the cell
	 * @param {int} oldRow: the old row index of the cell
	 * @param {int} oldCol: the old col index of the cell
	 * @param {boolean} force2Reset: true to reset the calculate no matter whether the old position is the same as the current
	 * @return {string}: the transfered data string, such as "=sum(F1:F3)"
	 */
	resetCalculateCellData : function(obj, sheetId, row, col, oldSheetId, oldRow, oldCol, force2Reset, reverse, changedTabName){
		if(!Ext.isDefined(oldSheetId)){
			oldSheetId = sheetId;
		}
		if(SCOM.nullOrUndefined(oldRow)){
			oldRow = row;
		}
		if(SCOM.nullOrUndefined(oldCol)){
			oldCol = col;
		}
		if(this.calculate){
			if(force2Reset || !(oldRow === row && oldCol === col) || reverse){
				var o = this.calculate.resetData(obj, this.getStore(), sheetId, row, col, oldSheetId, oldRow, oldCol, reverse, changedTabName);
				return o;
			}			
		}		
		return obj;
	},
	
	/**
	 * reset the condition cell's cdt property
	 * 
	 * @param {object} obj: obj contains the cdt string
	 * @param {int} sheetId: the sheet id of the cell
	 * @param {int} row: the row index of the cell
	 * @param {int} col: the col index of the cell
	 * @param {int} oldSheetId: the old sheet id of the cell
	 * @param {int} oldRow: the old row index of the cell
	 * @param {int} oldCol: the old col index of the cell
	 * @return {string}: the transfered cdt string
	 */
	resetConditionCellData : function(obj, sheetId, row, col, oldSheetId, oldRow, oldCol){
		if(!Ext.isDefined(oldSheetId)){
			oldSheetId = sheetId;
		}
		if(!Ext.isDefined(oldRow)){
			oldRow = row;
		}
		if(!Ext.isDefined(oldCol)){
			oldCol = col;
		}
		if(this.condition){
			return this.condition.resetConditionData(obj, this.getStore(), sheetId, row, col, oldSheetId, oldRow, oldCol);						
		}		
	},
			
	/**
	 * _private
	 * process the calculate if need
	 * @param {object} the cell data object
	 * @param {object} the scope which will be use in the calculating
	 * @param {string} the timestamp, which use to check the value is the newest or not 
	 * @return {object}:if calculate is successful, then the cell.data will be the result of calculate
	 * @param {boolean} skipUpdateValue: true to not update value in calculate
	 */
	processCalculate : function(cell, scope, skipUpdateValue){
		var store = this.getStore();		
		try{											
			if(this.calculate && this.isCalculateCell(cell)){
				//alert(Ext.encode(cell)+'\n'+scope.timestamp)
				if(store.isLoadingCells() || false != SCOM.typeOf(cell.value)){
					/*
					 * if the timestamp fit, then means the value is valid, we don't need calculate again, just apply the old result
					 */									
					cell.data = cell.value;					
				}else{					
					/*
					 * for merged cell, we need redirect the pos
					 */
					if(store.isMergedCell(cell, scope.sheet, scope.row, scope.col)){
						scope.row += cell.minrow;
						scope.col += cell.mincol;
					}											
					cell = this.calculate.processCalculate(cell, scope, skipUpdateValue);					
				}		
				/*
				 * if the data is an exception then show a red tip at left top corner of the cell
				 */
				var data = cell.data;
                if(Ext.isNumber(data)){
                    var digitalLen = HELPER.getDigitalLen(data);
                    if (digitalLen > 13){
                        data = HELPER.roundUpNonZero(data);
                    }
                    cell.data = data;
                }
           
				if(Ext.isObject(data) && data._isExp){
					var exp = this.processCalculateException(data, scope);
					delete(exp.expTip);
					Ext.apply(cell, exp);
					
				}else if(Ext.isString(cell.data)){
					cell.data = Ext.htmlEncode(cell.data);
				}
				/*
				 * set the fm to regular if it's undefined, force the SFORMAT to decide the format
				 */
				if(!cell.fm){
					cell.fm = 'regular';
				}
			}else{
				cell.data = Ext.htmlEncode(cell.data);
			}				
            if(Ext.isString(cell.data)){
                cell.data = cell.data.replace(/\n/gi, '<br/>');
            }
			return cell;
		}catch(e){		
			/*
			 * if the data is an exception then show a red tip at left top corner of the cell
			 */
			if(Ext.isObject(e) && e._isExp){
				var exp = this.processCalculateException(e, scope);
				delete(exp.expTip);
				Ext.apply(cell, exp);
				
			}else{
				cell.data = e;
			}
			
			return cell;
		}
	},
	
	/*
	 * @param {object} cell: the cell data object
	 * @param {int} sheetId: the sheet id
	 * @param {int} row: the row index of a cell
	 * @param {int} col: the column index of a cell
	 * @return {boolean}:true means it's a condition cell, or false 
	 */
	isConditionCell : function(cell, sheetId, row, col){		
		if(this.condition){			
			return cell.cdtVal || cell.dcfg || this.getStore().isConditionCell(sheetId, row, col);			
		}
		return false;
	},
	
	isFitlerCell : function(cell, sheetId, row, col){		
		if(this.condition){
			if(!cell){
				cell = this.getStore().getCell(sheetId, row, col);
			}		
			/*
			 * some times cdt could be ''
			 */
			return cell.filter ? true : false;			
		}
		return false;
	},
	
	/*
	 * @param {int} sheetId: the sheet id
	 * @param {int} row: the row index of a cell
	 * @param {int} col: the column index of a cell
	 * @return {boolean}:true means it's a mini chart cell, or false 
	 */
	isMiniChartCell : function(sheetId, row, col){		
		if(this.condition){
			var store = this.getStore();
			var cdt = this.getConditionOfCell(sheetId, row, col);		
			/*
			 * some times cdt could be ''
			 */
			if(0 < cdt.length){				
				for(var i = 0, len = cdt.length; i < len; i++){
					var it = cdt[i];					
					if('minichart' == it.name){
						return true;
					}
				}
			}
		}
		return false;
	},
	
	getMiniChartRange : function(sheetId, row, col){
		if(this.condition){
					
			return this.condition.getMiniChartRangeByCell(sheetId, row, col);
		}
	},
	
	/*
	 * @param {object} cell: the cell data object
	 * @param {int} sheetId: the sheet id
	 * @param {int} row: the row index of a cell
	 * @param {int} col: the column index of a cell
	 * @return {boolean}:true means it's a tableTpl cell, or false	 
	 */
	isTableTplCell : function(cell, sheetId, row, col){
		if(this.tableTpl){
			if(!cell){
				cell = this.getStore().getCellData(sheetId, row, col);
			}
			return cell.tpl ? true : false;
		}					
		return false;
	},
           
    isTableTplHeader : function(cell, sheetId, row, col){
        if(this.tableTpl){
            if(!cell){
                cell = this.getStore().getCellData(sheetId, row, col);
            }
            return this.tableTpl.isTableHeader(cell, sheetId, row, col);
        }
        return false;
    },
	
	getTableTpl : function(){
		return this.tableTpl;
	},
	
	/*
	 * _private
	 * apply the condition style directly
	 */
	applyCondition : function(cell){
		var styles = EnterpriseSheet.sheet.calculate.Condition.styleMap;
        for(var p in styles){
            if(styles.hasOwnProperty(p)){
                var q = styles[p];
                if(Ext.isDefined(cell[p])){
                    cell[q] = cell[p];
                }
            }
        }				
		
		return cell;
	},
	
	/**
	 * _private
	 * process the condition if need
	 * @param {object} the cell data object
	 * @param {object} the scope which will be use in calculating the condition	 
	 * @return {object}:if calculating condition is successful, 
	 * then the cell will be applied to the condition, or it will show the exception
	 * @param {boolean} skipUpdateValue: true to not update value in calculate
	 */
	processCondition : function(cell, scope, skipUpdateValue){
		
		var store = this.getStore();		
		try{											
			if(this.isConditionCell(cell, scope.sheet, scope.row, scope.col)){
				if(store.isLoadingCells() || true === cell.cdtVal){
					/*
					 * if timestamp is not defined, then just apply the last result of condition
					 */
					cell = this.applyCondition(cell);
					
				}else{
					/*
					 * for merged cell, we need redirect the pos
					 */
					if(store.isMergedCell(cell, scope.sheet, scope.row, scope.col)){
						scope.row += cell.minrow;
						scope.col += cell.mincol;
					}					
					
					cell = this.condition.processCondition(cell, scope, skipUpdateValue);
					cell = this.applyCondition(cell);
				}							
			}	
			if(!SCOM.nullOrUndefined(cell.allow)){
				cell.data = cell.allow;
			}
			
			return cell;
		}catch(e){
			cell.data = e;
			return cell;
		}
	},
	
	/*
	 * _private
	 * process the table tpl if need
	 * @param {object} the cell data object	
	 * @param {object} the scope which will be use in apply table tpl	 
	 * @return {object}:if process successful, 
	 * then the cell will be applied to the table tpl, or it will show the exception
	 */
	processTableTpl : function(cell, scope){		
		try{											
			if(this.isTableTplCell(cell)){													
				cell = this.tableTpl.processTpl(cell, scope);					
			}				
			return cell;
		}catch(e){
			cell.data = e;
			return cell;
		}
	},
	
	/*
	 * get cell data and process the calculate and condition
	 */
	getCellData : function(sheetId, row, col){
		return this.processData(sheetId, row, col);
	},
	
	getCellProperty : function(sheetId, row, col){
		if(false == SCOM.typeOf(sheetId)){
			sheetId = this.getSheetId();
		}		
		var store = this.getStore();
		var cell = store.getCellData(sheetId, row, col);
		/*
		 * process the calculate if need, pass the timestamp to check the valid
		 */		
		var scope = {
			store:store,
			sheet:sheetId,
			row:row,
			col:col,
            timestamp: cell.timestamp
		};
		cell = this.processCellDataConfig(cell, scope);
		
		return cell;
	},
	
	/*
	 * get the value of the passed cell, not need process the format
	 */
	getCellValue : function(sheetId, row, col, timestamp, withFormat){
		if(false == SCOM.typeOf(sheetId)){
			sheetId = this.getSheetId();
		}		
		var store = this.getStore();
		var cell = store.getCellData(sheetId, row, col);
		/*
		 * process the calculate if need, pass the timestamp to check the valid
		 */		
		var scope = {
			store:store,
			sheet:sheetId,
			row:row,
			col:col,
            timestamp: cell.timestamp
		};
		cell = this.processCellDataConfig(cell, scope);
		cell = this.processCalculate(cell, scope);				
		
		if(withFormat && 0 !== row && 0 !== col){
			cell = SFORMAT.transferFormat(cell, cell.fm);
		}
		return cell;
	},
	
	/**
	 * find the prev non empty cell in col
	 */
	findPrevNonEmptyColIndex : function(sheetId, row, col, region){
		var store = this.getStore();
		var startCol = region.colStart-region.colEnd+col;
		if(1 > startCol){
			startCol = 1;
		}
		for(var i = col-1; i >= startCol; i--){
			var cell = store.getCell(sheetId, row, i);
			if(this.isContentCell(cell)){
				return i;
			}
		}
	},
	
	/**
	 * find the next non empty cell in col
	 */
	findNextNonEmptyColIndex : function(sheetId, row, col, region){
		var store = this.getStore();
		var endCol = col-region.colStart+region.colEnd;
		for(var i = col+1; i <= endCol; i++){
			var cell = store.getCell(sheetId, row, i);
			if(this.isContentCell(cell)){
				return i;
			}
		}
	},
	
	/**
	 * process calculate and condition
	 * @param {int} sheetId: the sheet id
	 * @param {int} row: the row index
	 * @param {int} col: the col index
	 * @param {object} cell: the cell object, if this one is not empty then we don't get the cell object again from store
	 * @param {boolean} skipUpdateValue: true to not update value in calculate
	 * @param {boolean} region: the region call the process data
	 */
	processCalCdtData : function(sheetId, row, col, cell, skipUpdateValue, region){
		
		if(false == SCOM.typeOf(sheetId)){
			sheetId = this.getSheetId();
		}		
		var store = this.getStore();
		if(!cell){
			cell = store.getCellData(sheetId, row, col);			
		}
		/*
		 * process the calculate if need, pass the timestamp to check the valid
		 */		
		var scope = {
			store:store,
			sheet:sheetId,
			row:row,
			col:col,
            timestamp: cell.timestamp
		};
		cell = this.processCalculate(cell, scope, skipUpdateValue);
		/*
		 * process the condition if need		 
		 */
		cell = this.processCondition(cell, scope, skipUpdateValue);

        
		return cell;
	},
	
	/**
	 * a listener of 'processdata' event from body regions
	 * process data, the data after process will be display on the region
	 * process calculate, format and condition if need
	 * @param {int} sheetId: the sheet id
	 * @param {int} row: the row index
	 * @param {int} col: the col index
	 * @param {object} cell: the cell object, if this one is not empty then we don't get the cell object again from store
	 * @param {string} timestamp: the timestamp for calcualte and condition	 
	 * @param {boolean} skipUpdateValue: true to not update value in calculate
	 * @param {boolean} region: the region call the process data
	 */
	processData : function(sheetId, row, col, cell, timestamp, skipUpdateValue, region){
		
		if(false == SCOM.typeOf(sheetId)){
			sheetId = this.getSheetId();
		}		
		var store = this.getStore();
		if(!cell){
			cell = store.getCellData(sheetId, row, col);			
		}		
        
		/*
		 * process the calculate if need, pass the timestamp to check the valid
		 */		
		var scope = {
			store:store,
			sheet:sheetId,
			row:row,
			col:col,
            timestamp: cell.timestamp
		};
		
		cell = this.processCellDataConfig(cell, scope);
        
		cell = this.processCalculate(cell, scope, skipUpdateValue);			
        		
		/*
		 * process the item/trigger/comment if need		 
		 */
		var pos = [sheetId, row, col];
		
		/*
		 * process the condition if need		 
		 */
		cell = this.processCondition(cell, scope, skipUpdateValue);
		
		cell = this.processCellDataRender(cell, scope);
		
		if(region && 0 !== row && 0 !== col){
			cell.zd = col;
			if('normal' !== cell.ws && this.isContentCell(cell)){
				var next = this.findNextNonEmptyColIndex(sheetId, row, col, region) || SCONST['MAX_COL_Z_INDEX'];
				cell.zd = next;
			}
		}
        /*
         * for array formula processing
         */
        cell = this.calculate.processArrayFormulaResult(cell, row, col);
           
		/*
		 * process the text format for the cell,
		 * it will based on the fm property of the cell
		 */
        if(0 !== row && 0 !== col){
            cell = SFORMAT.transferFormat(cell, cell.fm);
        }
           
        cell = this.processComment(cell, pos);
	
		cell = this.processVariable(cell, pos);
		
		cell = this.processItemTrigger(cell);
		
        if(cell.showIconOnly){
           cell.data = '';
        } else if (cell.rotation) {
            cell = this.processVerticalText(cell);
        }
                        
		return cell;
	},
           
    /**
     * process vertical text
     */
    processVerticalText : function(cell){
    	if (cell.rotation == 90) {
    		cell.data = '<div class="ss-cell-vertical_90">'+cell.data+'</div>';
    	} else {
    		cell.data = '<div class="ss-cell-vertical_270">'+cell.data+'</div>';
    		if (cell.va == 'top') cell.va = 'bottom'; // this is for default ...
    	}
        
        return cell;
    },
           
    /**
     * add a plain property for the tpl cell if need
     */
    processPlainForTplCell : function(sheetId, row, col){
        if(0 !== row && 0 !== col){
            var store = this.getStore();
            var cell = this.getCellValue(sheetId, row, col);
            store.setCell(sheetId, row, col, {'plain': cell.data}, undefined, true);
        }
    },
	
	isContentCell : function(cell){
		if(cell.it || cell.trigger || (!SCOM.nullOrUndefined(cell.data) && '' !== cell.data) || cell.itms){
			return true;
		}
		return false;
	},
	
	/**
	 * process comment when render the cell
	 * @param {object} cell: the cell object
	 * @param {object} cellPos: the coord info of the cell, such as sheetId, row and col, can be null
	 */
	processComment : function(cell, cellPos){
		/*
		 * process comment format specially
		 */
    	if(cell.comment){	    			    			
    		
    		var info = '';
    		if(cellPos){
    			info = 'sheet="'+cellPos[0]+'" row="'+cellPos[1]+'" col="'+cellPos[2]+'"';
    		}
    		var comment = '<div class="ss-comment-sign ss-cell-inside" '+info+' style="z-index:'+SCONST['TOP_Z_INDEX']+';"></div>';	    		
			cell.rtcorner = comment;
			
		}
    	return cell;
	},
	
	/**
	 * process variable when render the cell
	 * @param {object} cell: the cell object
	 * @param {object} cellPos: the coord info of the cell, such as sheetId, row and col, can be null
	 */
	processVariable : function(cell, cellPos){
		/*
		 * process comment format specially
		 */			
    	if(cell.vname && 'hide' !== cell.vnameEdit){
    		var info = '';
    		if(cellPos){
    			info = 'sheet="'+cellPos[0]+'" row="'+cellPos[1]+'" col="'+cellPos[2]+'"';
    		}
    		var varSign = '<div class="ss-var-sign ss-cell-inside" '+info+' style="z-index:'+SCONST['TOP_Z_INDEX']+';"></div>';	    		
			cell.rbcorner = varSign;
			
		}
    	return cell;
	},
	
	/*
	 * create trigger and item based on trigger property
	 */
	processItemTrigger : function(cell){
		var topZIndex = SCONST['INCELL_ITEM_Z_INDEX'];
		//topZIndex = 0;
		var data = cell['data'];
		if(SCOM.nullOrUndefined(data)){
			data = '';
			cell['data'] = data;
		}
        var z = -1;
		if(cell.body && (cell.it || cell.trigger || cell.seq || cell.drop || cell.ltcorner || cell.rtcorner || cell.lbcorner || cell.rbcorner)){				
			
			if(cell.it) {
				if (cell.it == "button") {
					cell['data'] = '<button style="' + cell.btnStyle + '" type="button">' + cell['data'] + '</button>';
				} else {
				    cell['data'] = '<input style="margin:0 2px;z-index:'+topZIndex+';" type="'+cell.it+'" '+(cell.itchk ? 'checked':'')+' />'+cell['data'];                 
				}
				data = cell['data']; 
			}
            var va = cell.va;
			if(cell.trigger){
                var style = 'top:0;margin-top:0px;';
                if('middle' === va){
                    style = 'top:50%;margin-top:-8px;';
                }else if('bottom' === va){
                    style = 'top:100%;margin-top:-18px;';
                }
				cell['posTrigger'] = '<div style="z-index:'+topZIndex+';'+style+'" class="ss-trigger '+cell.trigger+'"></div>';
				cell['data'] = data+'<span style="padding-left:20px;font-size:0px;">&nbsp;</span>';										
			}else if(cell.drop){
                var style = 'top:1px;margin-top:0px;';
                if('middle' === va){
                    style = 'top:50%;margin-top:-8px;';
                }else if('bottom' === va){
                    style = 'top:100%;margin-top:-18px;';
                }
                var cls = 'date' === cell.drop ? 'ss-date-picker' : 'ss-drop-list';
				cell['posTrigger'] = '<div style="z-index:'+topZIndex+';'+style+'" class="ss-trigger '+cls+'"></div>';
				cell['data'] = data+'<span style="padding-left:20px;font-size:0px;">&nbsp;</span>';
			}
			if(cell.seq){
                cell['preItem'] = cell['preItem'] || '';
				cell['preItem'] += '<div style="z-index:'+topZIndex+';" class="ss-cell-seq">'+cell.seq+'</div>';
			}
			z = 0;
			//cell = SFORMAT.floatCellData(cell);
		}		
		/*
         * process incell image
         */
        if(cell.icp){
        	if (cell.imgStyle) 
        		cell.icp = '<img style="' + cell.imgStyle + 'z-index:'+z+';" src="'+cell.icp+'">';
        	else 
        	    cell.icp = '<img style="position:absolute;left:0px;top:0px;width:100%;height:100%;z-index:'+z+';" src="'+cell.icp+'">';
        }
		return cell;
	},
	
	/*
	 * set the celldata to store, and refresh the cell element
	 * @param {int} sheetId : the sheet id
	 * @param {int} row : the row index
	 * @param {int} col : the column index
	 * @param {object} modified : the cell data object to update the store	 
	 * @param {array} deleted : the array contains all property to delete
	 * @param {boolean} suspendRefresh : true to not refresh the element	 
	 */
	setCellData : function(sheetId, row, col, modified, deleted, suspendRefresh){
		
		if(suspendRefresh){
			this.setCell(sheetId, row, col, modified, deleted, suspendRefresh);
		}else{
			if(false !== this.fireEvent('beforesetcell', sheetId, row, col, modified, deleted, suspendRefresh, this)){				
				this.setCell(sheetId, row, col, modified, deleted, suspendRefresh);
			}
		}		
	},
	
	/*
	 * set the celldata to store, and refresh the cell element
	 * @param {int} sheetId : the sheet id
	 * @param {int} row : the row index
	 * @param {int} col : the column index
	 * @param {object} modified : the cell data object to update the store	 
	 * @param {array} deleted : the array contains all property to delete
	 * @param {boolean} suspendRefresh : true to not refresh the element	 
	 */
	setCell : function(sheetId, row, col, modified, deleted, suspendRefresh){			
		var separateChar = EnterpriseSheet.sheet.data.reader.CellReader.prototype.separateChar;
		var store = this.getStore();		
		var cell = store.getCell(sheetId, row, col, true);		
		if(false == SCOM.typeOf(sheetId)){
			sheetId = this.getSheetId();			
		}
		var isSameSheet = sheetId === this.getSheetId();
		/*
		 * here we need process the data if it's a calculate
		 */
		deleted = deleted || [];
        deleted = deleted.concat(EnterpriseSheet.sheet.calculate.Condition.stylesWithoutMini);
        
		if(this.calculate && modified){
			modified = this.calculate.transferCalculate(modified, store, sheetId, row, col);
           
			if(!this.isCalculateCell(modified)){
				/*
				 * if not a calculate, then we need remove the cal field in the cell
				 */
				
				deleted = deleted.concat(EnterpriseSheet.sheet.calculate.Calculate.prototype.calculateRelatedProperty);
			}		
		}		
		if(store.isMergedCell(cell, sheetId, row, col)){
			var minrow = row+cell.minrow;
			var mincol = col+cell.mincol;			
			/*
			 * upate the left top cell, and suspend the event
			 */			
			store.setCell(sheetId, minrow, mincol, modified, deleted, suspendRefresh || !isSameSheet);
            if(this.isTableTplHeader(undefined, sheetId, minrow, mincol)){
                this.processPlainForTplCell(sheetId, minrow, mincol);
            }
		}else{
			var cdtChanged = false;
			var cellPro = store.getCellProperty(sheetId, row, col);
			if(deleted){
				for(var i = 0, len = deleted.length; i < len; i++){
					delete(cellPro[deleted[i]]);
				}
			}
			cellPro = Ext.apply(cellPro, modified);
			
			var reCalCells;
			if(modified && modified['data']){
				var num = Number(modified['data']);
				if(Ext.isNumber(num)){
					/*
					 * auto extend condition range
					 */
					var extendCdt = this.autoExtendCondtion(sheetId, row, col);
					if(extendCdt){
						var changedCdt = extendCdt;
						/*
						 * get recalculated cells
						 */
						reCalCells = this.getRecalculateCellsByCoord([[sheetId, row, col, row, col]]);
						
						/*
						 * fire prepare data change event
						 */
						this.fireEvent('prepareautoextendcdt', sheetId, row, col, changedCdt, this, reCalCells);
						/*
						 * set condition floating item
						 */
						for(var p in changedCdt){
							if(changedCdt.hasOwnProperty(p)){
								var it = changedCdt[p];
								store.setFloatingItem(sheetId, it.id, 'cdt', Ext.encode(it));
							}
						}						
						cdtChanged = true;
					}
				}
			}
			var suspendFlag = suspendRefresh;
			if(cdtChanged){
				/*
				 * update the cell
				 */								
				store.setCell(sheetId, row, col, modified, deleted, true);
				
				Ext.applyIf(reCalCells, this.getCalCdtCellsFromCoord([[sheetId, row, col, row, col]]));
				this.refreshCalCdt(reCalCells);
				/*
				 * fire event when auto extend the conditon
				 */
				this.fireEvent('autoextendcdt', sheetId, row, col, modified, deleted, this, reCalCells);
			}else{
				/*
				 * update the cell
				 */								
				store.setCell(sheetId, row, col, modified, deleted, suspendFlag);
			}
            if(this.isTableTplHeader(undefined, sheetId, row, col)){
                this.processPlainForTplCell(sheetId, row, col);
            }
            if(!suspendFlag){
            	this.checkRowHeight(sheetId, row);
            }
		}
	},	
	
	checkRowHeight : function(sheetId, row){
		var store = this.store;
		var rowPro = store.getCellProperty(sheetId, row, 0);
		if(!SCOM.canbeNumber(rowPro.height)){
			var h = this.cregion.guessMaxRowHeight(sheetId, row);
			
			var isNum = Ext.isNumber(h);
			if(isNum){
				h = store.correctRenderHeight(h);
			}
			
			var ah = rowPro.autoHeight;
			if(!SCOM.canbeNumber(ah)){
				ah = store.defaultProperty.height;
			}
			
			if(h != ah){
				if(isNum){
					store.setRow(sheetId, row, {'autoHeight': h}, null, true, false, null, true);
				}else{
					store.setRow(sheetId, row, null, ['autoHeight'], true, false, null, true);
				}
			}
		}
	},	
	
	/**
	 * auto extend conditon
	 */
	autoExtendCondtion : function(sheetId, row, col){
		var store = this.getStore();
		var changedCdt = {};
		if(1 < row){
			var lastRow = row-1;
			
			var cdt = this.getConditionOfCell(sheetId, lastRow, col);
			if(0 < cdt.length){
				var changed = false;						
				for(var i = 0, len = cdt.length; i < len; i++){
					var condition = cdt[i];
							
					if(this.condition.isAutoExtendType(condition.name)){
						var rng = condition.rng;
						for(var j = 0, size = rng.length; j < size; j++){
							var it = rng[j];
							var span, stype;
							if(Ext.isArray(it)){
								span = it;
								stype = SCONST['ABSOLUTE_COORD'];
							}else{
								span = it.span;
								stype = it.type;
							}
							if(SCONST['RELATIVE_COORD'] == stype){							
								span[1] += lastRow;
								span[3] += lastRow;
								span[2] += col;
								span[4] += col;							
							}
							if(0 != span[3] && 0 != span[4]){
								if(span[3]+1 == row && span[2] == col && span[4] == col){
									span[3]++;
									changed = true;
									changedCdt[condition.id] = condition;									
								}							
							}
						}
					}					
				}
				if(changed){					
					return changedCdt;
				}
			}
		}
		if(1 < col){
			var lastCol = col-1;			
			var cdt = this.getConditionOfCell(sheetId, row, lastCol);
			if(0 < cdt.length){
				var changed = false;
                
				for(var i = 0, len = cdt.length; i < len; i++){
					var condition = cdt[i];					
					if(this.condition.isAutoExtendType(condition.name)){
						var rng = condition.rng;
						for(var j = 0, size = rng.length; j < size; j++){
							var it = rng[j];
							var span, stype;
							if(Ext.isArray(it)){
								span = it;
								stype = SCONST['ABSOLUTE_COORD'];
							}else{
								span = it.span;
								stype = it.type;
							}
							if(SCONST['RELATIVE_COORD'] == stype){							
								span[1] += row;
								span[3] += row;
								span[2] += lastCol;
								span[4] += lastCol;														
							}
							if(0 != span[3] && 0 != span[4]){
								if(span[4]+1 == col && span[1] == row && span[3] == row){
									span[4]++;
									changed = true;
									changedCdt[condition.id] = condition;									
								}							
							}
						}
					}					
				}
				if(changed){					
					return changedCdt;
				}
			}
		}
	},
	
	
	
	/**
	 * refresh all calculate and conditon cells	 
	 * @param {object} reCalCells: this object contains the cells need re-calculated
	 * @param {boolean} suspendRefresh: true to not refresh the UI
	 * @param {boolean} skipUpdateValue: true to not update value in calculate
     * @param {array} coord: a coord need refresh
     * @param {function} callback: the callback function
     * @param {object} scope: the scope of callback function
	 */
	refreshCalCdt : function(reCalCells, suspendRefresh, skipUpdateValue, coord, callback, scope){
        var me = this;
        var coordPro = EnterpriseSheet.sheet.calculate.Coordinate.prototype;
		if(Ext.isObject(reCalCells)){
            var ret = [];
			if(!SCOM.isEmptyObj(reCalCells)){
                this.clearValueForCalCells(reCalCells);
                ret = this.recalculateCalCdtCells(reCalCells, skipUpdateValue, function(ret){
                    if(Ext.isArray(coord)){
                        ret = ret.concat(coord);
                    }
                    /*
                     * get the cdt cells
                     */
                    var cdtCoord = me.processRelatedCdt(ret);
                    ret = ret.concat(cdtCoord);
                    if(!suspendRefresh){
                        me.refreshRange(ret);
                    }
                    if(callback){
                        callback.call(scope, ret);
                    }
                }, this);
            }else{
                if(callback){
                    callback.call(scope, ret);
                }
            }
           
            return ret;
        }else{
            /*
             * here we need refresh all calculate and condition in the actived sheet
             */
            var ret = this.reprocessCalCdtCellsInActiveSheet();
            if(!suspendRefresh){
                this.refreshRange(ret);
            }
            if(callback){
                callback.call(scope, ret);
            }
            return ret;
		}		
	},
	
        
	
	/*
	 * _private
	 * when data of cell is changed, we will check the current cells in this region,
	 * if there is calculate cells, may need refresh them to show the new value
	 */
	onDataChange : function(timestamp, sheet, row, col, modified, deleted, originJson, currentJson, store, suspendRefresh){
		
		var reCalCells = {};
	
		this.fireEvent('datachange', timestamp, sheet, row, col, modified, deleted, originJson, currentJson, store, suspendRefresh, reCalCells);
		var res = this.processDataChange(sheet, row, col, modified, deleted, originJson, currentJson, store, suspendRefresh, undefined, reCalCells);
		
		var region = this.getCurrentRegion();
		/*
		 * for refresh the prev cell to show the overflow letters in case
		 */
		var prev = this.findPrevNonEmptyColIndex(sheet, row, col, region);
		if(prev){	
			
			this.refreshRange([[sheet, row, prev, row, prev]]);
		}
		
		return res;
	},
	
	
    /**
     * return the direct related calculate cells of the passed cell
     */
    findDirectRecalculateCellsOfCell : function(sheet, row, col, excludeSelf){
        var store = this.getStore();
        var coordPro = EnterpriseSheet.sheet.calculate.Coordinate.prototype;
        
        var lookupId = [sheet, row, col];
        var cells = {};
        store.each(function(rec, internalId){
            var data = rec.data, json = data.json, refs = json.refs, id = internalId;
            if(json.cal && refs){
                if(coordPro.isCellInCoord(lookupId, refs)){
                    cells[id] = [data.sheet, data.row, data.col];
                }
            }
        }, this);
        Ext.apply(cells, this.findNameRefCellsByCoord([[sheet, row, col, row, col]]));
        return cells;
    },
           
    findDirectRecalculateCellsForCells : function(cells){
        var reCalCells = {};
        for(var p in cells){
            if(cells.hasOwnProperty(p)){
                var pos = cells[p];
                Ext.apply(reCalCells, this.findDirectRecalculateCellsOfCell(pos[0], pos[1], pos[2]));
            }
        }
        return reCalCells;
    },
           
    /**
     * find the related name reference by the coord
     */
    findNameRefCellsByCoord : function(coord){
    	var store = this.getStore();
    	var nameRefs = store.getRefConfigLookup();
    	var coordPro = EnterpriseSheet.sheet.calculate.Coordinate.prototype;
    	var changed = {}, names = {};
    	for(var p in nameRefs){
    		if(nameRefs.hasOwnProperty(p)){
    			var it = nameRefs[p];
                var refs = it.refs;
    			if(refs && coordPro.isOverlappedCoord(coord, refs)){
    				changed[p] = it;
                    names[p] = it;
    			}
    		}
    	}
    	/*
    	 * for named formula
    	 */
    	for(var p in nameRefs){
    		if(nameRefs.hasOwnProperty(p)){
    			var it = nameRefs[p];
    			if('named_func' === it.ctype){
    				for(var q in names){
    					if(names.hasOwnProperty(q)){
    						if(this.isCalIncludedName(it.json, q)){
    							changed[p] = it;
    						}
    					}
    				}
    			}
    		}
    	}
    	var obj = {};
    	store.each(function(rd, internalId){
    		var json = rd.data.json;
    		if(json.cal){
	    		for(var p in changed){
	    			if(changed.hasOwnProperty(p)){
	    				if(this.isCalIncludedName(json.data, p)){
	    					obj[internalId] = [rd.data.sheet, rd.data.row, rd.data.col];
	    					break;
	            		}
	    			}    			
	    		}    		
    		}
    	}, this);
    	return obj;
    },
    
    
    /**
     * find the related name reference
     */
    findNameRefCells : function(changed){
    	var store = this.getStore();
    	
    	var calPro = EnterpriseSheet.sheet.calculate.Calculate.prototype;    	
    	
    	var obj = {};
    	store.each(function(rd, internalId){
    		var json = rd.data.json;
    		if(json.cal){
	    		for(var p in changed){
	    			if(changed.hasOwnProperty(p)){
	    				if(this.isCalIncludedName(json.data, p)){
	    					obj[internalId] = [rd.data.sheet, rd.data.row, rd.data.col];
	    					break;
	            		}
	    			}    			
	    		}    		
    		}
    	}, this);
    	return obj;
    },
    
    isCalIncludedName : function(cal, name){
    	if(-1 !== cal.indexOf(name)){
    		return true;
    	}
    },
	
	/**
	 * get recalculate cells by coord
	 */
	getRecalculateCellsByCoord : function(coord){
		var store = this.getStore();
        var coordPro = EnterpriseSheet.sheet.calculate.Coordinate.prototype;
		var found = {};
        store.each(function(rec, internalId){
            var data = rec.data, json = data.json, refs = json.refs, id = internalId;
            if(json.cal && refs){
    			if(coordPro.isOverlappedCoord(coord, refs)){
                    found[id] = [data.sheet, data.row, data.col];
                }
            }
        }, this);
		
		
        return found;
	},
	
    /**
     * get related conditional cells
     */
    getRelatedCdtCoord : function(coords){
        return this.getStore().getRelatedCdtCoord(coords);
    },
           
    /**
     * process the related conditons in the passed coords
     */
    processRelatedCdt : function(coords){
        var sep = EnterpriseSheet.sheet.calculate.Coordinate.prototype.separator;
        var cdtCoord = this.getRelatedCdtCoord(coords), store = this.getStore(), visited = {}, mergeds = [];
        this.clearCdtValueForCoord(coords);
        if(0 < cdtCoord.length){
            this.clearCdtValueForCoord(cdtCoord);
            var cells = {};
            store.walkRange(cdtCoord, function(rec, walkSpan, store, internalId){
                var id = internalId;
                if(!cells[id]){
                    cells[id] = rec;
                    var json = rec.data.json, s = rec.data.sheet;
                    if(Ext.isNumber(json.abminrow)){
                        /*
                         * need cover the merged cells
                         */
                        var abMinRow = json.abminrow, abMinCol = json.abmincol, abMaxRow = json.abmaxrow, abMaxCol = json.abmaxcol;
                        var span = [s, abMinRow, abMinCol, abMaxRow, abMaxCol];
                        var mid = span.join('sep');
                        if(!visited[mid]){
                            visited[mid] = true;
                            mergeds.push(span);
                        }
                    }
                }
            }, this, true);
           
            var timestamp = SCOM.genTimeStamp();
            for(var p in cells){
                if(cells.hasOwnProperty(p)){
                    var rec = cells[p], s = rec.data.sheet, r = rec.data.row, c = rec.data.col;
                    store.setCell(s, r, c, {
                         'timestamp': timestamp
                    }, ['cdtVal'], true);
                    var cd = store.getCellData(s, r, c);
                    this.processCalCdtData(s, r, c, cd);
                }
            }
        }
        return cdtCoord.concat(mergeds);
    },
	
	/*
	 * _private
	 * when data of cell is changed, we will check the current cells in this region,
	 * if there is calculate cells, may need refresh them to show the new value
	 */
	processDataChange : function(sheet, row, col, modified, deleted, originJson, currentJson, store, suspendRefresh, skipUpdateValue, reCalCells){
        originJson = originJson || {};
        currentJson = currentJson || {};
        var timestamp = SCOM.genTimeStamp();
        var scope = {
            store:store,
            sheet:sheet,
            row:row,
            col:col,
            timestamp: timestamp
        };
        var coord = [[sheet, row, col, row, col]];
        /*
         * if it's a calculated cell
         */
        var cell = store.getCellData(sheet, row, col), me = this;
        var oldVal = originJson.cal ? originJson.value : originJson.data, oldItchk = originJson.itchk;
        if(!SCOM.isEmptyValue(oldVal)){
            oldVal = oldVal.toString();
        }
        var isCal = me.isCalculateCell(cell);
        
        var updateFn = function(){
            me.clearValueForCalCells(reCalCells);
            me.recalculateCalCdtCells(reCalCells, skipUpdateValue, function(ret){
                if(ret){
                    ret = ret.concat(coord);
                }else{
                    ret = coord;
                }
                /*
                 * get the cdt cells
                 */
                var cdtCoord = me.processRelatedCdt(ret);
                ret = ret.concat(cdtCoord);
                me.refreshRange(ret);
                me.loadMask.hide();
            }, this);
        }
        var checkRelatedFn = function(){
            var reCals = me.findDirectRecalculateCellsOfCell(sheet, row, col);
            if(reCalCells){
                Ext.apply(reCalCells, reCals);
            }else{
                reCalCells = reCals;
            }
            me.loadMask.show(SLANG['calculating'], 10 > SCOM.countObjMember(reCalCells) ? me.calMaskDelayTime : false);
            Ext.Function.defer(updateFn, 10, me);
        }
        var fn = function(){
            /*
             * need delete the value so it will recalculate
             */
            delete(cell.value);
            cell = me.processCalculate(cell, scope);
            var curVal = cell.value;
            if(!SCOM.isEmptyValue(curVal)){
                curVal = curVal.toString();
            }
            if(curVal !== oldVal){
                checkRelatedFn();
            }else{
                me.refreshRange(coord);
                me.loadMask.hide();
            }
        };
        if(isCal){
            var refs = cell.refs;
            if(refs){
                me.loadMask.show(SLANG['calculating'], me.calMaskDelayTime);
                store.checkLoadCoord(refs, fn, this);
            }else{
                fn();
            }
        }else if(currentJson.data !== oldVal || currentJson.itchk !== oldItchk){
            checkRelatedFn();
        }
	},
      
    /**
     * _private
     * need clear the value for the passed cal cells, so it will be recalculated
     */
    clearValueForCalCells : function(cells){
    	var deleteCdtStyles = ['cdtVal', 'value'].concat(EnterpriseSheet.sheet.calculate.Condition.styles);
    	var store = this.getStore(), lookup = {}, timestamp = SCOM.genTimeStamp();
    	for(var p in cells){
    		if(cells.hasOwnProperty(p)){
    			var cell = store.getByMapId(p);
    			if(cell){
                    var json = cell.data.json;
                    store.setCell(cell.data.sheet, cell.data.row, cell.data.col, {
                        'timestamp': timestamp,
                        'lastVal': json.value || ''
                    }, deleteCdtStyles, true);
    			}
    		}
    	}
    },

    /**
     * clear the cdtVal for the passed coord
     */
    clearCdtValueForCoord : function(coord){
    	this.getStore().clearCdtForCoord(coord);
    },
           
    /**
     * clear the value for the passed coord
     */
    clearValueForCoord : function(coord){
        var deleteStyles = ['value'];
        var store = this.getStore(), timestamp = SCOM.genTimeStamp(), lookup = {};
        store.walkRange(coord, function(rec, walkSpan, store, internalId){
            lookup[internalId] = rec;
        }, this, true);
        for(var p in lookup){
            if(lookup.hasOwnProperty(p)){
                var rec = lookup[p], json = rec.data.json;
                store.setCell(rec.data.sheet, rec.data.row, rec.data.col, {
                    'timestamp': timestamp,
                    'lastVal': json.value || ''
                }, deleteStyles, true);
            }
        }
    },
	
    getChangedLoadedCells : function(cells){
    	var store = this.getStore(), lookup = {};
    	for(var p in cells){
    		if(cells.hasOwnProperty(p)){
    			var cell = store.getByMapId(p);
    			if(cell){    				
    				var json = cell.data.json;
    				if(!SCOM.isEmptyValue(json.data)){
    					lookup[p] = cells[p];
    				}
    			}
    		}
    	}
    	
    	return lookup;
    },
	
	/**
	 * cache the last timestamp
	 */
	cacheLastTimeStamp : function(timestamp){
		this.lastTimestamp = timestamp;
	},
	
	getLastTimestamp : function(){
		return this.lastTimestamp;
	},
      
    /**
     * reprocess all cal and cdt cells in the active sheet
     */
    reprocessCalCdtCellsInActiveSheet : function(skipUpdateValue){
        var store = this.getStore(), me = this;
		var sid = this.getSheetId();
        var arr = [];

        store.eachCal(function(rd){
            var s = rd.data.sheet, r = rd.data.row, c = rd.data.col, cell = rd.data.json;
                      
            /*
             * only care body cells and the cell.data should not be null/undefined/null string
             */
            if(s === sid && 0 != r && 0 != c && cell.data){
                   
                var cal = me.isCalculateCell(cell);
                
                /*
                 * check whether it's cal or cdt cell
                 */
                if(cal){
                    cell = store.getCellData(s, r, c);
                    var scope = {
                        store: store,
                        sheet: s,
                        row: r,
                        col: c,
                        timestamp: cell.timestamp
                    };
                    me.processCalculate(cell, scope, skipUpdateValue);
                    arr.push([s, r, c, r, c]);
                }
            }
        }, this);

        return arr;
    },
           
    /**
     * _private
     */
    getherCells : function(s, r, c, myReCals, id, skipUpdateValue){
        var store = this.getStore(), me = this;
        var cell = store.getCellData(s, r, c);
        var scope = {
            store: store,
            sheet: s,
            row: r,
            col: c,
            timestamp: cell.timestamp
        };
        var cal = me.isCalculateCell(cell);
           
        /*
         * check whether it's cal or cdt cell
         */
        if(cal){
            /*
             * process cal and cdt for the cell
             */
            var oldVal = cell.lastVal;
            if(!SCOM.isEmptyValue(oldVal)){
                oldVal = oldVal.toString();
            }
            var obj = me.processCalculate(cell, scope, skipUpdateValue);
            var curVal = obj.value;
            if(!SCOM.isEmptyValue(curVal)){
                curVal = curVal.toString();
            }
            /*
             * if value is changed then we find other calculate cells related to it
             */
            if(oldVal !== curVal){
                var changedCalCells = me.findDirectRecalculateCellsOfCell(s, r, c);
                if(changedCalCells){
                    me.clearValueForCalCells(changedCalCells);
                    Ext.apply(myReCals, changedCalCells);
                }
            }
        }
    },
           
	/**
	 * re-calculate all calculate and condition cells
	 */
	reprocessCalCdtCells : function(reCals, skipUpdateValue, callback, cbScope){
		var me = this, sep = EnterpriseSheet.sheet.calculate.Coordinate.prototype.separator;
		/*
		 * this array will contain all cells need be refresh
		 */
		var arr = [];
		
		var store = me.getStore();
		var sid = me.getSheetId();
			
        var first = true;
        var newReCals = {}, allCals = Ext.apply({}, reCals);
        
        var checkFn = function(){
            var tmp = {};
            for(var p in newReCals){
                if(newReCals.hasOwnProperty(p) && !allCals.hasOwnProperty(p)){
                    tmp[p] = newReCals[p];
                }
            }
            if(!SCOM.isEmptyObj(tmp)){
                Ext.apply(allCals, tmp);
                reCals = tmp;
                newReCals = {};
                /*
                 * call it in loop
                 */
                if(first){
                    first = false;
                    Ext.Function.defer(function(){
                        loopFn(checkFn, me);
                    }, 5, me);
                }else{
                    loopFn(checkFn, me);
                }
            }else{
                /*
                 * means the loop is over
                 */
                if(callback){
                    callback.call(cbScope, arr);
                }
            }
        }
        var loopFn = function(fn, fnScope){
            var cells = [];
            for(var p in reCals){
                if(reCals.hasOwnProperty(p)){
                    var pos = reCals[p];
                    var s = pos[0], r = pos[1], c = pos[2];
                    /*
                     * only care body cells and the cell.data should not be null/undefined/null string
                     */
                    if(0 != r && 0 != c){
                        cells.push([s, r, c, p]);
                        arr.push([s, r, c, r, c]);
                    }else{
                        /*
                         * for row/col coord
                         */
                        store.walkRange([[s, r, c, r, c]], function(rd, walkSpan, store, internalId){
                            var iRow = rd.data.row, iCol = rd.data.col, cell = rd.data.json;
                            if(iRow && iCol){
                                cells.push([s, iRow, iCol, internalId]);
                                arr.push([s, iRow, iCol, iRow, iCol]);
                            }
                        }, me);
                    }
                }
            }
            /*
             * to avoid the browser freezing to alert, we will try to defer 5 ms every 1000 ms
             */
            SCOM.eachLimitDefer(cells, function(it){
                me.getherCells.call(me, it[0], it[1], it[2], newReCals, it[3], skipUpdateValue);
            }, me, fn, fnScope, 1000, 5);
        }
           
        loopFn(checkFn, this);
		
		return arr;
	},
           
	/**
	 * re-calculate all calculate and condition cells and refresh them
	 */
	recalculateCalCdtCells : function(reCals, skipUpdateValue, callback, scope){
        var arr = this.reprocessCalCdtCells(reCals, skipUpdateValue, function(ret){
            var sheetId = this.getSheetId();
            if(reCals && this.highlightCellsAfterCalculate){
                /*
                 * highlight the cells recalculated
                 */
                Ext.Function.defer(function(){
                    for(var i = 0, len = ret.length; i < len; i++){
                        var it = ret[i];
                        if(sheetId === it[0]){
                            var startRow = it[1], endRow = it[3], startCol = it[2], endCol = it[4];
                            for(var x = startRow; x <= endRow; x++){
                                for(var y = startCol; y <= endCol; y++){
                                    var cellEls = this.getCellEls(x, y);
                                    for(var k = 0, count = cellEls.length; k < count; k++){
                                        cellEls[k].highlight("00aa00", { attr: 'color', duration: 2000 });
                                    }
                                }
                            }
                        }
                    }
                }, 100, this);
            }
            if(callback){
                callback.call(scope, ret);
            }
        }, this);
           
        return arr;
	},
	
	/*
	 * true if the sheet is splited 
	 */
	isSplited : function(){
		return this.splitPos ? true : false;
	},
	
	/*
	 * true if the sheet is freezed 
	 */
	isFreezed : function(){
		return this.freezePos ? true : false;
	},	
	
	/*
	 * get row/col range info for every regions of this sheet	 
	 */
	getRangeInfo : function(){
		var info = {};
		for(var i = 0, len = this.regionLookup.length; i < len; i++){
			var name = this.regionLookup[i];
			info[name] = this[name].getRangeSpan();
		}		
		return info;
	},
		
	/*
	 * set range info
	 */
	setRangeInfo : function(info){
		for(var p in info){
			var o = info[p];
			this[p].setRangeSpan(o);
		}
	},
	
	
	/*
	 * _private 
	 * get group pin
	 */
	getRowGroupPin : function(){
		var el = this.getInnerEl();
		var pinEl = el.down('.ss-row-group-pin');
		if(!pinEl){
			pinEl = Ext.DomHelper.append(el.dom, '<div class="ss-row-group-pin"></div>', true);
		}
		return pinEl;
	},
	
	removeRowGroupPin : function(){
		var el = this.getInnerEl();
		var pinEl = el.down('.ss-row-group-pin');
		if(pinEl){
			Ext.removeNode(pinEl.dom);
		}
	},
	
	getColumnGroupPin : function(){
		var el = this.getInnerEl();
		var pinEl = el.down('.ss-col-group-pin');
		if(!pinEl){
			pinEl = Ext.DomHelper.append(el.dom, '<div class="ss-col-group-pin"></div>', true);
		}
		return pinEl;
	},
	
	removeColumnGroupPin : function(){
		var el = this.getInnerEl();
		var pinEl = el.down('.ss-col-group-pin');
		if(pinEl){
			Ext.removeNode(pinEl.dom);
		}
	},
	
	/*
	 * set col/row group info
	 */
	/*
	 * set column groups, update to store and layout if need
	 */
	layoutColumnGroups : function(colGroups){
		if(colGroups && 0 === colGroups.length){
			colGroups = null;
		}
		var needLayout = this.setColumnGroups(colGroups);
		this.updateColumnGroups();
		if(needLayout){
			if(Ext.isFunction(this.doLayout)){
				this.doLayout();
			}else if(Ext.isFunction(this.updateLayout)){
				this.updateLayout();
			} 
		}
	},
	
	/*
	 * set row groups, update to store and layout if need
	 */
	layoutRowGroups : function(rowGroups){
		if(rowGroups && 0 === rowGroups.length){
			rowGroups = null;
		}
		var needLayout = this.setRowGroups(rowGroups);
		this.updateRowGroups();
		if(needLayout){
			if(Ext.isFunction(this.doLayout)){
				this.doLayout();
			}else if(Ext.isFunction(this.updateLayout)){
				this.updateLayout();
			} 
		}
	},
	
	setRowGroups : function(rowGroups, refreshPin){		
		var colorLen = SCOM.colors.length;
		var el = this.getEl(), needLayout = false;
		if(rowGroups){			
			this.rowGroupNameMap = {};
			this.rowGroupLookup = {};
			this.rowGroups = SCOM.copy(rowGroups);
			el.addCls('ss-row-group-ct');
			var maxLevel = 0;
			for(var i = 0, len = this.rowGroups.length; i < len; i++){
				var group = this.rowGroups[i], span = group.span, level = group.level;
				if(level > maxLevel){
					maxLevel = level;
				}
				var name = span.join('$');
				/*
				 * add to name map
				 */
				this.rowGroupNameMap[name] = group;
				var minRow = span[0], maxRow = span[1];
				for(var j = minRow; j <= maxRow; j++){
					this.rowGroupLookup[j] = this.rowGroupLookup[j] || {};
					this.rowGroupLookup[j][name] = group;
				}
			}
			needLayout = maxLevel != this.rowGroupMaxLevel;				
			if(needLayout || refreshPin){
				this.rowGroupMaxLevel = maxLevel;
				var padding = this.groupOffset*maxLevel+this.groupPadding;
				el.setStyle('padding-left', padding+'px');
				
				var pinEl = this.getRowGroupPin();
				pinEl.setStyle('left', (-padding-1)+'px');
				pinEl.setWidth(padding);
				var arr = [];
				for(var i = maxLevel; i > 0; i--){
					var color = SCOM.colors[(i-1)%colorLen];
					arr.push('<div class="ss-row-group-no" style="background-color:'+color+';" level="'+i+'">'+i+'</div>');
				}
				pinEl.update(arr.join(''));
			}						
		}else{
			needLayout = this.rowGroupMaxLevel ? true : false;
			if(needLayout || refreshPin){
				this.removeRowGroupPin();
				delete(this.rowGroups);
				delete(this.rowGroupNameMap);
				delete(this.rowGroupLookup);
				delete(this.rowGroupMaxLevel);			
				el.removeCls('ss-row-group-ct');
				el.setStyle('padding-left', '0px');
			}			
		}
		/*
		 * return whether need do layout
		 */
		return needLayout;
	},
	
	setColumnGroups : function(colGroups, refreshPin){		
		var colorLen = SCOM.colors.length;
		var el = this.getEl(), needLayout = false;
		if(colGroups){
			this.colGroupNameMap = {};
			this.colGroupLookup = {};
			this.colGroups = SCOM.copy(colGroups);
			el.addCls('ss-col-group-ct');
			var maxLevel = 0;
			for(var i = 0, len = this.colGroups.length; i < len; i++){
				var group = this.colGroups[i], span = group.span, level = group.level;
				if(level > maxLevel){
					maxLevel = level;
				}
				var name = span.join('$');
				/*
				 * add to name map
				 */
				this.colGroupNameMap[name] = group;
				var minRow = span[0], maxRow = span[1];
				for(var j = minRow; j <= maxRow; j++){
					this.colGroupLookup[j] = this.colGroupLookup[j] || {};
					this.colGroupLookup[j][name] = group;
				}
			}
			needLayout = maxLevel != this.colGroupMaxLevel;			
			if(needLayout || refreshPin){
				this.colGroupMaxLevel = maxLevel;
				var padding = maxLevel*this.groupOffset+this.groupPadding;
				el.setStyle('padding-top', padding+'px');
				
				var pinEl = this.getColumnGroupPin();
				pinEl.setStyle('top', (-padding-1)+'px');
				pinEl.setHeight(padding);
				var arr = [];
				for(var i = maxLevel; i > 0; i--){
					var color = SCOM.colors[(i-1)%colorLen];
					arr.push('<div class="ss-col-group-no" style="background-color:'+color+';" level="'+i+'">'+i+'</div>');
				}
				pinEl.update(arr.join(''));
			}
		}else{
			needLayout = this.colGroupMaxLevel ? true : false;
			if(needLayout || refreshPin){
				this.removeColumnGroupPin();
				delete(this.colGroups);
				delete(this.colGroupNameMap);
				delete(this.colGroupLookup);
				delete(this.colGroupMaxLevel);
				el.removeCls('ss-col-group-ct');
				el.setStyle('padding-top', '0px');
			}			
		}
		/*
		 * return whether need do layout
		 */
		return needLayout;
	},	
	
	setGroups : function(data){		
		/*
		 * set row/column groups
		 */
		var rowGroups, needLayout = false;
		if(data.rowGroups){
			rowGroups = Ext.decode(data.rowGroups);
		}
		if(this.setRowGroups(rowGroups)){
			needLayout = true;
		}
		var colGroups;
		if(data.colGroups){
			colGroups = Ext.decode(data.colGroups);
		}	
		if(this.setColumnGroups(colGroups)){
			needLayout = true;
		}		
		return needLayout;
	},
	
	
	/*
	 * get the group level info
	 */
	getGroupLevel : function(dir){
		var maps = this[dir+'GroupNameMap'];
		var mapStates = {};
		for(var p in maps){
			mapStates[p] = maps[p].collapsed || false;
		}
		var levelPins = '', pinEl;
		if('row' == dir){
			pinEl = this.getRowGroupPin();
		}else{
			pinEl = this.getColumnGroupPin();
		}
		if(pinEl){
			levelPins = pinEl.dom.innerHTML;
		}
		return {
			mapStates: mapStates,
			levelPins: levelPins
		}
	},
	
	/*
	 * set group level info
	 */
	setGroupLevel : function(dir, info){
		var maps = this[dir+'GroupNameMap'];
		var mapStates = info.mapStates, levelPins = info.levelPins;
		if('row' == dir){
			pinEl = this.getRowGroupPin();
		}else{
			pinEl = this.getColumnGroupPin();
		}
		if(pinEl){
			pinEl.update(levelPins);
		}
		for(var name in mapStates){
			maps[name].collapsed = mapStates[name];
		}
	},
	
	/*
	 * getter and setter for sheetId
	 */
	getSheetId : function(){
		return this.sheetId;
	},
	
	setSheetId : function(sheetId){
		this.sheetId = sheetId;
		
		for(var i = 0, len = this.regionLookup.length; i < len; i++){
			this[this.regionLookup[i]].setSheetId(sheetId);
		}
		/*
		 * handle left-top corner
		 */
		this.ltcorner.setSheetId(sheetId)
	},
	
	/*
	 * update the current sheet config
	 */
	updateSheetConfig : function(suspendEvent){
		var config = this.getSheetConfig();
		
		var store = this.getStore(), sheetId = this.getSheetId();
				
		store.updateSheetConfig(sheetId, config, suspendEvent);
		return config;
	},
	
	/*
	 * update row and column groups to store
	 */
	updateRowGroups : function(suspendUpdateStore){		
		var store = this.getStore(), sheetId = this.getSheetId();
		if(!suspendUpdateStore){
			return store.updateRowGroups(sheetId, this.rowGroups);
		}else{
			return this.rowGroups;
		}
	},
	
	updateColumnGroups : function(suspendUpdateStore){		
		var store = this.getStore(), sheetId = this.getSheetId();
		if(!suspendUpdateStore){
			return store.updateColumnGroups(sheetId, this.colGroups);
		}else{
			return this.colGroups;
		}
	},
	
	/*
	 * get the sheet config, which contains visible, range span and bound of all regions, 
	 * the selection, focus cell, and freeze or split info 	 
	 */
	getSheetConfig : function(){
		var sm = this.getSelectionModel();
		var rm = this.getReferenceModel();
		var config = {
			'rangeInfo':this.getRangeInfo(),
			/*
			 * selection and focus cell
			 */
			'selection':sm.getSelection(),
			'focusCell':sm.getFocusCell(),
			'noGridLine': !this.withGridLine(),
			'rowNameHidden': this.store.rowNameHidden,
			'colNameHidden': this.store.colNameHidden
		};
		if(this.freezePos){
			config.freezePos = Ext.apply({}, this.freezePos);
		}
		if(this.splitPos){
			config.splitPos = Ext.apply({}, this.splitPos);
		}		
		//console.log(Ext.encode(config))
		return config;
	},
	
	/*
	 * return a default config for a sheet
	 */
	getDefaultConfig : function(){
		var rangeInfo = {
			'lheader':{visible:false},
			'sheader':this.sheader.getDefaultRangeSpan(),
			'ulefter':{visible:false},
			'slefter':this.slefter.getDefaultRangeSpan(),
			'ltregion':{visible:false},
			'lregion':{visible:false},
			'tregion':{visible:false},
			'cregion':this.cregion.getDefaultRangeSpan()	
		};
		var sm = this.getSelectionModel();
		var config = {
			'rangeInfo':rangeInfo,
			'selection':sm.getDefaultSelection(),
			'focusCell':sm.getDefaultFocusCell(),
			'reference':[]
		};
		
		return config;
	},
	
    /**
     * prepare and process the sheet config for further processing
     */
    prepareSheetConfig : function(config){
        var flag = this.prepareFreezeConfig(config);
        if(this.prepareSplitConfig(config)){
            flag = true;
        }
        if(flag){
            /*
             * save the current sheet config first
             */
            this.updateSheetConfig(true);
        }
    },
           
    prepareSplitConfig : function(config){
        var store = this.getStore(), sheetId = this.getSheetId();
           
        var splitPos = config.splitPos, rangeInfo = config.rangeInfo;
        if(splitPos){
            var frow = splitPos.row, fcol = splitPos.col, srow = splitPos.startRow || 1, scol = splitPos.startCol || 1;
            var reset = splitPos.reset;
            if(!reset){
                return;
            }
            delete(splitPos.startCol);
            delete(splitPos.startRow);
            delete(splitPos.row);
            delete(splitPos.col);
            delete(splitPos.reset);
            splitPos.width = scol < fcol ? store.getRangeWidth(sheetId, scol, fcol-1) : 0;
            splitPos.height = srow < frow ? store.getRangeHeight(sheetId, srow, frow-1) : 0;

            if(1 < frow){
                rangeInfo.ulefter = rangeInfo.ulefter || {};
                Ext.apply(rangeInfo.ulefter, {
                    visible: srow < frow,
                    range: {
                        rowStart: srow,
                        rowEnd: frow-1,
                        colStart: 0,
                        colEnd: 0
                    },
                    colBound: {
                        min: 0,
                        low: 0,
                        high: true
                    },
                    rowBound: {
                        min: 1,
                        low: 1,
                        high: false
                    }
                });
                rangeInfo.tregion = rangeInfo.tregion || {};
                Ext.apply(rangeInfo.tregion, {
                    visible: srow < frow,
                    range: {
                        rowStart: srow,
                        rowEnd: frow-1,
                        colStart: fcol
                    },
                    colBound: {
                        min: 1,
                        low: 1,
                        high: false
                    },
                    rowBound: {
                        min: 1,
                        low: 1,
                        high: false
                    }
                });
                Ext.apply(rangeInfo.slefter, {
                    range: {
                        rowStart: frow,
                        colStart: 0,
                        colEnd: 0
                    },
                    colBound: {
                        min: 0,
                        low: 0,
                        high: true
                    },
                    rowBound: {
                        min: 1,
                        low: 1,
                        high: false
                    }
                });
            }
            if(1 < fcol){
                rangeInfo.lheader = rangeInfo.lheader || {};
                Ext.apply(rangeInfo.lheader, {
                    visible: scol < fcol,
                    range: {
                        colStart: scol,
                        colEnd: fcol-1,
                        rowStart: 0,
                        rowEnd: 0
                    },
                    rowBound: {
                        min: 0,
                        low: 0,
                        high: true
                    },
                    colBound: {
                        min: 1,
                        low: 1,
                        high: false
                    }
                });
                rangeInfo.lregion = rangeInfo.lregion || {};
                Ext.apply(rangeInfo.lregion, {
                    visible: scol < fcol,
                    range: {
                        colStart: scol,
                        colEnd: fcol-1,
                        rowStart: frow
                    },
                    rowBound: {
                        min: 1,
                        low: 1,
                        high: false
                    },
                    colBound: {
                        min: 1,
                        low: 1,
                        high: false
                    }
                });
                Ext.apply(rangeInfo.sheader, {
                    range: {
                        colStart: fcol,
                        rowStart: 0,
                        rowEnd: 0
                    },
                    rowBound: {
                        min: 0,
                        low: 0,
                        high: true
                    },
                    colBound: {
                        min: 1,
                        low: 1,
                        high: false
                    }
                });
            }
            if(srow < frow || scol < fcol){
                Ext.apply(rangeInfo.cregion, {
                    range: {
                        rowStart: frow,
                        colStart: fcol
                    },
                    colBound: {
                        min: 1,
                        low: 1,
                        high: false
                    },
                    rowBound: {
                        min: 1,
                        low: 1,
                        high: false
                    }
                });
            }
            if(srow < frow && scol < fcol){
                rangeInfo.ltregion = rangeInfo.ltregion || {};
                Ext.apply(rangeInfo.ltregion, {
                    visible: true,
                    range: {
                        colStart: scol,
                        colEnd: fcol-1,
                        rowStart: srow,
                        rowEnd: frow-1
                    },
                    rowBound: {
                        min: 1,
                        low: 1,
                        high: false
                    },
                    colBound: {
                        min: 1,
                        low: 1,
                        high: false
                    }
                });
            }
            return true;
        }
    },
	
    /**
     * prepare and process the sheet config for further processing
     */
    prepareFreezeConfig : function(config){
           
        var freezePos = config.freezePos, rangeInfo = config.rangeInfo;
           
        if(freezePos){
            var frow = freezePos.row, fcol = freezePos.col, srow = freezePos.startRow || 1, scol = freezePos.startCol || 1;
            var reset = freezePos.reset;
            if(!reset){
                return;
            }
            delete(freezePos.startCol);
            delete(freezePos.startRow);
            delete(freezePos.reset);
            if(1 < frow){
                rangeInfo.ulefter = rangeInfo.ulefter || {};
                Ext.apply(rangeInfo.ulefter, {
                    visible: srow < frow,
                    range: {
                        rowStart: srow,
                        rowEnd: frow-1,
                        colStart: 0,
                        colEnd: 0
                    },
                    colBound: {
                        min: 0,
                        low: 0,
                        high: true
                    },
                    rowBound: {
                        min: srow,
                        low: srow,
                        high: frow-1
                    }
                });
                rangeInfo.tregion = rangeInfo.tregion || {};
                Ext.apply(rangeInfo.tregion, {
                    visible: srow < frow,
                    range: {
                        rowStart: srow,
                        rowEnd: frow-1,
                        colStart: fcol
                    },
                    colBound: {
                        min: scol,
                        low: fcol,
                        high: false
                    },
                    rowBound: {
                        min: srow,
                        low: frow-1,
                        high: frow-1
                    }
                });
                Ext.apply(rangeInfo.slefter, {
                    range: {
                        rowStart: frow,
                        colStart: 0,
                        colEnd: 0
                    },
                    colBound: {
                        min: 0,
                        low: 0,
                        high: true
                    },
                    rowBound: {
                        min: srow,
                        low: frow,
                        high: false
                    }
                });
            }
            if(1 < fcol){
                rangeInfo.lheader = rangeInfo.lheader || {};
                Ext.apply(rangeInfo.lheader, {
                    visible: scol < fcol,
                    range: {
                        colStart: scol,
                        colEnd: fcol-1,
                        rowStart: 0,
                        rowEnd: 0
                    },
                    rowBound: {
                        min: 0,
                        low: 0,
                        high: true
                    },
                    colBound: {
                        min: scol,
                        low: scol,
                        high: fcol-1
                    }
                });
                rangeInfo.lregion = rangeInfo.lregion || {};
                Ext.apply(rangeInfo.lregion, {
                    visible: scol < fcol,
                    range: {
                        colStart: scol,
                        colEnd: fcol-1,
                        rowStart: frow
                    },
                    rowBound: {
                        min: srow,
                        low: frow,
                        high: false
                    },
                    colBound: {
                        min: scol,
                        low: fcol-1,
                        high: fcol-1
                    }
                });
                Ext.apply(rangeInfo.sheader, {
                    range: {
                        colStart: fcol,
                        rowStart: 0,
                        rowEnd: 0
                    },
                    rowBound: {
                        min: 0,
                        low: 0,
                        high: true
                    },
                    colBound: {
                        min: scol,
                        low: fcol,
                        high: false
                    }
                });
            }
            if(1 < frow || 1 < fcol){
                Ext.apply(rangeInfo.cregion, {
                    range: {
                        rowStart: frow,
                        colStart: fcol
                    },
                    colBound: {
                        min: scol,
                        low: fcol,
                        high: false
                    },
                    rowBound: {
                        min: srow,
                        low: frow,
                        high: false
                    }
                });
            }
            if(srow < frow && scol < fcol){
                rangeInfo.ltregion = rangeInfo.ltregion || {};
                Ext.apply(rangeInfo.ltregion, {
                    visible: true,
                    range: {
                        colStart: scol,
                        colEnd: fcol-1,
                        rowStart: srow,
                        rowEnd: frow-1
                    },
                    rowBound: {
                        min: srow,
                        low: frow-1,
                        high: frow-1
                    },
                    colBound: {
                        min: scol,
                        low: fcol-1,
                        high: fcol-1
                    }
                });
            }
            return true;
        }
    },
     
	/*
	 * set the sheet config, which contains visible, range span and bound of all regions, 
	 * the selection, focus cell, and freeze or split info 	 
	 * @param {object} config: the config object 
	 */
	setSheetConfig : function(config){		
		/*
		 * if it's a new sheet, there is no config maybe, so we use default config for that sheet
		 */
		config = Ext.applyIf(config || {}, this.getDefaultConfig());
 
        this.prepareSheetConfig(config);
		/*
		 * for freeze and split info
		 */

		if(config.freezePos){
			this.freezePos = Ext.apply({}, config.freezePos);
		}else{
			delete(this.freezePos);
		}
		if(config.splitPos){
			this.splitPos = Ext.apply({}, config.splitPos);
		}else{
			delete(this.splitPos);
		}		
		
		/*
		 * set range info
		 */
		this.setRangeInfo(config.rangeInfo);
		/*
		 * handle rowNameHidden and colNameHidden
		 */
		Ext.apply(this.store, {
			rowNameHidden: config.rowNameHidden,
			colNameHidden: config.colNameHidden
		});
		if(config.colNameHidden || config.rowNameHidden){
			this.ltcorner.hide();
		}else{
			this.ltcorner.show();
		}
		/*
		 * hanlde the lefter width
		 */
		this.checkLefterWidth(true, true);
		
		var sm = this.getSelectionModel();
		if(config.selection){			
			/*
			 * update selction
			 */
			sm.selectRange(config.selection.startPos, config.selection.endPos);
		}				
		if(config.reference){					
			var rm = this.getReferenceModel();
			/*
			 * update reference
			 */			
			rm.setReference(config.reference, true);
		}
		if(config.focusCell){
			/*
			 * update focus
			 */
			sm.setFocusCell(config.focusCell.row, config.focusCell.col);
		}	
		if(config.noGridLine){
			this.hideGridLine(true);
		}else{
			this.showGridLine(true);
		}			
	},		
	
	/*
	 * sync the sheet with the config, groups and floors
	 */
	syncSheetFloating : function(suspendEvent){
		var store = this.getStore(), sheetId = this.getSheetId();
		/*
		 * get the config of the new sheet from its' cell(0, 0)
		 */
		var data = store.getCell(sheetId, 0, 0, true);
		var needLayout = false;
		if(this.enableRowColGroup){
			needLayout = this.setGroups(store.getGroupsBySheetId(sheetId));
		}		
		
		/*
		 * set the new config info
		 */
		var config = Ext.decode(data.config);
		
		this.setSheetConfig(config);

		/*
		 * only show the floors belong to current sheetId
		 */
		this.setFloors(store.getFloorsBySheetId(sheetId));
		this.refreshFloor();
		
		return needLayout;
	},	
	
	/*
	 * change sheet 
	 */
	go2Sheet : function(sheetId, callback, scope){
		var oldSheetId = this.getSheetId();		
		if(oldSheetId != sheetId){					
			var store = this.getStore();
			/*
			 * first need check and load the data
			 */
			store.loadSheet(sheetId, function(success){
                if(success){
				this.switchSheet(sheetId);
				if(callback){
					callback.call(scope);
				}
                }else{
                    this.loadMask.hide();
                }
			}, this);
		}
	},
	
	/*
	 * switch sheet, it will change the sheetId, and refresh the sheet
	 * @param {int} sheetId: the id of the sheet we switch to 	
	 * @return {boolean}: true means switched, or means the sheetId is the current sheet id
	 */
	switchSheet : function(sheetId){
		var oldSheetId = this.getSheetId();		
		if(oldSheetId != sheetId){		
			if(false !== this.fireEvent('beforeswitchsheet', oldSheetId, sheetId, this)){
				var store = this.getStore();
                if(store.getSheetById(oldSheetId)){
                    /*
                     * means this sheet is not deleted
                     */
                    /*
                     * save the current sheet config first
                     */
                    this.updateSheetConfig(true);
                    if(this.enableRowColGroup){
                        /*
                         * update row and column groups, save the old one first
                         */
                        this.updateRowGroups();
                        this.updateColumnGroups();
                    }
                }
				/*
				 * then switch sheet id
				 */
				store.setActivedSheetId(sheetId);
				this.setSheetId(sheetId);	
				
				/*
				 * sync groups, floors and sheet config to the current sheet
				 */
				var needLayout = this.syncSheetFloating();
				
				/*
				 * refresh the new sheet,
				 * refresh the calculate and condition cell
				 */
				this.refreshRange(null, true);
                //this.refreshRange();
           
				if(needLayout){
					if(Ext.isFunction(this.doLayout)){
						this.doLayout();
					}else if(Ext.isFunction(this.updateLayout)){
						this.updateLayout();
					} 
				}
				
				this.fireEvent('switchsheet', oldSheetId, sheetId, this);
										
				return true;
			}			
		}
		return false;
	},
	
	/**
	 * refresh the sheet based on the range
	 * @param {array} ranges: the coord array;
	 * @param {object} reCalCells: this object contains these cells need to be recalculated, it can be null or undefined
	 * if it's null or undfined, then refresh the whole sheet
	 * @param {boolean} skipUpdateValue: true to not update value in calculate
	 */
	refreshRange : function(ranges, reCalCells, skipUpdateValue){
		var ratio = 0.3;
		var fn = function(ranges){
            if(!ranges){
                this.refresh();
                return;
            }
			var region = this.getCurrentRegion();
			/*
			 * use cache to filter out repeat cell
			 */
			var cache = {}, sheetId = this.getSheetId(), flag = false, rows = {};
            var len = ranges.length;
            if(20 < len){
                flag = true;
            }else{
                for(var i = 0; i < len; i++){
                    var range = ranges[i];
                    if(sheetId == range[0]){
                        if(0 == range[1] || 0 == range[2] || 0 == range[3] || 0 == range[4]){
                            flag = true;
                            break;
                        }else{
                            for(var j = range[1]; j <= range[3]; j++){
                                var minCol = range[2];
                                rows[j] = minCol;
                                for(var k = minCol; k <= range[4]; k++){
                                    var key = j+'$'+k;
                                    cache[key] = [j, k];
                                    if(1 < j){
                                        key = (j-1)+'$'+k;
                                        cache[key] = [j-1, k];
                                    }
                                    if(1 < k){
                                        key = j+'$'+(k-1);
                                        cache[key] = [j, k-1];
                                    }
                                    key = (j+1)+'$'+k;
                                    cache[key] = [j+1, k];
                                    key = j+'$'+(k+1);
                                    cache[key] = [j, k+1];
                                }
                            }
                        }
                    }
                }
            }
			if(!flag){				
				/*
				 * if range is less then 1/3 of the sheet, then we just refresh the range part
				 */
				var lookup = this.bodyRegionLookup, update = [];
				
				for(var i = 0, len = lookup.length; i < len; i++){
					var region = this[lookup[i]];
					if(region.isVisible()){
						/*
						 * add the prev non empty cell to refresh
						 */
						for(var p in rows){
							if(rows.hasOwnProperty(p)){
								var row = Number(p), col = rows[p];
								if(region.isInRange(row, col)){
									var prev = this.findPrevNonEmptyColIndex(sheetId, row, col, region);
									if(prev){
										cache[row+'$'+prev] = [row, prev];
									}									
								}
							}
						}
						for(var p in cache){
							var row = cache[p][0], col = cache[p][1];
							
							if(region.isInRange(row, col)){
								update.push([region, row, col]);
							}							
						}
					}
				}
				var count = update.length;
				var sum = this.countCell();
				if(count < sum*ratio){		
					
					/*
					 * check whether the updated cells beyond the level, if not then refresh them or just refresh the whole sheet
					 */
					for(var i = 0; i < count; i++){
						var it = update[i];
						var region = it[0], row = it[1], col = it[2];
						region.refreshCell(row, col);
					}
					this.checkLefterWidth();
					return;
				}
			}
            this.refresh();
		}
        if(reCalCells){
            this.refreshCalCdt(reCalCells, false === SCOM.typeOf(ranges), skipUpdateValue, ranges, function(ret){
                if(ranges){
                    ranges = ranges.concat(ret);
                }
                fn.call(this, ranges);
            }, this);
        }else{
            fn.call(this, ranges);
        }
	},				
	
	/*
	 * sync reference during editing
	 */
	syncReferenceForCalculate : function(value, disableReferFlag, clearFlag){
		if(this.calculate){		
			var me = this;
			var rm = this.getReferenceModel();
			if(clearFlag){
				rm.clearSelection();
			}
			var sheetId = this.getSheetId();
			var v = value;					
			if(this.calculate.couldbeCalculate(v)){
				if(!disableReferFlag){
					/*
					 * if it's a calculate, then enable refer and disable select
					 */
					this.disableSelect();
					this.enableRefer();
				}			
				/*
				 * get reference names in calculate
				 */
				var arr = this.checkReferenceNamesInCal(v, 0);
				var colorIndex = 0;
				EnterpriseSheet.sheet.calculate.Coordinate.prototype.spanReg.lastIndex = 0;
				v.replace(EnterpriseSheet.sheet.calculate.Coordinate.prototype.spanReg, function(w){
					var pos = arguments[arguments.length-2];
					var str = arguments[arguments.length-1];						
									
					var ret = EnterpriseSheet.sheet.calculate.Coordinate.prototype.assembleCoordByRegResult(arguments);
					
					if(!ret){
						return w;
					}
					var span = ret.span;		
										
					if(!Ext.isNumber(span[0])){
						/*
						 * try to get the sheet id by sheet name
						 */
						if(span[0]){
							var foundSheetId = me.getStore().getSheetIdByName(span[0]);
							if(Ext.isNumber(foundSheetId)){
								/*
								 * find sheet id by name
								 */
								span[0] = foundSheetId;
							}
						}else{
							span[0] = sheetId;
						}						
					}							
					//if(me.isInShowRange(span[0], span[1], span[2]) || me.isInShowRange(span[0], span[3], span[4])){
					/*
					 * check wheter out of the max row/column range
					 */
					if(Ext.isNumber(span[0]) && span[3] <= SCONST['MAX_ROW_NUMBER'] && span[4] <= SCONST['MAX_COLUMN_NUMBER']){
						arr.push({
							span: span,
							colorIndex: colorIndex  
						});
					}					
					colorIndex++;
				});
				
				if(0 < arr.length){					
					rm.setReference(arr, true, false, 'ss-cal-ref');			
					rm.show();
					return true;
				}
			}else{
				/*
				 * disable reference
				 */
				this.enableSelect();
				this.disableRefer();
			}			
		}
	},				
	
	/**
	 * check reference names in calculate
	 */
	checkReferenceNamesInCal : function(calStr, colorIndex){
		var store = this.getStore();
		var lookup = store.getRefConfigLookup();
		var arr = [];
		calStr.replace(EnterpriseSheet.sheet.calculate.Calculate.prototype.refNameReg, function(w){
			var found = lookup[w];
			if(found && 'ref' === found.ctype){
				var json = Ext.decode(found.json);
				if(!Ext.isArray(json)){
					json = [json];
				}
				for(var i = 0, len = json.length; i < len; i++){
					var it = json[i];
					arr.push({
						span: it.span,
						colorIndex: colorIndex, 
						cls: 'ss-rm-name'
					});
				}
			}
		});
		return arr;
	},
	
	/*
	 * visit every body regions
	 * @param {function} fn: the callback function
	 * @param {object} scope:the scope of fn
	 */
	walkBodyRegions : function(fn, scope){
		for(var i = 0, len = this.bodyRegionLookup.length; i < len; i++){
			var p = this.bodyRegionLookup[i];
			var region = this[p];
			fn.call(scope, region, p, this);
		}
	},
	
	walkFloorRegions : function(fn, scope){
		for(var i = 0, len = this.floorRegionLookup.length; i < len; i++){
			var p = this.floorRegionLookup[i];
			var region = this[p];
			fn.call(scope, region, p, this);
		}
	},
	
	/*
	 * register the floor in sheet
	 */
	registerFloor : function(floor, suspendEvent, register2SheetId){
		this.floorLookup = this.floorLookup || {};
        if(Ext.isDefined(register2SheetId)){
           floor.sheetId = register2SheetId;
        }else{
           /*
            * save the sheetId
            */
           floor.sheetId = this.getSheetId();
        }
		var action = 'update';
		if(!this.floorLookup[floor.getId()]){
			action = 'create';
		}
		this.floorLookup[floor.getId()] = floor;
		/*
		 * sync floor info to store
		 */
		if(!suspendEvent && floor.getFloorInfo){
			this.syncFloors(floor, action);
		}		
	},
	
	/*
	 * unregister the floor in sheet
	 */
	unregisterFloor : function(floor, suspendUpdate){
		if(this.floorLookup){
			delete(this.floorLookup[floor.getId()]);
			/*
			 * sync floor info to store
			 */
			if(!suspendUpdate && floor.getFloorInfo){
				this.syncFloors(floor, 'remove');
			}		
		}							
	},
	
	/*
	 * clear all floors in sheet
	 */
	clearFloor : function(suspendUpdate, suspendEvent){
		if(this.floorLookup){
			for(var p in this.floorLookup){
				var floor = this.floorLookup[p];
                if(!floor.isLocalKit()){
				floor.destroy(suspendUpdate, suspendEvent);				
			}
			}
			delete(this.floorLookup);
		}		
	}, 
	
	/*
	 * _private sources
	 */
	prepareSource : function(source){
		var curSheetId = this.getSheetId();
		var series = source.series;
		for(var i = 0, len = series.length; i < len; i++){
			var it = series[i];
			if('' == it[0] || SCOM.nullOrUndefined(it[0])){
				it[0] = curSheetId;
			}
		}
		var labels = source.labels;
		if(labels){
			for(var i = 0, len = labels.length; i < len; i++){
				var it = labels[i];
				if('' == it[0] || SCOM.nullOrUndefined(it[0])){
					it[0] = curSheetId;
				}
			}
		}		
		var categories = source.categories;
		if(categories){
			for(var i = 0, len = categories.length; i < len; i++){
				var it = categories[i];
				if('' == it[0] || SCOM.nullOrUndefined(it[0])){
					it[0] = curSheetId;
				}
			}
		}		
	},

	removeFloor : function(name, sheetId){
		var id = name+'-'+sheetId;
		if(this.floorLookup && this.floorLookup[id]){				
			var it = this.floorLookup[id];
			delete(this.floorLookup[id]);
			it.destroy(true, true);
		}
	},
	
	/*
	 * set floors for sheet
	 */
	setFloors : function(floors){
		for(var i = 0, len = floors.length; i < len; i++){
			var floor = floors[i];
			var id = floor.id+'-'+floor.sheetId;
			/*
			 * delete the existed one first
			 */
			if(this.floorLookup && this.floorLookup[id]){				
				var it = this.floorLookup[id];
				delete(this.floorLookup[id]);
				it.destroy(true, true);
			}	
			var floorType = floor.floorType;
			if('picture' == floorType){
				this.createPicture(floor.url, floor, true, true);					
            }else if('wedgit' == floorType){
                this.createWedgit(floor.url, floor, true, true);
            }else if('chart' == floorType){
				var source = floor.source;
				source.seriesPosition = floor.seriesPosition;										
				source.cacheFields = SCOM.copy(source.cacheFields);
                source.firstRowLabel = floor.firstRowLabel;
                source.firstColLabel = floor.firstColLabel;
				this.prepareSource(source);
				var rangeStore = this.createRangeStore(source);
				this.createChart(floor.chartType, rangeStore, floor, true, true);
			}
		}
	},
	
	/*
	 * get a registered floor from this sheet
	 */
	getFloorById : function(floorId){
		return this.floorLookup[floorId];
	},
	
	/*
	 * get the whole registered floor set
	 */
	getFloorSet : function(){
		return this.floorLookup;
	},	
	
	hideCurrentOptionFloors : function(){
		var sheetId = this.getSheetId();
		for(var p in this.floorLookup){
			if(this.floorLookup.hasOwnProperty(p)){
				var floor = this.floorLookup[p];
				if(sheetId == floor.sheetId && 'function' != Ext.typeOf(floor.getFloorInfo)){
					floor.hide();
				}
			}			
		}
	},
	
	/*
	 * only show floors in current sheet
	 */
	refreshFloor : function(){
		var sheetId = this.getSheetId();
		for(var p in this.floorLookup){
			if(this.floorLookup.hasOwnProperty(p)){
				var floor = this.floorLookup[p];
				if(sheetId == floor.sheetId){
					floor.show();
				}else{
					floor.hide();
				}
			}			
		}
	},
	
	/*
	 * get the floor info belong to actived sheet
	 */
	getActiveFloorInfo : function(){
		var info = [];
		var sheetId = this.getSheetId();
		for(var p in this.floorLookup){		
			if(this.floorLookup.hasOwnProperty(p)){
				var floor = this.floorLookup[p];
				if(sheetId == floor.sheetId && 'function' == Ext.typeOf(floor.getFloorInfo)){
					info.push(floor.getFloorInfo());
				}
			}
		}
		if(0 < info.length){
			return info;
		}
	},
	
	/*
	 * sort the selection
	 */
	sortSelection : function(keys, dir){		
		var sm = this.getSelectionModel();
		var span = sm.selection2Span();	
		span = EnterpriseSheet.sheet.range.Range.prototype.expandSpanWithContent(span, this);
		sm.selectRange({
			row: span[1],
			col: span[2]
		}, {
			row: span[3],
			col: span[4]
		});
		this.checkSortSpan(span, keys, dir);			
	},
	
	/*
	 * check the valid of the span and sort it if valid
	 */
	checkSortSpan : function(span, keys, dir){
		if((span[1] === span[3] && span[2] === span[4] && 0 !== span[1] && 0 !== span[2])
			|| (0 === span[1] && 0 === span[2])){
			/*
			 * can not sort single cell or whole sheet
			 */
			Ext.Msg.show({
				title:SLANG['hint'],
				msg:SLANG['can_not_sort_range'],
				icon:Ext.Msg.INFO,
				buttons:Ext.Msg.OK
			});			
		}else{
           
			var store = this.getStore(), withMerged = false, expand;			
			SPOP.showSortColumnOption({
				applyCallback:{
					fn:function(opt){							
						if(0 == opt){
							expand = true;
						}else{
							expand = false;
						}
						var tmpSpan = [].concat(span);
						/*
						 * if the sort function will move the whole row, then need check the whole row for valid
						 */
						if(expand){
							tmpSpan[2] = tmpSpan[4] = 0;
						}			
						store.walkRange([tmpSpan], function(rd){				
							var json = rd.data.json;
							if(store.isMergedCell(json, rd.data.sheet, rd.data.row, rd.data.col) || json['tpl']){
								withMerged = true;
								return false;
							}
						}, this, true);
						if(withMerged){
							/*
							 * can not sort with merged cell
							 */
							Ext.Msg.show({
								title:SLANG['hint'],
								msg:SLANG['can_not_sort_merged_or_table_tpl'],
								icon:Ext.Msg.INFO,
								buttons:Ext.Msg.OK
							});
						}else{							
                            store.checkLoadCoord([span], function(){
                                this.sortSpan(span, keys, dir, 'col', expand, false);
                            }, this);
						}
					},
					scope:this
				}
			});					
		}
	},
	
	
	/*
	 * sort a span and refresh the UI
	 */
	sortSpan : function(span, keys, dir, sortOn, expand, allString, suspendRefresh, suspendEvent){
		var store = this.getStore();
		var coordPro = EnterpriseSheet.sheet.calculate.Coordinate.prototype;
		var relatedRows = this.getRelatedRowsForAutoHeight([span], undefined, undefined, true);
		
		var coord;
		if(expand){
			coord = [[span[0], span[1], 0, span[3], 0]];			
		}else{
			coord = [span];
		}
		/*
		 * get cells need recalculated
		 */
		var reCalCells = coordPro.transferCoord2CellLookup(coord);
		
        var oldCals = {}, newCals = {};
		
		
		var diff = store.sortSpan(span, keys, dir, sortOn, expand, allString, suspendEvent);
		
		
		/*
		 * need process calculate cell specially, update the calculate text string, cause it could change
		 */
		store.walkRange(coord, function(rd, walkSpan, store, internalId){
			var sid = rd.data.sheet, row = rd.data.row, col = rd.data.col, json = rd.data.json;
			var isCal = this.isCalculateCell(json);
			if(isCal){
				/*
				 * reset the calculate string for the new [sheet, row, col]
				 */
				var oldRow, oldCol;
				
				if('row' == sortOn){
					oldCol = diff[rd.data.col];
				}else{
					oldRow = diff[rd.data.row];
				}
				if(SCOM.nullOrUndefined(oldRow)){
					oldRow = row;
				}
				if(SCOM.nullOrUndefined(oldCol)){
					oldCol = col;
				}
				var oldId = store.getIdBasedData({
					sheet: sid,
					row: oldRow,
					col: oldCol
				});
				var id = internalId;
				
				if(isCal){
					if(oldRow !== row || oldCol !== col){
						if(!oldCals[oldId]){
							oldCals[oldId] = {
								sheet: sid,
								row: oldRow,
								col: oldCol,
								json: store.getCell(sid, row, col, true)
							};
						}
						var o = this.resetCalculateCellData(json, sid, row, col, undefined, oldRow, oldCol);					
						store.setCell(sid, row, col, o, null, true);
						newCals[id] = {
							sheet: sid,
							row: row,
							col: col,
							json: store.getCell(sid, row, col, true)
						};
					}
				}
				

				if(!reCalCells[id]){
					reCalCells[id] = [rd.data.sheet, rd.data.row, rd.data.col];
				}
			}
		}, this, true);
		
		//console.log(Ext.encode(oldCals))
		Ext.applyIf(relatedRows, this.getRelatedRowsForAutoHeight([span]));
		
		/*
		 * check auto height change
		 */
		var changedHeights = this.checkAutoHeightForRows(relatedRows);
		
		if(!suspendEvent){
			/*
			 * after the span is sorted
			 */
			this.fireEvent('spansorted', span, keys, dir, null, expand, allString, reCalCells, oldCals, newCals, changedHeights, store, this);
		}
		if(!suspendRefresh){
			/*
			 * refresh the whole sheet if it's expand sort and recalcualte
			 */				
			this.refreshRange(expand?null:[span], reCalCells);
		}
		return diff;
	},
		
	
	/**
	 * apply brush from one coord to anthoer
	 */
	applyBrush : function(fromCoord, toCoord){
		var store = this.getStore(), sm = this.getSelectionModel();
		var fromSpan = fromCoord[0], toSpan = toCoord[0];
		
		if(store.withBrokenMergedCell(toCoord)){
			Ext.Msg.alert(SLANG['hint'], SLANG['can_not_change_part_merged_cell']);
			return;
		}
		
		
		var fsheet = fromSpan[0], fminrow = fromSpan[1], fmincol = fromSpan[2], fmaxrow = fromSpan[3], fmaxcol = fromSpan[4];			
		var tsheet = toSpan[0], tminrow = toSpan[1], tmincol = toSpan[2], tmaxrow = toSpan[3], tmaxcol = toSpan[4];
		var frowLen = 0 == fromSpan[3] ? 0 : fromSpan[3]-fromSpan[1]+1,
			fcolLen = 0 == fromSpan[4] ? 0 : fromSpan[4]-fromSpan[2]+1,
			trowLen = 0 == toSpan[3] ? 0 : toSpan[3]-toSpan[1]+1,
			tcolLen = 0 == toSpan[4] ? 0 : toSpan[4]-toSpan[2]+1;
		
		
		var range = new EnterpriseSheet.sheet.range.Range({
			sheet:this,
			coord:toCoord
		});
		if(false !== this.fireEvent('beforestylebrush', range, fromCoord, this)){
			/*
			 * a lookup cache and count for record the condition id,
			 * for condition cell, when we copy/paste, we need reset the id, because it could be different with
			 * the original condition, with the same id, we can not list them all in the condition manager
			 */
			var lookup = {}, cdtMap = {};
			var oldCdt = this.getCdtsFromCoord(fromCoord), originCdts = {};
			for(var p in oldCdt){
				if(oldCdt.hasOwnProperty(p)){
					var it = oldCdt[p];
					var id = Ext.id()+'-'+SCOM.genTimeStamp();
					lookup[p] = id;
					originCdts[id] = {
						sheet: fsheet,
						name: id
					};
					cdtMap[p] = {
                        id: id,
						sheet: tsheet,
						cdt: Ext.decode(it.json)
					};
				}
			}
            var reCalCells = {};
			this.fireEvent('preparestylebrush', range, fromCoord, this, originCdts, reCalCells);
			/*
			 * need save the data of from span and to span first
			 */
			var cellDataCache = {};
			store.walkRange([fromSpan, toSpan], function(rd){
				var r = rd.data.row, c = rd.data.col; 
				var cd = store.getCellProperty(rd.data.sheet, r, c, true);	
				Ext.applyIf(cd, store.defaultProperty);
				cellDataCache[rd.data.sheet+'-'+r+'-'+c] = cd;
			}, this);
           
            var oldCellCdtLookup = {};
            store.walkRange([toSpan], function(rd, walkSpan, store, internalId){
                var sid = rd.data.sheet, r = fminrow+(rd.data.row-tminrow)%frowLen, c = fmincol+(rd.data.col-tmincol)%fcolLen;
                var cdt = this.getConditionOfCell(sid, r, c);
                if(0 < cdt.length){
                    oldCellCdtLookup[internalId] = cdt;
                }
            }, this);
			
			for(var i = tminrow; i <= tmaxrow; i++){
				for(var j = tmincol; j <= tmaxcol; j++){
					if(0 == i && 0 == j){
						/*
						 * for whole range
						 */
						var cd = cellDataCache[fsheet+'-'+fminrow+'-'+fmincol];
						cd = this.prepareForMoveCell(cd, tsheet, i, j, fsheet, fminrow, fmincol, lookup, 'style-cdt');
						
						store.setWhole(tsheet, cd, null, true);
					}else if(0 == i){
						/*
						 * for column range
						 */
						var col = (j-tmincol)%fcolLen+fmincol;
						if(0 != fmaxrow){							
							var cd = Ext.apply({}, cellDataCache[fsheet+'-'+fminrow+'-'+col]);							
							cd = this.prepareForMoveCell(cd, tsheet, i, j, fsheet, fminrow, col, lookup, 'style-cdt');
							
							store.setColumn(tsheet, j, cd, null, true, true);
						}else{
							store.walkRange([[fsheet, 0, col, 0, col]], function(rd){
								var r = rd.data.row, c = rd.data.col;
								var cd = cellDataCache[fsheet+'-'+r+'-'+c];
								cd = this.prepareForMoveCell(cd, tsheet, r, j, fsheet, r, c, lookup, 'style-cdt');
								store.setCell(tsheet, r, j, cd, null, true);
							}, this);
						}						
					}else if(0 == j){
						/*
						 * for row range
						 */
						var row = (i-tminrow)%frowLen+fminrow;
						if(0 != fmaxcol){							
							var cd = cellDataCache[fsheet+'-'+row+'-'+fmincol];
							cd = this.prepareForMoveCell(cd, tsheet, i, j, fsheet, row, fmincol, lookup, 'style-cdt');
							
							store.setRow(tsheet, i, cd, null, true, true);
						}else{
							store.walkRange([[fsheet, row, 0, row, 0]], function(rd){
								var r = rd.data.row, c = rd.data.col;
								var cd = cellDataCache[fsheet+'-'+r+'-'+c];
								cd = this.prepareForMoveCell(cd, tsheet, i, c, fsheet, r, c, lookup, 'style-cdt');
								store.setCell(tsheet, i, c, cd, null, true);
							}, this);
						}			
					}else{
						/*
						 * for cell range
						 */
						var row = (i-tminrow)%frowLen+fminrow;
						var col = (j-tmincol)%fcolLen+fmincol;
						var cd = cellDataCache[fsheet+'-'+row+'-'+col];
						
						cd = this.prepareForMoveCell(cd, tsheet, i, j, fsheet, row, col, lookup, 'style-cdt');
						
						store.setCell(tsheet, i, j, cd, null, true, true);
					}
				}
			}
			/*
			 * check autoHeight for ralted range
			 */
			if(range.isCellCoord()){
				this.checkAutoHeightForCoord(null, range.getCoord(), false, true);
			}
			
			/*
			 * refresh UI
			 */
			var coord = [toSpan];
			
			/*
			 * set condition for toSpan
			 */
			this.syncConditonForCoord(coord, originCdts, cdtMap, oldCellCdtLookup);
			
            var coordPro = EnterpriseSheet.sheet.calculate.Coordinate.prototype;
           
            Ext.apply(reCalCells, coordPro.transferCoord2CellLookup(this.getRelatedCdtCoord(coord)));
			
            this.refreshRange(coord, reCalCells);
			
			this.fireEvent('stylebrush', range, fromCoord, this);
		}				
	},
	
	/**
	 * apply the data in a span to another span 
	 * @param {array} fromSpan: the fromSpan where we will copy the cell from
	 * @param {array} toSpan: the toSpan where we will paste the cell to
	 * @param {boolean} applyType: can be ['keep-style', 'keep-data', 'style', 'data', 'default'],
	 * "keep-style" means clear the target and apply style part of source to it
	 * "keep-data" means clear the target and apply data part of source to it
	 * "style" means only apply the style part to the target, and not change the data part of target; 
	 * "data" means only apply the data part, and not change the style part of target;
	 * "default" means copy the source to target, it will make the target as the same as source 
	 * @param {function} processData: the callback to let process the data before apply, the params for processData will be
	 * @param {boolean} bottomup: true to match from bottom to top or right to left
	 * @param {boolean} clearFlag: true to clear the from span
	 * @param {boolean} suspendRefresh: true to not refresh the span
	 */
	apply2Span : function(fromSpan, toSpan, applyType, processData, bottomup, clearFlag, suspendRefresh, refreshCalCdt){
		//console.log(Ext.encode(refreshCalCdt))
		var me = this;
		applyType = applyType || 'default';
		var store = this.getStore(), sheetId = this.getSheetId();
		var fsheet = fromSpan[0], fminrow = fromSpan[1], fmincol = fromSpan[2], fmaxrow = fromSpan[3], fmaxcol = fromSpan[4];
		var frlen = 0 == fmaxrow ? 0 : fmaxrow-fminrow+1, fclen = 0 == fmaxcol ? 0 : fmaxcol-fmincol+1;
		var tsheet = toSpan[0], tminrow = toSpan[1], tmincol = toSpan[2], tmaxrow = toSpan[3], tmaxcol = toSpan[4];			
		/*
		 * means the from and to span are the same
		 */
		if(fsheet == tsheet && fminrow == tminrow && fmincol == tmincol && fmaxrow == tmaxrow && fmaxcol == tmaxcol){			
			return;
		}
		var minrow = tminrow, mincol = tmincol, maxrow = tmaxrow, maxcol = tmaxcol;
		if(fminrow == tminrow && fmincol == tmincol){
			if(fmaxcol == tmaxcol){
				minrow = fmaxrow+1;				
			}else{
				mincol = fmaxcol+1;
			}			
		}else{
			if(fmincol == tmincol){
				maxrow = fminrow-1;
			}else{
				maxcol = fmincol-1;
			}
		}		
		/*
		 * a lookup cache and count for record the condition id,
		 * for condition cell, when we copy/paste, we need reset the id, because it could be different with
		 * the original condition, with the same id, we can not list them all in the condition manager
		 */
		var lookup = {};
		var fn = function(br2lt, callback, scope){	
			if(0 == maxrow || 0 == maxcol){
				store.walkRange([[tsheet, minrow, mincol, maxrow, maxcol]], function(rd){
					store.setCell(rd.data.sheet, rd.data.row, rd.data.col, {
						'tpl': rd.data.json.tpl
					}, null, true, 'clear');
				});
			}
			for(var i = minrow; i <= maxrow; i++){
				for(var j = mincol; j <= maxcol; j++){
					if(0 == i){						
						/*
						 * for column 
						 */
						var coff, c = j;
						if('r2l' == br2lt){
							coff = tmaxcol-j;
							c = fmaxcol-(coff%fclen);
						}else{
							coff = j-tmincol;
							c = (coff%fclen)+fmincol;
						}
						store.walkRange([[tsheet, 0, c, 0, c]], function(rd){
							var r = rd.data.row;							
							callback.call(scope, r, c, r, j);
						}, scope);
					}else if(0 == j){
						/*
						 * for row
						 */
						var roff, r = i;
						if('b2t' == br2lt){
							roff = tmaxrow-i;
							r = fmaxrow-(roff%frlen);
						}else{
							roff = i-tminrow;
							r = (roff%frlen)+fminrow;
						}
						
						store.walkRange([[tsheet, r, 0, r, 0]], function(rd){
							var c = rd.data.col;							
							callback.call(scope, r, c, i, c);
						}, scope);
					}else{
						var roff, r = i;
						if(0 != frlen){
							if('b2t' == br2lt){
								roff = tmaxrow-i;
								r = fmaxrow-(roff%frlen);
							}else{
								roff = i-tminrow;
								r = (roff%frlen)+fminrow;
							}
						}				
						var coff, c = j;
						if(0 != fclen){
							if('r2l' == br2lt){
								coff = tmaxcol-j;
								c = fmaxcol-(coff%fclen);
							}else{
								coff = j-tmincol;
								c = (coff%fclen)+fmincol;
							}
						}													
						callback.call(scope, r, c, i, j);
					}
				}
			}
			
			if(clearFlag){
				
				store.walkRange([fromSpan], function(rd){
					store.setCell(rd.data.sheet, rd.data.row, rd.data.col, null, null, true, 'clear');
				});								
			}
		}
        var refs = [];
		fn(bottomup, function(r, c, row, col){
			/*
			 * get the data from the cache
			 */
			var cd = store.getCellProperty(fsheet, r, c, true), curCd = store.getCellProperty(tsheet, row, col);		
			if(!store.isDisabledForMe(curCd.dsd)){
				cd = this.prepareForMoveCell(cd, tsheet, row, col, fsheet, r, c, lookup, applyType, true);
	            if(cd.cal && cd.refs){
	                refs = refs.concat(cd.refs);
	            }
				var flag = 'data' == applyType ? null : 'clear';
				if(!(fsheet === tsheet && r === row && c === col)){					
					if(('data' == applyType || 'default' == applyType) && 'function' == SCOM.typeOf(processData)){
						cd = processData(cd, row, col);
					}								
					if(0 == row || 0 == col){
						/*
						 * no data property for header or lefter
						 */
						delete(cd.data);
					}
					
					/*
					 * apply the data and changed style back
					 */										
					store.setCell(tsheet, row, col, cd, null, true, flag);
				}
			}
		}, this);
		/*
		 * update the cdt in the toSpan
		 */
		this.syncAutoExtendCdt(toSpan, fromSpan);
		var coord = [toSpan];
		
		if(clearFlag){
			coord.push(fromSpan);
		}
		if(!suspendRefresh){
			if(Ext.isObject(refreshCalCdt)){
				/*
				 * extend the recalculated cells
				 */				
				var reCalCells = this.getCalCdtCellsFromCoord([[tsheet, minrow, mincol, maxrow, maxcol]]);				
				
				Ext.applyIf(refreshCalCdt, reCalCells);
			}
            if(0 < refs.length){
                this.loadMask.show(SLANG['calculating'], this.calMaskDelayTime);
                store.checkLoadCoord(refs, function(){
                    var arr = refs.concat(coord);
                    this.refreshRange(arr, refreshCalCdt);
                    this.loadMask.hide();
                }, this);
            }else{
                /*
                 * refresh UI
                 */
                this.refreshRange(coord, refreshCalCdt);
            }
		}	
		return coord;
	},		
	
	/**
	 * split condition
	 */
	splitCdt : function(coord, originCdts){
		var me = this;
		var curSheetId = me.getSheetId();
		var store = me.getStore();
		var findIncludedSpan = EnterpriseSheet.sheet.range.Range.prototype.findIncludedSpan;
		var isCoordAIncludeCoordB = EnterpriseSheet.sheet.range.Range.prototype.isCoordAIncludeCoordB;
		var cdts = {};
		for(var p in originCdts){
			if(originCdts.hasOwnProperty(p)){
				cdts[p] = Ext.decode(originCdts[p].json);
			}
		}
        var lookup = {}, deleted = {}, remains = {};
        for(var p in cdts){
            if(cdts.hasOwnProperty(p)){
                var it = cdts[p], name = it.name, rng = it.rng, arr = [];
                for(var i = 0, len = rng.length; i < len; i++){
                    var span = rng[i].span;
                    arr.push(span);
                }
                if(isCoordAIncludeCoordB(coord, arr)){
                    deleted[p] = it;
                }else{
                    remains[p] = it;
                }
            }
        }
        if(0 < SCOM.countObjMember(remains)){
            store.walkRange(coord, function(rd){
                var sheetId = rd.data.sheet, row = rd.data.row, col = rd.data.col;
                for(var p in remains){
                    if(remains.hasOwnProperty(p)){
                        if(!lookup[p]){
                            lookup[p] = {};
                        }
                        var it = remains[p];
                        var found = findIncludedSpan(sheetId, row, col, it.rng);
                        if(found){
                            var cid = sheetId+'-'+row+'-'+col;
                            lookup[p][cid] = true;
                            it.rng.splice(found.index, 1);
                            var splitedSpans = me.splitSpanByRowCol(found.span, row, col);
                            if(splitedSpans && 0 < splitedSpans.length){
                                it.rng = it.rng.concat(splitedSpans);
                            }
                        }
                    }
                }
            });
            for(var p in remains){
                if(remains.hasOwnProperty(p)){
                    var cdt = remains[p];
                    cdt.rng = me.connectRowSpans(cdt.rng);
                    store.setFloatingItem(curSheetId, cdt.id, 'cdt', 0 < cdt.rng.length ? Ext.encode(cdt) : null);
                }
            }
        }
        for(var p in deleted){
            if(deleted.hasOwnProperty(p)){
                store.setFloatingItem(curSheetId, deleted[p].id, 'cdt');
            }
        }
	},
		
	/**
	 * _private 
	 * connect row spans, will try to connect the span with splited is "true", so we can reduce the span number in the rng property
	 */
	connectRowSpans : function(rng){
		var splited = [], others = [];
		for(var i = 0, len = rng.length; i < len; i++){
			var it = rng[i];
			if(it.splited){
				splited.push(it);
			}else{
				others.push(it);
			}
		}
		var found = true;
		while(found){
			found = false;
			for(var i = 0, len = splited.length; i < len; i++){
				var it = splited[i];
				if(it.splited){
					delete(it.splited);
					found = it;
					splited.splice(i, 1);
					break;
				}
			}
			if(found){
				splited = this.mergeRanges(splited, found.span);
			}
		}
		return others.concat(splited); 
	},
	
	/*
	 * connect the spans in the range array
	 */
	connectSpan : function(rng){
		for(var i = 0, len = rng.length; i < len; i++){
			var it = rng[i];
			it.splited = true;
		}
		var found = true;
		while(found){
			found = false;
			for(var i = 0, len = rng.length; i < len; i++){
				var it = rng[i];
				if(it.splited){
					delete(it.splited);
					found = it;
					rng.splice(i, 1);
					break;
				}
			}
			if(found){
				rng = this.mergeRanges(rng, found.span);
			}
		}
		return rng;
	},
	
	/**
	 * _private
	 * split a column span array by row index
	 * @param {array} span: the 5-tpl span array
	 * @param {int} col: the column index to split
	 * @return {array}: the splitted span array
	 */
	splitColSpanByRow : function(span, row){
		var sheetId = span[0], minrow = span[1], maxrow = span[3], mincol = span[2], maxcol = span[4];
		if(minrow == row && row == maxrow){
			return [];
		}
		if(0 === minrow){
			minrow = 1;
		}
		if(minrow == row){
			return [{
				span: [sheetId, minrow+1, mincol, maxrow, maxcol],
				type: SCONST['ABSOLUTE_COORD'],
				splited: true
			}];
		}
		if(maxrow == row){
			return [{
				span: [sheetId, minrow, mincol, maxrow-1, maxcol],
				type: SCONST['ABSOLUTE_COORD'],
				splited: true
			}];
		}
		return [{
			span: [sheetId, minrow, mincol, row-1, maxcol],
			type: SCONST['ABSOLUTE_COORD'],
			splited: true
		}, {
			span: [sheetId, row+1, mincol, maxrow, maxcol],
			type: SCONST['ABSOLUTE_COORD'],
			splited: true
		}];
	},
	
	/**
	 * _private
	 * split a row span array by col index
	 * @param {array} span: the 5-tpl span array
	 * @param {int} col: the column index to split
	 * @return {array}: the splitted span array
	 */
	splitRowSpanByCol : function(span, col){
		var sheetId = span[0], minrow = span[1], maxrow = span[3], mincol = span[2], maxcol = span[4];
		if(mincol == col && col == maxcol){
			return [];
		}
		if(0 === mincol){
			mincol = 1;
		}
		if(mincol == col){
			return [{
				span: [sheetId, minrow, mincol+1, maxrow, maxcol],
				type: SCONST['ABSOLUTE_COORD'],
				splited: true
			}];
		}
		if(maxcol == col){
			return [{
				span: [sheetId, minrow, mincol, maxrow, maxcol-1],
				type: SCONST['ABSOLUTE_COORD'],
				splited: true
			}];
		}
		return [{
			span: [sheetId, minrow, mincol, maxrow, col-1],
			type: SCONST['ABSOLUTE_COORD'],
			splited: true
		}, {
			span: [sheetId, minrow, col+1, maxrow, maxcol],
			type: SCONST['ABSOLUTE_COORD'],
			splited: true
		}];
	},
	
	/**
	 * _private
	 * split the passed span by row first, and then split the splitted row by col
	 * @param {array} span: the 5-tpl span array
	 * @param {int} row: the row index to split
	 * @param {int} col: the col index to split
	 * @return {array}: the new span array after splitted
	 */
	splitSpanByRowCol : function(span, row, col){
		var sheetId = span[0], minrow = span[1], maxrow = span[3], mincol = span[2], maxcol = span[4];
		/*
		 * means the span will be deleted
		 */
		if(minrow == row && row == maxrow && mincol == col && maxcol == col){
			return;
		}
		if(0 === minrow){
			minrow = 1;
		}
		var hitted = [sheetId, row, mincol, row, maxcol];
		var rowSpans = this.splitRowSpanByCol(hitted, col);
		var arr;
		if(minrow == row && row == maxrow){
			arr = rowSpans;
		}else{
			if(minrow == row){
				arr = rowSpans.concat([{
					span: [sheetId, minrow+1, mincol, maxrow, maxcol],
					type: SCONST['ABSOLUTE_COORD']
				}]);
			}else if(maxrow == row){
				arr = [{
					span: [sheetId, minrow, mincol, maxrow-1, maxcol],
					type: SCONST['ABSOLUTE_COORD']
				}].concat(rowSpans);
			}else{
				arr = [{
					span: [sheetId, minrow, mincol, row-1, maxcol],
					type: SCONST['ABSOLUTE_COORD']
				}].concat(rowSpans).concat([{
					span: [sheetId, row+1, mincol, maxrow, maxcol],
					type: SCONST['ABSOLUTE_COORD']
				}]);
			}
		}
		return arr;
	},
	
	/**
	 * _private
	 * split the passed span by column first, and then split the splitted column by row
	 * @param {array} span: the 5-tpl span array
	 * @param {int} row: the row index to split
	 * @param {int} col: the col index to split
	 * @return {array}: the new span array after splitted
	 */
	splitSpanByColRow : function(span, row, col){
		var sheetId = span[0], minrow = span[1], maxrow = span[3], mincol = span[2], maxcol = span[4];
		/*
		 * means the span will be deleted
		 */
		if(minrow == row && row == maxrow && mincol == col && maxcol == col){
			return;
		}
		if(0 === mincol){
			mincol = 1;
		}
		var hitted = [sheetId, minrow, col, maxrow, col];
		var colSpans = this.splitColSpanByRow(hitted, row);
		var arr;
		if(mincol == col && col == maxcol){
			arr = colSpans;
		}else{
			if(mincol == col){
				arr = colSpans.concat([{
					span: [sheetId, minrow, mincol+1, maxrow, maxcol],
					type: SCONST['ABSOLUTE_COORD']
				}]);
			}else if(maxcol == col){
				arr = [{
					span: [sheetId, minrow, mincol, maxrow, maxcol-1],
					type: SCONST['ABSOLUTE_COORD']
				}].concat(colSpans);
			}else{
				arr = [{
					span: [sheetId, minrow, mincol, maxrow, col-1],
					type: SCONST['ABSOLUTE_COORD']
				}].concat(colSpans).concat([{
					span: [sheetId, minrow, col+1, maxrow, maxcol],
					type: SCONST['ABSOLUTE_COORD']
				}]);
			}
		}
		return arr;
	},
	
	/**
	 * _private
	 */
	syncAutoExtendCdt : function(toSpan, fromSpan, oldCdts){
		var coord = [toSpan];
		var me = this;
		var curSheetId = me.getSheetId();
		var store = me.getStore();
		var relatedCdts = {}, cdtNewRng = {};
        var fromSheetId = fromSpan[0], fromRowSpan = fromSpan[3]-fromSpan[1]+1, fromColSpan = fromSpan[4]-fromSpan[2]+1;
		store.walkRange(coord, function(rd){
			var sheetId = rd.data.sheet, row = rd.data.row, col = rd.data.col;
            var rowOff = row-toSpan[1], colOff = col-toSpan[2];
            var oldRow = fromSpan[1]+rowOff%fromRowSpan, oldCol = fromSpan[2]+colOff%fromColSpan;
			var cdt = me.getCdtFloatingOfCell(fromSheetId, oldRow, oldCol);
			if(0 < cdt.length){				
				for(var i = 0, len = cdt.length; i < len; i++){
					var it = cdt[i];
					var id = it.name;
					if(!relatedCdts[id]){
						var found = it.jsonObj;
						if(!found && oldCdts){
							var old = oldCdts[id];
							found = Ext.decode(old.json);
							found.rng = [];
						}
						relatedCdts[id] = found;
					}
					if(!cdtNewRng[id]){
						cdtNewRng[id] = [];
					}
					var included = false;
					var rng = relatedCdts[id].rng;
					for(var j = 0, count = rng.length; j < count; j++){
						var span = rng[j].span;
						if(span[1] <= row && (row <= span[3] || 0 == span[3]) && span[2] <= col && (col <= span[4] || 0 == span[4])){
							included = true;
							break;
						}
					}
					if(!included){
						cdtNewRng[id].push([sheetId, row, col]);
					}
				}
			}			
		});
		
		for(var p in cdtNewRng){
			if(cdtNewRng.hasOwnProperty(p)){
				var it = cdtNewRng[p];
				var minrow = false, maxrow = false, mincol = false, maxcol = false;
				for(var i = 0, len = it.length; i < len; i++){
					var span = it[i];
					if(false === minrow){
						minrow = span[1];
					}else if(minrow > span[1]){
						minrow = span[1];
					}
					if(false === maxrow){
						maxrow = span[1];
					}else if(0 !== maxrow && maxrow < span[1]){
						maxrow = span[1];
					}
					if(false === mincol){
						mincol = span[2];
					}else if(mincol > span[2]){
						mincol = span[2];
					}
					if(false === maxcol){
						maxcol = span[2];
					}else if(0 !== maxcol && maxcol < span[2]){
						maxcol = span[2];
					}
				}
				var rngs = relatedCdts[p].rng;
				
				relatedCdts[p].rng = this.mergeRanges(rngs, [curSheetId, minrow, mincol, maxrow, maxcol]);
			}
		}
		//console.log(Ext.encode(relatedCdts))
		for(var p in relatedCdts){
			if(relatedCdts.hasOwnProperty(p)){
				var it = relatedCdts[p];
				store.setFloatingItem(curSheetId, it.id, 'cdt', Ext.encode(it));
			}
		}
	},
	
	/**
	 * _private
	 * merge the rangs as much as it can 
	 */
	mergeRanges : function(rngs, newSpan){
		var merged = false, changed = true;
		var minrow = newSpan[1], maxrow = newSpan[3], mincol = newSpan[2], maxcol = newSpan[4];
		while(changed){
			changed = false;
			for(var i = 0, len = rngs.length; i < len; i++){
				var span = rngs[i].span;
				if(span[2] == mincol && span[4] == maxcol){
					if(span[1] <= minrow){
						if(0 === span[3] || span[3] >= minrow-1){
							merged = true;
							changed = true;
							minrow = span[1];
							if(0 === span[3] || 0 === maxrow){
								maxrow = 0;
							}else if(span[3] > maxrow){
								maxrow = span[3];
							}
							rngs.splice(i, 1);
							break;
						}
					}else{
						if(0 === maxrow || maxrow >= span[1]-1){
							merged = true;
							changed = true;
							if(0 === span[3] || 0 === maxrow){
								maxrow = 0;
							}else if(span[3] > maxrow){
								maxrow = span[3];
							}
							rngs.splice(i, 1);
							break;							
						}
					}
					/*
					if(span[3] >= minrow-1 && 0 !== span[3] && span[3] < maxrow){
						span[3] = maxrow;
						merged = true;
						changed = true;
						if(span[1] < minrow){
							minrow = span[1];
						}
						rngs.splice(i, 1);
						break;
					}else if(span[1] == maxrow+1 && 0 !== maxrow && span[1] > minrow){
						span[1] = minrow;
						merged = true;
						changed = true;
						maxrow = span[3];
						rngs.splice(i, 1);
						break;
					}*/
				}else if(span[1] == minrow && span[3] == maxrow){
					if(span[2] <= mincol){
						if(0 === span[4] || span[4] >= mincol-1){
							merged = true;
							changed = true;
							mincol = span[2];
							if(0 === span[4] || 0 === maxcol){
								maxcol = 0;
							}else if(span[4] > maxcol){
								maxcol = span[4];
							}
							rngs.splice(i, 1);
							break;
						}
					}else{
						if(0 === maxcol || maxcol >= span[2]-1){
							merged = true;
							changed = true;
							if(0 === span[4] || 0 === maxcol){
								maxcol = 0;
							}else if(span[4] > maxcol){
								maxcol = span[4];
							}
							rngs.splice(i, 1);
							break;							
						}
					}
					/*
					if(span[4] == mincol-1 && 0 !== span[4] && span[4] < maxcol){
						span[4] = maxcol;
						merged = true;
						changed = true;
						mincol = span[2];
						rngs.splice(i, 1);
						break;
					}else if(span[2] == maxcol+1 && 0 !== maxcol && span[2] > mincol){
						span[2] = mincol;
						merged = true;
						changed = true;
						maxcol = span[4];
						rngs.splice(i, 1);
						break;
					}*/
				}
			}
		}
		if(false !== minrow){
			var obj = {
				span: [newSpan[0], minrow, mincol, maxrow, maxcol],
				type: SCONST['ABSOLUTE_COORD']
			};
			rngs.push(obj);
		}
		return rngs;
	},		
	
	/*
	 * prepare the cell data for move to another cell 
	 * @param {boolean} skipResetCondition: true to skip reset the condition cells for the move
	 */
	prepareForMoveCell : function(cell, nowSheetId, nowRow, nowCol, oldSheetId, oldRow, oldCol, lookup, prepareType, skipResetCondition){
		cell = Ext.apply({}, cell);
		var store = this.getStore();
		lookup = lookup || {};		
		var nowCell = store.getCell(nowSheetId, nowRow, nowCol);
		
		if(this.isCalculateCell(cell)){
			/*
			 * if it's a calculate cell, we need update the cell.data, cause we moved the cell
			 */			
			var o = this.resetCalculateCellData(cell, nowSheetId, nowRow, nowCol, oldSheetId, oldRow, oldCol, undefined, 'reverse' == prepareType);			
			Ext.apply(cell, o);
		}
		
		/*
		 * can not auto fill the tpl property, always use the original tpl property
		 */
		cell.tpl = nowCell.tpl;
		if(!cell.tpl){
			delete(cell.tpl);
		}
		/*
		 * process item stuff
		 */
		delete(cell.itchk);
		
		if(0 !== nowRow){			
			for(var p in EnterpriseSheet.sheet.data.Store.colProperties){
				if(EnterpriseSheet.sheet.data.Store.colProperties.hasOwnProperty(p)){
					delete(cell[p]);
				}
			}
		}
		if(0 !== nowCol){
			for(var p in EnterpriseSheet.sheet.data.Store.rowProperties){
				if(EnterpriseSheet.sheet.data.Store.rowProperties.hasOwnProperty(p)){
					delete(cell[p]);
				}
			}
		}
		/*
		 * the data/value properties
		 */
		var arr = ['data', 'cal', 'arg', 'value', 'timestamp', 'cdt', 'tpl', 'itms'].concat(EnterpriseSheet.sheet.calculate.Condition.styles);
		var withoutCdt = ['data', 'cal', 'arg', 'value', 'timestamp', 'tpl', 'itms'].concat(EnterpriseSheet.sheet.calculate.Condition.styles);
		
		if('keep-style' == prepareType){
			/*
			 * only apply style part
			 * remove the data/values first
			 */
			for(var k = 0, len = arr.length; k < len; k++){
				delete(cell[arr[k]]);
			}
		}else if('keep-data' == prepareType){
			cell = Ext.copyTo({}, cell, arr);
		}else if('style' == prepareType){
			/*
			 * only apply style part
			 * remove the data/values first
			 */
			for(var k = 0, len = arr.length; k < len; k++){
				delete(cell[arr[k]]);
			}
			/*
			 * keep the data/value of itself
			 */							
			Ext.copyTo(cell, nowCell, arr);
		}else if('style-cdt' == prepareType){
			/*
			 * only apply style part
			 * remove the data/values first
			 */
			for(var k = 0, len = withoutCdt.length; k < len; k++){
				delete(cell[withoutCdt[k]]);
			}
			/*
			 * keep the data/value of itself
			 */							
			Ext.copyTo(cell, nowCell, withoutCdt);
		}else if('data' == prepareType){
			/*
			 * only apply the data part
			 */						
			cell = Ext.copyTo({}, cell, arr);;			
		}
		/*
		 * need avoid some properties for header and lefter
		 */
		var avoidProperties = ['ticon'];
		if(0 == nowRow || 0 == nowCol){
			avoidProperties = avoidProperties.concat(['minrow', 'mincol', 'maxrow', 'maxcol', 'abminrow', 'abmincol', 'abmaxrow', 'abmaxcol']);
		}
		if(0 != oldRow){
			avoidProperties = avoidProperties.concat(['width', 'woff']);
		}
		if(0 != oldCol){
			avoidProperties = avoidProperties.concat(['height', 'hoff']);
		}
		for(var k = 0, size = avoidProperties.length; k < size; k++){
			delete(cell[avoidProperties[k]]);
		}
		return cell;
	},
	
	/*
	 * get the filter of this sheet if have
	 */
	getFilter : function(){
		if(this.filter){
			return this.filter;
		}
	},
	
	/*
	 * before process the border in store
	 */
	beforeProcessBorder : function(sheetId, row, col, cell, store){
		var scope = {
			store: store,
			sheet: sheetId,
			row: row,
			col: col
		};
		if(true !== cell.cdtVal){
			this.processCondition(cell, scope);
		}
		this.processTableTpl(cell, scope);		
	},
	
	/*
	 * set the property or remove property for the selection range, and refresh the UI to show
	 * @param {object} modified: the property set which need modified for selection range
	 * @param {array} deleted: the array of propertys which need removed from selection range
	 * @param {boolean} suspendRefresh: a flag to suspend the refresh action for ss
	 * @param {boolean} suspendEvent: a flag to suspend the event for ss
	 */
	setPropertyForSelection : function(modified, deleted, suspendRefresh, suspendEvent){		
		var sm = this.getSelectionModel();    	
    	var coord = sm.selection2Coord();    		
		var range = new EnterpriseSheet.sheet.range.Range({
    		sheet:this,
    		coord:coord
    	});
		range.setProperty(modified, deleted, suspendRefresh, suspendEvent);
		this.focus(this.focusDelayTime);
	},	
	
	/*
	 * insert the range at the selection position, it could insert cell/row/column, which depends on the selection
	 */
	insertRange : function(){						
		var sheetId = this.getSheetId();
		var store = this.getStore();
		var sm = this.getSelectionModel();
		var pos = sm.getMinMaxPos();	
		var minrow = pos.minrow, maxrow = pos.maxrow, mincol = pos.mincol, maxcol = pos.maxcol;
		var rowSpan = maxrow-minrow+1, colSpan = maxcol-mincol+1;	
		if(0 == minrow && 0 == mincol){
			return;
		}else if(0 == minrow){
			this.insertColumn();
		}else if(0 == mincol){
			this.insertRow();
		}else{					
			this.insertCell();
		}
	},	
	
	/**
	 * insert cell and move to right
	 */
	insertCellMoveRight : function(sheetId, pos, insertCellCache){
		var dir = 'right';
		var store = this.getStore();
		var minrow = pos.minrow, maxrow = pos.maxrow, mincol = pos.mincol, maxcol = pos.maxcol;
		var rowSpan = maxrow-minrow+1, colSpan = maxcol-mincol+1;
		
		var brokenMergeFlag = store.withBrokenMergedCell([[sheetId, minrow, mincol, maxrow, 0]]);
		if(!brokenMergeFlag){
			var brokenTplFlag = store.withBrokenTplCell([[sheetId, minrow, mincol, maxrow, 0]]);
			if(!brokenTplFlag){
				this.doInsertCellMoveRight(sheetId, pos, insertCellCache);
			}else{
				Ext.Msg.alert(SLANG['hint'], SLANG['broken_tpl_cell_hint']);
			}			
		}else{
			Ext.Msg.alert(SLANG['hint'], SLANG['broken_merge_cell_hint']);
		}		
	},
	
	doInsertCellMoveRight : function(sheetId, pos, insertCellCache){
		var dir = 'right';
		var store = this.getStore();
		var minrow = pos.minrow, maxrow = pos.maxrow, mincol = pos.mincol, maxcol = pos.maxcol;
		var rowSpan = maxrow-minrow+1, colSpan = maxcol-mincol+1;
		
		store.insertCell(sheetId, minrow, mincol, rowSpan, colSpan, dir, undefined, insertCellCache);
		var relatedRows = this.getRelatedRowsForAutoHeight([[sheetId, minrow, mincol, maxrow, 0]], undefined, undefined, true);
		var changedHeights = this.checkAutoHeightForRows(relatedRows);
		this.fireEvent('cellinserted', sheetId, minrow, mincol, rowSpan, colSpan, dir, changedHeights, this);
		/*
		 * refocus the cell
		 */
		this.refreshFocus();
	},
	
	/**
	 * insert cell and move to bottom
	 */
	insertCellMoveBottom : function(sheetId, pos, insertCellCache){
		var dir = 'bottom';
		var store = this.getStore();
		var minrow = pos.minrow, maxrow = pos.maxrow, mincol = pos.mincol, maxcol = pos.maxcol;
		var rowSpan = maxrow-minrow+1, colSpan = maxcol-mincol+1;
		
		var brokenMergeFlag = store.withBrokenMergedCell([[sheetId, minrow, mincol, 0, maxcol]]);
		if(!brokenMergeFlag){
			var brokenTplFlag = store.withBrokenTplCell([[sheetId, minrow, mincol, 0, maxcol]]);
			if(!brokenTplFlag){
				this.doInsertCellMoveBottom(sheetId, pos, insertCellCache);
			}else{
				Ext.Msg.alert(SLANG['hint'], SLANG['broken_tpl_cell_hint']);
			}			
		}else{
			Ext.Msg.alert(SLANG['hint'], SLANG['broken_merge_cell_hint']);
		}		
	},
	
	doInsertCellMoveBottom : function(sheetId, pos, insertCellCache){
		var dir = 'bottom';
		var store = this.getStore();
		var minrow = pos.minrow, maxrow = pos.maxrow, mincol = pos.mincol, maxcol = pos.maxcol;
		var rowSpan = maxrow-minrow+1, colSpan = maxcol-mincol+1;
		
		var relatedRows = this.getRelatedRowsForAutoHeight([[sheetId, minrow, mincol, 0, maxcol]], undefined, undefined, true);
		store.insertCell(sheetId, minrow, mincol, rowSpan, colSpan, dir, undefined, insertCellCache);
		Ext.applyIf(relatedRows, this.getRelatedRowsForAutoHeight([[sheetId, minrow, mincol, 0, maxcol]], undefined, undefined, true));
		var changedHeights = this.checkAutoHeightForRows(relatedRows);
		this.fireEvent('cellinserted', sheetId, minrow, mincol, rowSpan, colSpan, dir, changedHeights, this);
		/*
		 * refocus the cell
		 */
		this.refreshFocus();
	},
	
	
	/*
	 * for insert cell at the selection position, the rest cell will move right
	 */	
	insertCell : function(sheetId, pos, insertCellCache){
		if(SCOM.nullOrUndefined(sheetId)){
			sheetId = this.getSheetId();
		}
		
		var store = this.getStore();
		var sm = this.getSelectionModel();
		if(!pos){
			pos = sm.getMinMaxPos();
		}					
		var minrow = pos.minrow, maxrow = pos.maxrow, mincol = pos.mincol, maxcol = pos.maxcol;
		var rowSpan = maxrow-minrow+1, colSpan = maxcol-mincol+1;	
		if(0 == minrow || 0 == mincol){
			return;
		}else if(SPOP){
			/*
			 * call option window to let user choose an option
			 * and do the related action
			 */	
			SPOP.showInsertCellOption({
				applyCallback:{
					fn:function(opt){					
						if(opt < 2){
							var dir = 0 == opt?'bottom':'right';
							if('right' == dir){
								this.insertCellMoveRight(sheetId, pos, insertCellCache);
							}else{
								this.insertCellMoveBottom(sheetId, pos, insertCellCache);
							}	
						}else if(2 == opt){
							this.doInsertRow(sheetId, minrow, rowSpan, undefined, insertCellCache);
						}else if(3 == opt){
							this.doInsertColumn(sheetId, mincol, colSpan, undefined, insertCellCache);
						}						
					},
					scope:this
				}
			});	
		}	
	},
	
	/*
	 * insert row(s) at the selection position, the number of insert rows depend on how many rows are selected
	 */
	insertRow : function(){				
		var sheetId = this.getSheetId();
		var store = this.getStore();
		var sm = this.getSelectionModel();
		var pos = sm.getMinMaxPos();	
		var minrow = pos.minrow, maxrow = pos.maxrow;
		var span = maxrow-minrow+1;
		if(minrow < 1){
			minrow = 1;
		}
		this.doInsertRow(sheetId, minrow, span);		
	},
	
	doInsertRow : function(sheetId, row, span, suspendEvent, insertCellCache){
		var store = this.getStore();
		
		store.insertRow(sheetId, row, span, suspendEvent, insertCellCache);
		/*
		 * refocus the cell
		 */
		this.refreshFocus();
	},
	
	/*
	 * insert column(s) at the selection position, the number of insert columns depend on how many columns are selected
	 */
	insertColumn : function(){			
		var sheetId = this.getSheetId();
		var store = this.getStore();
		var sm = this.getSelectionModel();
		var pos = sm.getMinMaxPos();	
		var mincol = pos.mincol, maxcol = pos.maxcol;
		var span = maxcol-mincol+1;
		if(mincol < 1){
			mincol = 1;
		}
		this.doInsertColumn(sheetId, mincol, span);		
	},	
	
	doInsertColumn : function(sheetId, col, span, suspendEvent, insertCellCache){
		var store = this.getStore();
		
		store.insertColumn(sheetId, col, span, suspendEvent, insertCellCache);
		/*
		 * refocus the cell
		 */
		this.refreshFocus();
	},
	
	/*
	 * delete the selection range, it could be cell/row/column
	 */ 
	deleteRange : function(){
		var sheetId = this.getSheetId();
		var store = this.getStore();

		var sm = this.getSelectionModel();
		var pos = sm.getMinMaxPos();	
		var minrow = pos.minrow, maxrow = pos.maxrow, mincol = pos.mincol, maxcol = pos.maxcol;
		if(0 == minrow && 0 == mincol){
			return;
		}else if(0 == minrow){
			this.deleteColumn({
				mincol: mincol, 
				maxcol: maxcol
			});
		}else if(0 == mincol){
			this.deleteRow({
				minrow: minrow,
				maxrow: maxrow
			});			
		}else{
			//store.removeCell(sheetId, minrow, maxrow, mincol, maxcol, 'left');
			this.deleteCell();
		}		
	},
	
	/**
	 * delete the cells and move left
	 */
	deleteCellMoveLeft : function(sheetId, pos){
		var dir = 'left';
		if(SCOM.nullOrUndefined(sheetId)){
			sheetId = this.getSheetId();
		}
		var store = this.getStore();
		var minrow = pos.minrow, maxrow = pos.maxrow, mincol = pos.mincol, maxcol = pos.maxcol;
		var brokenMergeFlag = store.withBrokenMergedCell([[sheetId, minrow, mincol, maxrow, 0]]);
		
		if(!brokenMergeFlag){
			var brokenTplFlag = store.withBrokenTplCell([[sheetId, minrow, mincol, maxrow, 0]]);
			if(!brokenTplFlag){				
				this.doDeleteCellMoveLeft(sheetId, minrow, maxrow, mincol, maxcol);				
			}else{
				Ext.Msg.alert(SLANG['hint'], SLANG['broken_tpl_cell_hint']);
			}
		}else{
			Ext.Msg.alert(SLANG['hint'], SLANG['broken_merge_cell_hint']);
		}		
	},
	
	doDeleteCellMoveLeft : function(sheetId, minrow, maxrow, mincol, maxcol){
		var dir = 'left';
		var store = this.getStore();		
		var relatedRows = this.getRelatedRowsForAutoHeight([[sheetId, minrow, mincol, maxrow, 0]], undefined, undefined, true);
		store.removeCell(sheetId, minrow, maxrow, mincol, maxcol, dir);
		var changedHeights = this.checkAutoHeightForRows(relatedRows);
		this.fireEvent('cellremoved', sheetId, minrow, mincol, maxrow, maxcol, dir, changedHeights, this);
		/*
		 * refocus the cell
		 */
		this.refreshFocus();
	},
	
	/**
	 * delete the cells and move top
	 */
	deleteCellMoveTop : function(sheetId, pos){
		var dir = 'top';
		if(SCOM.nullOrUndefined(sheetId)){
			sheetId = this.getSheetId();
		}
		var store = this.getStore();
		var minrow = pos.minrow, maxrow = pos.maxrow, mincol = pos.mincol, maxcol = pos.maxcol;
		var brokenMergeFlag = store.withBrokenMergedCell([[sheetId, minrow, mincol, 0, maxcol]]);
		
		if(!brokenMergeFlag){
			var brokenTplFlag = store.withBrokenTplCell([[sheetId, minrow, mincol, 0, maxcol]]);
			if(!brokenTplFlag){			
				this.doDeleteCellMoveTop(sheetId, minrow, maxrow, mincol, maxcol);				
			}else{
				Ext.Msg.alert(SLANG['hint'], SLANG['broken_tpl_cell_hint']);
			}			
		}else{
			Ext.Msg.alert(SLANG['hint'], SLANG['broken_merge_cell_hint']);
		}
	},
	
	doDeleteCellMoveTop : function(sheetId, minrow, maxrow, mincol, maxcol){
		var dir = 'top';
		var store = this.getStore();
		
		var relatedRows = this.getRelatedRowsForAutoHeight([[sheetId, minrow, mincol, 0, maxcol]], undefined, undefined, true);
		store.removeCell(sheetId, minrow, maxrow, mincol, maxcol, dir);
		Ext.applyIf(relatedRows, this.getRelatedRowsForAutoHeight([[sheetId, minrow, mincol, 0, maxcol]], undefined, undefined, true));
		var changedHeights = this.checkAutoHeightForRows(relatedRows);
		this.fireEvent('cellremoved', sheetId, minrow, mincol, maxrow, maxcol, dir, changedHeights, this);
		/*
		 * refocus the cell
		 */
		this.refreshFocus();
	},
           
    deleteCellRangesMoveTop : function(ranges){
		var dir = 'top';
        var sheetId = this.getSheetId();
        var store = this.getStore();
        for(var i = 0, len = ranges.length; i < len; i++){
            var pos = ranges[i];
            var minrow = pos.minrow, maxrow = pos.maxrow, mincol = pos.mincol, maxcol = pos.maxcol;
            if(store.withBrokenMergedCell([[sheetId, minrow, mincol, 0, maxcol]])){
                Ext.Msg.alert(SLANG['hint'], SLANG['broken_merge_cell_hint']);
                return false;
            }
            if(store.withBrokenTplCell([[sheetId, minrow, mincol, 0, maxcol]])){
                Ext.Msg.alert(SLANG['hint'], SLANG['broken_tpl_cell_hint']);
                return false;
            }
        }
        this.doDeleteCellRangesMoveTop(ranges);
    },
    
    doDeleteCellRangesMoveTop : function(ranges){
    	var dir = 'top';
    	var sheetId = this.getSheetId();
    	var store = this.getStore();
    	if(false !== this.fireEvent('beforedeletecellrangemovetop', ranges, this)){
            this.fireEvent('preparedeletecellrangemovetop', ranges, this)
            var count = 0;
            for(var i = 0, len = ranges.length; i < len; i++){
                var pos = ranges[i];
                var minrow = pos.minrow-count, maxrow = pos.maxrow-count, mincol = pos.mincol, maxcol = pos.maxcol;
                var relatedRows = this.getRelatedRowsForAutoHeight([[sheetId, minrow, mincol, 0, maxcol]], undefined, undefined, true);
                store.removeCell(sheetId, minrow, maxrow, mincol, maxcol, dir);
                Ext.applyIf(relatedRows, this.getRelatedRowsForAutoHeight([[sheetId, minrow, mincol, 0, maxcol]], undefined, undefined, true));
                var changedHeights = this.checkAutoHeightForRows(relatedRows);
                this.fireEvent('cellremoved', sheetId, minrow, mincol, maxrow, maxcol, dir, changedHeights, this);
                count += (maxrow-minrow+1);
            }
            this.fireEvent('deletecellrangemovetop', ranges, this);            
        }
    	/*
		 * refocus the cell
		 */
		this.refreshFocus();
    },
	
	/**
	 * delete the selected cells, and the rest cells can be move up or left
	 */
	deleteCell : function(){			
		var sheetId = this.getSheetId();
		var store = this.getStore();
		var sm = this.getSelectionModel();
		var pos = sm.getMinMaxPos();	
		var minrow = pos.minrow, maxrow = pos.maxrow, mincol = pos.mincol, maxcol = pos.maxcol;
		if(0 == minrow || 0 == mincol){
			return;
		}else if(SPOP){
			/*
			 * call option window to let user choose an option
			 * and do the related action
			 */	
			SPOP.showRemoveCellOption({
				applyCallback:{
					fn:function(opt){					
						if(opt < 2){
							var dir = 1 == opt?'left':'top';
							if('left' == dir){
								this.deleteCellMoveLeft(sheetId, pos);
							}else{
								this.deleteCellMoveTop(sheetId, pos);
							}
							
						}else if(2 == opt){
							this.deleteRow({
								minrow: minrow,
								maxrow: maxrow
							});							
						}else if(3 == opt){
							this.deleteColumn({
								mincol: mincol,
								maxcol: maxcol
							});							
						}
						/*
						 * refocus the cell
						 */
						this.refreshFocus();
					},
					scope:this
				}	 
			});	
		}
	},
	
	/*
	 * delete the selected rows
	 */
	deleteRow : function(pos){			
		var sheetId = this.getSheetId();
		var store = this.getStore();
		var sm = this.getSelectionModel();
		if(!pos){			
			pos = sm.getMinMaxPos();
		}		
		var minrow = pos.minrow, maxrow = pos.maxrow;
		if(minrow < 1){
			minrow = 1;
		}
		if(maxrow < 1){
			maxrow = 1;
		}
		store.removeRow(sheetId, minrow, maxrow);
		/*
		 * refocus the cell
		 */
		this.refreshFocus();
	},
           
    deleteRows : function(deleted){
        if(false !== this.fireEvent('beforedeleterows', deleted, this)){
            this.fireEvent('preparedeleterows', deleted, this);
            var store = this.getStore(), sheetId = this.getSheetId();
            for(var i = 0, len = deleted.length; i < len; i++){
                var r = deleted[i]-i;
                store.removeRow(sheetId, r, r);
            }
            this.fireEvent('deleterows', deleted, this)
        }
        /*
         * refocus the cell
         */
        this.refreshFocus();
    },
	 
	/*
	 * delete the selected columns
	 */
	deleteColumn : function(pos){		 	
	 	var sheetId = this.getSheetId();
		var store = this.getStore();
		var sm = this.getSelectionModel();
		if(!pos){			
			pos = sm.getMinMaxPos();
		}		
		var mincol = pos.mincol, maxcol = pos.maxcol;
		if(mincol < 1){
			mincol = 1;
		}
		if(maxcol < 1){
			maxcol = 1;
		}
		
		var relatedRows = this.getRelatedRowsForAutoHeight([[sheetId, 0, mincol, 0, maxcol]], undefined, undefined, true, true);
		
		store.removeColumn(sheetId, mincol, maxcol);
		
		var changedHeights = this.checkAutoHeightForRows(relatedRows);
		
		this.fireEvent('columnremoved', sheetId, pos.mincol, pos.maxcol, changedHeights, this);
		/*
		 * refocus the cell
		 */
		this.refreshFocus();
	},
	
	/*
	 * for set row height for the selected rows
	 * @param {int} h: the height to set
	 * @param {object} pos: the row pos to set, if null then use the current selection
	 */
	setRowHeight : function(h, pos){		
		var sheetId = this.getSheetId();
		var store = this.getStore();
		var sm = this.getSelectionModel();
		if(!pos){
			pos = sm.getMinMaxPos();
		}		
		var minrow = pos.minrow, maxrow = pos.maxrow, old = {}, cur = {};										
		if(0 == minrow){	
			/*
			 * for column selection, it means all row height will be changed
			 */																 
			if(5 > h){
				h = 5;
			} 
			h = store.correctRenderHeight(h);
            var cornerPro = store.getCell(sheetId, 0, 0);
            if(cornerPro.height === h){
                return;
            }
			/*
			 * set old and cur for event
			 */
            old[0] = {
                height: cornerPro.height
            };
			cur[0] = h;
			store.setWhole(sheetId, {
				height:h
			}, null, true);
           
			/*
			 * refresh UI
			 */
			this.refreshRange();
			sm.refreshSelection();
		}else{				
			if(0 >= h){
				/*
				 * set old and cur for event
				 */
				for(var i = minrow; i <= maxrow; i++){
					old[i] = true;
					cur[i] = false;
				}
				store.hideRow(sheetId, minrow, maxrow, true);
				/*
				 * refresh UI
				 */
				this.refreshRange();
				sm.refreshSelection();
			}else{
				if(minrow == maxrow){
					/*
					 * set old and cur for event
					 */
					var oh = store.getRowHeight(sheetId, minrow);
					if(oh != h){
						var rowPro = store.getCell(sheetId, minrow, 0);
						old[minrow] = {
							'height': rowPro.height,
							'autoHeight': rowPro.autoHeight,
							'hoff': rowPro.hoff		
						};
						cur[minrow] = h;
						store.setRowHeight(sheetId, minrow, h, true);
					}
				}else{
					for(var i = minrow; i <= maxrow; i++){
						/*
						 * set old and cur for event
						 */
						var oh = store.getRowHeight(sheetId, i);
						var rowPro = store.getCell(sheetId, i, 0);
						old[i] = {
							'height': rowPro.height,
							'autoHeight': rowPro.autoHeight,
							'hoff': rowPro.hoff		
						};
						cur[i] = h;
						store.setRowHeight(sheetId, i, h, true, true);
					}
					/*
					 * refresh UI
					 */
					this.refreshRange();
					sm.refreshSelection();
				}
			}
		}
		/*
		 * fire rowresized event
		 */
		this.fireEvent('rowresized', maxrow, old, cur, this);
	},
	
	/*
	 * set the column width for selected columns
	 * @param {int} w: the width to set
	 * @param {object} pos: the column pos to set, if null then use the current selection
	 */
	setColumnWidth : function(w, pos){								
		var sheetId = this.getSheetId();
		var store = this.getStore();
		var sm = this.getSelectionModel();
		if(!pos){			
			pos = sm.getMinMaxPos();
		}
		var mincol = pos.mincol, maxcol = pos.maxcol, old = {}, cur = {};			
		if(0 == mincol){						
			/*
			 * for row selection, it means all column width will be changed
			 */						
			if(5 > w){
				w = 5;
			} 
			w = store.correctRenderWidth(w);
            var cornerPro = store.getCell(sheetId, 0, 0);
            if(cornerPro.width === w){
                return;
            }
			/*
			 * set old and cur for event
			 */
            old[0] = cornerPro.width;
			cur[0] = w;
			store.setWhole(sheetId, {
				width:w
			}, null, true);
			/*
			 * refresh UI
			 */
			this.refreshRange();
			sm.refreshSelection();
		}else{		
			if(0 >= w){		
				/*
				 * set old and cur for event
				 */
				for(var i = mincol; i <= maxcol; i++){
					old[i] = true;
					cur[i] = false;
				}
				store.hideColumn(sheetId, mincol, maxcol, true);
				/*
				 * refresh UI
				 */
				this.refreshRange();
				sm.refreshSelection();
			}else{
				if(mincol == maxcol){
					/*
					 * set old and cur for event
					 */
					old[mincol] = store.getColWidth(sheetId, mincol);
					cur[mincol] = w;
					store.setColumnWidth(sheetId, mincol, w, true);
				}else{
					for(var i = mincol; i <= maxcol; i++){
						/*
						 * set old and cur for event
						 */
						old[i] = store.getColWidth(sheetId, i);
						cur[i] = w;
						store.setColumnWidth(sheetId, i, w, true, true);
					}
					/*
					 * refresh UI
					 */
					this.refreshRange();
					sm.refreshSelection();
				}	
			}
		}
		/*
		 * fire columnresized event
		 */
		this.fireEvent('columnresized', maxcol, old, cur, this);
	},

	/*
	 * hide selected rows
	 */ 
	hideRow : function(pos, sheetId){
        if(!Ext.isDefined(sheetId)){
            sheetId = this.getSheetId();
        }
		var store = this.getStore();
		if(!pos){
			var sm = this.getSelectionModel();
			pos = sm.getMinMaxPos();
		}		
		var minrow = pos.minrow, maxrow = pos.maxrow;
		if(minrow < 1){
			minrow = 1;
		}
		if(maxrow < 1){
			maxrow = 1;
		}
		var visibles = store.hideRow(sheetId, minrow, maxrow);
		this.fireEvent('rowhide', sheetId, minrow, maxrow, visibles, this);
		
		this.checkLefterWidth();
		return visibles;
	},
	
	/*
	 * hide selected columns
	 */
	hideColumn : function(pos, sheetId){
        if(!Ext.isDefined(sheetId)){
            sheetId = this.getSheetId();
        }
		var store = this.getStore();
		if(!pos){
			var sm = this.getSelectionModel();
			pos = sm.getMinMaxPos();
		}		
		var mincol = pos.mincol, maxcol = pos.maxcol;
		if(mincol < 1){
			mincol = 1;
		}
		if(maxcol < 1){
			maxcol = 1;
		}
		var visibles = store.hideColumn(sheetId, mincol, maxcol);
		this.fireEvent('columnhide', sheetId, mincol, maxcol, visibles, this);			
		return visibles;
	},
	
	/*
	 * show all the rows in the selection
	 */
	showRow : function(pos, sheetId){
        if(!Ext.isDefined(sheetId)){
            sheetId = this.getSheetId();
        }
		var store = this.getStore();
		if(!pos){
			var sm = this.getSelectionModel();
			pos = sm.getMinMaxPos();
		}		
		var minrow = pos.minrow, maxrow = pos.maxrow;
		if(minrow < 1){
			minrow = 1;
		}
		if(maxrow < 1){
			maxrow = 1;
		}
		/*
		 * get the hidden rows first, cause these are going to shown
		 */
		
		var hidden = store.showRow(sheetId, minrow, maxrow);
		this.fireEvent('rowshow', sheetId, minrow, maxrow, hidden, this);	
		
		this.checkLefterWidth();
		return hidden;
	},
	
	/*
	 * show all the columns in the selection
	 */
	showColumn : function(pos, sheetId){
        if(!Ext.isDefined(sheetId)){
            sheetId = this.getSheetId();
        }
		var store = this.getStore();
		if(!pos){
			var sm = this.getSelectionModel();
			pos = sm.getMinMaxPos();
		}		
		var mincol = pos.mincol, maxcol = pos.maxcol;
		var colStart = this.getColStart();			
		if(mincol < 1){
			mincol = 1;
		}			
		if(maxcol < 1){
			maxcol = 1;
		}
		/*
		 * get the hidden columns first, cause these are going to shown
		 */
		
		var hidden = store.showColumn(sheetId, mincol, maxcol);
		this.fireEvent('columnshow', sheetId, mincol, maxcol, hidden, this);	
		return hidden;
	},
	
	/*
	 * included merged cell
	 * @param {object} pos: the pos object included minrow, mincol, maxrow, maxcol
	 */
	includedMergedCell : function(pos){
		var store = this.getStore(), sheetId = this.getSheetId();
		for(var i = pos.minrow; i <= pos.maxrow; i++){			
			for(var j = pos.mincol; j <= pos.maxcol; j++){
				if(store.isMergedCell(null, sheetId, i, j)){
					return true;
				}
			}
		}
		return false;
	},
	
	/*
	 * included table-tpl cell
	 */
	includedTableTplCell : function(pos, sheetId){
        var store = this.getStore();
        sheetId = Ext.isDefined(sheetId) ? sheetId : this.getSheetId();
		for(var i = pos.minrow; i <= pos.maxrow; i++){			
			for(var j = pos.mincol; j <= pos.maxcol; j++){
				var cell = store.getCell(sheetId, i, j);
				if(cell.tpl){
					return true;
				}
			}
		}
		return false;
	},
	
	/*
     * For merge cells, we only need change the records in store,
     * store will fire 'cellchange' event, and region will refresh changed cell
     * @param {array} span: the span included the sheetId/minrow/maxrow/mincol/maxcol to merge
     * @param {boolean} suspendEvent: true to not fire event
     * @param {boolean} suspendRefresh: true to not refresh the cells
     */
    mergeCellForSpan : function(span, suspendEvent, suspendRefresh){
        if(this.includedTableTplCell({
            minrow: span[1],
            mincol: span[2],
            maxrow: span[3],
            maxcol: span[4]
        })){
            Ext.Msg.alert(SLANG['hint'], SLANG['cannot_operate_table_tpl']);
        }else{
            this.mergeCell(span, suspendEvent, suspendRefresh);
        }
    },
	
	/*
	 * merge the selected cells and align center
	 */
	mergeCellandAlignCenter : function(){		
		var store = this.getStore();
		var sm = this.getSelectionModel();
		var pos = sm.getMinMaxPos();
		if(this.includedTableTplCell(pos)){
			Ext.Msg.alert(SLANG['hint'], SLANG['cannot_operate_table_tpl']);
		}else{
			store.setCell(this.getSheetId(), pos.minrow, pos.mincol, {
				'ta':'center'
			}, null, true);
			this.mergeCell([null, pos.minrow, pos.mincol, pos.maxrow, pos.maxcol]);
		}				
	},
	
	/*
	 * merge the selected cell
	 */
	mergeSelectedCell : function(){			
		var sm = this.getSelectionModel();
		var pos = sm.getMinMaxPos();
		if(this.includedTableTplCell(pos)){
			Ext.Msg.alert(SLANG['hint'], SLANG['cannot_operate_table_tpl']);
		}else{
			this.mergeCell([null, pos.minrow, pos.mincol, pos.maxrow, pos.maxcol]);
		}
	},
	
	/*
	 * merge the selected cell in column
	 */
	mergeCellInColumn : function(){			
		var sm = this.getSelectionModel();
		var pos = sm.getMinMaxPos();
		if(this.includedTableTplCell(pos)){
			Ext.Msg.alert(SLANG['hint'], SLANG['cannot_operate_table_tpl']);
		}else{
			var minrow = pos.minrow, maxrow = pos.maxrow;
			for(var i = pos.mincol; i <= pos.maxcol; i++){
				this.mergeCell([null, minrow, i, maxrow, i]);
			}
		}
	},
	
	/*
	 * merge the selected cells in row
	 */
	mergeCellInRow : function(){			
		var sm = this.getSelectionModel();
		var pos = sm.getMinMaxPos();
		if(this.includedTableTplCell(pos)){
			Ext.Msg.alert(SLANG['hint'], SLANG['cannot_operate_table_tpl']);
		}else{
			var mincol = pos.mincol, maxcol = pos.maxcol;
			for(var i = pos.minrow; i <= pos.maxrow; i++){
				this.mergeCell([null, i, mincol, i, maxcol]);
			}		
		}
	},
	
	/*
	 * cancel the merge cell in selection
	 */
	cancelMergeCell : function(){			
		var sm = this.getSelectionModel();
		var pos = sm.getMinMaxPos();
		this.unmergeCell([null, pos.minrow, pos.mincol, pos.maxrow, pos.maxcol]);
	},
			
	/**
	 * This will add currently date or time in pass format
	 */
	addCurrentDateOrTime : function(fm, dfm) {
		var sm = this.getSelectionModel(), focusCell = sm.getFocusCell();	
		if(focusCell) {
			var row = focusCell.row, col = focusCell.col;			
			var currentDate = Ext.Date.format(new Date(), SCONST.DEFAULT_DATE_FORMAT);
			var dateObjs = {data: currentDate, 'fm': fm, 'dfm': dfm};
			this.setCell(this.getSheetId(), row, col, dateObjs, null, false);
		}
	},
			
    /*
     * set text format for selection
     */
    setTextFormatForSelection : function(format){
    	var sm = this.getSelectionModel();    	
    	var coord = sm.selection2Coord();    		
		var range = new EnterpriseSheet.sheet.range.Range({
    		sheet:this,
    		coord:coord
    	});
    	range.setProperty({'fm':format, 'dfm': null});    		
    },
    
    // set format for the selection number ...
    setNumberFormatForSelection : function(format){
    	var sm = this.getSelectionModel();    	
    	var coord = sm.selection2Coord();    		
		var range = new EnterpriseSheet.sheet.range.Range({
    		sheet:this,
    		coord:coord
    	});
    	range.setProperty({'fm': SCONST.FORMAT_NUMBER, 'dfm': format});    		
    },
    
    // this is for percent format
    setPercentFormatForSelection : function(format){
    	var sm = this.getSelectionModel();    	
    	var coord = sm.selection2Coord();    		
		var range = new EnterpriseSheet.sheet.range.Range({
    		sheet:this,
    		coord:coord
    	});
    	range.setProperty({'fm': SCONST.FORMAT_PERCENT, 'dfm': format});    		
    }, 
    
    /*
     * set date format for selection
     */
    setDateFormatForSelection : function(dateFormat){
    	var sm = this.getSelectionModel();    	
    	var coord = sm.selection2Coord();    		
		var range = new EnterpriseSheet.sheet.range.Range({
    		sheet:this,
    		coord:coord
    	});
    	range.setProperty({'fm': SCONST.FORMAT_DATE, 'dfm': dateFormat});    		
    },
    
    setTimeFormatForSelection : function(dateFormat){
    	var sm = this.getSelectionModel();    	
    	var coord = sm.selection2Coord();    		
		var range = new EnterpriseSheet.sheet.range.Range({
    		sheet:this,
    		coord:coord
    	});
    	range.setProperty({'fm': SCONST.FORMAT_TIME, 'dfm': dateFormat});    		
    },
    
    /**
     * For this method, dfm is hard code 
     */
    setDateTimeFormatForSelection : function(dateTimeFormat){
    	var sm = this.getSelectionModel();    	
    	var coord = sm.selection2Coord();    		
		var range = new EnterpriseSheet.sheet.range.Range({
    		sheet:this,
    		coord:coord
    	});
		
		//var fm = HELPER.parseDateTimeFM(dateTimeFormat);	
    	range.setProperty({'fm': SCONST.FORMAT_DATE_TIME, 'dfm': dateTimeFormat});    		
    },
    
    /**
     * For this method, dfm is hard code 
     */
    setSpecialFormatForSelection : function(format){
    	var sm = this.getSelectionModel();    	
    	var coord = sm.selection2Coord();    		
		var range = new EnterpriseSheet.sheet.range.Range({
    		sheet:this,
    		coord:coord
    	});
		
		//var fm = HELPER.parseDateTimeFM(dateTimeFormat);	
    	range.setProperty({'fm': SCONST.FORMAT_SPECIAL, 'dfm': format});    		
    },
    
    /*
     * move decimal point position for the data in selection
     * @param {int} offset: the move offset, if > 0 means move right, or means move left
     */
    moveDecimalPoint : function(offset){
    	if(0 != offset){	    		
    		var sm = this.getSelectionModel();   
    		var focusCell = sm.getFocusCell();
    		var cell = this.getCellData(this.getSheetId(), focusCell.row, focusCell.col);
    		var dpd = Number(cell.dpd), digital = 0;
    		if(Ext.isNumber(dpd)){
    			digital = dpd;
    		}else{
    			var num = Number(cell.data);
    			if(Ext.isNumber(num)){
    				var arr = num.toString().split('.');
    				if(2 == arr.length){
    					digital = arr[1].length;
    				}
    			}
    		}
    		digital += offset;
    		if(0 > digital){
    			digital = 0;
    		}else if(this.maxDigital < digital){
    			digital = this.maxDigital;
    		}
	    	var coord = sm.selection2Coord();    		
    		var range = new EnterpriseSheet.sheet.range.Range({
	    		sheet:this,
	    		coord:coord
	    	});
    		range.moveDecimalPoint(digital);
    	}
    },	    	   
	 
	/*
	 * this function provide a interface to set a border for the selection range
	 * @param {string} dir: the direction of the border, should be one of ['l', 'r', 't', 'b']
	 * @param {string} color: the color of the border
	 * @param {int} width: the width of the border
	 * @param {string} style: the style of the broder
	 * @param {boolean} suspendRefresh: a flag to suspend the refresh action for ss
	 * @param {boolean} suspendEvent: a flag to suspend the event for ss
	 */
	setRangeBorder : function(dir, color, width, style, suspendRefresh, suspendEvent){
		var sm = this.getSelectionModel();    	
    	var coord = sm.selection2Coord();    		
		var range = new EnterpriseSheet.sheet.range.Range({
    		sheet:this,
    		coord:coord
    	});
		range.setRangeBorder(dir, color, width, style, suspendRefresh, suspendEvent);	
		this.focus(this.focusDelayTime);
	},
	
	/**
	 * set condition for assigned range
	 * @param {object} ranges: the ranges to set the condition 
	 * @param {string} condition: the condition name
	 * @param {object} option: the option object for this condition		 
	 * @param {boolean} suspendRefresh: true to not refresh the condition cells
	 */
	setConditionForRange : function(ranges, condition, option, suspendRefresh, suspendEvent, cdtId){
        var store = this.getStore();
		store.checkLoadCoord(ranges, function(){
            /*
             * create a range first, and then set the condition for it
             */
            var range = new EnterpriseSheet.sheet.range.Range({
                sheet:this,
                coord:ranges
            });
            var newCdtId = range.setCondition(condition, option, suspendRefresh, suspendEvent, cdtId);
            /*
             * refresh focus
             */
            this.refreshFocus();
        }, this);
	},
			
	/*
	 * set condition for selection
	 * @param {string} condition: the condition name
	 * @param {object} option: the option object for this condition
	 * @param {int} sheetId: the sheetId of the sheet we want to set the condition for
	 * @param {boolean} suspendRefresh: true to not refresh the condition cells
	 */
	setConditionForSelection : function(condition, option, sheetId, suspendRefresh){
		/*
		 * use current sheetId if not assigned
		 */
		if(false == SCOM.typeOf(sheetId)){
			sheetId = this.getSheetId();
		}
		var store = this.getStore();
		var sm = this.getSelectionModel();
		var pos = sm.getMinMaxPos();			
		var minrow = pos.minrow, mincol = pos.mincol, maxrow = pos.maxrow, maxcol = pos.maxcol;			
		this.setConditionForRange([[sheetId, minrow, mincol, maxrow, maxcol]], condition, option, suspendRefresh);		
	},
	
	/*
	 * clear the condition for the cells in the selection range
	 * @param {int} sheetId: the sheetId of the sheet we want to set the condition for
	 */
	clearConditionForSelection : function(sheetId){
		/*
		 * use current sheetId if not assigned
		 */
		if(false == SCOM.typeOf(sheetId)){
			sheetId = this.getSheetId();
		}								
		var sm = this.getSelectionModel();
		var pos = sm.getMinMaxPos();			
		var minrow = pos.minrow, mincol = pos.mincol, maxrow = pos.maxrow, maxcol = pos.maxcol;			
		var range = new EnterpriseSheet.sheet.range.Range({
			sheet:this,
			coord:[[sheetId, minrow, mincol, maxrow, maxcol]]
		});		
		range.clearCondition();		
		/*
		 * refresh focus cell
		 */
		this.refreshFocus();
	},
			
	/*
	 * clear the condition for the whole sheet
	 * @param {int} sheetId: the sheetId of the sheet we want to set the condition for
	 */
	clearConditonForSheet : function(sheetId){
		var store = this.getStore();
		/*
		 * use current sheetId if not assigned
		 */
		if(false == SCOM.typeOf(sheetId)){
			sheetId = this.getSheetId();
		}
		var styles = ['cdtVal'].concat(EnterpriseSheet.sheet.calculate.Condition.styles);		
		
		
		var floatings = store.getFloatingBySheet(sheetId, 'cdt'), oldCdts = {};
		var coord = [];
		
		for(var i = 0, len = floatings.length; i < len; i++){
			var it = floatings[i];
			oldCdts[it.name] = it;
			var cdt = Ext.decode(it.json);
			var rng = cdt.rng;
			for(var j = 0, count = rng.length; j < count; j++){
				coord.push(rng[j].span);
			}
		}
		
		/*
		 * create a range
		 */
		var range = new EnterpriseSheet.sheet.range.Range({
			coord: coord,
			sheet: this
		});
		
		/*
		 * fire event
		 */
		if(false !== this.fireEvent('beforeconditionchange', range, this)){
			var cdtCoord = this.getRelatedCdtCoord(coord);
			this.fireEvent('prepareconditionchange', range, this, oldCdts, cdtCoord);    			
			
			for(var p in oldCdts){
				if(oldCdts.hasOwnProperty(p)){
					var it = oldCdts[p];
					store.setFloatingItem(it.sheet, it.name, 'cdt');
				}
			}
			range.setProperty({
				'cdt': ''
			}, styles, true, true, true);
    		
    		/*
    		 * refresh the range
    		 */
    		this.refreshRange(coord.concat(cdtCoord), true);
    		
    		this.fireEvent('conditionchange', range, this, oldCdts, cdtCoord);
		}
		/*
		 * refresh focus cell
		 */
		this.refreshFocus();
	},
	
	/*
	 * walk the selection, call the fn for every non-empty cell in selection
	 * @param {function} fn: the callback function
	 * @param {object} scope: the scope of the fn
	 */
	walkSelection : function(fn, scope){
		var store = this.getStore(), sm = this.getSelectionModel(), sheetId = this.getSheetId();
		/*
		 * get min max pos of the selection
		 */
		var mm = sm.getMinMaxPos();
		var ranges = [
		    [sheetId, mm.minrow, mm.mincol, mm.maxrow, mm.maxcol]
		];
		/*
		 * call walk range
		 */
		store.walkRange(ranges, fn, scope);
	},
	
	/*
	 * get the average of the selection
	 * @param {int} decimalNumber: the maxium number of the decimal reserve
	 */
	getAverageOfSelection : function(decimalNumber){
		var avg = 0, count = 0;
		this.walkSelection(function(rd, span, store){
			var o = store.getCellData(rd.data.sheet, rd.data.row, rd.data.col);
			if(SCOM.canbeNumber(o.data)){
				avg += Number(o.data);
				count++;
			}
		});
		if(0 < count){
			avg = avg/count;
		}
		if(false != SCOM.typeOf(decimalNumber)){
			var b = Math.pow(10, decimalNumber);
			avg = Math.round(avg*b)/b;
		}
		return avg;
	},
	
	/*
	 * clean the selection 
	 * @param {string} which: can be ['content', 'style'], if null/undefined means both content and style
	 */
	cleanSelection : function(which){			
		var sm = this.getSelectionModel();    	
    	var coord = sm.selection2Coord();    
    	/*
    	 * create range
    	 */
		var range = new EnterpriseSheet.sheet.range.Range({
    		sheet:this,
    		coord:coord
    	});
		if('content' == which){
			range.cleanContent();
		}else if('style' == which){
			range.cleanStyle();
		}else{
			range.clean();
		}
		this.focus(this.focusDelayTime);
		/*
		 * reset the focus cell
		 */
		this.refreshFocus();
	},
	
	/*
	 * create a calculate to sum the selection 		 
	 */
	setCal2Selection : function(cal){
		var sm = this.getSelectionModel();
		var span = sm.selection2Span();
		var maxrow = span[3], maxcol = span[4];
		var flag = true;
		if(span[1] != span[3]){
			maxrow++;
			flag = false;
		}
		if(span[2] != span[4]){
			maxcol++;
			flag = false;
		}			
		/*
		 * make sure the focus
		 */
		this.focus(this.focusDelayTime);
		if(!flag){
			var str = EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String([{
				span: span,
				type: SCONST.RELATIVE_COORD
			}], '');
			str = '='+cal.toUpperCase()+'('+str+')';									
			this.setCellData(span[0], maxrow, maxcol, {data:str}, null);			
			sm.selectRange({row:span[1], col:span[2]}, {row:maxrow, col:maxcol});
			return str;
		}			
	},	
	
	/*
	 * move the selection, will move the cells in the selection to the drop place
	 */
	moveSelection : function(fromSpan, toSpan, sm, move2Insert, insertDir){		
		var me = this;
		var store = this.getStore(), sheetId = this.getSheetId();
		if(fromSpan.length == toSpan.length){
			var flag = true;
			for(var i = 0, len = fromSpan.length; i < len; i++){
				if(fromSpan[i] != toSpan[i]){
					flag = false;
					break;
				}
			}
			if(flag){
				return;
			}
		}
		/*
		 * check whether there is merged cell not fully included in this move action
		 */
		var coord = [fromSpan, toSpan];
		if(store.withBrokenMergedCell(coord)){
			Ext.Msg.alert(SLANG['hint'], SLANG['can_not_change_part_merged_cell']);
			return;
		}
		
		var removeAfterMove, sameSpan;
		if(true === move2Insert){
			var colSpan = toSpan[4]-toSpan[2]+1, rowSpan = toSpan[3]-toSpan[1]+1;
			if(0 == toSpan[1]){
				if(toSpan[2] !== fromSpan[2]){
					if(toSpan[2] < fromSpan[2]){
						fromSpan[2] += colSpan;
						fromSpan[4] += colSpan;
					}					
					removeAfterMove = 'col';
				}				
			}else if(0 == toSpan[2]){
				if(toSpan[1] !== fromSpan[1]){
					if(toSpan[1] < fromSpan[1]){
						fromSpan[1] += rowSpan;
						fromSpan[3] += rowSpan;
					}					
					removeAfterMove = 'row';
				}				
			}else{
				if(toSpan[1] !== fromSpan[1] || toSpan[2] !== fromSpan[2]){
					var valid = false;
					if('right' === insertDir){
						sameSpan = (fromSpan[1] === toSpan[1] && fromSpan[3] === toSpan[3]);
						if(toSpan[2] > fromSpan[4]){
							valid = true;
						}else if(sameSpan && toSpan[2] <= fromSpan[2]){
							if(toSpan[2] < fromSpan[2]){
								fromSpan[2] += colSpan;
								fromSpan[4] += colSpan;
							}
							valid = true;
						}else if(fromSpan[1] > toSpan[3] || fromSpan[3] < toSpan[1]){
							valid = true;
						}
					}else{
						sameSpan = (fromSpan[2] === toSpan[2] && fromSpan[4] === toSpan[4]);
						if(toSpan[1] > fromSpan[3]){
							valid = true;
						}else if(sameSpan && toSpan[1] <= fromSpan[1]){
							if(toSpan[1] < fromSpan[1]){
								fromSpan[1] += rowSpan;
								fromSpan[3] += rowSpan;
							}
							valid = true;
						}else if(fromSpan[2] > toSpan[4] || fromSpan[4] < toSpan[2]){
							valid = true;
						}						
					}
					if(valid){						
						removeAfterMove = 'cell';
					}					
				}											
			}
		}
		var range = new EnterpriseSheet.sheet.range.Range({
			coord: coord,
			sheet: this
		});
		
		if(false !== this.fireEvent('beforerangemove', range, this)){			
			if(removeAfterMove){					
				this.fireEvent('preparemoveforinsert', range, this);
				if('col' === removeAfterMove){
					store.insertColumn(toSpan[0], toSpan[2], colSpan);
				}else if('row' === removeAfterMove){
					store.insertRow(toSpan[0], toSpan[1], rowSpan);
				}else if('cell' === removeAfterMove){
					store.insertCell(toSpan[0], toSpan[1], toSpan[2], rowSpan, colSpan, insertDir);
				}
			}
			/*
			 * get the recal cells
			 */
			var reCalCells = this.getRecalculateCellsByCoord(coord);
			/*
			 * get the cdt cell in the range
			 */
			var oldCdt = this.getCdtsFromCoord(range.getCoord());
			
			var changedHeights = {};
			this.fireEvent('preparerangemove', range, this, oldCdt, reCalCells, changedHeights);
						
			var fsheet = fromSpan[0], fminrow = fromSpan[1], fmincol = fromSpan[2], fmaxrow = fromSpan[3], fmaxcol = fromSpan[4];			
			var tsheet = toSpan[0], tminrow = toSpan[1], tmincol = toSpan[2], tmaxrow = toSpan[3], tmaxcol = toSpan[4];			
			/*
			 * calculate the offset between fromSpan to toSpan
			 */
			var sroff = tminrow-fminrow, scoff = tmincol-fmincol;
			/*
			 * need save the data of from span and to span first
			 */
			var cellDataCache = {};
			store.walkRange([fromSpan, toSpan], function(rd){
				var r = rd.data.row, c = rd.data.col; 
				var cd = store.getCellProperty(rd.data.sheet, r, c, true);				
				cellDataCache[rd.data.sheet+'-'+r+'-'+c] = cd;
			}, this);
           /*
            * update the cdt in the toSpan
            */
           this.syncAutoExtendCdt(toSpan, fromSpan, oldCdt);
			/*
			 * a lookup cache and count for record the condition id,
			 * for condition cell, when we copy/paste, we need reset the id, because it could be different with
			 * the original condition, with the same id, we can not list them all in the condition manager
			 */
			var lookup = {}, refs = [];
			var clearMove = function(callback, scope){		
				/*
				 * clear the to span first
				 */
				var toRange = new EnterpriseSheet.sheet.range.Range({
					sheet: me,
					coord: [toSpan]
				});
				/*
				 * clean the range slicently
				 */
				toRange.clean(true, null, true);				
				var arr = [];
				/*
				 * move the range
				 */
				store.walkRange([fromSpan], function(rd){
					var r = rd.data.row, c = rd.data.col; 
					var i = r+sroff, j = c+scoff;						
					var span = callback.call(scope, fsheet, r, c, tsheet, i, j);
					if(span){
						arr.push(span);
					}					
				}, scope);
				/*
				 * clear the from span
				 */
				var fromRange = new EnterpriseSheet.sheet.range.Range({
					sheet: me,
					coord: [fromSpan]
				});
				toRange.coord = toRange.coord.concat(arr);
				
				fromRange.clean(true, toRange, true);	
				if(0 < arr.length){
					Ext.Msg.alert(SLANG['hint'], SLANG['skip_process_action_on_disabled_cell']);
				}
			}
			
			clearMove(function(fs, r, c, ts, i, j){
				/*
				 * get the data from the cache
				 */
				var cd = cellDataCache[fs+'-'+r+'-'+c], curCd = cellDataCache[ts+'-'+i+'-'+j];		
				if((!curCd || !store.isDisabledForMe(curCd.dsd)) && (!cd || !store.isDisabledForMe(cd.dsd))){
					/*
					 * set the last param to true, so we will skip the condition reset
					 */
					cd = this.prepareForMoveCell(cd, ts, i, j, fs, r, c, lookup, 'default', true);		
	                if(cd.cal && cd.refs){
	                    refs = refs.concat(cd.refs);
	                }
					if(!(fs === ts && r === i && c === j)){															
						/*
						 * apply the data and changed style back
						 */										
						store.setCell(ts, i, j, cd, null, true, 'clear');
					}
				}else{
					if(store.isDisabledForMe(curCd.dsd)){
						return [fs, r, c, r, c];
					}
				}
			}, this);
			
			
			/*
			 * refresh UI
			 */
			
			if(EnterpriseSheet.sheet.range.Range.prototype.isCellCoord(coord)){
				Ext.apply(changedHeights, this.checkAutoHeightForCoord(null, coord, false, true));
			}
			/*
			 * extend the recalculated cells
			 */
			var reCals = this.getCalCdtCellsFromCoord([toSpan]);
			Ext.applyIf(reCalCells, reCals);
            
            if(0 < refs.length){
                this.loadMask.show(SLANG['calculating'], this.calMaskDelayTime);
                store.checkLoadCoord(refs, function(){
                    var arr = refs.concat(coord);
                    this.refreshRange(arr, reCalCells);
                    this.loadMask.hide();
                }, this);
            }else{
                this.refreshRange(coord, reCalCells);
            }
			this.fireEvent('rangemove', range, this, reCalCells);
			if(removeAfterMove){
				if('col' === removeAfterMove){
					store.removeColumn(fromSpan[0], fromSpan[2], fromSpan[4]);
				}else if('row' === removeAfterMove){
					store.removeRow(fromSpan[0], fromSpan[1], fromSpan[3]);
				}else if('cell' === removeAfterMove && sameSpan){					
					store.removeCell(fromSpan[0], fromSpan[1], fromSpan[3], fromSpan[2], fromSpan[4], 'right' === insertDir ? 'left' : 'up');
				}
				this.fireEvent('moveforinsert', range, this);
			}
		}		
	},
	
	/*
	 * get calculate tool
	 */
	getCalculate : function(){
		return this.calculate;
	},
	
	getCondition : function(){
		return this.condition;
	},	
	
	/*
	 * create range store based on the current selection
	 */
	createRangeStore : function(config){
		config = config || {};
		var sm = this.getSelectionModel();
		var coordSpan = sm.selection2Span();
		var chartType = config.chartType;
		
		if('pie' === chartType){		
			if(coordSpan[1] === coordSpan[3]){
				config.seriesPosition = 'row';
			}else if(coordSpan[2] === coordSpan[4]){
				config.seriesPosition = 'col';
			}else{
				var rowSpan = coordSpan[3]-coordSpan[1]+1, colSpan = coordSpan[4]-coordSpan[2]+1;
				if(rowSpan > colSpan){
					config.seriesPosition = 'col';
				}else{
					config.seriesPosition = 'row';
				}
			}
		}
		
		var store = new EnterpriseSheet.sheet.data.RangeStore(Ext.applyIf({
			sheet: this,
			coord: [coordSpan]			
		}, config));
		return store;
	},
	
	/*
	 * click on chart, will show the related range
	 */
	onChartFocus : function(coordReference){
		var rm = this.getReferenceModel();
		rm.enableSelect(undefined, undefined, undefined, undefined, true);
		rm.setReference(coordReference);
		rm.show();
	},		
	
	/*
	 * after store load
	 */
	afterLoad : function(store){
        if(!this.getEl()){
            this.on('afterrender', function(){
                this.afterLoad(store);
            }, this, {single: true});
            return;
        }

		var rm = this.getReferenceModel();
		rm.clearSelection();
		/*
		 * clear all floor first
		 */
		this.clearFloor(true, true);
		/*
		 * set the current sheet id to the activesd one of store
		 */
		var sheetId = store.getActivedSheetId();
		this.setSheetId(sheetId);
		
		/*
		 * sync groups, floors and sheet config to the current sheet
		 */		
		var needLayout = this.syncSheetFloating(true);
           		//var start = new Date();
		/*
		 * refresh the new sheet,
		 * refresh the calculate and condition cell
		 */
		this.refreshRange(null, true, true);
        //alert(Ext.Date.getElapsed(start));
        /*
         * need set the height for region if it's splited sheet
         */
        if(this.splitPos){
            if(this.ulefter.isVisible()){
                this.ulefter.getEl().setHeight(this.ulefter.getHeight());
            }
            if(this.ltregion.isVisible()){
                this.ltregion.getEl().setHeight(this.ltregion.getHeight());
            }
            if(this.tregion.isVisible()){
                this.tregion.getEl().setHeight(this.tregion.getHeight());
            }
        }
           
        if(needLayout){
			if(Ext.isFunction(this.doLayout)){
				this.doLayout();
			}else if(Ext.isFunction(this.updateLayout)){
				this.updateLayout();
			} 
		}
        this.refreshFocus();

		this.fireEvent('changing', this);
        /*
         * set it again
         */
        this.setReadOnly(this.readOnly);
           
        /*
         * fire event after load sheet
         */
        this.fireEvent('afterloadsheet', store, this);
        
        this.processAfterLoadSheet();

        // console.log(Ext.Date.getElapsed(window['startCounting']))
	},
           
    processAfterLoadSheet : function(){
        this.loadMask.hide();
    },
	
	/*
	 * create chart based on the selection
	 * @param {string} chartType: the type of chart to create
	 * @param {EnterpriseSheet.sheet.data.RangeStore} rangeStore: an rangestore object ref
	 * @param {object} config: config for the chart
	 * @param {boolean} suspendEvent: true to not fire event
	 */
	createChart : function(chartType, rangeStore, config, suspendEvent, suspendPulling) {
		if('column' == chartType){
			return this.createColumnChart(rangeStore, config, suspendEvent, suspendPulling);
		}else if('area' == chartType){
			return this.createAreaChart(rangeStore, config, suspendEvent, suspendPulling);
		}else if('pie' == chartType){
			return this.createPieChart(rangeStore, config, suspendEvent, suspendPulling);
		}else if('line' == chartType){
			return this.createLineChart(rangeStore, config, suspendEvent, suspendPulling);
		}else if('bar' == chartType){
			return this.createBarChart(rangeStore, config, suspendEvent, suspendPulling);
		}else if('scatter' == chartType){
			return this.createScatterChart(rangeStore, config, suspendEvent, suspendPulling);
		}else if('radar' == chartType){
			return this.createRadarChart(rangeStore, config, suspendEvent, suspendPulling);
		}
	},
	
	/*
	 * create chart based on the selection
	 * @param {EnterpriseSheet.sheet.data.RangeStore} rangeStore: an rangestore object ref
	 * @param {object} config: config for the chart
	 * @param {boolean} suspendEvent: true to not fire event
	 */
	createColumnChart : function(rangeStore, config, suspendEvent, suspendPulling) {
        config = config || {};
		if(!suspendEvent){
			/*
			 * fire event 
			 */
			if(false === this.fireEvent('beforecreatechart', 'column', config, rangeStore, this)){
				return;
			}
			this.fireEvent('preparecreatechart', 'column', config, rangeStore, this);
		}	
		if(!rangeStore){
			rangeStore = this.createRangeStore();
		}else if(rangeStore.useAbs){
			/*
			 * if useAbs is not right, then reset it and regenerate data
			 */
			rangeStore.useAbs = false;
			rangeStore.regenerateData();
		}
        /*
         * prepare the picture position and size info
         */
        var transfered = this.preparePicturePosition(config);
        var pos = this.cregion.getIfPosOfCenter(), width = 400, height = 300, x = pos.x-Math.floor(width/2), y = pos.y-Math.floor(height/2);
		var chart = new EnterpriseSheet.sheet.floating.chart.ChartFloor('column', Ext.apply({			
			sheet : this,
			store : rangeStore,
			x : x,
			y : y,
			width : width,
			height : height
		}, config), suspendPulling);
		if(!suspendEvent){
			/*
			 * fire event 
			 */
			this.fireEvent('createchart', 'column', chart, rangeStore, this);
        }else if(transfered){
           /*
            * update to backend
            */
           this.fireEvent('floorresize', chart);
        }
		
		return chart;
	},
	
	createPieChart : function(rangeStore, config, suspendEvent, suspendPulling) {
        config = config || {};
		if(!suspendEvent){
			/*
			 * fire event 
			 */
			if(false === this.fireEvent('beforecreatechart', 'pie', config, rangeStore, this)){
				return;
			}
			this.fireEvent('preparecreatechart', 'pie', config, rangeStore, this);
		}	
		if(!rangeStore){
			rangeStore = this.createRangeStore({
				useAbs: true,
				chartType: 'pie'				
			});
		}else if(!rangeStore.useAbs){
			/*
			 * if useAbs is not right, then reset it and regenerate data
			 */
			rangeStore.useAbs = true;
			rangeStore.regenerateData();
		}
        /*
         * prepare the picture position and size info
         */
        var transfered = this.preparePicturePosition(config);
		var pos = this.cregion.getIfPosOfCenter(), width = 400, height = 300, x = pos.x-Math.floor(width/2), y = pos.y-Math.floor(height/2);
		var chart = new EnterpriseSheet.sheet.floating.chart.ChartFloor('pie', Ext.apply({
			sheet : this,
			store : rangeStore,
			x : x,
			y : y,
			width : width,
			height : height
		}, config), suspendPulling);
		if(!suspendEvent){
			/*
			 * fire event 
			 */
			this.fireEvent('createchart', 'pie', chart, rangeStore, this);
        }else if(transfered){
           /*
            * update to backend
            */
           this.fireEvent('floorresize', chart);
        }
		
		return chart;
	},
	
	createAreaChart : function(rangeStore, config, suspendEvent, suspendPulling) {
        config = config || {};
		if(!suspendEvent){
			/*
			 * fire event 
			 */
			if(false === this.fireEvent('beforecreatechart', 'area', config, rangeStore, this)){
				return;
			}
			this.fireEvent('preparecreatechart', 'area', config, rangeStore, this);
		}	
		if(!rangeStore){
			rangeStore = this.createRangeStore({
				useAbs: true
			});
		}else if(!rangeStore.useAbs){
			/*
			 * if useAbs is not right, then reset it and regenerate data
			 */
			rangeStore.useAbs = true;
			rangeStore.regenerateData();
		}
        /*
         * prepare the picture position and size info
         */
        var transfered = this.preparePicturePosition(config);
        var pos = this.cregion.getIfPosOfCenter(), width = 400, height = 300, x = pos.x-Math.floor(width/2), y = pos.y-Math.floor(height/2);
		var chart = new EnterpriseSheet.sheet.floating.chart.ChartFloor('area', Ext.apply({
			sheet : this,
			store : rangeStore,
            x : x,
            y : y,
            width : width,
            height : height
		}, config), suspendPulling);
		
		if(!suspendEvent){
			/*
			 * fire event 
			 */
			this.fireEvent('createchart', 'area', chart, rangeStore, this);
        }else if(transfered){
           /*
            * update to backend
            */
           this.fireEvent('floorresize', chart);
        }
		
		return chart;
	},
	
	createLineChart : function(rangeStore, config, suspendEvent, suspendPulling) {
        config = config || {};           
		if(!suspendEvent){
			/*
			 * fire event 
			 */
			if(false === this.fireEvent('beforecreatechart', 'line', config, rangeStore, this)){
				return;
			}
			this.fireEvent('preparecreatechart', 'line', config, rangeStore, this);
		}	
		if(!rangeStore){
			rangeStore = this.createRangeStore();
		}else if(rangeStore.useAbs){
			/*
			 * if useAbs is not right, then reset it and regenerate data
			 */
			rangeStore.useAbs = false;
			rangeStore.regenerateData();
		}
        /*
         * prepare the picture position and size info
         */
        var transfered = this.preparePicturePosition(config);
        var pos = this.cregion.getIfPosOfCenter(), width = 400, height = 300, x = pos.x-Math.floor(width/2), y = pos.y-Math.floor(height/2);
		var chart = new EnterpriseSheet.sheet.floating.chart.ChartFloor('line', Ext.apply({
			sheet : this,
			store : rangeStore,
            x : x,
            y : y,
            width : width,
            height : height
		}, config), suspendPulling);
		if(!suspendEvent){
			/*
			 * fire event 
			 */
			this.fireEvent('createchart', 'line', chart, rangeStore, this);
        }else if(transfered){
           /*
            * update to backend
            */
           this.fireEvent('floorresize', chart);
        }
		
		return chart;
	},
	
	createBarChart : function(rangeStore, config, suspendEvent, suspendPulling) {
        config = config || {};
		if(!suspendEvent){
			/*
			 * fire event 
			 */
			if(false === this.fireEvent('beforecreatechart', 'bar', config, rangeStore, this)){
				return;
			}
			this.fireEvent('preparecreatechart', 'bar', config, rangeStore, this);
		}	
		if(!rangeStore){
			rangeStore = this.createRangeStore();
		}else if(rangeStore.useAbs){
			/*
			 * if useAbs is not right, then reset it and regenerate data
			 */
			rangeStore.useAbs = false;
			rangeStore.regenerateData();
		}
        /*
         * prepare the picture position and size info
         */
        var transfered = this.preparePicturePosition(config);
        var pos = this.cregion.getIfPosOfCenter(), width = 400, height = 300, x = pos.x-Math.floor(width/2), y = pos.y-Math.floor(height/2);
		var chart = new EnterpriseSheet.sheet.floating.chart.ChartFloor('bar', Ext.apply({
			sheet : this,
			store : rangeStore,
            x : x,
            y : y,
            width : width,
            height : height
		}, config), suspendPulling);
		if(!suspendEvent){
			/*
			 * fire event 
			 */
			this.fireEvent('createchart', 'bar', chart, rangeStore, this);
        }else if(transfered){
           /*
            * update to backend
            */
           this.fireEvent('floorresize', chart);
        }
		
		return chart;
	},
	
	createScatterChart : function(rangeStore, config, suspendEvent, suspendPulling) {
        config = config || {};
		if(!suspendEvent){
			/*
			 * fire event 
			 */
			if(false === this.fireEvent('beforecreatechart', 'scatter', config, rangeStore, this)){
				return;
			}
			this.fireEvent('preparecreatechart', 'scatter', config, rangeStore, this);
		}	
		if(!rangeStore){
			rangeStore = this.createRangeStore();
		}else if(rangeStore.useAbs){
			/*
			 * if useAbs is not right, then reset it and regenerate data
			 */
			rangeStore.useAbs = false;
			rangeStore.regenerateData();
		}
        /*
         * prepare the picture position and size info
         */
        var transfered = this.preparePicturePosition(config);
        var pos = this.cregion.getIfPosOfCenter(), width = 400, height = 300, x = pos.x-Math.floor(width/2), y = pos.y-Math.floor(height/2);
		var chart = new EnterpriseSheet.sheet.floating.chart.ChartFloor('scatter', Ext.apply({
			sheet : this,
			store : rangeStore,
            x : x,
            y : y,
            width : width,
            height : height
		}, config), suspendPulling);
		if(!suspendEvent){
			/*
			 * fire event 
			 */
			this.fireEvent('createchart', 'scatter', chart, rangeStore, this);
        }else if(transfered){
           /*
            * update to backend
            */
            this.fireEvent('floorresize', chart);
        }
		
		return chart;
	},
	
	createRadarChart : function(rangeStore, config, suspendEvent, suspendPulling) {
        config = config || {};
		if(!suspendEvent){
			/*
			 * fire event 
			 */
			if(false === this.fireEvent('beforecreatechart', 'radar', config, rangeStore, this)){
				return;
			}
			this.fireEvent('preparecreatechart', 'radar', config, rangeStore, this);
		}	
		if(!rangeStore){
			rangeStore = this.createRangeStore({
				useAbs: true
			});
		}else if(!rangeStore.useAbs){
			/*
			 * if useAbs is not right, then reset it and regenerate data
			 */
			rangeStore.useAbs = true;
			rangeStore.regenerateData();
		}
        /*
         * prepare the picture position and size info
         */
        var transfered = this.preparePicturePosition(config);
        var pos = this.cregion.getIfPosOfCenter(), width = 400, height = 300, x = pos.x-Math.floor(width/2), y = pos.y-Math.floor(height/2);
		var chart = new EnterpriseSheet.sheet.floating.chart.ChartFloor('radar', Ext.apply({
			sheet : this,
			store : rangeStore,
            x : x,
            y : y,
            width : width,
            height : height
		}, config), suspendPulling);
		if(!suspendEvent){
			/*
			 * fire event 
			 */
			this.fireEvent('createchart', 'radar', chart, rangeStore, this);
        }else if(transfered){
           /*
            * update to backend
            */
           // updated @ 2015 03 07 -- seems floor is undefined ... 
           if (typeof floor != 'undefined') this.fireEvent('floorresize', floor);
        }
		
		return chart;
	},
           
    /*
     * create wedig
     */
    createWedgit : function(url, config, suspendEvent, suspendPulling){
        config = config || {};
        if(!suspendEvent){
            /*
             * fire event
             */
            if(false === this.fireEvent('beforecreatewedgit', url, config, this)){
                return;
            }
            this.fireEvent('preparecreatewedgit', url, config, this);
        }
        /*
         * prepare the picture position and size info
         */
        var transfered = this.preparePicturePosition(config);
        var pos = this.cregion.getIfPosOfCenter(), width = 400, height = 300, x = pos.x-Math.floor(width/2), y = pos.y-Math.floor(height/2);
        var floor = new EnterpriseSheet.sheet.floating.wedgit.WedgitFloor(url, {
            sheet : this,
            sheetId: config.sheetId,
            floatingConfig : Ext.apply({
                x : x,
                y : y,
                width : width,
                height : height
            }, config)
        }, suspendPulling);
        if(!suspendEvent){
            /*
             * fire event
             */
            this.fireEvent('createwedgit', url, floor, this);
        }else if(transfered){
            /*
             * update to backend
             */
            this.fireEvent('floorresize', floor);
        }
    },
	
	/*
	 * create picture
	 */
	createPicture : function(url, config, suspendEvent, suspendPulling){
        config = config || {};
		if(!suspendEvent){
			/*
			 * fire event 
			 */
			if(false === this.fireEvent('beforecreatepicture', url, config, this)){
				return;
			}
			this.fireEvent('preparecreatepicture', url, config, this);
		}	
        /*
         * prepare the picture position and size info
         */
        var transfered = this.preparePicturePosition(config);
        var pos = this.cregion.getIfPosOfCenter(), width = 200, height = 200, x = pos.x-Math.floor(width/2), y = pos.y-Math.floor(height/2);
		var floor = new EnterpriseSheet.sheet.floating.picture.PictureFloor(url, {
			sheet : this,
            sheetId: config.sheetId,                                                                  
			floatingConfig : Ext.apply({
                x : x,
                y : y,
                width : width,
                height : height
            }, config)
		}, suspendPulling);
		if(!suspendEvent){
			/*
			 * fire event 
			 */
			this.fireEvent('createpicture', url, floor, this);
        }else if(transfered){
            /*
             * update to backend
             */
            this.fireEvent('floorresize', floor);
		}	
	},
		
	/*
	 * create incell picture
	 */
	createInCellPicture : function(url){        
		var sm = this.getSelectionModel();
		var focusCell = sm.getFocusCell();
		if(focusCell){
			/*
			 * create a range object
			 */
			var range = new EnterpriseSheet.sheet.range.Range({
				coord: [[this.getSheetId(), focusCell.row, focusCell.col, focusCell.row, focusCell.col]],
				sheet: this
			}); 
			range.setProperty({			
				icp: url
			});
		}
	},
		
    /**
     * _private
     */
    preparePicturePosition : function(config){
        if(config && Ext.isDefined(config.sr)){
            var sr = config.sr+1, sc = config.sc+1, er = config.er+1, ec = config.ec+1;
            var sx = config.sx, sy = config.sy, ex = config.ex, ey = config.ey;
            var store = this.getStore(), sheetId = this.getSheetId();
            var w = store.getRangeWidth(sheetId, sc, ec-1)-sx+ex;
            var h = store.getRangeHeight(sheetId, sr, er-1)-sy+ey;
            var x = store.getRangeWidth(sheetId, 1, sc-1)+sx;
            var y = store.getRangeHeight(sheetId, 1, sr-1)+sy;
            delete(config.sr);
            delete(config.er);
            delete(config.sc);
            delete(config.ec);
            delete(config.sx);
            delete(config.sy);
            delete(config.ex);
            delete(config.ey);
            Ext.apply(config, {
                x: x,
                y: y,
                width: w,
                height: h
            });
            return true;
        }
	},
	
	/*
	 * sync floor info to store
	 */
	syncFloors : function(floors, action){
		var store = this.getStore();
		if(!Ext.isArray(floors)){
			floors = [floors];
		}
		
		if('remove' == action){			
			for(var i = 0, len = floors.length; i < len; i++){
				var floor = floors[i];
				store.setFloatingItem(floor.sheetId, floor.getName(), 'floor');				
			}			
		}else{			
			for(var i = 0, len = floors.length; i < len; i++){
				var floor = floors[i];
				if('function' == Ext.typeOf(floor.getFloorInfo)){
					var json = Ext.encode(floor.getFloorInfo());
					store.setFloatingItem(floor.sheetId, floor.getName(), 'floor', json);	
				}			
			}
			
		}				
	},
	
	/*
	 * create different shapes
	 */
	createCircleShape : function(){
		new EnterpriseSheet.sheet.floating.Floor({
			sheet : this,
			floatingConfig : {
				xtype: 'drawcomponent',
				style : 'cursor:default;',				
				x : 100,
				y : 100,		
				width: 110,
				height: 110,
				viewBox: false,
			    items: [{
			        type: 'circle',
			        fill: '#79BB3F',
			        radius: 50,
			        x: 50,
			        y: 50
			    }]
			}
		});
	},
	
	/*
	 * create hyperlink - based on sheet where I am ...
	 */
	createHyperlink : function(url, sheetId, row, col){
	
		// this is for the sheet I selected ...
		if(!Ext.isDefined(sheetId)){
			sheetId = this.getSheetId();
			var sm = this.getSelectionModel();
		    var focusCell = sm.getFocusCell();
			row = focusCell.row;
			col = focusCell.col;
		}
		
		var store = this.getStore();
		var cell = store.getCell(sheetId, row, col);
		var md = {
			link: url,
			fm: 'link'	
		};
		if(SCOM.nullOrUndefined(cell.data)){
			md.data = url;
			this.setCellData(sheetId, row, col, md);
		}else{
			var range = new EnterpriseSheet.sheet.range.Range({
				sheet: this,
				coord: [[sheetId, row, col, row, col]]
			});
			range.setProperty(md);
		}
	},
	
	/*
	 * insert comment for the focus cell
	 * @param {string} comment: the comment to insert
	 * @param {object} pos: the sheet, row, col position
	 */
	insertComment : function(comment, pos){
		var coord;
		if(pos){
			coord = [[pos.sheet, pos.row, pos.col, pos.row, pos.col]];
		}else{
			var sm = this.getSelectionModel();
			var focusCell = sm.getFocusCell();
			var sheetId = this.getSheetId();
			var row = focusCell.row, col = focusCell.col; 
			coord = [[sheetId, row, col, row, col]];
		}		
		/*
		 * create a range object
		 */
		var range = new EnterpriseSheet.sheet.range.Range({
			coord: coord,
			sheet: this
		}); 
		range.setProperty({			
			comment: comment
		});
	},
	
	/*
	 * delete comment for the selection
	 */
	deleteComment : function(coord, suspendRefresh, suspendEvent){
		if(!coord){
			var sm = this.getSelectionModel();
			coord = sm.selection2Coord();
		}				
		/*
		 * create a range object
		 */
		var range = new EnterpriseSheet.sheet.range.Range({
			coord: coord,
			sheet: this
		}); 
		range.setProperty(null, ['comment'], suspendRefresh, suspendEvent);
	},
	
	
	
	/*
	 * process the exception
	 */
	processCalculateException : function(e, scope){		
		var info = SCALEXP.getExceptionInfo(e);
		var html = '<div class="ss-exception-sign" style="z-index:'+SCONST['CORNER_Z_INDEX']+';"></div>';
		
		var title = info.title, msg = info.msg;
		var expTip = '<div class="ss-exception-title">'+title+'</div>'+msg;
		return {
			data: info.code,
			ltcorner: html,
			expTip: expTip
		};
	},
	
	/*
	 * active a span in reference
	 */
	activeCoordSpan : function(coord, colorIndex){
		for(var i = 0, len = this.regionLookup.length; i < len; i++){
			var region = this[this.regionLookup[i]];
			if(region.isVisible()){
				var refModel = region.getReferenceModel();				
				if(refModel){					
					refModel.activeCoordSpan(coord, colorIndex);
				}
			}
		}	
	},
	
	/*
	 * deactive a span in reference
	 */
	deactiveCoordSpan : function(coord){
		for(var i = 0, len = this.regionLookup.length; i < len; i++){
			var region = this[this.regionLookup[i]];
			if(region.isVisible()){
				var refModel = region.getReferenceModel();				
				if(refModel){					
					refModel.deactiveCoordSpan(coord);
				}
			}
		}	
	},
	
	/*
	 * process column group
	 */
	processColumnGroup : function(colData, sheetId, row, col){
		if(this.colGroupLookup){
			var groups = this.colGroupLookup[col];
			if(groups){
				var arr = [], colorLen = SCOM.colors.length;
				for(var i in groups){
					var obj = groups[i];
					var span = obj.span, level = obj.level;
					color = SCOM.colors[(level-1)%colorLen];
					var min = col == span[0], max = col == span[1];
					var cls = min ? 'ss-col-group-start' : (max ? 'ss-col-group-end' : '');
					if(obj.collapsed){
						cls += ' ss-collasped-group';
					}
					var html = SLAYOUT['group'].apply({
						name: i,
						start: span[0],
						end: span[1],
						dir: 'col',
						cls: cls,
						min: min,
						max: max,
						color: color,
						top: -this.groupOffset*level
					});
					arr.push(html);
				}
				colData.data += arr.join('');
			}
		}		
	},
	
	/*
	 * process row group
	 */
	processRowGroup : function(rowData, sheetId, row, col){		
		if(this.rowGroupLookup){
			var groups = this.rowGroupLookup[row];
			if(groups){
				var arr = [], colorLen = SCOM.colors.length;
				for(var i in groups){
					var obj = groups[i];
					var span = obj.span, level = obj.level;
					var color = SCOM.colors[(level-1)%colorLen];
					var min = row == span[0], max = row == span[1];
					var cls = min ? 'ss-row-group-start' : (max ? 'ss-row-group-end' : '');
					if(obj.collapsed){
						cls += ' ss-collasped-group';
					}
					var html = SLAYOUT['group'].apply({
						name: i,
						start: span[0],
						end: span[1],
						dir: 'row',
						cls: cls,
						min: min,
						max: max,
						color: color,
						left: -this.groupOffset*level
					});
					arr.push(html);
				}
				rowData.data += arr.join('');
			}
		}
	},
	
	/*
	 * _private
	 * toggle group no
	 */
	toggleGroupNo : function(dir, level, state){
		var colorLen = SCOM.colors.length;
		var pnode;
		if('row' == dir){
			pnode = this.getRowGroupPin().dom;
		}else{
			pnode = this.getColumnGroupPin().dom;
		}
		
		var len = pnode.childNodes.length;
		var noEl = Ext.get(pnode.childNodes[len-level]);
		if(state){
			noEl.removeCls('ss-group-level-collapsed');
			
			for(var i = 0; i < len; i++){
				var child = pnode.childNodes[i];
				var childEl = Ext.get(child);
				var color = SCOM.colors[(len-1-i)%colorLen];
				childEl.setStyle('color', 'white');
				childEl.setStyle('border', '1px solid white');
				childEl.setStyle('background-color', color);
				if(child == noEl.dom){
					break;
				}
				childEl.removeCls('ss-group-level-collapsed');
			}
		}else{
			noEl.addCls('ss-group-level-collapsed');
			
			for(var i = len-1; 0 <= i; i--){
				var child = pnode.childNodes[i];
				var childEl = Ext.get(child);
				var color = SCOM.colors[(len-1-i)%colorLen];
				childEl.setStyle('color', color);
				childEl.setStyle('border', '1px solid '+color);
				childEl.setStyle('background-color', 'white');
				if(child == noEl.dom){
					break;
				}
				childEl.addCls('ss-group-level-collapsed');
			}
		}
	},
	
	/*
	 * toggle a group level
	 * @param {string} dir: the row or col
	 * @param {int} level: the level to toggle
	 * @param {boolean} state: true to expand, false to collapse
	 */
	toggleGroupLevel : function(dir, level, state){
		var store = this.getStore(), sheetId = this.getSheetId();
		var action, reaction, update, event, oldGroups, oldLevels = this.getGroupLevel(dir);
		if('row' != dir){
			dir = 'col';
			update = 'updateColumnGroups';
			action = state ? 'showColumn' : 'hideColumn';
			reaction = !state ? 'showColumn' : 'hideColumn';
			event = 'togglecolgrouplevel';
			oldGroups = SCOM.copy(this.colGroups);
		}else{
			update = 'updateRowGroups';
			action = state ? 'showRow' : 'hideRow';
			reaction = !state ? 'showRow' : 'hideRow';
			event = 'togglerowgrouplevel';
			oldGroups = SCOM.copy(this.rowGroups);
		}
		this.toggleGroupNo(dir, level, state);
		var groups = this[dir+'Groups'], showns = {}, hiddens = {};
		if(state){
			/*
			 * expand
			 */
			var others = [];
			for(var i = 0, len = groups.length; i < len; i++){
				var group = groups[i], span = group.span;
				if(group.level >= level){
					delete(group.collapsed);
					var arr = store[action](sheetId, span[0]+1, span[1], true);
					for(var k = 0, size = arr.length; k < size; k++){
						showns[arr[k]] = true;
					}
				}else{
					others.push(group);
				}
			}
			for(var i = 0, len = others.length; i < len; i++){
				var group = others[i], span = group.span;
				group.collapsed = true;
				var arr = store[reaction](sheetId, span[0]+1, span[1], true);
				for(var k = 0, size = arr.length; k < size; k++){
					hiddens[arr[k]] = true;
				}
			}
			
		}else{
			/*
			 * collapse
			 */
			var others = [];
			for(var i = 0, len = groups.length; i < len; i++){
				var group = groups[i], span = group.span;
				if(group.level == level){
					others.push(group);
				}else if(group.level > level){
					delete(group.collapsed);
					var arr = store[reaction](sheetId, span[0]+1, span[1], true);
					for(var k = 0, size = arr.length; k < size; k++){
						showns[arr[k]] = true;
					}
				}
			}
			for(var i = 0, len = others.length; i < len; i++){
				var group = others[i], span = group.span;
				group.collapsed = true;
				var arr = store[action](sheetId, span[0]+1, span[1], true);
				for(var k = 0, size = arr.length; k < size; k++){
					hiddens[arr[k]] = true;
				}
			}
		}
		
		
		/*
		 * update to store
		 */
		this[update]();
		/*
		 * refresh the sheet
		 */
		this.refresh();
		
		var newGroups;
		if('row' == dir){
			newGroups = this.updateRowGroups();
		}else{
			newGroups = this.updateColumnGroups();
		}
		var newLevels = this.getGroupLevel(dir);
		
		/*
		 * fire togglegrouplevel event to let history know
		 */
		this.fireEvent(event, state, sheetId, showns, hiddens, oldGroups, newGroups, oldLevels, newLevels, this);
	},
	
	/*
	 * click on inner ct
	 */
	onClickInnerCt : function(e){		
		var rowGroup = e.getTarget('.ss-row-group', null, true);
		if(rowGroup){
			/*
			 * click on row group
			 */
			var name = rowGroup.dom.getAttribute('name'), start = rowGroup.dom.getAttribute('start'), end = rowGroup.dom.getAttribute('end');
			start = Number(start);
			end = Number(end);
			this.toggleRowGroup(name, rowGroup.hasCls('ss-collasped-group'), [start, end], rowGroup.hasCls('ss-row-group-end'));
		}else{
			var colGroup = e.getTarget('.ss-col-group', null, true);
			if(colGroup){
				/*
				 * click on column group
				 */
				var name = colGroup.dom.getAttribute('name'), start = colGroup.dom.getAttribute('start'), end = colGroup.dom.getAttribute('end');
				start = Number(start);
				end = Number(end);
				this.toggleColumnGroup(name, colGroup.hasCls('ss-collasped-group'), [start, end], colGroup.hasCls('ss-col-group-end'));
			}else{
				var rowGroupNo = e.getTarget('.ss-row-group-no', null, true);
				if(rowGroupNo){
					var level = rowGroupNo.dom.getAttribute('level');
					level = Number(level);
					if(rowGroupNo.hasCls('ss-group-level-collapsed')){
						this.toggleGroupLevel('row', level, true);
					}else{
						this.toggleGroupLevel('row', level, false);
					}
				}else{
					var colGroupNo = e.getTarget('.ss-col-group-no', null, true);
					if(colGroupNo){
						var level = colGroupNo.dom.getAttribute('level');
						level = Number(level);
						if(colGroupNo.hasCls('ss-group-level-collapsed')){
							this.toggleGroupLevel('col', level, true);
						}else{
							this.toggleGroupLevel('col', level, false);
						}
					}
				}
			}
		}
	},
	
	/*
	 * toggle row group
	 */
	toggleRowGroup : function(name, expand, span, atEnd){
		var store = this.getStore(), sheetId = this.getSheetId();
		var oldRowGroups = SCOM.copy(this.rowGroups);
		/*
		 * click on column group
		 */		
		var minrow = span[0], maxrow = span[1], pinrow;
		if(atEnd){
			maxrow--;
			pinrow = span[1];
		}else{
			minrow++;
			pinrow = span[0];
		}
		var rows = [];
		if(expand){
			/*
			 * update the row group status
			 */
			this.updateGroupState('row', name, false);
			/*
			 * only expand the rows without other collapsed group
			 */
			for(var i = minrow; i <= maxrow; i++){
				var groups = this.getGroupsByIndex('row', i);
				var flag = true;
				if(groups){
					for(var j in groups){
						var group = groups[j];
						if(j != name && group.collapsed && group.collapsed != i){
							flag = false;
							break;
						}
					}
				}
				if(flag){
					rows.push(i);
					store.showRow(sheetId, i, i, true);
				}
			}
		}else{
			/*
			 * update the row group status
			 */
			this.updateGroupState('row', name, pinrow);
			
			rows = store.hideRow(sheetId, minrow, maxrow, true);
		}
		/*
		 * save the changes to store
		 */
		var rowGroups = this.updateRowGroups();
		
		this.refresh();
		/*
		 * fire togglecolgroup event to let history know
		 */
		this.fireEvent('togglerowgroup', name, expand, sheetId, rows, oldRowGroups, rowGroups, this);
	},
	
	/*
	 * toggle column group
	 */
	toggleColumnGroup : function(name, expand, span, atEnd){
		var store = this.getStore(), sheetId = this.getSheetId();
		var oldColGroups = SCOM.copy(this.colGroups);
		/*
		 * click on column group
		 */		
		var mincol = span[0], maxcol = span[1], pincol;
		if(atEnd){
			maxcol--;
			pincol = span[1];
		}else{
			mincol++;
			pincol = span[0];
		}
		var columns = [];
		if(expand){
			/*
			 * update the row group status
			 */
			this.updateGroupState('col', name, false);
			/*
			 * only expand the rows without other collapsed group
			 */
			for(var i = mincol; i <= maxcol; i++){
				var groups = this.getGroupsByIndex('col', i);
				var flag = true;
				if(groups){
					for(var j in groups){
						var group = groups[j];
						if(j != name && group.collapsed && group.collapsed != i){
							flag = false;
							break;
						}
					}
				}
				if(flag){
					columns.push(i);
					store.showColumn(sheetId, i, i, true);
				}
			}						
		}else{
			/*
			 * update the row group status
			 */
			this.updateGroupState('col', name, pincol);			
			columns = store.hideColumn(sheetId, mincol, maxcol, true);
		}
		/*
		 * save the changes to store
		 */
		var colGroups = this.updateColumnGroups();
		this.refresh();
		/*
		 * fire togglecolgroup event to let history know
		 */
		this.fireEvent('togglecolgroup', name, expand, sheetId, columns, oldColGroups, colGroups, this);
	},
	
	/*
	 * update group state
	 */
	updateGroupState : function(dir, name, collapsed){
		if('row' !== dir){
			dir = 'col';
		}
		var map = this[dir+'GroupNameMap'];
		if(map && map[name]){
			map[name].collapsed = collapsed;
		}
	},
		
	/*
	 * add a new col/row group
	 */
	add2Groups : function(dir, group, setFlag){
		var name;
		if(group){
			name = group.span.join('$');		
			if('row' !== dir){
				dir = 'col';
			}
			var groups = this[dir+'Groups'] || [];
			groups.push(group);
			this[dir+'Groups'] = groups;
		}
		if(setFlag){
			/*
			 * update the group info
			 */
			if('row' == dir){
				this.setRowGroups(this.rowGroups);
			}else{
				this.setColumnGroups(this.colGroups);
			}
		}		
		return name;
	},
	
	/*
	 * remove some groups
	 */
	removeFromGroups : function(dir, removes, setFlag){		
		var groups = this[dir+'Groups'];
		if(groups){
			for(var name in removes){
				if(removes.hasOwnProperty(name)){
					for(var i = 0, len = groups.length; i < len; i++){
						var group = groups[i];
						if(group.span.join('$') == name){
							groups.splice(i, 1);
							break;
						}
					}
				}
			}
			
			if(0 == groups.length){
				delete(this[dir+'Groups']);
			}
		}
		
		if(setFlag){
			/*
			 * update the group info
			 */
			if('row' == dir){
				this.setRowGroups(this.rowGroups);
			}else{
				this.setColumnGroups(this.colGroups);
			}
		}
	},
	
	clearGroups : function(dir, setFlag){
		delete(this[dir+'Groups']);
		if(setFlag){
			/*
			 * update the group info
			 */
			if('row' == dir){
				this.setRowGroups(this.rowGroups);
			}else{
				this.setColumnGroups(this.colGroups);
			}
		}
	},
		
	/*
	 * prepare group for add
	 */
	prepareGroupForAdd : function(dir, start, end){
		var maps = this[dir+'GroupLookup'], lookup = this[dir+'GroupNameMap'], maxLevel = this[dir+'GroupMaxLevel'];
		if(maps){
			/*
			 * get related groups and put them in different levels
			 */
			var levels = {};
			for(var i = start; i <= end; i++){
				var groups = maps[i];
				if(groups){
					for(var j in groups){
						var group = groups[j], span = group.span, level = group.level;						
						levels[level] = levels[level] || {};
						levels[level][j] = group;
					}
				}				
			}		
			/*
			 * loop to find the right place for the new group
			 */
			var flag = false, included = false, level = 1, removes = {}, includes = {};
			for(var i = maxLevel; 1 <= i; i--){				
				var line = levels[i];
				if(line){
					for(var n in line){
						var group = line[n], span = group.span, name = n;
						if(span[0] == start && end == span[1]){
							/*
							 * means already have a group with the same span, just ignore it and return
							 */
							return;
						}else if(span[0] <= start && end <= span[1]){
							/*
							 * skip this level, check other levels
							 */
							break;
						}else if(span[0] >= start && end >= span[1]){
							if(!flag){
								/*
								 * if includedd an existed group and has no overlap with others, then it's a high level one
								 */
								included = true;
								level = i+1;
								flag = true;
								includes[name] = true;
							}else{
								removes[name] = true;
							}							
						}else if(span[0] <= start && start <= span[1]){
							/*
							 * update the span
							 */
							level = i;
							included = false;
							flag = true;
							start = span[0];
							if(span[1] > end){
								end = span[1];
							}	
							removes[name] = true;
						}else if(span[0] <= end && end <= span[1]){
							/*
							 * update the span
							 */
							level = i;
							included = false;
							flag = true;
							end = span[1];
							if(span[0] < start){
								start = span[0];
							}
							removes[name] = true;
						}else{
							level = i;
							flag = true;
							included = false;
						}
					}
				}else{
					level = i;
					flag = true;
					break;
				}
				if(flag){					
					break;
				}
			}
			
			if(flag){
				if(included){
					/*
					 * if the added one includedd some old one
					 * first we need check whether there is empty space in the low level, 
					 * if yes then move upper levels in the span downstair
					 */
					var min = maxLevel, max = 0, stopFlag, tmpSet = {};
					for(var i = start; i <= end; i++){
						var obj = maps[i];
						for(var p in obj){							
							var group = obj[p], lv = group.level;
							tmpSet[p] = group;
							if(lv < min){
								min = lv;
							}
							if(lv > max){
								max = lv;
							}
							if(maxLevel == max-min+1){
								stopFlag = true;
								break;
							}
						}
						if(stopFlag){
							break;
						}
					}
					
					if(stopFlag){
						var buts = {};
						for(var k = 1; k < level; k++){
							var line = levels[k];
							if(line){
								for(var m in line){
									buts[m] = line[m];
								}
							}
						}						
						for(var name in lookup){
							if(!buts[name]){
								lookup[name].level++;
							}							
						}
					}else{
						level--;
						for(var p in tmpSet){							
							if(level >= tmpSet[p].level){
								tmpSet[p].level--;
							}
						}
					}					
				}else{
					Ext.apply(removes, includes);
				}
				return {
					group: {
						level: level,
						span: [start, end]
					},
					removes: removes
				};
			}else{
				var group = {
					level: 1,
					span: [start, end]
				};
				var groups = this[dir+'Groups'];
				for(var i = 0, len = groups.length; i < len; i++){
					groups[i].level++;
				}				
				return {
					group: group
				};
			}			
		}else{
			return {
				group: {
					level: 1,
					span: [start, end]
				}
			};
		}
	},
	
	/*
	 * prepare for cancel group
	 */
	prepareGroupForCancel : function(dir, start, end){
		var maps = this[dir+'GroupLookup'], maxLevel = this[dir+'GroupMaxLevel'];
		if(maps){
			/*
			 * get related groups and put them in different levels
			 */
			var levels = {};
			for(var i = start; i <= end; i++){
				var groups = maps[i];
				if(groups){
					for(var j in groups){
						var group = groups[j], span = group.span, level = group.level;						
						levels[level] = levels[level] || {};
						levels[level][j] = group;
					}
				}				
			}
			
			var removes = {}, flag = false, level;
			for(var i = 1; i <= maxLevel; i++){
				if(flag){
					break;
				}
				level = i;
				var line = levels[i];
				if(line){
					for(var name in line){
						var group = line[name], span = group.span;
						if((start <= span[0] && end >= span[1]) || (span[0] <= start && start <= span[1]) || (span[0] <= end && end <= span[1])){
							flag = true;
							removes[name] = true;
						}
					}
				}
			}
			
			var nameMaps = this[dir+'GroupNameMap'], left = false;
			for(var name in nameMaps){
				var group = nameMaps[name];
				if(group.level == level && !removes[name]){
					left = true;
					break;
				}
			}
			if(!left){
				for(var name in nameMaps){
					var group = nameMaps[name];
					if(group.level > level){
						group.level--;
					}
				}
			}
			
			return {
				removes: removes
			};
		}
	},
	
	/*
	 * prepare group for a span
	 */
	prepareGroupForSpan : function(dir, action, start, end){
		if('cancel' == action){
			return this.prepareGroupForCancel(dir, start, end);
		}else{
			return this.prepareGroupForAdd(dir, start, end);
		}
	},
	
	/*
	 * get groups by index
	 */
	getGroupsByIndex : function(dir, index){
		var maps = this[dir+'GroupLookup'];
		if(maps){
			return maps[index];
		}
	},
	
	/*
	 * return true if the selection includedd a group
	 */
	isSelectedGroup : function(dir){
		var sm = this.getSelectionModel();
		var span = sm.selection2Span();
		if('row' == dir){
			if(this.rowGroupLookup){
				var minrow = span[1], maxrow = span[3];
				for(var i = minrow; i <= maxrow; i++){
					var groups = this.rowGroupLookup[i];
					if(groups && !SCOM.isEmptyObj(groups)){
						return true;
					}
				}
			}
		}else{
			if(this.colGroupLookup){
				var mincol = span[2], maxcol = span[4];
				for(var i = mincol; i <= maxcol; i++){
					var groups = this.colGroupLookup[i];
					if(groups && !SCOM.isEmptyObj(groups)){
						return true;
					}
				}
			}
		}
		return false;
	},
	
	/*
	 * add group for selection
	 */
	addGroupForSelection : function(){
		this.updateGroupForSelection();
	},
	
	/*
	 * cancel group for selection
	 */
	cancelGroupForSelection : function(){
		this.updateGroupForSelection('cancel');
	},
	
	/* 
	 * update group for selection, add or cancel group
	 */
	updateGroupForSelection : function(action){
		var store = this.getStore(), sheetId = this.getSheetId();
		var sm = this.getSelectionModel();		
		var span = sm.selection2Span();
		if(0 == span[1]){
            this.updateColGroup(action, span[2], span[4]);
		}else if(0 == span[2]){
            this.updateRowGroup(action, span[1], span[3]);
		}
	},
        
    /**
     * apply the groups
     */
    applyGroups : function(groups, suspendUpdateStore){
		var store = this.getStore(), curSheetId = this.getSheetId(), needLayout;
        var oldMaxLevel = this.rowGroupMaxLevel;
        var oldMaxLevel = this.colGroupMaxLevel;
        var oldRowGroups = SCOM.copy(this.rowGroups);
        var oldColGroups = SCOM.copy(this.colGroups);
           
        for(var i = 0, len = groups.length; i < len; i++){
            var it = groups[i];
            var dir = it.dir, sheetId = Ext.isDefined(it.sheetId) ? it.sheetId : curSheetId;
            var startIndex = it.start, endIndex = it.end, action = it.action;
            if('row' === dir){
                /*
                 * for row dir
                 */
                var obj = this.prepareGroupForSpan('row', action, startIndex, endIndex);
           
                if(obj){
                    this.removeFromGroups('row', obj.removes);
                    this.add2Groups('row', obj.group, true);
                    this.updateRowGroups(suspendUpdateStore);
                    if(!needLayout){
                        needLayout = oldMaxLevel != this.colGroupMaxLevel;
                    }
                }
            }else{
                /*
                 * for column dir
                 */
                var obj = this.prepareGroupForSpan('col', action, startIndex, endIndex);
           
                if(obj){
                    this.removeFromGroups('col', obj.removes);
                    this.add2Groups('col', obj.group, true);
                    this.updateColumnGroups(suspendUpdateStore);
                    if(!needLayout){
                        needLayout = oldMaxLevel != this.rowGroupMaxLevel;
                    }
                }
            }
        }
        this.refresh();
        if(needLayout){
			if(Ext.isFunction(this.doLayout)){
				this.doLayout();
			}else if(Ext.isFunction(this.updateLayout)){
				this.updateLayout();
			} 
		}
        var rowGroups = SCOM.copy(this.rowGroups);
        var colGroups = SCOM.copy(this.colGroups);
        /*
         * fire addgroup event to history
         */
        this.fireEvent('updategroups', sheetId, oldRowGroups, oldColGroups, rowGroups, colGroups, this);
    },
           
    /**
     * update col group for span
     */
    updateColGroup : function(action, mincol, maxcol, suspendUpdateStore){
		var store = this.getStore(), sheetId = this.getSheetId();
        var oldMaxLevel = this.colGroupMaxLevel;
        var oldColGroups = SCOM.copy(this.colGroups);
        /*
         * for column dir
         */
        var obj = this.prepareGroupForSpan('col', action, mincol, maxcol);
           
        if(obj){
            this.removeFromGroups('col', obj.removes);
            this.add2Groups('col', obj.group, true);
           
            var colGroups = this.updateColumnGroups(suspendUpdateStore);
            this.refresh();
            /*
             * fire addgroup event to history
             */
            this.fireEvent('changegroup', 'col', sheetId, oldColGroups, colGroups, this);
            
            if(oldMaxLevel != this.colGroupMaxLevel){
    			if(Ext.isFunction(this.doLayout)){
    				this.doLayout();
    			}else if(Ext.isFunction(this.updateLayout)){
    				this.updateLayout();
    			} 
    		}
        }
    },
           
    /**
     * update row group for span
     */
    updateRowGroup : function(action, minrow, maxrow, suspendUpdateStore){
        var store = this.getStore(), sheetId = this.getSheetId();
        var oldMaxLevel = this.rowGroupMaxLevel;
        var oldRowGoups = SCOM.copy(this.rowGroups);
        /*
         * for row dir
         */
        var obj = this.prepareGroupForSpan('row', action, minrow, maxrow);
           
        if(obj){
            this.removeFromGroups('row', obj.removes);
            this.add2Groups('row', obj.group, true);
           
            var rowGroups = this.updateRowGroups(suspendUpdateStore);
            this.refresh();
            /*
             * fire addgroup event to history
             */
            this.fireEvent('changegroup', 'row', sheetId, oldRowGoups, rowGroups, this);
            
            if(oldMaxLevel != this.rowGroupMaxLevel){
    			if(Ext.isFunction(this.doLayout)){
    				this.doLayout();
    			}else if(Ext.isFunction(this.updateLayout)){
    				this.updateLayout();
    			} 
    		}
        }
    },
           
           
	
	/*
	 * reset all calculate in all sheets, it should be called after sheet is renamed or deleted
	 */
	resetAllCalculates : function(changedTab, deletedTabName, callback, scope){
		var changedTabName, oldTabName;
		if(changedTab){
			changedTabName = changedTab.name;
			oldTabName = changedTab.lastOldName;
		}		
		var me = this, sm = me.getSelectionModel(), store = this.getStore();
		var changed = {};
		if(this.calculate){
			store.each(function(rd, internalId){
				var json = rd.data.json;
				if(json.cal && json.data){
					var flag = !oldTabName && !deletedTabName;
					if(!flag && oldTabName && -1 !== json.data.indexOf(oldTabName)){
						flag = true;
					}
					if(!flag && deletedTabName && -1 !== json.data.indexOf(deletedTabName)){
						flag = true;
					}
					if(flag){
						var old = Ext.apply({}, json);
						var modified = me.resetCalculateCellData(old, rd.data.sheet, rd.data.row, rd.data.col, undefined, undefined, undefined, true, undefined, changedTabName);
						var data = modified.data;
						if(data != old.data || modified.arg != old.arg){								
							store.setCell(rd.data.sheet, rd.data.row, rd.data.col, modified, null, true);
							if(modified.arg != old.arg){
								changed[internalId] = [rd.data.sheet, rd.data.row, rd.data.col];
							}
						}
					}													
				}
			});
		}	
		
		if(changed){				
			Ext.Function.defer(function(){
				/*
				 * refresh the new sheet,
				 * refresh the calculate and condition cell
				 */
				this.refreshRange(null, changed);
				if(callback){
					callback.call(scope);
				}
			}, 10, this);			
		}else{
			if(callback){
				callback.call(scope);
			}
		}
		/*
		 * refresh focuse cell
		 */
		this.refreshFocus();
	},
	
	/*
	 * after rename a sheet, sync the sheet name in related calculate
	 */
	afterRenameSheet : function(sheetId, newName){
		this.loadMask.show();
		Ext.Function.defer(function(){
			var tab = this.store.getSheetById(sheetId);
			this.resetAllCalculates(tab, undefined, function(){
				this.loadMask.hide();
			}, this);			
		}, 1, this);		
	},
	
	/*
	 * after delete a sheet, sync the related calculate
	 */
	afterDeleteSheet : function(sheetId, deletedSheet){
		this.loadMask.show();
		Ext.Function.defer(function(){
			this.resetAllCalculates(undefined, deletedSheet.name, function(){
				this.loadMask.hide();
			}, this);			
		}, 1, this);		
	},
	
	/*
	 * when a floor is moved or resized, we will sync the change to store 
	 */
	onFloorMoveResize : function(floor){		
		this.syncFloors(floor, 'update');
	},
	
	/*
	 * sync the floors when the range store is changed
	 */
	onRangeStoreCoordChange : function(rangeStore){
		var floorSet = this.getFloorSet();
		var relatedFloors = [];
		for(var p in floorSet){
			var floor = floorSet[p];
			if('function' == Ext.typeOf(floor.getRangeStore)){
				if(floor.getRangeStore() == rangeStore){
					relatedFloors.push(floor);
				}
			}
		}
		if(0 < relatedFloors.length){
			this.syncFloors(relatedFloors, 'update');
		}		
	},
	
	/*
	 * update the change to store
	 */
	onChartChange : function(chartFloor){
		this.syncFloors(chartFloor, 'update');
	},
	
	/*
	 * change sheet order
	 */
	changeSheetOrder : function(preIndex, curIndex, callback, scope){
		this.getStore().changeSheetOrder(preIndex, curIndex, callback, scope);
	},
	
	/*
	 * focus the center region
	 */
	focus : function(delay){
		this.getEditor().focus(delay);
	},
	
	
	/*
	 * when prepare autofill
	 */
	onPrepareAutofill : function(sm){
		for(var i = 0, len = this.regionLookup.length; i < len; i++){
			var region = this[this.regionLookup[i]];
			var selModel = region.getSelectionModel();
			if(selModel != sm){
				selModel.prepareForAutofill(true);
			}
		}
	},
	
	onResetAutofill : function(sm){
		for(var i = 0, len = this.regionLookup.length; i < len; i++){
			var region = this[this.regionLookup[i]];
			var selModel = region.getSelectionModel();
			if(selModel != sm){
				selModel.resetAutofill(true);
			}
		}
	},
	
	/*
	 * set item for the selection
	 * can be a checkbox, radio or something else
	 */
	setItemForSelection : function(itemType, itemName){
		var sm = this.getSelectionModel();
		var coord = sm.selection2Coord();
		var range = new EnterpriseSheet.sheet.range.Range({
			sheet: this,
			coord: coord
		});
		var modified = {
			'it': itemType || '',
			'itn': itemName || '',
			'itchk': false
		};
		
		range.setProperty(modified);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
	},
	
	clearItemForSelection : function(){
		var sm = this.getSelectionModel();
		var coord = sm.selection2Coord();
		var range = new EnterpriseSheet.sheet.range.Range({
			sheet: this,
			coord: coord
		});
		
		range.setProperty({'it': '', 'itn': ''}, ['itchk']);    
	},
	
	/*
	 * click on in-cell item
	 */
	onClickCellItem : function(tagName, target, rowCol, region){
		
		if('INPUT' == tagName){
            this.fireEvent('prepareclickitem', tagName, target, rowCol, this);
            target = Ext.get(target);
            var checked = target.getAttribute('checked');
            var row = rowCol[0], col = rowCol[1];
            var sheetId = this.getSheetId(), store = this.getStore();
            var cell = this.getCellProperty(sheetId, row, col);
            var itemType = cell.it, itemName = cell.itn, itchk = cell.itchk;
            /*
             * for readonly we need set the checked back to the pre state
             */
            if(this.isReadOnly()){
                if(itchk){
                    target.dom.checked = 'checked';
                }else{
                    target.dom.checked = '';
                }
                return;
            }
			
			var coord;
			if('radio' == itemType){
				var arr = [[sheetId, row, col, row, col]];
				store.walkRange([[sheetId, 0, 0, 0, 0]], function(rd){
					var r = rd.data.row, c = rd.data.col;
					var cell = this.getCellProperty(rd.data.sheet, r, c);
					if(itemName == cell.itn && cell.itchk && itemType == cell.it && !(row == r && col == c)){
						arr.push([rd.data.sheet, r, c, r, c]);
					}
				}, this, true);
				coord = arr;
			}else{
				coord = [[sheetId, row, col, row, col]];
			}
			var range = new EnterpriseSheet.sheet.range.Range({
				sheet: this,
				coord: coord
			})
			if(checked){
				if('radio' == itemType){
					/*
					 * for group, we will toggle the checked
					 */
					range.toggleItemCheck(sheetId, row, col);
				}else if('checkbox' === itemType){
					store.setCell(sheetId, row, col, {'itchk':true});
				}else{
					range.setProperty({'itchk':true});
				}
			}else{
				if('checkbox' === itemType){
					store.setCell(sheetId, row, col, undefined, ['itchk']);
				}else{
					range.setProperty(null, ['itchk']);
				}
			}
		} else if('BUTTON' == tagName) { 
            this.fireEvent('prepareclickitem', tagName, target, rowCol, this);           
			var row = rowCol[0], col = rowCol[1];
			var sheetId = this.getSheetId(), store = this.getStore();
            var cell = store.getCellProperty(sheetId, row, col);
            if (cell.onBtnClickFn) {        
                this.onCellEventCallback("onBtnClickFn", sheetId, row, col);
            }
		} else if('TRIGGER' == tagName){
			var row = rowCol[0], col = rowCol[1];
			var sheetId = this.getSheetId();			
			this.fireEvent('clickcelltrigger', sheetId, row, col, region, this, target);
		}
	},	

           
    /**
     * before mouse down on a cell, return false to cancel the mousedown event
     */
    beforeCellMouseDown : function(row, col, region, e){
        var xy = e.getXY(), store = this.getStore();
        var cell = store.getCell(this.getSheetId(), row, col);
        if(Ext.isDefined(cell.minrow)){
            row += cell.minrow;
            col += cell.mincol;
        }
        var cellEl = region.getCellEl(row, col);
        if(cellEl) {
            var inputEl = cellEl.down('input'), buttonEl = cellEl.down('button'), triggerEl = cellEl.down('.ss-trigger');
            if(inputEl) {          	
                var left = inputEl.getLeft(), top = inputEl.getTop(), right = inputEl.getRight(), bottom = inputEl.getBottom();
                var x = xy[0], y = xy[1];
                if(left <= x && x <= right && top <= y && y <= bottom){
                    if(inputEl.getAttribute('checked') && 'checkbox' === inputEl.dom['type'])  inputEl.dom.checked = '';
                    else inputEl.dom.checked = 'checked';                 
                    this.onClickCellItem('INPUT', inputEl, [row, col], region);
                    return false; // cancel event
                }
            }
            if(buttonEl) {          	
                var left = buttonEl.getLeft(), top = buttonEl.getTop(), right = buttonEl.getRight(), bottom = buttonEl.getBottom();
                var x = xy[0], y = xy[1];
                if(left <= x && x <= right && top <= y && y <= bottom){            
                    this.onClickCellItem('BUTTON', buttonEl, [row, col], region);
                    return false; // cancel event
                }
            }
            if(triggerEl) {          	
                var left = triggerEl.getLeft(), top = triggerEl.getTop(), right = triggerEl.getRight(), bottom = triggerEl.getBottom();
                var x = xy[0], y = xy[1];
                if(left <= x && x <= right && top <= y && y <= bottom){                	
                    this.onClickCellItem('TRIGGER', triggerEl, [row, col], region);
                    return false; // cancel event
                }
            }
        }
    },
	
	/*
	 * when mouse down on a cell, need set the focus cell
	 */
	onCellMouseDown : function(row, col, region, e){
		var sm = region.getSelectionModel();

		if(!sm.disabled){
			if(0 == row && 0 == col){
				if(this.ltregion.isVisible()){
					region = this.ltregion;
				}else if(this.tregion.isVisible()){
					region = this.tregion;
				}else if(this.lregion.isVisible()){
					region = this.lregion;
				}else{
					region = this.cregion;
				}
				row = region.rowStart;
				col = region.colStart;
			}else if(0 == row){
				if(this.ltregion.isVisible()){
					region = this.ltregion;
				}else if(this.lregion.isVisible()){
					region = this.lregion;
				}else{
					region = this.cregion;
				}
				row = region.rowStart;
			}else if(0 == col){
				if(this.ltregion.isVisible()){
					region = this.ltregion;
				}else if(this.tregion.isVisible()){
					region = this.lregion;
				}else{
					region = this.cregion;
				}
				col = region.colStart;
            }
			sm.setFocusCell(row, col);
			
			// call back function
			this.onCellEventCallback("onCellMouseDownFn", region.getSheetId(), row, col);
		}
	},	
	
	/**
	 * when column is resized
	 */
	onColumnResized : function(col, old, cur){
		var mincol = false, maxcol = false, relatedRows = {};
		var sheetId = this.getSheetId();
		for(var p in cur){
			if(cur.hasOwnProperty(p)){
				var col = Number(p);
				if(Ext.isNumber(col)){
					Ext.apply(relatedRows, this.getRelatedRowsForAutoHeight([[sheetId, 0, col, 0, col]]));
				}
			}
		}
		
		var changedHeights = this.checkAutoHeightForRows(relatedRows);
		
		this.fireEvent('aftercolumnresized', col, old, cur, changedHeights, this);
	},
	
	onSelectedColumnResized : function(w, mincol, maxcol){
		this.setColumnWidth(w, {mincol:mincol, maxcol:maxcol});
		/*
		 * return false to cancal the default move
		 */
		return false;
	},
	
	onSelectedRowResized : function(h, minrow, maxrow){
		this.setRowHeight(h, {minrow:minrow, maxrow:maxrow});
		/*
		 * return false to cancal the default move
		 */
		return false;
	},
	
	/*
	 * get the related rows of the passed coord
	 */
	getRelatedRowsForAutoHeight : function(coord, modified, deleted, checkNoWrap, skipDefaultHeight){
		var store = this.getStore();
		var dh = store.defaultProperty.height;
		if((!modified && !deleted) || (modified && (modified['fz'] || modified['ws']))	
			|| (deleted && (-1 != Ext.Array.indexOf(deleted, 'fz') || -1 != Ext.Array.indexOf(deleted, 'ws')))){
			/*
			 * means the change could affect the row height, so we need check all related rows
			 */
			var relatedRows = {};
			store.walkRange(coord, function(rec){
				var sheetId = rec.data.sheet, row = rec.data.row, col = rec.data.col;
				if(0 !== row && 0 !== col){
					var id = sheetId+'-'+row;
					var rowPro = store.getCellProperty(sheetId, row, 0);
					if(!relatedRows[id]){
						if(!SCOM.canbeNumber(rowPro.height)){
							var autoHeight = Number(rowPro.autoHeight);
							if(!skipDefaultHeight || (Ext.isNumber(autoHeight) && autoHeight > dh)){
								if(!checkNoWrap){
									var cellPro = store.getCellProperty(sheetId, row, col);
									if('normal' == cellPro.ws){
										relatedRows[id] = {
											sheetId: sheetId,
											row: row,
											autoHeight: rowPro.autoHeight
										}	
									}
								}else{
									relatedRows[id] = {
										sheetId: sheetId,
										row: row,
										autoHeight: rowPro.autoHeight
									}
								}
							}											
						}
					}
				}
			}, this, true);
			return relatedRows;
		}
	},
	
	/*
	 * check autoHeight for the passed rows
	 */
	checkAutoHeightForRows : function(relatedRows, suspendRefresh){		
		var store = this.getStore(), dh = store.defaultProperty.height;
		var oldHeights = {}, newHeights = {}, minRow = false;
		for(var p in relatedRows){
			if(relatedRows.hasOwnProperty(p)){
				var it = relatedRows[p];
				var oldHeight;
				if(SCOM.nullOrUndefined(it.autoHeight) || '' === it.autoHeight){
					oldHeight = dh;
				}else{
					oldHeight = it.autoHeight;
				}
				var h = this.cregion.guessMaxRowHeight(it.sheetId, it.row);
				var isNum = Ext.isNumber(h);
				if(isNum){
					h = store.correctRenderHeight(h);
				}
				if(h !== oldHeight){
					var id = it.sheetId+'-'+it.row;
					oldHeights[id] = {
						sheetId: it.sheetId,
						row: it.row,
						ah: oldHeight						
					};
					newHeights[id] = {
						sheetId: it.sheetId,
						row: it.row,						
						ah: h
					};
					if(false === minRow || minRow > it.row){
						minRow = it.row;
					}
					if(isNum){
						store.setRow(it.sheetId, it.row, {'autoHeight': h}, null, true, suspendRefresh, null, true);
					}else{
						store.setRow(it.sheetId, it.row, null, ['autoHeight'], true, suspendRefresh, null, true);
					}					
				}
			}
		}
		if(this.isFreezed()){
			if(minRow <= this.freezePos.row){
				this.onUpperRowResize();
			}			
		}	
		return {
			oldHeights: oldHeights,
			newHeights: newHeights
		};
	},
	
	/*
	 * check the oldCoord and paste coord, whether need recalculate the autoHeight for related rows
	 */
	checkAutoHeightForCoord : function(avoidCoord, coord, suspendRefresh, checkNoWrap, skipDefaultHeight){
		var relatedRows = {};
		var store = this.getStore();
		var dh = store.defaultProperty.height;
		store.walkRange(coord, function(rec){
			var sheetId = rec.data.sheet, row = rec.data.row, col = rec.data.col;
			if(!avoidCoord || !EnterpriseSheet.sheet.range.Range.prototype.isIncluded(sheetId, row, col, avoidCoord)){
				if(0 !== row && 0 !== col){
					var id = sheetId+'-'+row;
					var rowPro = store.getCellProperty(sheetId, row, 0);
					if(!SCOM.canbeNumber(rowPro.height)){
						var autoHeight = Number(rowPro.autoHeight);
						if(!skipDefaultHeight || (Ext.isNumber(autoHeight) && autoHeight > dh)){
							if(!checkNoWrap){
								var cellPro = store.getCellProperty(sheetId, row, col);
								
								if('normal' == cellPro.ws){
									relatedRows[id] = {
										sheetId: sheetId,
										row: row,
										autoHeight: rowPro.autoHeight
									}
								}								
							}else{
								relatedRows[id] = {
									sheetId: sheetId,
									row: row,
									autoHeight: rowPro.autoHeight
								}
							}
						}											
					}
				}
			}
		});
		return this.checkAutoHeightForRows(relatedRows, suspendRefresh);
	},
	
	/*
	 * adjust autoheight for the rows effect by the column resize
	 */
	adjusAutotHeightForColumn : function(sheetId, mincol, maxcol, suspendRefresh, checkNoWrap, skipDefaultHeight){
		return this.checkAutoHeightForCoord(null, [[sheetId, 0, mincol, 0, maxcol]], suspendRefresh, checkNoWrap, skipDefaultHeight);
	},
	
	/*
	 * mark selection
	 */
	markSelection : function(){
		var me = this, store = me.getStore();
		var refs = store.getRefConfig();
		var sm = me.getSelectionModel();
		var coord = sm.selection2Coord();
		SPOP.showReferenceNameBox({
			sheet: this,
			title: SLANG['define_reference'],
			fieldLabel: SLANG['input_reference_name'],
			refList: refs,
			refValue: coord,
			applyCallback : {
				fn: function(name, val, ctype, scope){
					var store = me.getStore();
                    if('named_func' === ctype){
                        var found = store.getFileConfigById(name, ctype);
                        if(found){
                            var json = Ext.decode(found.json);
                            if(!Ext.isArray(json)){
                                json = [json];
                            }
                            for(var i = 0, len = json.length; i < len; i++){
                                var it = json[i];
                                if(it.scope === scope){
                                    it.cal = val;
                                    store.setFileConfig(ctype, name, 1 === len ? Ext.encode(json[0]) : Ext.encode(json));
                                    return;
                                }
                            }
                            var obj = {
                                'cal': val
                            };
                            if(Ext.isDefined(scope)){
                                obj['scope'] = scope;
                            }
                            json.push(obj);
                            store.setFileConfig(ctype, name, Ext.encode(json));
                        }else{
                            var json = {
                                'cal': val
                            };
                            if(Ext.isDefined(scope)){
                                json['scope'] = scope;
                            }
                            store.setFileConfig(ctype, name, Ext.encode(json));
                        }
                    }
				},
				scope: this
			},
            deleteCallback : {
                fn: function(ctype, name, scope){
                    var found = store.getFileConfigById(name, ctype);
                    var json;
                    try{
                        json = Ext.decode(found.json);
                        if(!Ext.isArray(json)){
                            json = [json];
                        }
                        var arr = [];
                        for(var i = 0, len = json.length; i < len; i++){
                            var it = json[i];
                            if(it.scope !== scope){
                                arr.push(it);
                            }
                        }
                        var alen = arr.length;
                        if(0 < alen){
                            store.setFileConfig(ctype, name, 1 === alen ? Ext.encode(arr[0]) : Ext.encode(arr));
                        }else{
                            store.setFileConfig(ctype, name);
                        }
                    }catch(e){
                        store.setFileConfig(ctype, name);
                    }
                },
                scope: this
            },
			checkValid : function(win){
				var name = win.nameField.getValue();
				var calculate = me.calculate;
				if(name && calculate){
					/*
					 * check whether this name is taked by calculate
					 */
					var cals = calculate.calculates;
					var upper = name.toUpperCase();
					var lower = name.toLowerCase();
					if(cals[upper] || cals[lower]){
						Ext.Msg.alert(SLANG['hint'], SLANG['name_repeated_with_calculate']);
						return false;
					}else{						
						// it should start with a letter or underscore
						// TODO: 12_  --- this should not allowed ... do not know why the following match does not work ...
						if(-1 != upper.indexOf(' ') || 0 < EnterpriseSheet.sheet.calculate.Coordinate.prototype.string2Coord(upper).length
								|| Ext.isNumber(Number(upper)) || !(/^[a-zA-Z_]/.test(upper)) ){
							Ext.Msg.alert(SLANG['hint'], SLANG['reference_name_invalid']);
							return false;
						}
					}
				}
				return true;
			}
		});
	},
	
	/**
	 * when file config reference item is changed
	 */
	onRefConfigChange : function(refStr, store, changed, cdts){
        var cellCoord = [];
        for(var p in changed){
            if(changed.hasOwnProperty(p) && 'deleted' !== changed[p]){
                var it = cdts[p];
                if(it.refs){
                    cellCoord = cellCoord.concat(it.refs);
                }
            }
        }
        /*
         * check and load these cells refered by the calculate if not loaded
         */
        store.checkLoadCoord(cellCoord, function(){
            this.refreshCalCdt(this.findNameRefCells(changed) || {});
        }, this);
	},
	
	/**
	 * get the conditions of the passed coord
	 */
	getCdtsFromCoord : function(coord, decode){
        var coordPro = EnterpriseSheet.sheet.calculate.Coordinate.prototype;
		var store = this.getStore();
		var lookup = {}, cdts = store.getConditionLookup();
		store.walkRange(coord, function(rec){
            var sheetId = rec.data.sheet, row = rec.data.row, col = rec.data.col;
            var cellCoord = [sheetId, row, col];
    		for(var p in cdts){
    			if(cdts.hasOwnProperty(p) && !lookup.hasOwnProperty(p)){
    				var it = cdts[p], jsonObj = it.jsonObj, refs = it.refs;
                    if(refs && coordPro.isCellInCoord(cellCoord, refs)){
                        lookup[p] = it;
                    }
    			}
    		}            
        }, this, true);
		
		var cdts = {};
		for(var p in lookup){
			if(lookup.hasOwnProperty(p)){
				var it = lookup[p];
				if(decode){
					cdts[it.name] = SCOM.copy(it.jsonObj);
				}else{
					cdts[it.name] = SCOM.copy(it);
				}				
			}
		}
		return cdts;
	},
	
	/**
	 * sync condition for the coord passed
	 */
	syncConditonForCoord: function(coord, cdts, cdtMap, oldCellCdtLookup){
		var me = this;
		var store = this.getStore();
		var lookup = {};
		for(var p in cdts){
			if(cdts.hasOwnProperty(p)){
                lookup[p] = {
                    rng:[]
                };
			}
		}
		
		store.walkRange(coord, function(rd, walkSpan, store, internalId){
			var sheetId = rd.data.sheet, row = rd.data.row, col = rd.data.col;
			var cdt = oldCellCdtLookup[internalId];
			if(cdt && 0 < cdt.length){
				for(var i = 0, len = cdt.length; i < len; i++){
					var it = cdt[i];
					var id = it.id;
					var newId = cdtMap[id].id;
					if(lookup[newId]){
                        lookup[newId].oldId = id;
						var rng = lookup[newId].rng;
						rng.push({
							span: [sheetId, row, col, row, col],
							type: SCONST.ABSOLUTE_COORD
						});
					}
				}
			}
		}, me);
		var needRefreshCdt;
		for(var p in lookup){
			if(lookup.hasOwnProperty(p)){
				var rng = lookup[p].rng, oldId = lookup[p].oldId;
				this.connectSpan(rng);
				var json = cdtMap[oldId].cdt, sheetId = cdtMap[oldId].sheet;
				json.rng = rng;
				json.id = p;
				store.setFloatingItem(sheetId, p, 'cdt', Ext.encode(json));
				needRefreshCdt = true;
			}
		}
		return needRefreshCdt;
	},
	
	
	/**
	 * get calCdt cells from the passed coord
	 */
	getCalCdtCellsFromCoord : function(coord, avoidCoord){
		
		var rangePro = EnterpriseSheet.sheet.range.Range.prototype;
		var reCalCells = {};
		var store = this.getStore();
		store.walkRange(coord, function(rd, walkSpan, store, internalId){
			var sheetId = rd.data.sheet, row = rd.data.row, col = rd.data.col;
			var json = rd.data.json;			
			if(json.cal || this.isConditionCell(json, sheetId, row, col)){				
				if(!avoidCoord || !rangePro.isIncluded(sheetId, row, col, avoidCoord)){
					var id = internalId;
					reCalCells[id] = [sheetId, row, col];
				}
			}
		}, this, true);
				
		return reCalCells;
	},
	
	/*
	 * show a link tool kit on the UI
	 */
	showLinkKit : function(pos, cd){
		var kitOffset = this.kitOffset;
		var store = this.getStore(), sheetId = this.getSheetId();
		var x = store.getRangeWidth(sheetId, 1, pos.col-1);
		var y = store.getRangeHeight(sheetId, 1, pos.row);
		if(kitOffset){
			x += kitOffset[0];
			y += kitOffset[1];
		}
        var linkRef = store.getCellLink(cd);
		var link = SLANG['go_to_link']+': <a href="'+linkRef+'" target="_blank" class="ss-cell-link">'+linkRef+'</a>&nbsp;&nbsp;&nbsp;&nbsp;<span class="ss-link-remove">'+SLANG['remove']+'</span>';
		
		if(!this.linkKit){
			
			this.linkKit = new EnterpriseSheet.sheet.floating.Floor({
				sheet:this,
                localKit: true,                                                                    
				floatingConfig:{
					xtype:'component',
					cls: 'ss-link-kit',
					html: link,
					x:x,
					y:y,
					ddConfig:false,
					resizeConfig:false,
					destroyMenu: false,
					listeners: {
						'afterrender': {
							fn: function(comp){
								var el = comp.getEl();
								this.mon(el, 'click', this.clickLinkKit, this);
							},
							scope: this
						}
					}
				}
			});
		}else{		
			this.linkKit.eachFloating(function(comp){
				comp.update(link);
			}, this);
			/*
			 * register to the sheet
			 */
			this.registerFloor(this.linkKit, true);
			this.linkKit.setXY([x, y]);
			this.linkKit.show();
		}	
		
	},
	
	/*
	 * hide the clipKit and destory related comp
	 */
	hideLinkKit : function(){
		if(this.linkKit && !this.suspendHideFlag){				
			this.linkKit.destroy();
			delete(this.linkKit);
		}
	},
	
	/**
	 * click on link kit
	 */
	clickLinkKit : function(e){
		var target = e.getTarget('span.ss-link-remove');
		if(target){
			var sm = this.getSelectionModel(), sheetId = this.getSheetId();
			var focusCell = sm.getFocusCell();
			var row = focusCell.row, col = focusCell.col;
			var range = new EnterpriseSheet.sheet.range.Range({
				sheet: this,
				coord: [[sheetId, row, col, row, col]]
			});
			range.setProperty(null, ['link']);
			
			this.refreshFocus(row, col);
        }else{        	
            target = e.getTarget('a.ss-cell-link');
            if(target){
                var val = target.innerHTML;
                if(!val || 0 !== val.indexOf('http://')){                	
                	e.stopEvent();
                	this.go2CoordSpan(val)
                }                
            }
        }
	},
           
    /**
     * go to a span coord
     */
    go2CoordSpan : function(val){
        try{
        	// check 2 case, one is name mgr ...
        	var me = this, store = me.getStore();
		    
		    // check to see whether it is refs for the val ...
		    if (val.indexOf("http") == -1) {
		        var refConfigs = store.getRefConfig();
		        for(var i = 0, len = refConfigs.length; i < len; i++){
					var it = refConfigs[i];
		            if (it.name == val && it.ctype == "named_func") {
		            	var json = Ext.decode(it.json);
		            	val = json[0].cal;
		            	break;
		            }
				}
		    }
        	
            var coord = EnterpriseSheet.sheet.calculate.Coordinate.prototype.string2Coord(val);
            if(0 < coord.length){
                var span = coord[0].span, store = this.getStore();
                var sheetId = this.getSheetId(), curSheetId = sheetId;
                if('' !== span[0]){
                    sheetId = store.getSheetIdByName(span[0]);
                }
                if(Ext.isNumber(sheetId)){
                    if(sheetId === curSheetId){
                        this.go2Pos(span[1], span[2]);
                    }else{
                        this.go2Sheet(sheetId, function(){
                            this.go2Pos(span[1], span[2]);
                        }, this);
                    }
                }
                return true;
            }
        }catch(e){}
    },
	
	/**
	 * when mouse move on cell, do a list of things ...
	 */
	onCellMouseMove : function(row, col, region, e){
		this.anchorTipForCell(row, col, region);			
		
		// this is another case to check whether data have defined: customBinding
		this.showCellCustomBindingData(row, col, region);
		
		// add cellOnMouseMoveCallBack listener - client defined callback during mouse over cell
		this.onCellEventCallback("onCellMouseMoveFn", region.getSheetId(), row, col);
	},
	
	anchorTipForCell : function(row, col, region){
		var store = this.getStore();
		var sheetId = this.getSheetId();
		var cd = store.getCellData(sheetId, row, col);		
		var cellEl, comment = cd.comment, commentDecorate = cd.commentStyle;
		if(comment){
			var pos = this.commentTip.currentPos;
			var curPos = {
				sheet: sheetId,
				row: row,
				col: col
			};
			this.commentTip.currentPos = curPos;
			this.commentTip.comment = comment;
			if(!this.commentTip.isVisible() || !pos || !(pos.sheet === curPos.sheet && pos.row === curPos.row && pos.col === curPos.col)){				
				cellEl = region.getCellEl(row, col);
				this.commentTip.showBy(cellEl);

				if (commentDecorate && commentDecorate == "b") comment = "<b>"+ comment + "</b>";
				else if (commentDecorate && commentDecorate == "u") comment = "<u>"+ comment + "</u>";
				else if (commentDecorate && commentDecorate == "i") comment = "<i>"+ comment + "</i>";
				
				this.commentTip.updateComment(comment);				
			}			
		} else {
			this.commentTip.hide();
		}
		
		// show or hide btn
		if (cd.commentEdit == "hide") this.commentTip.hideBtn();
		else if (comment) this.commentTip.showBtn();
		
		var vname = cd.vname, vnameEdit = cd.vnameEdit;
		if(vname && 'hide' !== vnameEdit){
			var pos = this.variableTip.currentPos;
			var curPos = {
				sheet: sheetId,
				row: row,
				col: col
			};
			this.variableTip.currentPos = curPos;
			this.variableTip.vname = vname;
						
			if(!this.variableTip.isVisible() || !pos || !(pos.sheet === curPos.sheet && pos.row === curPos.row && pos.col === curPos.col)){				
				cellEl = region.getCellEl(row, col);
				if(this.commentTip.isVisible()){
					this.variableTip.showBy(this.commentTip.getEl(), 'tl-bl?');
				}else{
					this.variableTip.showBy(cellEl);
				}
				
				this.variableTip.updateContent(vname);				
			}	
		}else{
			this.variableTip.hide();
		}
		
		// show or hide btn
		if (cd.vnameEdit == "hide") this.variableTip.hideBtn();
		else if (vname) this.variableTip.showBtn();
		
		/*
		 * show customer binding info
		 */
		this.showCustomBindingInfo({info: cd.info}, sheetId, row, col, region);
		
		var val = cd.value;
		
		if(Ext.isObject(val) && val._isExp){			
			cellEl = cellEl || region.getCellEl(row, col);
			this.exceptionTip.showBy(cellEl);		
			this.exceptionTip.removeCls('ss-validate-hint');
            var info = this.processCalculateException(val);
            this.exceptionTip.update(info.expTip);
		}else if(Ext.isDefined(cd.hint)){
			var hint = cd.hint;
			if(Ext.isObject(hint)){					
				hint = EnterpriseSheet.sheet.calculate.Condition.prototype.generateHint(hint);
			}
			cellEl = cellEl || region.getCellEl(row, col);
			this.exceptionTip.showBy(cellEl);
			this.exceptionTip.addCls('ss-validate-hint');
			this.exceptionTip.update('<div class="ss-exception-title">'+SLANG['invalid_cell_content']+'</div>'+hint);
		}else{
			this.exceptionTip.delayHide();
		}
	},
	
	/**
	 * show custom binding information
	 */
	showCustomBindingInfo : function(obj, sheetId, row, col, region){
		var anchorEl, alignPos;
		
		if(this.variableTip.isVisible()){
			anchorEl = this.variableTip.getEl();
			alignPos = 'tl-bl?';			
		}else if(this.commentTip.isVisible()){
			anchorEl = this.commentTip.getEl();
			alignPos = 'tl-bl?';			
		}else{
			anchorEl = region.getCellEl(row, col);
		}
		
		/*
		 * fire an event, listener can set obj.info to the stuff they want to show
		 */
		if(false !== this.fireEvent('beforeshowcustombindinginfo', obj, sheetId, row, col, region, anchorEl, alignPos, this)){
			var info = obj.info;
			if(info){			
				var pos = this.customBindingDataTip.currentPos;
				var curPos = {
					sheet: sheetId,
					row: row,
					col: col
				};
				this.customBindingDataTip.currentPos = curPos;
				this.customBindingDataTip.info = info;
				if(!this.customBindingDataTip.isVisible() || !pos || !(pos.sheet === curPos.sheet && pos.row === curPos.row && pos.col === curPos.col)){									
					this.customBindingDataTip.showBy(anchorEl, alignPos);
					this.customBindingDataTip.updateContent(info);				
				}	
			}else{
				this.customBindingDataTip.hide();
			}
		}else{
			this.customBindingDataTip.hide();
		}
	},
	
	/**
	 * concat rng
	 */
	concatRng : function(bus, rng){
		for(var i = 0, len = rng.length; i < len; i++){
			var it = rng[i];
			if(Ext.isArray(it)){
				bus.push(it);
			}else if (it.span) {
				bus.push(it.span);
			}
		}
		return bus;
	},
	
	/**
	 * change conditions
	 */
	changeConditions : function(changedCdts, preCdtCache, posCdtCache){
		
		var sheet = this;
		var deleteCdtStyles = [].concat(EnterpriseSheet.sheet.calculate.Condition.styles);
		
		var store = sheet.getStore();    		    	
		var coord = [], changedCells = [], updateCdts = [], oldCdts = {};
		for(var p in changedCdts){
			if(changedCdts.hasOwnProperty(p)){    				
				var cdt = preCdtCache[p];
				/*
				 * save old cdts
				 */
				oldCdts[p] = store.getFloatingById(p, cdt.sheet);
				coord = sheet.concatRng(coord, cdt.rng);
				if('update' == changedCdts[p]){
					updateCdts.push(posCdtCache[p]);
				}
			}
		}
		
		/*
		 * process update cdts
		 */
		for(var i = 0, len = updateCdts.length; i < len; i++){
			var it = updateCdts[i];
			coord = sheet.concatRng(coord, it.rng);
		}
		/*
		 * create a range
		 */
		var range = new EnterpriseSheet.sheet.range.Range({
			coord: coord,
			sheet: sheet
		});
		/*
		 * fire event
		 */
		if(false !== sheet.fireEvent('beforeconditionchange', range, sheet)){
			var cdtCoord = this.getRelatedCdtCoord(coord);
			sheet.fireEvent('prepareconditionchange', range, sheet, oldCdts, cdtCoord);    			
			/*
    		 * delete the changed cdt
    		 */
    		for(var p in changedCdts){
    			if(changedCdts.hasOwnProperty(p)){
    				var cdt = preCdtCache[p];    				
    				store.setFloatingItem(cdt.sheet, cdt.id, 'cdt');
    			}
    		}
    		    		
    		
    		for(var i = 0, len = updateCdts.length; i < len; i++){
    			var it = updateCdts[i];
    			sheet.setConditionForRange(it.rng, it.name, it.opt, true, true, it.id);
    		}
    		/*
    		 * clear the cdt value
    		 */
    		sheet.clearCdtValueForCoord(coord);
    		/*
    		 * refresh the range
    		 */
    		sheet.refreshRange(coord.concat(cdtCoord));
    		
    		sheet.fireEvent('conditionchange', range, sheet, oldCdts, cdtCoord);
		}
	},
	
	/**
	 * set validation
	 */
	setValidation : function(json, suspendRefresh, suspendEvent, cdtId, action){
		var sheetId = this.getSheetId();
		if('delete' == action){
			var changedCdts = {};
			changedCdts[cdtId] = 'deleted';
			var store = this.getStore();
			var oldCdt = store.getConditionById(cdtId, sheetId);
			oldCdt.sheet = sheetId;
			var preCdtCache = {};
			preCdtCache[cdtId] = oldCdt;
			
			this.changeConditions(changedCdts, preCdtCache, preCdtCache);
		}else{
			var coord = json.coord;
			delete(json.coord);
			if(!cdtId){
				
				/*
				 * create a range first, and then set the condition for it
				 */						
				var range = new EnterpriseSheet.sheet.range.Range({
					sheet:this,
					coord: coord
				});		
				var newCdtId = range.setCondition('vd', json, suspendRefresh, suspendEvent, cdtId);			
				/*
				 * refresh focus
				 */
				this.refreshFocus();		
				
				return newCdtId;
			}else{
				var changedCdts = {};
				changedCdts[cdtId] = 'update';
				var store = this.getStore();
				var oldCdt = store.getConditionById(cdtId, sheetId);
				oldCdt.sheet = sheetId;
				var preCdtCache = {};
				preCdtCache[cdtId] = oldCdt;
				
				var newCdt = Ext.apply({}, oldCdt);
				newCdt.rng = coord;
				newCdt.opt = json;
				
				var posCdtCache = {};
				posCdtCache[cdtId] = newCdt;
				
				this.changeConditions(changedCdts, preCdtCache, posCdtCache);
			}
		}
	},
	
	/**
	 * check the input valid when complete edit
	 */
	beforeCompleteEdit : function(sheetId, row, col, editor){
		var store = this.getStore(), condition = this.condition;
		var cell = store.getCellData(sheetId, row, col);
		cell.data = editor.getValue();
		var cdt = this.getConditionOfCell(sheetId, row, col, true);
		if(0 < cdt.length){			
			for(var i = 0, len = cdt.length; i < len; i++){
				var found = cdt[i];						
				if(found && 'vd' == found.name){
					var opt = found.opt;
					if(!opt.allow){
						if(!condition.checkValidate(cell, opt)){
							var cellEl = editor.region.getCellEl(row, col);
							if(cellEl){
								this.exceptionTip.showBy(cellEl);
								this.exceptionTip.addCls('ss-validate-hint');
								var hint = opt.hint;
								if(!hint){
									hint = EnterpriseSheet.sheet.calculate.Condition.prototype.generateHint(opt);
								}
								this.exceptionTip.update(hint);
							}
							return false;
						}
					}
				}
			}
		}
	},
	
	/**
	 * processing the data change, empty fn
	 */
	onProcessingDataChange : function(){
		
	},
	
	/**
	 * toggle the editable for the selection
	 */
	toggleEditableForSelection : function(){
		var store = this.getStore(), sm = this.getSelectionModel();
		
	},
	
	onChanging: function(){
        // CLEAN the cache value if anything is changed
        SCONST.GOLBAL_CACHE_LIST_10 = [];
        SCONST.GOLBAL_CACHE_KEY_10 = [];
           
		this.simulateFocusChange();
	},
	
	/**
	 * coord to string with sheet name
	 */
	coord2StringWithSheetName : function(coords, sep, withSheet){
		if(!Ext.isDefined(sep)){			
			sep = EnterpriseSheet.sheet.calculate.Coordinate.prototype.separator;
		}
		var store = this.getStore(), arr = [];
		for(var i = 0, len = coords.length; i < len; i++){
			var it = coords[i];				
			if(Ext.isObject(it)){
				it = [].concat(it['span']);
			}else{
				it = [].concat(it);
			}
			/*
			 * transfer sheet id to sheet name
			 */
			if(Ext.isNumber(it[0])){
				it[0] = store.getSheetNameById(it[0]);
			}else{
				it[0] = store.getSheetNameById(this.getSheetId());
			}				
			arr.push({
				span: it,
				type: SCONST.ABSOLUTE_COORD
			});
		}			
		var coordStr = EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String(arr, sep, withSheet);
		
		return coordStr;
	},
	
	/**
	 * 
	 * @param varName
	 */
	isValidVariable : function(varName){
		return this.getStore().isValidVariable(varName);
	},

	
	/**
	 * insert the variable
	 */
	insertVariable : function(sheetId, row, col, varName){		
		var coord = [[sheetId, row, col, row, col]];		
		
		/*
		 * create a range object
		 */
		var range = new EnterpriseSheet.sheet.range.Range({
			coord: coord,
			sheet: this
		}); 
		range.setProperty({			
			vname: varName
		});		
	},
	
	/**
	 * delete variable for the selection
	 */
	deleteVariable : function(coord){		
		if(!coord){
			var sm = this.getSelectionModel();
			coord = sm.selection2Coord();
		}				
		
		/*
		 * create a range object
		 */
		var range = new EnterpriseSheet.sheet.range.Range({
			coord: coord,
			sheet: this
		}); 
		range.setProperty(null, ['vname']);
	},
	
	onSetCell2Update : function(origin, current, store, sheetId, row, col){		
		var originData = origin.data, currentData = current.data;
		if(!Ext.isDefined(originData)){
			originData = '';
		}
		if(!Ext.isDefined(currentData)){
			currentData = '';
		}
		if(origin.vname === current.vname){
			if(current.vname && originData !== currentData){
				var cell = this.getCellValue(sheetId, row, col);
				store.setFileConfig('var', current.vname, cell.data);
			}
		}else{
			if(origin.vname){
				store.setFileConfig('var', origin.vname);
			}
			if(current.vname){
				var cell = this.getCellValue(sheetId, row, col);
				store.setFileConfig('var', current.vname, cell.data);
			}
		}
	},
	
	/**
	 * insert a sequence no at the focuse cell
	 */
	insertSequenceNo : function(){
		var sm = this.getSelectionModel(), focusCell = sm.focusCell;
		var coord = [[this.getSheetId(), focusCell.row, focusCell.col, focusCell.row, focusCell.col]];
		var range = new EnterpriseSheet.sheet.range.Range({
			sheet: this,
			coord: coord
		});
		var modified = {
			'seq': '#1.'
		};
		
		range.setProperty(modified);
	},
	
	insertDropList : function(json){
		var sm = this.getSelectionModel(), mm = sm.getMinMaxPos();
		var coord = [[this.getSheetId(), mm.minrow, mm.mincol, mm.maxrow, mm.maxcol]];
		var range = new EnterpriseSheet.sheet.range.Range({
			sheet: this,
			coord: coord
		});
		var modified = {
			'drop': json.drop
		};
        if(json.ovil){
           modified['ovil'] = true;
        }
		
		range.setProperty(modified);
	},
	
	/**
	 * return true if sheet has grid line
	 */
	withGridLine : function(sheetId){
        var activedSheetId = this.getSheetId(), store = this.getStore();
        if(!Ext.isDefined(sheetId) || sheetId === activedSheetId){
        	var el = this.getEl();
        	return !el.hasCls('ss-no-gridline');		
        }else{
            var obj = store.getCell(sheetId, 0, 0), config = obj.config;
            if(!config){
                config = {};
            }else{
                config = Ext.decode(config);
            }
            return !config['noGridLine'];
        }
	},
	
	showGridLine : function(suspendEvent, sheetId){
        var activedSheetId = this.getSheetId(), store = this.getStore();
        if(!Ext.isDefined(sheetId) || sheetId === activedSheetId){
        	this.getEl().removeCls('ss-no-gridline');
            this.updateSheetConfig(suspendEvent);
        }else{
            var obj = store.getCell(sheetId, 0, 0);
            var config = obj.config;
            if(config){
                config = Ext.decode(config);
                delete(config['noGridLine']);
                store.updateSheetConfig(sheetId, config, suspendEvent);
            }
		}
	},
	
	hideGridLine : function(suspendEvent, sheetId){
        var activedSheetId = this.getSheetId(), store = this.getStore();
        if(!Ext.isDefined(sheetId) || sheetId === activedSheetId){
        	this.getEl().addCls('ss-no-gridline');
            this.updateSheetConfig(suspendEvent);
        }else{
            var obj = store.getCell(sheetId, 0, 0);
            var config = obj.config;
            if(config){
                config = Ext.decode(config);
            }else{
                config = {};
            }
            config['noGridLine'] = true;
            store.updateSheetConfig(sheetId, config, suspendEvent);
		}
	},
	
    /**
     * here we need transferCalculate
     */
	beforeAfterLoad : function(store){
        // CLEAN the cache value if the file is loaded
        SCONST.GOLBAL_CACHE_LIST_10 = [];
        SCONST.GOLBAL_CACHE_KEY_10 = [];
           
        var calculate = this.calculate, lookup = [];

		store.eachCal(function(rec){
			var json = rec.data.json;
			if(json.cal){                     
				calculate.transferCalculate(json, store, rec.data.sheet, rec.data.row, rec.data.col);
                if(json.refs){
                   lookup = lookup.concat(json.refs);
                }
			}
		}, this);

        /*
         * need get the cell refered in nameFuncs too.
         */
        var nameRefs = store.getRefConfigLookup();
        for(var p in nameRefs){
            if(nameRefs.hasOwnProperty(p)){
                var it = nameRefs[p];
                if(it.refs){
                    lookup = lookup.concat(it.refs);
                }
            }
        }
        /*
         * check and load these cells refered by the calculate if not loaded
         */
        store.checkLoadCoord(lookup, function(){
            store.fireEvent('prepareafterload', store);
            store.afterLoad();

        }, this, true);
        return false;
	},
        
    
           
    isReadOnly : function(){
        return this.readOnly;
    },
           
    setReadOnly : function(readOnly){
        this.readOnly = readOnly;

        if(readOnly){
            this.disableEdit();
            this.disableSelect();
            for(var p in this.regionLookup){
                if(this.regionLookup.hasOwnProperty(p)){
                    var region = this[this.regionLookup[p]];
                    region.setReadOnly(true);
                    if(region.getSelectionModel){
                        var sm = region.getSelectionModel();
                        sm.hide();
                    }
                    if(region.getReferenceModel){
                        var rm = region.getReferenceModel();
                        if(rm){
                            rm.hide();
                        }
                    }
                }
            }
            this.hideLinkKit();
        }else{
            this.enableEdit();
            this.enableSelect();
            for(var p in this.regionLookup){
                if(this.regionLookup.hasOwnProperty(p)){
                    var region = this[this.regionLookup[p]];
                    region.setReadOnly(false);
                    if(region.getSelectionModel){
                        var sm = region.getSelectionModel();
                        sm.show();
                    }
                }
            }
            var sm = this.getSelectionModel();
            sm.selectRange(sm.startPos, sm.endPos);
        }
        this.fireEvent('changereadonly', readOnly, this);
    },
           
    saveJsonFile : function(config, callback, scope){
        var store = this.getStore();
           
        this.loadMask.show();
        store.saveJsonFile(config, function(newFileId){
            this.setSheetId(store.getActivedSheetId());
            this.loadMask.hide();
            if(callback){
                callback.call(scope, newFileId);
            }
        }, this);
    },
      
    /**
     * get json data
     */
    getJsonData : function(compress){
        var store = this.getStore();
           
        return store.getJsonData(compress);
    },
    
    /*
     * detect delete
     */
    onKeyDown : function(e) {
        var key = e.getKey(), sm = this.getSelectionModel(), store = this.getStore();
        var pos = sm.getMinMaxPos(), minX = pos.minrow, minY = pos.mincol, maxX = pos.maxrow, maxY = pos.maxcol;
           
        if (46 == key || 8 == key) {
            this.cleanSelection('content');
            return false;
        }
    },
           
    /**
     * load sheet tab and switch to it
     */
    loadSwitchSheet : function(sheetId, callback, scope){
        var store = this.getStore();
        store.loadSheet(sheetId, function(success){
            if(success){
                /*
                 * call sheet to switch
                 */
                this.switchSheet(sheetId);
                if(callback){
                    callback.call(scope, sheetId);
                }
            }else{
                this.loadMask.hide();
            }
        }, this);
    },
           
    /**
     * add dropdown store
     */
    addDropdownStore : function(name, config, callback, scope){
        var store = this.getStore();
        if(store.isDisabledPulling()){
            if(callback){
                callback.call(scope, false);
            }
            return;
        }
        Ext.Ajax.request({
            timeout: SCONST['PULLING_TIMEOUT'],
            url: SCONFIG.urls['createDataset'],
            params: {
                documentId: store.fileId,
                name: name,
                data: Ext.encode(config)
            },
            success: function(response, options){
                var json = Ext.decode(response.responseText);
                var success = true;
                if(true !== json.success && 'true' !== json.success) {
                    success = false;
                    Ext.Msg.alert(SLANG['hint'], SLANG['fail2add_dataset']);
                }
                if(callback){
                    callback.call(scope, success, json);
                }
            },
            failure: function(response){
                Ext.Msg.alert(SLANG['hint'], SLANG['fail2add_dataset']);
                if(callback){
                    callback.call(scope, false);
                }
            },
            scope: this
        });
    },
           
    /**
     * delete the dropdown store
     */
    deleteDropdownStore : function(drop, callback, scope){
        if(store.isDisabledPulling()){
            if(callback){
                callback.call(scope, false);
            }
           return;
        }
        Ext.Ajax.request({
            timeout: SCONST['PULLING_TIMEOUT'],
            url: SCONFIG.urls['deleteDataset'],
            params: {
                id: drop.id
            },
            success: function(response, options){
                var json = Ext.decode(response.responseText);
                var success = true;
                if (true === json.success || 'true' === json.success) {
                    EnterpriseSheet.sheet.plugin.DropList.prototype.deleteDatasetFromLookup(drop);
                }else{
                    success = false;
                    Ext.Msg.alert(SLANG['hint'], SLANG['fail2delete_dataset']);
                }
                if(callback){
                    callback.call(scope, success, drop);
                }
            },
            failure: function(response){
                Ext.Msg.alert(SLANG['hint'], SLANG['fail2delete_dataset']);
                if(callback){
                    callback.call(scope, false, drop);
                }
            },
            scope: this
        });

    },
           
    /**
     * when backend connection is broken
     */
    onLostConnection : function(){
        if(!Ext.isDefined(this.originReadOnly)){
            this.originReadOnly = this.readOnly || false;
        }
        this.setReadOnly(true);
    },
           
    onConnectServer : function(){
        this.setReadOnly(this.originReadOnly);
    },
           
    onLoadingMore : function(sheetId, store){
        var sheetObj = store.getSheetById(sheetId);
        var currentCellCount = sheetObj.currentCellCount || 0;
        var currentFloatingCount = sheetObj.currentFloatingCount || 0;
        var totalCellCount = sheetObj.totalCellCount || 0;
        var totalFloatingCount = sheetObj.totalFloatingCount || 0;
           
        var count = currentCellCount+currentFloatingCount, total = totalCellCount+totalFloatingCount;
        var percent = 0 === total ? 1 : count/total;
        if(this.loadMask){
            this.loadMask.updatePercent(percent);
        }
    },
           
    /**
     * delete repeat items for the selection
     */
    deleteRepeatItem : function(){
        var sm = this.getSelectionModel(), store = this.getStore();
        var pos = sm.getMinMaxPos(), coord = [[store.getActivedSheetId(), pos.minrow, pos.mincol, pos.maxrow, pos.maxcol]];
        coord = store.shrinkCoordWithContent(coord);
        var span = coord[0];

        sm.selectRange({
            row: span[1],
            col: span[2]
        }, {
            row: span[3],
            col: span[4]
        });
        if(!this.deleteRepeatOption){
            this.deleteRepeatOption = Ext.create('EnterpriseSheet.sheet.floating.DeleteRepeatOption', {
                sheet: this
            });
        }
        var data = [];
        for(var i = span[2]; i <= span[4]; i++){
            data.push({
                'col': i,
                'display': SLANG['column']+store.getColName(i)
            });
        }
        this.deleteRepeatOption.prepare(data);
        this.deleteRepeatOption.showBy(sm.getEl(), 'tl-tr?');
    },
           
    /**
     * set array formula for selection
     */
    setArrayFormulaForSelection : function(json){
        var sm = this.getSelectionModel(), store = this.getStore();
        var pos = sm.getMinMaxPos(), span = [store.getActivedSheetId(), pos.minrow, pos.mincol, pos.maxrow, pos.maxcol];
        this.setArrayFormulaForSpan(span, json);
    },
           
    /**
     * set array formula for the passed coord span
     */
    setArrayFormulaForSpan : function(span, json){
        var store = this.getStore();
        var sheetId = span[0], minrow = span[1], mincol = span[2], maxrow = span[3], maxcol = span[4];
        if(0 !== maxrow && 0 !== maxcol){
            var data = '='+store.getColName(mincol)+minrow;
            for(var i = minrow; i <= maxrow; i++){
                for(var j = mincol; j <= maxcol; j++){
                    if(i === minrow && j === mincol){
                        this.setCellData(sheetId, i, j, Ext.apply({
                            afrow: minrow-i,
                            afcol: mincol-j,
                            aerow: maxrow-i,
                            aecol: maxcol-j
                        }, json), ['value']);
                    }else{
                        this.setCellData(sheetId, i, j, Ext.applyIf({
                            afrow: minrow-i,
                            afcol: mincol-j,
                            data: data
                        }, json), ['value']);
                    }
                }
            }
        }
    },
           
    onTry2ChangePartOfArrayFormula : function(){
        Ext.Msg.alert(SLANG['hint'], SLANG['can_not_only_change_part_of_array_formula']);
    },
           
    isTitleRegionVisible : function(){
        return this.ltcorner.isVisible();
    },    		
		
   /**
	 * call back function for different events
	 */
    onCellEventCallback : function(eventType, sheetId, row, col){
		var store = this.getStore();
		var cd = store.getCell(sheetId, row, col);
        var callback = cd[eventType];
        if(callback && window[callback]){
            cd = this.getCellValue(sheetId, row, col);
            window[callback](cd.data, row, col, sheetId, cd, store);
        }
	},
	
	/**
	 * this function checks the customized event
	 */
	checkCustomizedEvent : function(eventName, sheetId, row, col, opt){
		var store = this.getStore();
		var cd = store.getCellProperty(sheetId, row, col);
		var event = cd[eventName];
		if(event){
			return this.fireEvent(event, sheetId, row, col, cd, this, opt);
		}
	},
	
	/**
	 * This function will get custom defined binding data result
	 */
	showCellCustomBindingData : function(row, col, region){
		var store = this.getStore(), sheetId = this.getSheetId();
		var cd = store.getCellData(sheetId, row, col);		
		var customBindingFn = cd.onCustomBindingFn;
		if(customBindingFn && "" != customBindingFn){
			var callFn = customBindingFn + '(' + Ext.encode(cd) + ',' + row + ',' + col + ')';
            var result = (function(){
                return eval(callFn)
            })();
		    
		    if (result && result.length > 0) {
			    // now we need display this result into the floating window ...
			    var pos = this.customBindingDataTip.currentPos;
				var curPos = {
					sheet: sheetId,
					row: row,
					col: col
				};
				this.customBindingDataTip.currentPos = curPos;
				if(!this.customBindingDataTip.isVisible() || !pos || !(pos.sheet === curPos.sheet && pos.row === curPos.row && pos.col === curPos.col)){				
					var cellEl = region.getCellEl(row, col);
				    this.customBindingDataTip.showBy(cellEl);		
					this.customBindingDataTip.updateContent(result);				
				}	
		    }
		} else {
			this.customBindingDataTip.hide();
		}
	},
              
           
    hideTitleRegion : function(){
           
    },
           
    hideTitleRegion : function(){
           
    },
           
    /**
     * get all cell vars
     */
    getCellVariables : function(){
        var store = this.getStore();
        var vnames = {};
        store.each(function(rec){
            var sheetId = rec.data.sheet, row = rec.data.row, col = rec.data.col;
            var json = rec.data.json, vn = json.vname;
            if(vn){
                var parts = vn.split('.');
                if(1 < parts.length){
                    parts.pop();
                    var vng = parts.join('.'), vals = [this.getCellValue(sheetId, row, col).data];
                    var i = row+1;
                    while(true){
                        var cell = store.getCell(sheetId, i, 0);
                        if(cell.vng === vng){
                            var val = this.getCellValue(sheetId, i, col).data;
                            if(!SCOM.isEmptyValue(val)){
                                vals.push(val);
                            }
                        }else{
                            break;
                        }
                        i++;
                    }
                    vnames[vn] = vals;
                }else{
                    vnames[vn] = this.getCellValue(sheetId, row, col).data;
                }
            }
        }, this);
        return vnames;
    },
           
    setValueToVariable : function(vnVals){
        var store = this.getStore();
        var changedCells = store.setValueToVariable(vnVals, true);
        this.refreshRange(undefined, this.findDirectRecalculateCellsForCells(changedCells));
    },
           
    clearAllVariables : function(){
        var store = this.getStore();
        store.each(function(rec){
            var json = rec.data.json;
            if(json.vng){
                delete(json.vng);
            }
            if(json.vname){
                delete(json.vname);
            }
        }, this);
        this.refreshRange();
    },
           
    /**
     * get the value of a checkbox or radio based on the passed name
     */
    getItemValueByName : function(name){
        var store = this.getStore(), itype, value;
        store.each(function(rec){
            var json = rec.data.json, sheetId = rec.data.sheet, row = rec.data.row, col = rec.data.col;
            if(name === json.itn){
                if(!Ext.isDefined(itype)){
                    itype = json.it;
                }
                if(json.it === itype){
                    if('radio' === itype){
                        if(json.itchk){
                            value = this.getCellValue(sheetId, row, col).data;
                            return false;
                        }
                    }else if('checkbox' === itype){
                        if(json.itchk){
                            value = value || [];
                            value.push(this.getCellValue(sheetId, row, col).data);
                        }
                    }
                }
            }
        }, this);
        if(Ext.isDefined(itype)){
            return {
                itemType: itype,
                itemValue: value
            }
        }
    },
           
    /**
     * create pivot table
     */
    createPivotTable : function(){
           
    },
           
    setSelectedRowAsHeaderTitle : function(){
        var sm = this.getSelectionModel(), store = this.getStore();
        var mm = sm.getMinMaxPos(), sheetId = this.getSheetId();
        var span = [sheetId, mm.minrow, mm.mincol, mm.minrow, mm.maxcol], coord = [span];
        this.fireEvent('preparesetheadertitle', span, this);
        var titles = {};
        store.walkRange(coord, function(rec, walkSpan, store, internalId){
            var obj = this.getCellValue(rec.data.sheet, rec.data.row, rec.data.col);
            var data = obj.data;
            
            store.setCell(rec.data.sheet, 0, rec.data.col, {
                data : data
            }, undefined, true);
            var id = internalId;
            titles[id] = data;
        }, this);
        
        this.refreshRange([[sheetId, 0, mm.mincol, 0, mm.maxcol]]);
        this.fireEvent('setheadertitle', span, titles, this);
    },
    
    setColumnTitle : function(sheetId, col, title){
    	this.getStore().setCell(sheetId, 0, col, {
    		data: title
    	});
    },
    
    setColumnIcon : function(col, iconPath){
    	this.setCell(this.getSheetId(), 0, col, {
    		'ticon': iconPath
    	});
    },
    
    cleanColumnIcon : function(col) {
		this.setCell(this.getSheetId(), 0, col, null, ['ticon']);
	},
    
    addCellDataRender : function(obj){    	
    	SCRENDER.addRender(obj);    	
    },
    
    processCellDataRender : function(cell, scope){
    	if(cell.render){
    		var render = SCRENDER.getRender(cell.render);
    		if(render){
    			var data = render(scope.sheet, scope.row, scope.col, cell, this);
    			if(Ext.isDefined(data)){
    				cell.data = data;
    			}
    		}
    	}
    	return cell;
    },
    
    processCellDataConfig : function(cell, scope){
    	return this.dtProcessor.processCellDataConfig(cell, scope);    	
    },
    
    checkDataTypeConfigBeforeEdit : function(sheetId, row, col, region){
    	return this.dtProcessor.checkBeforeEdit(sheetId, row, col, region);    	
    },
    
    setColumnTitleVisible : function(visible, startCol, endCol){
    	var coord = [[this.getSheetId(), 0, startCol, 0, endCol]];
		var range = new EnterpriseSheet.sheet.range.Range({
			sheet: this,
			coord: coord
		});		
		if(!visible){
			range.setProperty({			
				'hideTitle': true
			});		
		}else{
			range.setProperty(undefined, ['hideTitle']);
		}
    },
    
    /**
	 * get the related conditions of the passed cell coord
	 */
	getConditionOfCell : function(sheetId, row, col, withDataTypeConfig){
		var conditions = this.store.getConditionOfCell(sheetId, row, col);
		if(withDataTypeConfig){
			var dataTypeConfig = this.dtProcessor.getDataTypeConfigForCell(sheetId, row, col);		
			if(dataTypeConfig){
	        	conditions.push({name: 'vd', opt: dataTypeConfig});
	        }
		}
		return conditions;
	},
	
	getCdtFloatingOfCell : function(sheetId, row, col, withDataTypeConfig){
		var conditions = this.store.getCdtFloatingOfCell(sheetId, row, col);	
		if(withDataTypeConfig){
			var dataTypeConfig = this.dtProcessor.getDataTypeConfigForCell(sheetId, row, col);		
			if(dataTypeConfig){
				conditions.push({
	        		jsonObj: {name: 'vd', opt: dataTypeConfig}
	        	});
	        }		
		}
		return conditions;
	},
	
	/**
	 * save the print setting
	 */
	savePrintSettingForSheet : function(sheetId, setting, callback, scope){
		this.store.saveExtraInfo(sheetId, {
			printSetting: setting
		}, 'apply', callback, scope);
	},
	
	setColNameVisible : function(visible, sheetId, suspendEvent){		
		this.store.colNameHidden = !visible;
		if(this.store.colNameHidden || this.store.rowNameHidden){
			this.ltcorner.hide();
		}else{
			this.ltcorner.show();
		}
		
		var activedSheetId = this.getSheetId(), store = this.getStore();
        if(!Ext.isDefined(sheetId) || sheetId === activedSheetId){        	
            this.updateSheetConfig(suspendEvent);
        }else{
            var obj = store.getCell(sheetId, 0, 0);
            var config = obj.config;
            if(config){
                config = Ext.decode(config);
                config['colNameHidden'] = this.store.colNameHidden;
                store.updateSheetConfig(sheetId, config, suspendEvent);
            }
		}
        
		
		this.refresh();
		if(Ext.isFunction(this.doLayout)){
			this.doLayout();
		}else if(Ext.isFunction(this.updateLayout)){
			this.updateLayout();
		}		
	},
	
	setRowNameVisible : function(visible, sheetId, suspendEvent){		
		this.store.rowNameHidden = !visible;
		if(this.store.colNameHidden || this.store.rowNameHidden){
			this.ltcorner.hide();
		}else{
			this.ltcorner.show();
		}
		
		var activedSheetId = this.getSheetId(), store = this.getStore();
        if(!Ext.isDefined(sheetId) || sheetId === activedSheetId){        	
            this.updateSheetConfig(suspendEvent);
        }else{
            var obj = store.getCell(sheetId, 0, 0);
            var config = obj.config;
            if(config){
                config = Ext.decode(config);
                config['rowNameHidden'] = this.store.rowNameHidden;
                store.updateSheetConfig(sheetId, config, suspendEvent);
            }
		}
		
		this.refresh();
		if(Ext.isFunction(this.doLayout)){
			this.doLayout();
		}else if(Ext.isFunction(this.updateLayout)){
			this.updateLayout();
		}
	}
});
Ext.define('EnterpriseSheet.sheet.RollingSheet', {
	
	/* Begin Definitions */
	
	extend: 'EnterpriseSheet.sheet.Sheet',
	
	
	alias : 'widget.swiftoosheet',
		
	constructor : function(){				
		
		this.callParent(arguments);
				
	},
           
    scrollingCheckBuffer: 1000,
	
	/**
	 * override bindListeners
	 */
	bindListeners : function(){
		this.callParent(arguments);
        this.on('rowscrolling', this.onRowScrolling, this);
		this.on('colscrolling', this.onColumnScrolling, this);
        this.store.on('prepareloadrange', this.beforeLoadRange, this);
        this.store.on('afterloadrange', this.afterLoadRange, this);
        this.on('filtering', this.processAfterLoadSheet, this);
        this.on('rowhide', this.processAfterLoadSheet, this);
        this.on('columnhide', this.processAfterLoadSheet, this);
        this.on('resetloadedblocks', this.resetLoadedBlocks, this, {buffer:500});
           
        this.store.on('beforeholdremoverow', this.processForInsertRemove, this);
        this.store.on('beforeholdremovecolumn', this.processForInsertRemove, this);
        this.store.on('beforeholdinsertrow', this.processForInsertRemove, this);
        this.store.on('beforeholdinsertcolumn', this.processForInsertRemove, this);
        this.store.on('beforeholdremovecell', this.processForInsertRemove, this);
        this.store.on('beforeholdinsertcell', this.processForInsertRemove, this);
        this.store.on('preparesortspan', function(span){
            var sheetId = span[0];
            if(SCOM.isEmptyValue(sheetId)){
                sheetId = this.store.getActivedSheetId();
            }
            this.processForInsertRemove(sheetId);
        }, this);
        this.store.on('moverows', function(sheetId){            
            if(SCOM.isEmptyValue(sheetId)){
                sheetId = this.store.getActivedSheetId();
            }
            this.processForInsertRemove(sheetId);
        }, this);
	},
           
    processForInsertRemove : function(sheetId){
    	var store = this.store;
    	
    	if(!store.isAllCellLoadedInSheet(sheetId)){
    		this.pauseLoadRange = true;
            this.store.on('pullover', function(){
                delete(this.pauseLoadRange);
                this.fireEvent('resetloadedblocks', sheetId, this);
            }, this, {single:true});
    	}        
    },
           
    resetLoadedBlocks : function(sheetId){
        var store = this.getStore();
        var tab = store.getSheetById(sheetId);
        tab.loadedBlocks = {};
        this.processAfterLoadSheet();
    },
           
	/**
	 * find region map key
	 */
	findRegionMapKey : function(region){
		for(var i = 0, len = this.bodyRegionLookup.length; i < len; i++){
			var key = this.bodyRegionLookup[i];
			var it = this[key];
			if(it === region){
				return key;
			}
		}
	},
           
    checkLoadRange : function(coord, justCheck){
        if(!Ext.isFunction(this.store.checkLoadRange) || this.pauseLoadRange){
           return;
        }
           
        this.store.checkLoadRange(coord, function(flag){
            this.loadMask.hide();
        }, this, justCheck);
    },
	
	/**
	 * when row or column scrolling
	 */
	onRowScrolling : function(offset, region, scroller){		
		this.processRowColScrolling(region, scroller);        
	},
	
	onColumnScrolling : function(offset, region, scroller){
		this.processRowColScrolling(region, scroller);  
    },
    
    processRowColScrolling : function(region, scroller){
    	if(!scroller.mdFlag){			
			var coord = region.getVisibleCoord();
	        this.checkLoadRange(coord, scroller.mdFlag);
		}else if(!this.loadMask.isVisible()){			
			if(Ext.isFunction(this.store.isSpansLoaded)){
				var coord = region.getVisibleCoord();
				if(!this.store.isSpansLoaded(coord)){
					this.loadMask.show(SLANG['locating_mouseup_render']);
				}			
			}
		}  
    },
           
    processAfterLoadSheet : function(){
        if(!Ext.isFunction(this.store.checkLoadRange)){
            this.loadMask.hide();           
            return;
        }
        var regions = [];
        for(var i = 0, len = this.bodyRegionLookup.length; i < len; i++){
            var it = this[this.bodyRegionLookup[i]];
            if(it.isVisible()){
                regions.push(it);
            }
        }
        
        var coord = [];
        for(var i = 0, len = regions.length; i < len; i++){
            var region = regions[i];
            coord = coord.concat(region.getVisibleCoord());
        }
        this.checkLoadRange(coord);        
    },
    
    go2Pos : function(){
    	this.callParent(arguments);
    	this.processAfterLoadSheet();
    },
    
    beforeLoadRange : function(){
        this.loadMask.show(SLANG['rendering']);
    },
           
    afterLoadRange : function(coord, store){
        this.refreshRange(coord, false, true);
        this.loadMask.hide();
    },
           
    switchSheet : function(sheetId){
        this.callParent(arguments);
        if(!Ext.isFunction(this.store.checkLoadRange)){
            return;
        }
        var regions = [];
        for(var i = 0, len = this.bodyRegionLookup.length; i < len; i++){
            var it = this[this.bodyRegionLookup[i]];
            if(it.isVisible()){
                regions.push(it);
            }
        }
        var coord = [];
        for(var i = 0, len = regions.length; i < len; i++){
            var region = regions[i];
            coord = coord.concat(region.getVisibleCoord());
        }
        this.store.checkLoadRange(coord);
    }
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.api.SheetAppHandle', {
	
	constructor : function(config){
		Ext.apply(this, config);
		
		this.callParent(arguments);
	},
	
	/*
	 * this function will return the reference of some useful component in your created sheet app such as sheet, store, toolbar and so on
	 */
	getRefer : function(name){
		return this[name];
	},
	
	getSheet : function(){
		return this.getRefer('sheet');
	},
	
	getStore : function(){
		return this.getRefer('store');
	},
	
	getAppContainer : function(){
		return this.getRefer('appCt');
	},
	
	getToolbar : function(){
		return this.getRefer('toolbar')
	},
	
	getContentbar : function(){
		return this.getRefer('contentbar')
	},
	
	getTitlebar : function(){
		return this.getRefer('titlebar')
	},
	
	getSidebar : function(){
		return this.getRefer('sidebar')
	}
});
/**
 * Enterprise Spreadsheet Solutions
 * Copyright(c) FeyaSoft Inc. All right reserved.
 * info@enterpriseSheet.com
 * http://www.enterpriseSheet.com
 * 
 * Licensed under the EnterpriseSheet Commercial License.
 * http://enterprisesheet.com/license.jsp
 * 
 * You need to have a valid license key to access this file.
 */
Ext.define('EnterpriseSheet.api.SheetAPI', {
	
	requires: [
        'EnterpriseSheet.lang.Language',
        'EnterpriseSheet.sheet.action.HotKey',
        'EnterpriseSheet.sheet.menu.ContextMenu',
        'EnterpriseSheet.sheet.data.RollingStore',
                         
        'EnterpriseSheet.sheet.toolbar.MenuTitlebar',
        'EnterpriseSheet.sheet.toolbar.SheetTabbar',
        'EnterpriseSheet.sheet.toolbar.Toolbar',
        'EnterpriseSheet.sheet.toolbar.Sidebar',
        'EnterpriseSheet.sheet.toolbar.Contentbar',
        'EnterpriseSheet.sheet.floating.Arrow',
        'EnterpriseSheet.sheet.floating.CalculateHint',
        'EnterpriseSheet.sheet.plugin.SequenceNumber',
        'EnterpriseSheet.sheet.plugin.DropList',
        'EnterpriseSheet.sheet.RollingSheet',
        'EnterpriseSheet.api.SheetAppHandle'
    ],
	
	constructor : function(config){
        Ext.apply(this, config);
        
        Ext.tip.QuickTipManager.init();
        SQTIP.init();
        
        /*
         * set the open file flag, if true then only load the data not refresh the url
         */
        SABOX.updateConfig({
            openFileByOnlyLoadDataFlag: this.openFileByOnlyLoadDataFlag
        });

        /*
         * set the timeout
         */
        if(SCONST.PULLING_TIMEOUT){
           Ext.Ajax.timeout = SCONST.PULLING_TIMEOUT;
        }
        if(Ext.isIE){
           /*
            * for an css issue in IE10
            */
           Ext.getBody().addCls('x-ie');
        }
           
        if(!Ext.isMac && Ext.isWebKit){
           Ext.getBody().addCls('iScroll');
        }
           
        this.callParent(arguments);
		
	},
           
    /**
     * _public
     * create Sheet app based the passed config
     * @param {Object} config: the configuration of the SheetApp to create,
     { 
       withoutTitlebar: true,
       withoutSheetbar: true,
       withoutToolbar: true,
       withoutContentbar: true,
       withoutSidebar: true
     },
     set true/false to show/hide some element of sheet
     * @return {Object}: the handle of the app just created
     {
        appCt: the container of the sheet app, which contains the sheet and some toolbar
        sheet: the sheet itself
        store: the store of sheet app
     }
     */
    createSheetApp : function(config){
        //window['startCounting'] = new Date();
        config = config || {};
        /*
        var store = Ext.create('EnterpriseSheet.sheet.data.SheetStore', {
            fileId: config.fileId
        });*/
        var store;
        if(config.store){
        	store = config.store;
        }else{
	        store = Ext.create('EnterpriseSheet.sheet.data.RollingStore', {
	            fileId: config.fileId
	        });
        }
        
        var plugins = [], lookup = {}, dockedItems = [];
        var arrowConfig = config.arrowConfig || {};
        Ext.applyIf(arrowConfig, {
        	itemsInMenu: SCONFIG.arrowmenu_items
        });
        var arrow = new EnterpriseSheet.sheet.floating.Arrow(arrowConfig);
        plugins.push(arrow);
        lookup['arrow'] = arrow;
        
        var dropListConfig = config.dropListConfig || {};
        var dropList = new EnterpriseSheet.sheet.plugin.DropList(dropListConfig);
        plugins.push(dropList);
        lookup['dropList'] = dropList;
           
        var hint = new EnterpriseSheet.sheet.floating.CalculateHint();
        plugins.push(hint);
        lookup['hint'] = hint;
           
        var contextMenuConfig = config.contextMenuConfig || {};
        Ext.applyIf(contextMenuConfig, {
        	itemsInMenu: SCONFIG.contextmenu_items
        });
        var contextMenu = new EnterpriseSheet.sheet.menu.ContextMenu(contextMenuConfig);
        plugins.push(contextMenu);
        lookup['contextMenu'] = contextMenu;
           
        var seqNumber = Ext.create('EnterpriseSheet.sheet.plugin.SequenceNumber');
        plugins.push(seqNumber);
        lookup['seqNumber'] = seqNumber;                  
        
        if(!config.withoutTitlebar){
        	var mtCfg = config.menuTitlebarConfig || {};
        	var titlebar = new EnterpriseSheet.sheet.toolbar.MenuTitlebar(Ext.apply(mtCfg, {
        		dock: 'top'
        	}));
        	plugins.push(titlebar);
        	dockedItems.push(titlebar);
        	lookup['titlebar'] = titlebar;
        }
           
        if(!config.withoutSheetbar){
        	var sheetBarClassName = config.sheetBarClassName || 'EnterpriseSheet.sheet.toolbar.SheetTabbar';
            var sheetbar = Ext.create(sheetBarClassName, {
                dock: SCONFIG.sheet_tab_bar_position
            });
            plugins.push(sheetbar);
            dockedItems.push(sheetbar);
            lookup['sheetbar'] = sheetbar;
        }

        if(!config.withoutToolbar){
        	var toolbarClassName = config.toolbarClassName || 'EnterpriseSheet.sheet.toolbar.Toolbar';
        	var tbCfg = config.toolbarConfig || {};
            var toolbar = Ext.create(toolbarClassName, Ext.apply(tbCfg, {
        		dock: 'top'
        	}));
            plugins.push(toolbar);
            dockedItems.push(toolbar);
            lookup['toolbar'] = toolbar;
        }

        if(!config.withoutSidebar){
            var sidebar = new EnterpriseSheet.sheet.toolbar.Sidebar({
                dock: 'right',
                bodyStyle: 'border-right:none;'
            });
            plugins.push(sidebar);
            dockedItems.push(sidebar);
            lookup['sidebar'] = sidebar;
        }
        if(!config.withoutContentbar){
            var contentbar = new EnterpriseSheet.sheet.toolbar.Contentbar({
                dock: 'top'
            });
            plugins.push(contentbar);
            lookup['contentbar'] = contentbar;
        }
        var sheetClassName = config.sheetClassName || 'EnterpriseSheet.sheet.RollingSheet';
        var sheet = Ext.create(sheetClassName, {
            style: 'border:none;',
            loadMask: {
                msg: SLANG['processing']
            },
            rowNameHidden: config.rowNameHidden,
            colNameHidden: config.colNameHidden,
            store: store,
            plugins: plugins,
            disableCalEditorStyle: config.disableCalEditorStyle,
            scrollerAlwaysVisible: config.scrollerAlwaysVisible
        });
        
        var inner;
        if(!config.withoutContentbar){
            inner = {
                border: false,
                layout: 'fit',
                bodyStyle: 'border:none;',
                items: [sheet],
                dockedItems: [contentbar]
            };
        }else{
            inner = sheet;
        }

        var panel = Ext.create('Ext.panel.Panel', Ext.applyIf({
            border: false,
            layout: 'fit',
            bodyStyle: 'border:none;',
            items: [inner],
            dockedItems: dockedItems
        }, config));
        
        if(sidebar && titlebar){
            var me = this;
            var findReplace = function(){
                sidebar.toggleOption(sidebar.searchBtn);
            };
           
            var showcellstyles = function() {
                sidebar.toggleOption(sidebar.cellStyleBtn);
            };
           
            var showCharts = function() {
                sidebar.toggleOption(sidebar.chartBtn);
            };
           
            var showTables = function() {
                sidebar.toggleOption(sidebar.tableStyleBtn);
            };
           
            var showinsertimage = function() {
                sidebar.toggleOption(sidebar.pictureBtn);
            };
            
            var showconditionmgr = function() {
                sidebar.toggleOption(sidebar.conditionStyleBtn);
            };
           
            titlebar.on('findreplace', findReplace);
            titlebar.on('showcellstyles', showcellstyles);
            titlebar.on('showCharts', showCharts);
            titlebar.on('showTables', showTables);
            titlebar.on('showconditionmgr', showconditionmgr);
            titlebar.on('showinsertimage', showinsertimage);
           
            PHKey.bindHotKey(70, true, false, false, findReplace);
        }
        this.checkBeforeUnload(store);
        
        store.on('reportservererror', this.reportServerError, this);
           
        return Ext.create('EnterpriseSheet.api.SheetAppHandle', Ext.apply({
            appCt: panel,
            sheet: sheet,
            store: store
        }, lookup));
    },
           
    /**
     * _public
     * create a window instance contains the sheet app and return the handle
     * @param {Object} sheetConfig: the configuration object for create the sheet app
     * @param {Object} winConfig: the configuration object for the Ext.window.Window
     * @return {Object}: the handle of this sheet app created
     */
    createSheetWin : function(sheetConfig, winConfig){
        sheetConfig = sheetConfig || {};
        winConfig = winConfig || {};
        delete(sheetConfig.renderTo);
        delete(winConfig.items);
        delete(winConfig.layout);
        var hd = this.createSheetApp(sheetConfig);
        var win = Ext.create('Ext.window.Window', Ext.apply({
            layout: 'fit',
            items: [hd.appCt]
        }, winConfig, {
            modal: true,
            closeAction: 'hide',
            width: 1000,
            height: 700
        }));
        hd.appWin = win;
        return hd;
    },
           
    /*
     * _private
     * check before refresh or close the browser
     */
    checkBeforeUnload : function(store){
        try{
            if(!window.onbeforeunload)
                window.onbeforeunload = function(){
                if(!store.isEmptyQueue()){
                    store.doPulling();
                    return SLANG['save_change_before_reload'];
                }else if(store.isPulling()){
                    return SLANG['save_change_before_reload'];
                }
            };
        }catch(e){}
    },
           
    /**
     * _public
     * load file to the passed sheet app
     * @param {Object} hd: the sheet app handle
     * @param {Integer/String} fileId: the file id to load
     * @param {Function} callback: the callback function which will be called after the file is loaded
     * @param {Object} scope: the scope for the callback function
     */
    loadFile : function(hd, fileId, callback, scope){
        hd.store.loadFile({
            fileId: fileId
        }, callback, scope);
    },
           
    /**
     * _public
     * load json for the sheet app
     * @param {Object} hd: the sheet app handle
     * @param {Object} json: the json data to load to this sheet
     */
    loadData : function(hd, json, callback, scope){
        if(json){        	
            hd.store.loadJsonFile(json);           
        }
        
	    if(callback){
	        callback.call(scope);
	    }
    },
    
    /**
     * _public
     * load json for the sheet tab
     * @param {Object} hd: the sheet app handle
     * @param {Object} json: the json data to load to this sheet
     */
    loadTabData : function(hd, json, callback, scope){
        if(json){  
        	var sheet = hd.sheet;   
            hd.store.loadTabJsonFile(json, function(){
            	
            }, this); 
            sheet.refresh();
        }
        
	    if(callback){
	        callback.call(scope);
	    }
    },
    
    loadMoreData : function(hd, json, callback, scope){
        if(json){ 
            var sheet = hd.sheet;      	
            hd.store.loadMoreJsonFile(json);    
            sheet.refresh();    
        }
        
	    if(callback){
	        callback.call(scope);
	    }
    },
    
    refreshSheet : function(hd) {
    	var sheet = hd.sheet;
    	sheet.refresh();  	
    },
           
    /**
     * _public
     * update cells for the passed sheet
     * @param {Object} hd: the sheet app handle
     * @param {Array} cellObjs: an array of the cells need to be update, every item of this array will be an object, which like this:
     {
        sheet:1, //the sheetId of the cell you want to update
        row:1, //the row index of the cell you want to update
        col:1, //the column index of the cell you want to update
        json:{//json property contains all the style and setting of the cell
            data:"ABC", //the data in this cell, it can be a calculate such as "=SUM(A1,B1)"
            cal: false, //if true means this cell is a calculate, the sheet will try to parse the data and calculate it
            bgc: 'black', //the background-color of this cell
            color: 'white' //the font-color of this cell
            ...
        },
        applyWay: 'clear'//could be ['apply', 'applyIf', 'clear'], default to 'clear'. 'apply' means it will use the property in json to replace these propety in the current cell; 'applyIf' means it will use the property in json to add to the current cell if the current cell doesn't have that property; 'clear' means clear all the property of the cell first and then apply json to this cell
     }
     * @param {Function} callback: the callback function which will be called after the cells are updated
     * @param {Object} scope: the scope for the callback function
     */
    updateCells : function(hd, cellObjs, callback, scope){
        var len = cellObjs.length;
        var fn = function(){
            var sheet = hd.sheet, store = sheet.getStore();
            var calculate = sheet.getCalculate();
            for(var i = 0; i < len; i++){
                var data = cellObjs[i], sheetId = data.sheet, row = data.row, col = data.col;
                if(!Ext.isDefined(sheetId)){
                    sheetId = sheet.getSheetId();
                }
                var json = data.json;
                
                // check to see whether json is string ...
            	if (typeof json === 'string' || json instanceof String) json = Ext.decode(json);
                var deleted = [];
                if(Ext.isDefined(json.data)){
                	if(EnterpriseSheet.sheet.calculate.Calculate.prototype.isCalculate(json.data)){
                		json.cal = true;
                	}else{
                    	delete(json.cal);
                    	deleted = ['cal', 'arg', 'refs', 'value'];
                    }                	
                }
                if(json.cal){
                	if(!json.arg){
                		calculate.transferCalculate(json, store, sheetId, row, col);
                	}                    
                }
                store.setCell(sheetId, row, col, json, deleted, false, data.applyWay || 'clear');
            }
            /*
             * need reset the history of undo/redo, or it will cause problem in some cases
             */
            sheet.fireEvent('resethistory', sheet);
            sheet.refresh();
        };
        
        if(1000 < len){
            hd.sheet.loadMask.show();
            Ext.Function.defer(function(){
                fn();
                hd.sheet.loadMask.hide();
                if(callback){
                    callback.call(scope);
                }
            }, 50, this);
        }else{
            fn();
            if(callback){
                callback.call(scope);
            }
        }
       
    },
           
    /**
     * _public
     * save the current sheet to backend, it will popup a window to ask input a file name if this sheet is not created in the backend, or it will save all data into the backend
     * @param {Object} hd: the sheet app handle
     * @param {Function} callback: the callback function which will be called after the data are saved
     * @param {Object} scope: the scope for the callback function
     */
    saveData : function(hd, callback, scope){
        var sheet = hd.sheet, store = hd.store;
        SSAVE.popup({
            callback: function(fileName, exname, fileId){
                sheet.saveJsonFile({
                    id: fileId,
                    name: fileName,
                    exname: exname
                }, function(newFileId){
                    store.loadFile({
                        fileId: newFileId
                    });
                    Ext.Msg.alert(SLANG['hint'], SLANG['all_changes_are_saved']);
                }, this);
            },
            scope: this
        });
    },
           
    setReadOnly : function(hd, readOnly){
        hd.sheet.setReadOnly(readOnly);
    },
           
    /**
     * _public
     * get the json data of the passed sheet
     * @param {Object} hd: the sheet app handle
     * @return {Object}: the json data of this sheet
     */
    getJsonData : function(hd, compress){
        var json = hd.sheet.getJsonData(compress);
        
        return json;
    },
    
    /**
     * _public
     * add the passed calculates to the sheet calculate system, so user can use these calculates in the cell
     * @param {Object} calculates: all the customized calculates want to add to the sheet calculate system
     * @return {Array} an array contains the names of these calculates which are failed to add to sheet calculate system, the reason for failure is there is already existed a calculate with the same name in the system
     */
    addCalculates : function(calculates){
        var calculate = EnterpriseSheet.sheet.calculate.Calculate.prototype,
            hint = EnterpriseSheet.sheet.floating.CalculateHint.prototype,
           fails = [];
        for(var p in calculates){
            if(calculates.hasOwnProperty(p)){
                var it = calculates[p], calFun = it.fn, calHint = it.hint;
                if(calculate.addCalculate(p, calFun)){
                    if(calHint){
                        hint.addHint(calHint);
                    }
                }else{
                    fails.push(p);
                }
            }
        }
        if(0 < fails.length){
            return fails;
        }
    },
    
    /**
     * _public
     * add the passed calculate exceptions to the sheet calculate system, so when there is a matched exception happened during the calculating, there will be a red tip on the cell to show some exception information to the user
     * @param {Object} calExceptions: all the customized calculate exceptions want to add to the sheet calculate system
     * @return {Array} an array contains the names of these calculate exceptions which are failed to add to sheet calculate system, the reason for failure is there is already existed a calculate exception with the same name in the system
    */
    addCalculateExceptions : function(calExceptions){
        var fails = [];
        for(var p in calExceptions){
            if(calExceptions.hasOwnProperty(p)){
                var it = calExceptions[p];
                if(!SCALEXP.addExceptionInfo(p, it)){
                    fails.push(p);
                }
            }
        }
        if(0 < fails.length){
           return fails;
        }
    },
           
    /**
     * _public
     * get the sheet json data of the passed sheet
     * @param {Object} hd: the sheet app handle
     * @return {Object}: the json data of this sheet
     */
    getSheetTabData : function(hd){
        var store = hd.sheet.getStore();
        var sheets = store.getSheets(), arr = [], activedSheetId = store.getActivedSheetId();
        for(var i = 0, len = sheets.length; i < len; i++){
            var it = sheets[i];
            arr.push({
                id: it.id,
                name: it.name,
                actived: activedSheetId === it.id,
                color: it.color
            });
        }
        return arr;
    },
           
    getActivedSheetId : function(hd){
        var store = hd.sheet.getStore();
        return store.getActivedSheetId();
    },
    
    getTabnameById : function(hd, tabId){
    	var store = hd.sheet.getStore();
        var sheets = store.getSheets();
        for(var i = 0, len = sheets.length; i < len; i++){
            var it = sheets[i];
            if (it.id == tabId) return it.name;
        }
        return null;
    },
           
    /**
     * _public
     * add a new sheet tab
     * @param {Object} hd: the sheet app handle
     * @param {Object} sheetTabConfig: the configuration of the new sheet tab to add
     * @param {Function} callback: the callback function which will be called after the new sheet tab is added
     * @param {Object} scope: the scope for the callback function
     * @param {Boolean} notSwitchToNewSheet: true means not switch to the sheet tab after added
     */
    addSheetTab : function(hd, sheetTabConfig, callback, scope, notSwitchToNewSheet){
        var sheet = hd.sheet, store = hd.store;
        store.addSheet(sheetTabConfig, function(data){
            var sheetId = data.id;
            if(!notSwitchToNewSheet){
                sheet.loadSwitchSheet(sheetId, function(){
                    if(callback){
                        callback.call(scope, sheetId, hd);
                    }
                }, this);
            }else if(callback){
                callback.call(scope, sheetId, hd);
            }
        }, this);

    },
	
    /**
     * _public
     * update the passed tab, rename it or change the color
     * @param {Object} hd: the sheet app handle
     * @param {Object} sheetTabConfig: the tabConfig to update
     {
        sheetId: sheetId, // the id of sheet tab to update, if undefined then use the actived sheet tab id as default
        name: name, // the new tab name to update
        color: color, // the new tab color to update
        position: position // the new position of this tab to update
     }
     * @param {Function} callback: the callback function which will be called after the tab is updated
     * @param {Object} scope: the scope for the callback function
     * @param {Boolean} notSwitchToNewSheet: true means not switch to the sheet tab after updated     
     */
    updateSheetTab : function(hd, sheetTabConfig, callback, scope, notSwitchToNewSheet){
        var sheet = hd.sheet, store = hd.store;
        store.updateSheetTab(sheetTabConfig.sheetId, sheetTabConfig, function(sheetId){
            if(!notSwitchToNewSheet){
                sheet.loadSwitchSheet(sheetId, function(){
                    if(callback){
                        callback.call(scope, sheetId, hd);
                    }
                }, this);
        }else{
                if(callback){
                    callback.call(scope, sheetId, hd);
                }
        }
        }, this);
    },
	
	/**
     * _public
     * delete the passed tab
     * @param {Object} hd: the sheet app handle
     * @param {Integer} sheetTabId: id of the sheet tab need to be updated
     * @param {Function} callback: the callback function which will be called after the tab is updated
     * @param {Object} scope: the scope for the callback function
     */
    deleteSheetTab : function(hd, sheetTabId, callback, scope){
        var sheet = hd.sheet, store = hd.store;
        store.deleteSheet(sheetTabId, function(){
            var activedSheetId = store.getActivedSheetId();
            sheet.loadSwitchSheet(activedSheetId, function(){
                if(callback){
                    callback.call(scope, hd);
                }
            }, this);
        }, this);
    },
        
    /**
     * _public
     * copy the passed tab
     * @param {Object} hd: the sheet app handle
     * @param {Integer} sheetTabId: id of the sheet tab to copy
     * @param {String} newName: the new name for the copied sheet
     * @param {Function} callback: the callback function which will be called after the tab is updated
     * @param {Object} scope: the scope for the callback function
     */
    copySheetTab : function(hd, sheetTabId, newName, callback, scope){
        var sheet = hd.sheet, store = hd.store;
        return store.copySheet(sheetTabId, newName, function(newSheet){
            if(callback){
                callback.call(scope, newSheet.id, hd);
            }
        }, this);
    },
	
	/**
     * _public
     * Show or hide gridline
     * @param {Object} hd: the sheet app handle
	 * @param {Boolean} hideLine: true means hide gridline.     
     * @param {Integer} sheetId: the id of the sheet to toggle the grid line, if not defined then use the actived sheet
     */
	toggleGridLine : function(hd, hideLine, sheetId) {
		var sheet = hd.sheet;

        if (hideLine) {
            sheet.hideGridLine(undefined, sheetId);
        }else{
            sheet.showGridLine(undefined, sheetId);
        }
	},
           
    /**
     * _public
     * get the cell by sheetId, rowIndex and colIndex
     * @param {Object} hd: the sheet app handle
     * @param {Integer} sheetId: the sheet id of the cell, if undefined then use the actived sheet id as default
     * @param {Integer} rowIndex: the row index of the cell
     * @param {Integer} colIndex: the column index of the cell
     */
    getCell : function(hd, sheetId, rowIndex, colIndex) {
        var sheet = hd.sheet;
        if(!Ext.isDefined(sheetId)){
            sheetId = sheet.getSheetId();
	    }
        return sheet.getCellData(sheetId, rowIndex, colIndex);
    },
    
    /**
     * _public
     * get the cell by sheetId, rowIndex and colIndex - not need process the format
     * @param {Object} hd: the sheet app handle
     * @param {Integer} sheetId: the sheet id of the cell, if undefined then use the actived sheet id as default
     * @param {Integer} rowIndex: the row index of the cell
     * @param {Integer} colIndex: the column index of the cell
     */ 
    getCellValue : function(hd, sheetId, rowIndex, colIndex) {
        var sheet = hd.sheet;
        if(!Ext.isDefined(sheetId)){
            sheetId = sheet.getSheetId();
	    }
        return sheet.getCellValue(sheetId, rowIndex, colIndex);
    },
	
    /**
     * _public
     * insert floating item
     * @param {Object} hd: the sheet app handle
     * @param {Integer} sheetTabId: id of the sheet tab to insert the floating item
     * @param {Object} config: config of the floating item to insert
     * @param {Function} callback: the callback function which will be called after the tab is updated
     * @param {Object} scope: the scope for the callback function
     */
    insertFloatingItem : function(hd, sheetTabId, config, callback, scope){
        var sheet = hd.sheet, store = hd.store;
        if(!Ext.isDefined(sheetTabId)){
            sheetTabId = store.getActivedSheetId();
        }
        var ftype = config.ftype;
        delete(config.ftype);
        if('wedgit' === ftype){
            var url = config.url;
            delete(config.url);
            sheet.createWedgit(url, Ext.apply({
                sheetId: sheetTabId
            }, config));
        }else if('picture' === ftype){
            var url = config.url;
            delete(config.url);
            sheet.createPicture(url, Ext.apply({
                sheetId: sheetTabId
            }, config));
        }else if('chart' === ftype){
           var source = config.source;
           config.sheetId = sheetTabId;
           source.seriesPosition = config.seriesPosition;
           source.cacheFields = SCOM.copy(source.cacheFields);
           sheet.prepareSource(source);
           var rangeStore = sheet.createRangeStore(source);
           sheet.createChart(config.chartType, rangeStore, config, true, true);
        }
        sheet.refreshFloor();
    },
    
    /**
     * action to update floating in the sheet tab.
     * @param {Object} hd: the sheet app handle
     * @param {Object} floatings: the floatings item to be inserted.
     *                 Ex: [{sheet: _sheetId, name:"merge1", ftype:"meg", json:"[1,3,1,6]"}]
     * @param {Function} callback: the callback function which will be called after the tab is updated
     * @param {Object} scope: the scope for the callback function
     */
    updateFloatings : function(hd, floatings, callback, scope) {
    	var sheet = hd.sheet, store = hd.store;        
        var len = floatings.length;
        for(var i = 0; i < len; i++){
            var data = floatings[i], ftype = data.ftype, sheetId = parseInt(data.sheet);
            
        	// check whether this is merge 
            if (ftype === "meg") {  
            	var span = data.json;
            	if (typeof span === 'string' || span instanceof String) span = Ext.decode(span);
            	span = [sheetId].concat(span);
            	sheet.mergeCellForSpan(span, false, false);
            }
        }
        sheet.refresh();
        
        if(callback){
             callback.call(scope, false);
         }
    },
           
    /**
     * _public
     * add dropdown store
     * @param {Object} hd: the sheet app handle
     * @param {String} storeName: the dropdown store name
     * @param {Object} config: the config obj for the dropdown store
     * @param {Function} callback: the callback function which will be called after add this dropdown store
     *  callback(success), the param passed to callback is a flag for whether the dropdown store is add successfully
     * @param {Object} scope: the scope for the callback function
     */
    addDropdownStore : function(hd, storeName, config, callback, scope){
        var sheet = hd.sheet;
        sheet.addDropdownStore(storeName, config, callback, scope);
    },
    
    /**
     * _public
     * get file name
     * @param {Object} hd: the sheet app handle
     */
    getFilename : function(hd) {
    	var store = hd.sheet.getStore();
    	return store.getLoadedFileName();
    },
    
    /**
     * _public
     * toggle freeze
     * @param {Object} hd: the sheet app handle
     * 
     */
    toggleFreeze : function(hd) {
    	var ss = hd.sheet;
    	if (ss.isFreezed()) ss.unfreeze();
    	else {
    		var sm = ss.getSelectionModel();
			var pos = sm.getMinMaxPos();
			ss.freeze(pos.minrow, pos.mincol);
			return ss.freezePos;
    	}
    },
    
    /**
     * _public
     * insert row
     * @param {Object} hd: the sheet app handle
     * @param {Integer} sheetId: the identified sheet tab
     * @param {Integer} row: the place to insert new row
     * @param {Integer} rowSpan: the new row number to be inserted
     */
    insertRow : function(hd, sheetId, row, rowSpan) {
    	var sheet = hd.sheet, store = sheet.getStore();
    	var insertedRowNo = 1;
    	if (rowSpan && rowSpan > 1) insertedRowNo = rowSpan;
		store.insertRow(sheetId, row, insertedRowNo);
		sheet.refreshFocus();
    },
    
    /**
     * _public
     * insert column
     * @param {Object} hd: the sheet app handle
     * @param {Integer} sheetId: the identified sheet tab
     * @param {Integer} row: the place to insert new row
     * @param {Integer} column: the new row number to be inserted
     */
    insertColumn : function(hd, sheetId, column, colSpan) {
    	var sheet = hd.sheet, store = sheet.getStore();
    	var insertedColNo = 1;
    	if (colSpan && colSpan > 1) insertedColNo = colSpan;
		store.insertColumn(sheetId, column, insertedColNo);
		sheet.refreshFocus();
    },
    
    /**
     * _public
     * freeze sheet
     * @param {Object} hd: the sheet app handle
     * @param {Integer} row
     * @param {Integer} column
     */
    freezeSheet : function(hd, row, column) {
    	var ss = hd.sheet;
    	if (ss.isFreezed()) ss.unfreeze();    	
		ss.freeze(row+1, column+1);
		return ss.freezePos;
    },
    
    /**
     * @ Depreciated
     * 
     * Try to use applyCellsBorder method for better parameters
     * 
     * this method will be used to apply border condition to the cells
     * @param {Object} hd: the sheet app handle
     * @param {Integer} sheetId: id of the sheet tab to insert the floating item
     * @param {Integer} startRow
     * @param {Integer} startCol
     * @param {Integer} endRow
     * @param {Integer} endCol
     * @param {String} position: 'outside', 'all', 'top', 'bottom', 'left', 'right', 'topbottom'
     * @param {String} color: red, blue etc 
     * @param {Integer} width: 1 or 2, default is 1
     * @param {String} lineType: dotted, dashed or solid (default is solid)
     */
    applyRangeBorder : function(hd, sheetId, startRow, startCol, endRow, endCol, position, color, width, lineType) {  
    	var sheet = hd.sheet;  	
    	var coord = [[sheetId, startRow, startCol, endRow, endCol]];		
		var range = new EnterpriseSheet.sheet.range.Range({
    		sheet: sheet,
    		coord: coord
    	});
		if (!width) width = 1;
		if (!lineType) lineType = 'solid';
		if (!color) color = 'black';
		range.setRangeBorder(position, color, width, lineType);
    },
    
     /**
     * this method will be used to apply border condition to the cells
     * @param {Object} hd: the sheet app handle
     * @param {Array} cood
     * @param {Object} conf
     *     position: 'outside', 'all', 'top', 'bottom', 'left', 'right', 'topbottom'
     *     color: red, blue etc 
     *     width: 1 or 2, default is 1
     *     lineType: dotted, dashed or solid (default is solid)
     */
    applyCellsBorder : function(hd, coord, conf) {  
    	var sheet = hd.sheet;  		
		var range = new EnterpriseSheet.sheet.range.Range({
    		sheet: sheet,
    		coord: coord
    	});
		
		var width = conf.width, lineType = conf.lineType, color = conf.color;
		if (!width) width = 1;
		if (!lineType) lineType = 'solid';
		if (!color) color = 'black';
		range.setRangeBorder(conf.position, color, width, lineType);
    },
    
    /**
     * action to clean cells border
     * @param {Object} hd: the sheet app handle
     * @param {Array} cood
     */
    clearCellsBorder : function(hd, coord) {  
    	var sheet = hd.sheet;  		
		var range = new EnterpriseSheet.sheet.range.Range({
    		sheet: sheet,
    		coord: coord
    	});
		
		range.setRangeBorder("all", "", 1, 'solid');
    },
    
    /**
     * this method will be used to apply table template to the cells
     * @param {Object} hd: the sheet app handle
     * @param {Integer} sheetId: id of the sheet tab to insert the floating item
     * @param {Integer} startRow
     * @param {Integer} startCol
     * @param {Integer} endRow
     * @param {Integer} endCol
     * @param {String} tpl: tpl_0 --- tpl_59
     * @param {boolean} trigger: true or false to show / hide trigger
     */
    applyTableTpl : function(hd, sheetId, startRow, startCol, endRow, endCol, tpl, trigger) {  
    	var sheet = hd.sheet;  	
    	if (trigger == null) trigger = true;

    	var tpl = {id: tpl, span:[sheetId, startRow, startCol, endRow, endCol]};
    	var cellObjs = [];
    	for (var i=startRow; i<=endRow; i++) {
    		for (var j=startCol; j<=endCol; j++) {
    			if (trigger == false && i == startRow) 
    				cellObjs.push({sheet:sheetId, row:i, col:j, json:{tpl: Ext.encode(tpl), trigger: false}, applyWay:"apply"});
    			else 
    		        cellObjs.push({sheet:sheetId, row:i, col:j, json:{tpl: Ext.encode(tpl)}, applyWay:"apply"});	
    		}
    	}
    	
    	this.updateCells(hd, cellObjs);
    },
    
    /**
     * Method to clean the table template
     */
    clearTableTpl : function(hd, span){
    	var sheet = hd.sheet;  
		var tableTpl = sheet.getTableTpl();
		if(tableTpl){		
			tableTpl.clearTplForSpan(span);
		}		
	},
    
    setWholeRowHeight : function(hd) {
    	var sheet = hd.sheet, pos = {minrow: 0};
    	sheet.setRowHeight(50, pos);
    },
    
    /**
     *  _private
     */
    reportServerError : function(serverFailure, comment){
        if(!SCONFIG['NOT_REPORT_ERROR2SERVER']){
            Ext.Ajax.request({
                url: SCONFIG.urls['createServerErrorReport'],
                params: {
                    action: serverFailure.action,
                    params: Ext.encode(serverFailure.params),
                    comment: comment
                }
            });
        }
    },
           
    /**
     * _public
     * show the related sidebar button
     * @param {Object} hd: the sheet app handle
     * @param {String} btn: should be one of them:
     *              chart, cellStyle, tableStyle, search, picture, widget, condition    
     * @param {Function} callback: the callback function which will be called after show the chart sidebar
     *  callback(success), the param passed to callback is the sidebar reference
     * @param {Object} scope: the scope for the callback function
    */
    showSidebarBtnWin : function(hd, btn, callback, scope){
        var sidebar = hd.sidebar;
        if(sidebar){
        	if (btn == "chart") btn = sidebar.chartBtn;
        	else if (btn == "cellStyle") btn = sidebar.cellStyleBtn;
        	else if (btn == "tableStyle") btn = sidebar.tableStyleBtn;
        	else if (btn == "search") btn = sidebar.searchBtn;
        	else if (btn == "picture") btn = sidebar.pictureBtn;
        	else if (btn == "widget") btn = sidebar.wedgitBtn;
        	else if (btn == "condition") btn = sidebar.conditionStyleBtn;
        	
            sidebar.toggleOption(btn, undefined, function(){
                if(callback){
                    callback.call(scope, sidebar, hd);
                }
            });
        }
    },
           
    /**
     * _public
     * hide rows
     * @param {Object} hd: the sheet app handle
     * @param {Integer} startRow: the start row to show
     * @param {Integer} endRow: the end row to show
     * @param {Integer} sheetId: the identified sheet tab, if not defined, then use the current tab
     */
    showRow : function(hd, startRow, endRow, sheetId) {
        var sheet = hd.sheet, store = sheet.getStore();
        sheet.showRow({
            minrow: startRow,
            maxrow: endRow
        }, sheetId);
        sheet.refreshFocus();
    },
           
    /**
     * _public
     * hide rows
     * @param {Object} hd: the sheet app handle
     * @param {Integer} startRow: the start row to hide
     * @param {Integer} endRow: the end row to hide
     * @param {Integer} sheetId: the identified sheet tab, if not defined, then use the current tab
     */
    hideRow : function(hd, startRow, endRow, sheetId) {
        var sheet = hd.sheet, store = sheet.getStore();
        sheet.hideRow({
            minrow: startRow,
            maxrow: endRow
        }, sheetId);
        sheet.refreshFocus();
    },
           
    /**
     * _public
     * hide columns
     * @param {Object} hd: the sheet app handle
     * @param {Integer} startCol: the start col to hide
     * @param {Integer} endCol: the end col to hide
     * @param {Integer} sheetId: the identified sheet tab, if not defined, then use the current tab
     */
    hideColumn : function(hd, startCol, endCol, sheetId) {
        var sheet = hd.sheet, store = sheet.getStore();
        sheet.hideColumn({
            mincol: startCol,
            maxcol: endCol
        }, sheetId);
        sheet.refreshFocus();
    },
           
           
    /**
     * _public
     * hide columns
     * @param {Object} hd: the sheet app handle
     * @param {Integer} startCol: the start col to show
     * @param {Integer} endCol: the end col to show
     * @param {Integer} sheetId: the identified sheet tab, if not defined, then use the current tab
     */
    showColumn : function(hd, startCol, endCol, sheetId) {
        var sheet = hd.sheet, store = sheet.getStore();
        sheet.showColumn({
            mincol: startCol,
            maxcol: endCol
        }, sheetId);
        sheet.refreshFocus();
    },
           
    /**
     * _public
     * set condition
     * @param {Object} hd: the sheet app handle
     * @param {Array} coord: the coordinate array
     * @param {String} cdtName: the condition name
     * @param {Object} config: the config of condition
     */
    setCondition : function(hd, coord, cdtName, config) {
        var sheet = hd.sheet;
        var range = new EnterpriseSheet.sheet.range.Range({
            sheet: sheet,
            coord: coord
        });
        range.setCondition(cdtName, config);
        sheet.refreshFocus();
    },

    /**
     * _public
     * clear condition
     * @param {Object} hd: the sheet app handle
     * @param {Array} coord: the coordinate array
     */
    clearCondition : function(hd, coord) {
        var sheet = hd.sheet;
        var range = new EnterpriseSheet.sheet.range.Range({
            sheet: sheet,
            coord: coord
        });
        range.clearCondition();
        sheet.refreshFocus();
    },
           
    /**
     * _public
     * update groups
     * @param {Object} hd: the sheet app handle
     * @param {Array} groups: the group array
     */
    updateGroups : function(hd, groups) {
        var sheet = hd.sheet;
        sheet.applyGroups(groups);
        sheet.refreshFocus();
    },
    
    /**
     * _public
     * cancel the first group in the selected area
     * @param {Object} hd: the sheet app handle
     * @param {String} dir: row or col
     * @param {String} start: start row or column
     * @param {String} end: end row or column
     */
    cancelGroup : function(hd, dir, start, end) {
        var sheet = hd.sheet;
        
        if( "col" == dir){
            sheet.updateColGroup("cancel", start, end);
		}else if("row" == dir){
            sheet.updateRowGroup("cancel", start, end);
		}
        
        sheet.refreshFocus();
    },
    
    /**
     * _public
     * Get a list of data on the selected range
     * @param {Object} hd: the sheet app handle
     */
    getSelectedRangeData : function(hd) {
    	var ss = hd.sheet, sm = ss.getSelectionModel(), pos = sm.getMinMaxPos();
    	var minX = pos.minrow, minY = pos.mincol, maxX = pos.maxrow, maxY = pos.maxcol;
    	var sheetId = ss.getSheetId();
    	
    	var result = [];
    	for (var i=minX; i<= maxX; i++) {
    		for (var j=minY; j<= maxY; j++) {
    			var cell = ss.getCellData(sheetId, i, j);
    			var cellObj = {row: i, col: j, val: cell.data};
    			result.push(cellObj);
    		}
    	}
    	
    	return result;
    },
    
    
    /**
     * _public
     * Get a list of cell comments information for the file
     * @param {Object} hd: the sheet app handle
     * @param {Integer} sheetId: the identified sheet tab, if not defined, then use the current tab
     */
    getCellsComment : function(hd, sheetId) {
    	var sheet = hd.sheet, store = hd.store, result = [];
    	
    	if (sheetId == null) sheetId = sheet.getSheetId(); 
    	
    	var coord = [[sheetId, 0, 0, 0, 0]];
    	store.walkRange(coord, function(rd){
			var row = rd.data.row, col = rd.data.col, currentSheetId = rd.data.sheet;
			if(0 !== row && 0 !== col && rd.data.json.comment) {	
				// calculate cell result if it is formula
				var cell = store.getCellData(sheetId, row, col), data = cell.data;
				if(cell.comment){
					if (rd.data.json.cal) {
						cell = SHEET_API.getCellValue(SHEET_API_HD, sheetId, row, col);
						data = cell.data;
					}
					
					var cellObj = {sheetId: sheetId, x: row, y: col, comment: cell.comment, result: data};
	    			result.push(cellObj);
				}				
			}
		}, this);
    	
    	return result;
    },

    /**
     * _public
     * set value to the variable
     * @param {Object} hd: the sheet app handle
     * @param {Object} vnVals: an object contains all the variable values
     */
    setValueToVariable : function(hd, vnVals){
        var sheet = hd.sheet;
        sheet.fireEvent('disablehistory', sheet);
        sheet.setValueToVariable(vnVals, true);        
        sheet.fireEvent('enablehistory', sheet);
    },
           
    /**
     * _public
     * get all variable values
     * @param {Object} hd: the sheet app handle
     */
    getCellVariables : function(hd){
        var sheet = hd.sheet;
        return sheet.getCellVariables();
    },
    
    /**
     * _public
     * clear all variables
     * @param {Object} hd: the sheet app handle
     */
    clearAllVariables : function(hd){
        hd.sheet.clearAllVariables();
    },
           
    /**
     * _public
     * copy the range and paste to another range
     * @param {Object} hd: the sheet app handle
     * @param {Array} fromCoord: the coord to copy
     * @param {Array} toCoord: the coord to paste, if not define then use the selection coord
     * @param {String} pasteType: the paste type, can be one of "default", "data", "style" or "reverse", if empty then means "default"
     * @param {Boolean} cutFlag: true then will clear the copy coord after pasted
     */
    copyPasteRange : function(hd, fromCoord, toCoord, pasteType, cutFlag){
        var sheet = hd.sheet;
        var clipboard = sheet.getClipboard();
        clipboard.copy(fromCoord, cutFlag);
        clipboard.paste(undefined, pasteType, true, toCoord, true);
    },
    
    /**
     * _public
     * add filter function to a list of span 
     * @param {Object} hd: the sheet app handle
     * @param {span} coord: the coordinate array [sheetId, x1, y1, x2, y2]
     */
    addFilter2Span : function(hd, span) {
    	var sheet = hd.sheet, filter = sheet.getFilter();
    	filter.createFilterForSpan(span, false);
    },
    
    removeFilter : function(hd, sheetId) {
        var sheet = hd.sheet, filter = sheet.getFilter();
    	filter.cleanFilterForSheet(sheetId);
    },
    
    sortCellByAsc : function(hd, span) {
    	var sheet = hd.sheet;
    	sheet.checkSortSpan(span, null, "asc");
    },
    
    sortCellByDesc : function(hd, span) {
    	var sheet = hd.sheet;
    	sheet.checkSortSpan(span, null, "desc");
    },
    
    /**
     * _public
     * Check whether cell is merged or not
     * @param {Object} hd: the sheet app handle
     * @param {sheetId} sheetId: the sheet id
     * @param {Integer} row: the checked cell row
     * @param {Integer} col: the checked cell col
     */
    isMergedCell : function(hd, sheetId, row, col) {
    	var sheet = hd.sheet, store = hd.store;
    	var cell = store.getCell(sheetId, row, col);
    	return store.isMergedCell(cell, sheetId, row, col);
    },

    /**
     * _public
     * merge the cells in the passed coord span
     * @param {Object} hd: the sheet app handle
     * @param {Array} span: the coordinate span array, it would like [sheetId, minrow, mincol, maxrow, maxcol],
     * @param {boolean} suspendEvent: true to not fire event
     * @param {boolean} suspendRefresh: true to not refresh the cells
     */
    mergeCellForSpan : function(hd, span, suspendEvent, suspendRefresh) {
        var sheet = hd.sheet;
        sheet.mergeCellForSpan(span, suspendEvent, suspendRefresh);
    },
           
    /**
     * _public
     * delete the comment in the passed coord
     * @param {Object} hd: the sheet app handle
     * @param {Array} coord: the coordinate array
     * @param {boolean} suspendEvent: true to not fire event
     * @param {boolean} suspendRefresh: true to not refresh the cells
     */
    deleteCommentForCoord : function(hd, coord, suspendEvent, suspendRefresh) {
        var sheet = hd.sheet;
        sheet.deleteComment(coord, suspendEvent, suspendRefresh);
    },
     
    /**
     * _public
     * get the item (radio or checkbox) value by the passed name
     * @param {Object} hd: the sheet app handle
     * @param {String} name: item name
     */
    getItemValueByName : function(hd, name){
        var sheet = hd.sheet;
        return sheet.getItemValueByName(name);
    },
    
    setFocus : function(hd, row, col) {  	
    	var sm = hd.sheet.getSelectionModel();
    	sm.selectRange({row:row, col:col}, {row:row, col:col}, false);
		sm.setFocusCell(row, col, false);
    },
    
    setMaxRowNumber : function(maxRow) {
    	if (Ext.isNumber(Number(maxRow)) && maxRow > 20) SCONST.MAX_ROW_NUMBER = maxRow;
    },
    
    setMaxColNumber : function(maxCol) {
    	if (Ext.isNumber(Number(maxCol)) && maxCol > 5) SCONST.MAX_COLUMN_NUMBER = maxCol;
    },
    
    /**
     * _public
     * show or hide the column name for the passed sheet
     * @param {Object} hd: the sheet app handle
     * @param {integer} sheetId: the sheet id
     * @param {boolean} visible: true to show, false to hide
     */
    setColNameVisible : function(hd, sheetId, visible){
    	hd.sheet.setColNameVisible(visible, sheetId);
    },
    
    /**
     * _public
     * show or hide the row name for the passed sheet
     * @param {Object} hd: the sheet app handle
     * @param {integer} sheetId: the sheet id
     * @param {boolean} visible: true to show, false to hide
     */
    setRowNameVisible : function(hd, sheetId, visible){
    	hd.sheet.setRowNameVisible(visible, sheetId);
    },
    

    /**
     * _public
     * get the content of the passed defined name variable, it could be a coord range or a formula or a expression
     * @param {Object} hd: the sheet app handle
     * @param {string} definedName: the defined name
     * @param {boolean} visible: true to show, false to hide
     */
    getDefinedNameContent : function(hd, definedName){
    	return hd.store.getDefinedNameContent(definedName);
    }
}, function(){
    
});
